// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiBoxSelectState {
 *     ImGuiID ID;
 *     bool IsActive;
 *     bool IsStarting;
 *     bool IsStartedFromVoid;
 *     bool IsStartedSetNavIdOnce;
 *     bool RequestClear;
 *     ImGuiKeyChord KeyMods : 16;
 *     ImVec2 StartPosRel;
 *     ImVec2 EndPosRel;
 *     ImVec2 ScrollAccum;
 *     ImGuiWindow *Window;
 *     bool UnclipMode;
 *     ImRect UnclipRect;
 *     ImRect BoxSelectRectPrev;
 *     ImRect BoxSelectRectCurr;
 * }
 * }
 */
public class ImGuiBoxSelectState {

    ImGuiBoxSelectState() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        imgui.C_INT.withName("ID"),
        imgui.C_BOOL.withName("IsActive"),
        imgui.C_BOOL.withName("IsStarting"),
        imgui.C_BOOL.withName("IsStartedFromVoid"),
        imgui.C_BOOL.withName("IsStartedSetNavIdOnce"),
        imgui.C_BOOL.withName("RequestClear"),
        MemoryLayout.paddingLayout(3),
        ImVec2.layout().withName("StartPosRel"),
        ImVec2.layout().withName("EndPosRel"),
        ImVec2.layout().withName("ScrollAccum"),
        MemoryLayout.paddingLayout(4),
        imgui.C_POINTER.withName("Window"),
        imgui.C_BOOL.withName("UnclipMode"),
        MemoryLayout.paddingLayout(3),
        ImRect.layout().withName("UnclipRect"),
        ImRect.layout().withName("BoxSelectRectPrev"),
        ImRect.layout().withName("BoxSelectRectCurr"),
        MemoryLayout.paddingLayout(4)
    ).withName("ImGuiBoxSelectState");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt ID$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static final OfInt ID$layout() {
        return ID$LAYOUT;
    }

    private static final long ID$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static final long ID$offset() {
        return ID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static int ID(MemorySegment struct) {
        return struct.get(ID$LAYOUT, ID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static void ID(MemorySegment struct, int fieldValue) {
        struct.set(ID$LAYOUT, ID$OFFSET, fieldValue);
    }

    private static final OfBoolean IsActive$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsActive"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsActive
     * }
     */
    public static final OfBoolean IsActive$layout() {
        return IsActive$LAYOUT;
    }

    private static final long IsActive$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsActive
     * }
     */
    public static final long IsActive$offset() {
        return IsActive$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsActive
     * }
     */
    public static boolean IsActive(MemorySegment struct) {
        return struct.get(IsActive$LAYOUT, IsActive$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsActive
     * }
     */
    public static void IsActive(MemorySegment struct, boolean fieldValue) {
        struct.set(IsActive$LAYOUT, IsActive$OFFSET, fieldValue);
    }

    private static final OfBoolean IsStarting$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsStarting"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsStarting
     * }
     */
    public static final OfBoolean IsStarting$layout() {
        return IsStarting$LAYOUT;
    }

    private static final long IsStarting$OFFSET = 5;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsStarting
     * }
     */
    public static final long IsStarting$offset() {
        return IsStarting$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsStarting
     * }
     */
    public static boolean IsStarting(MemorySegment struct) {
        return struct.get(IsStarting$LAYOUT, IsStarting$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsStarting
     * }
     */
    public static void IsStarting(MemorySegment struct, boolean fieldValue) {
        struct.set(IsStarting$LAYOUT, IsStarting$OFFSET, fieldValue);
    }

    private static final OfBoolean IsStartedFromVoid$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsStartedFromVoid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsStartedFromVoid
     * }
     */
    public static final OfBoolean IsStartedFromVoid$layout() {
        return IsStartedFromVoid$LAYOUT;
    }

    private static final long IsStartedFromVoid$OFFSET = 6;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsStartedFromVoid
     * }
     */
    public static final long IsStartedFromVoid$offset() {
        return IsStartedFromVoid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsStartedFromVoid
     * }
     */
    public static boolean IsStartedFromVoid(MemorySegment struct) {
        return struct.get(IsStartedFromVoid$LAYOUT, IsStartedFromVoid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsStartedFromVoid
     * }
     */
    public static void IsStartedFromVoid(MemorySegment struct, boolean fieldValue) {
        struct.set(IsStartedFromVoid$LAYOUT, IsStartedFromVoid$OFFSET, fieldValue);
    }

    private static final OfBoolean IsStartedSetNavIdOnce$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsStartedSetNavIdOnce"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsStartedSetNavIdOnce
     * }
     */
    public static final OfBoolean IsStartedSetNavIdOnce$layout() {
        return IsStartedSetNavIdOnce$LAYOUT;
    }

    private static final long IsStartedSetNavIdOnce$OFFSET = 7;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsStartedSetNavIdOnce
     * }
     */
    public static final long IsStartedSetNavIdOnce$offset() {
        return IsStartedSetNavIdOnce$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsStartedSetNavIdOnce
     * }
     */
    public static boolean IsStartedSetNavIdOnce(MemorySegment struct) {
        return struct.get(IsStartedSetNavIdOnce$LAYOUT, IsStartedSetNavIdOnce$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsStartedSetNavIdOnce
     * }
     */
    public static void IsStartedSetNavIdOnce(MemorySegment struct, boolean fieldValue) {
        struct.set(IsStartedSetNavIdOnce$LAYOUT, IsStartedSetNavIdOnce$OFFSET, fieldValue);
    }

    private static final OfBoolean RequestClear$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("RequestClear"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool RequestClear
     * }
     */
    public static final OfBoolean RequestClear$layout() {
        return RequestClear$LAYOUT;
    }

    private static final long RequestClear$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool RequestClear
     * }
     */
    public static final long RequestClear$offset() {
        return RequestClear$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool RequestClear
     * }
     */
    public static boolean RequestClear(MemorySegment struct) {
        return struct.get(RequestClear$LAYOUT, RequestClear$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool RequestClear
     * }
     */
    public static void RequestClear(MemorySegment struct, boolean fieldValue) {
        struct.set(RequestClear$LAYOUT, RequestClear$OFFSET, fieldValue);
    }

    private static final GroupLayout StartPosRel$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("StartPosRel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 StartPosRel
     * }
     */
    public static final GroupLayout StartPosRel$layout() {
        return StartPosRel$LAYOUT;
    }

    private static final long StartPosRel$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 StartPosRel
     * }
     */
    public static final long StartPosRel$offset() {
        return StartPosRel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 StartPosRel
     * }
     */
    public static MemorySegment StartPosRel(MemorySegment struct) {
        return struct.asSlice(StartPosRel$OFFSET, StartPosRel$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 StartPosRel
     * }
     */
    public static void StartPosRel(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, StartPosRel$OFFSET, StartPosRel$LAYOUT.byteSize());
    }

    private static final GroupLayout EndPosRel$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("EndPosRel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 EndPosRel
     * }
     */
    public static final GroupLayout EndPosRel$layout() {
        return EndPosRel$LAYOUT;
    }

    private static final long EndPosRel$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 EndPosRel
     * }
     */
    public static final long EndPosRel$offset() {
        return EndPosRel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 EndPosRel
     * }
     */
    public static MemorySegment EndPosRel(MemorySegment struct) {
        return struct.asSlice(EndPosRel$OFFSET, EndPosRel$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 EndPosRel
     * }
     */
    public static void EndPosRel(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, EndPosRel$OFFSET, EndPosRel$LAYOUT.byteSize());
    }

    private static final GroupLayout ScrollAccum$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ScrollAccum"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 ScrollAccum
     * }
     */
    public static final GroupLayout ScrollAccum$layout() {
        return ScrollAccum$LAYOUT;
    }

    private static final long ScrollAccum$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 ScrollAccum
     * }
     */
    public static final long ScrollAccum$offset() {
        return ScrollAccum$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 ScrollAccum
     * }
     */
    public static MemorySegment ScrollAccum(MemorySegment struct) {
        return struct.asSlice(ScrollAccum$OFFSET, ScrollAccum$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 ScrollAccum
     * }
     */
    public static void ScrollAccum(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ScrollAccum$OFFSET, ScrollAccum$LAYOUT.byteSize());
    }

    private static final AddressLayout Window$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Window"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiWindow *Window
     * }
     */
    public static final AddressLayout Window$layout() {
        return Window$LAYOUT;
    }

    private static final long Window$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiWindow *Window
     * }
     */
    public static final long Window$offset() {
        return Window$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiWindow *Window
     * }
     */
    public static MemorySegment Window(MemorySegment struct) {
        return struct.get(Window$LAYOUT, Window$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiWindow *Window
     * }
     */
    public static void Window(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Window$LAYOUT, Window$OFFSET, fieldValue);
    }

    private static final OfBoolean UnclipMode$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("UnclipMode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool UnclipMode
     * }
     */
    public static final OfBoolean UnclipMode$layout() {
        return UnclipMode$LAYOUT;
    }

    private static final long UnclipMode$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool UnclipMode
     * }
     */
    public static final long UnclipMode$offset() {
        return UnclipMode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool UnclipMode
     * }
     */
    public static boolean UnclipMode(MemorySegment struct) {
        return struct.get(UnclipMode$LAYOUT, UnclipMode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool UnclipMode
     * }
     */
    public static void UnclipMode(MemorySegment struct, boolean fieldValue) {
        struct.set(UnclipMode$LAYOUT, UnclipMode$OFFSET, fieldValue);
    }

    private static final GroupLayout UnclipRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("UnclipRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect UnclipRect
     * }
     */
    public static final GroupLayout UnclipRect$layout() {
        return UnclipRect$LAYOUT;
    }

    private static final long UnclipRect$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect UnclipRect
     * }
     */
    public static final long UnclipRect$offset() {
        return UnclipRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect UnclipRect
     * }
     */
    public static MemorySegment UnclipRect(MemorySegment struct) {
        return struct.asSlice(UnclipRect$OFFSET, UnclipRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect UnclipRect
     * }
     */
    public static void UnclipRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, UnclipRect$OFFSET, UnclipRect$LAYOUT.byteSize());
    }

    private static final GroupLayout BoxSelectRectPrev$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BoxSelectRectPrev"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectPrev
     * }
     */
    public static final GroupLayout BoxSelectRectPrev$layout() {
        return BoxSelectRectPrev$LAYOUT;
    }

    private static final long BoxSelectRectPrev$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectPrev
     * }
     */
    public static final long BoxSelectRectPrev$offset() {
        return BoxSelectRectPrev$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectPrev
     * }
     */
    public static MemorySegment BoxSelectRectPrev(MemorySegment struct) {
        return struct.asSlice(BoxSelectRectPrev$OFFSET, BoxSelectRectPrev$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectPrev
     * }
     */
    public static void BoxSelectRectPrev(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BoxSelectRectPrev$OFFSET, BoxSelectRectPrev$LAYOUT.byteSize());
    }

    private static final GroupLayout BoxSelectRectCurr$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BoxSelectRectCurr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectCurr
     * }
     */
    public static final GroupLayout BoxSelectRectCurr$layout() {
        return BoxSelectRectCurr$LAYOUT;
    }

    private static final long BoxSelectRectCurr$OFFSET = 84;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectCurr
     * }
     */
    public static final long BoxSelectRectCurr$offset() {
        return BoxSelectRectCurr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectCurr
     * }
     */
    public static MemorySegment BoxSelectRectCurr(MemorySegment struct) {
        return struct.asSlice(BoxSelectRectCurr$OFFSET, BoxSelectRectCurr$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect BoxSelectRectCurr
     * }
     */
    public static void BoxSelectRectCurr(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BoxSelectRectCurr$OFFSET, BoxSelectRectCurr$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

