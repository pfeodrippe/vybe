// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiComboPreviewData {
 *     ImRect PreviewRect;
 *     ImVec2 BackupCursorPos;
 *     ImVec2 BackupCursorMaxPos;
 *     ImVec2 BackupCursorPosPrevLine;
 *     float BackupPrevLineTextBaseOffset;
 *     ImGuiLayoutType BackupLayout;
 * }
 * }
 */
public class ImGuiComboPreviewData {

    ImGuiComboPreviewData() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        ImRect.layout().withName("PreviewRect"),
        ImVec2.layout().withName("BackupCursorPos"),
        ImVec2.layout().withName("BackupCursorMaxPos"),
        ImVec2.layout().withName("BackupCursorPosPrevLine"),
        imgui.C_FLOAT.withName("BackupPrevLineTextBaseOffset"),
        imgui.C_INT.withName("BackupLayout")
    ).withName("ImGuiComboPreviewData");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout PreviewRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("PreviewRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect PreviewRect
     * }
     */
    public static final GroupLayout PreviewRect$layout() {
        return PreviewRect$LAYOUT;
    }

    private static final long PreviewRect$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect PreviewRect
     * }
     */
    public static final long PreviewRect$offset() {
        return PreviewRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect PreviewRect
     * }
     */
    public static MemorySegment PreviewRect(MemorySegment struct) {
        return struct.asSlice(PreviewRect$OFFSET, PreviewRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect PreviewRect
     * }
     */
    public static void PreviewRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, PreviewRect$OFFSET, PreviewRect$LAYOUT.byteSize());
    }

    private static final GroupLayout BackupCursorPos$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BackupCursorPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPos
     * }
     */
    public static final GroupLayout BackupCursorPos$layout() {
        return BackupCursorPos$LAYOUT;
    }

    private static final long BackupCursorPos$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPos
     * }
     */
    public static final long BackupCursorPos$offset() {
        return BackupCursorPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPos
     * }
     */
    public static MemorySegment BackupCursorPos(MemorySegment struct) {
        return struct.asSlice(BackupCursorPos$OFFSET, BackupCursorPos$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPos
     * }
     */
    public static void BackupCursorPos(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BackupCursorPos$OFFSET, BackupCursorPos$LAYOUT.byteSize());
    }

    private static final GroupLayout BackupCursorMaxPos$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BackupCursorMaxPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorMaxPos
     * }
     */
    public static final GroupLayout BackupCursorMaxPos$layout() {
        return BackupCursorMaxPos$LAYOUT;
    }

    private static final long BackupCursorMaxPos$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorMaxPos
     * }
     */
    public static final long BackupCursorMaxPos$offset() {
        return BackupCursorMaxPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorMaxPos
     * }
     */
    public static MemorySegment BackupCursorMaxPos(MemorySegment struct) {
        return struct.asSlice(BackupCursorMaxPos$OFFSET, BackupCursorMaxPos$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorMaxPos
     * }
     */
    public static void BackupCursorMaxPos(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BackupCursorMaxPos$OFFSET, BackupCursorMaxPos$LAYOUT.byteSize());
    }

    private static final GroupLayout BackupCursorPosPrevLine$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("BackupCursorPosPrevLine"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPosPrevLine
     * }
     */
    public static final GroupLayout BackupCursorPosPrevLine$layout() {
        return BackupCursorPosPrevLine$LAYOUT;
    }

    private static final long BackupCursorPosPrevLine$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPosPrevLine
     * }
     */
    public static final long BackupCursorPosPrevLine$offset() {
        return BackupCursorPosPrevLine$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPosPrevLine
     * }
     */
    public static MemorySegment BackupCursorPosPrevLine(MemorySegment struct) {
        return struct.asSlice(BackupCursorPosPrevLine$OFFSET, BackupCursorPosPrevLine$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 BackupCursorPosPrevLine
     * }
     */
    public static void BackupCursorPosPrevLine(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, BackupCursorPosPrevLine$OFFSET, BackupCursorPosPrevLine$LAYOUT.byteSize());
    }

    private static final OfFloat BackupPrevLineTextBaseOffset$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("BackupPrevLineTextBaseOffset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float BackupPrevLineTextBaseOffset
     * }
     */
    public static final OfFloat BackupPrevLineTextBaseOffset$layout() {
        return BackupPrevLineTextBaseOffset$LAYOUT;
    }

    private static final long BackupPrevLineTextBaseOffset$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float BackupPrevLineTextBaseOffset
     * }
     */
    public static final long BackupPrevLineTextBaseOffset$offset() {
        return BackupPrevLineTextBaseOffset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float BackupPrevLineTextBaseOffset
     * }
     */
    public static float BackupPrevLineTextBaseOffset(MemorySegment struct) {
        return struct.get(BackupPrevLineTextBaseOffset$LAYOUT, BackupPrevLineTextBaseOffset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float BackupPrevLineTextBaseOffset
     * }
     */
    public static void BackupPrevLineTextBaseOffset(MemorySegment struct, float fieldValue) {
        struct.set(BackupPrevLineTextBaseOffset$LAYOUT, BackupPrevLineTextBaseOffset$OFFSET, fieldValue);
    }

    private static final OfInt BackupLayout$LAYOUT = (OfInt)$LAYOUT.select(groupElement("BackupLayout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiLayoutType BackupLayout
     * }
     */
    public static final OfInt BackupLayout$layout() {
        return BackupLayout$LAYOUT;
    }

    private static final long BackupLayout$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiLayoutType BackupLayout
     * }
     */
    public static final long BackupLayout$offset() {
        return BackupLayout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiLayoutType BackupLayout
     * }
     */
    public static int BackupLayout(MemorySegment struct) {
        return struct.get(BackupLayout$LAYOUT, BackupLayout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiLayoutType BackupLayout
     * }
     */
    public static void BackupLayout(MemorySegment struct, int fieldValue) {
        struct.set(BackupLayout$LAYOUT, BackupLayout$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

