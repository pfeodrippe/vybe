// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiOldColumns {
 *     ImGuiID ID;
 *     ImGuiOldColumnFlags Flags;
 *     bool IsFirstFrame;
 *     bool IsBeingResized;
 *     int Current;
 *     int Count;
 *     float OffMinX;
 *     float OffMaxX;
 *     float LineMinY;
 *     float LineMaxY;
 *     float HostCursorPosY;
 *     float HostCursorMaxPosX;
 *     ImRect HostInitialClipRect;
 *     ImRect HostBackupClipRect;
 *     ImRect HostBackupParentWorkRect;
 *     ImVector_ImGuiOldColumnData Columns;
 *     ImDrawListSplitter Splitter;
 * }
 * }
 */
public class ImGuiOldColumns {

    ImGuiOldColumns() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        imgui.C_INT.withName("ID"),
        imgui.C_INT.withName("Flags"),
        imgui.C_BOOL.withName("IsFirstFrame"),
        imgui.C_BOOL.withName("IsBeingResized"),
        MemoryLayout.paddingLayout(2),
        imgui.C_INT.withName("Current"),
        imgui.C_INT.withName("Count"),
        imgui.C_FLOAT.withName("OffMinX"),
        imgui.C_FLOAT.withName("OffMaxX"),
        imgui.C_FLOAT.withName("LineMinY"),
        imgui.C_FLOAT.withName("LineMaxY"),
        imgui.C_FLOAT.withName("HostCursorPosY"),
        imgui.C_FLOAT.withName("HostCursorMaxPosX"),
        ImRect.layout().withName("HostInitialClipRect"),
        ImRect.layout().withName("HostBackupClipRect"),
        ImRect.layout().withName("HostBackupParentWorkRect"),
        MemoryLayout.paddingLayout(4),
        ImVector_ImGuiOldColumnData.layout().withName("Columns"),
        ImDrawListSplitter.layout().withName("Splitter")
    ).withName("ImGuiOldColumns");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt ID$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static final OfInt ID$layout() {
        return ID$LAYOUT;
    }

    private static final long ID$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static final long ID$offset() {
        return ID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static int ID(MemorySegment struct) {
        return struct.get(ID$LAYOUT, ID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiID ID
     * }
     */
    public static void ID(MemorySegment struct, int fieldValue) {
        struct.set(ID$LAYOUT, ID$OFFSET, fieldValue);
    }

    private static final OfInt Flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiOldColumnFlags Flags
     * }
     */
    public static final OfInt Flags$layout() {
        return Flags$LAYOUT;
    }

    private static final long Flags$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiOldColumnFlags Flags
     * }
     */
    public static final long Flags$offset() {
        return Flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiOldColumnFlags Flags
     * }
     */
    public static int Flags(MemorySegment struct) {
        return struct.get(Flags$LAYOUT, Flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiOldColumnFlags Flags
     * }
     */
    public static void Flags(MemorySegment struct, int fieldValue) {
        struct.set(Flags$LAYOUT, Flags$OFFSET, fieldValue);
    }

    private static final OfBoolean IsFirstFrame$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsFirstFrame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsFirstFrame
     * }
     */
    public static final OfBoolean IsFirstFrame$layout() {
        return IsFirstFrame$LAYOUT;
    }

    private static final long IsFirstFrame$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsFirstFrame
     * }
     */
    public static final long IsFirstFrame$offset() {
        return IsFirstFrame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsFirstFrame
     * }
     */
    public static boolean IsFirstFrame(MemorySegment struct) {
        return struct.get(IsFirstFrame$LAYOUT, IsFirstFrame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsFirstFrame
     * }
     */
    public static void IsFirstFrame(MemorySegment struct, boolean fieldValue) {
        struct.set(IsFirstFrame$LAYOUT, IsFirstFrame$OFFSET, fieldValue);
    }

    private static final OfBoolean IsBeingResized$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("IsBeingResized"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool IsBeingResized
     * }
     */
    public static final OfBoolean IsBeingResized$layout() {
        return IsBeingResized$LAYOUT;
    }

    private static final long IsBeingResized$OFFSET = 9;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool IsBeingResized
     * }
     */
    public static final long IsBeingResized$offset() {
        return IsBeingResized$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool IsBeingResized
     * }
     */
    public static boolean IsBeingResized(MemorySegment struct) {
        return struct.get(IsBeingResized$LAYOUT, IsBeingResized$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool IsBeingResized
     * }
     */
    public static void IsBeingResized(MemorySegment struct, boolean fieldValue) {
        struct.set(IsBeingResized$LAYOUT, IsBeingResized$OFFSET, fieldValue);
    }

    private static final OfInt Current$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Current"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int Current
     * }
     */
    public static final OfInt Current$layout() {
        return Current$LAYOUT;
    }

    private static final long Current$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int Current
     * }
     */
    public static final long Current$offset() {
        return Current$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int Current
     * }
     */
    public static int Current(MemorySegment struct) {
        return struct.get(Current$LAYOUT, Current$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int Current
     * }
     */
    public static void Current(MemorySegment struct, int fieldValue) {
        struct.set(Current$LAYOUT, Current$OFFSET, fieldValue);
    }

    private static final OfInt Count$LAYOUT = (OfInt)$LAYOUT.select(groupElement("Count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int Count
     * }
     */
    public static final OfInt Count$layout() {
        return Count$LAYOUT;
    }

    private static final long Count$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int Count
     * }
     */
    public static final long Count$offset() {
        return Count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int Count
     * }
     */
    public static int Count(MemorySegment struct) {
        return struct.get(Count$LAYOUT, Count$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int Count
     * }
     */
    public static void Count(MemorySegment struct, int fieldValue) {
        struct.set(Count$LAYOUT, Count$OFFSET, fieldValue);
    }

    private static final OfFloat OffMinX$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("OffMinX"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float OffMinX
     * }
     */
    public static final OfFloat OffMinX$layout() {
        return OffMinX$LAYOUT;
    }

    private static final long OffMinX$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float OffMinX
     * }
     */
    public static final long OffMinX$offset() {
        return OffMinX$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float OffMinX
     * }
     */
    public static float OffMinX(MemorySegment struct) {
        return struct.get(OffMinX$LAYOUT, OffMinX$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float OffMinX
     * }
     */
    public static void OffMinX(MemorySegment struct, float fieldValue) {
        struct.set(OffMinX$LAYOUT, OffMinX$OFFSET, fieldValue);
    }

    private static final OfFloat OffMaxX$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("OffMaxX"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float OffMaxX
     * }
     */
    public static final OfFloat OffMaxX$layout() {
        return OffMaxX$LAYOUT;
    }

    private static final long OffMaxX$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float OffMaxX
     * }
     */
    public static final long OffMaxX$offset() {
        return OffMaxX$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float OffMaxX
     * }
     */
    public static float OffMaxX(MemorySegment struct) {
        return struct.get(OffMaxX$LAYOUT, OffMaxX$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float OffMaxX
     * }
     */
    public static void OffMaxX(MemorySegment struct, float fieldValue) {
        struct.set(OffMaxX$LAYOUT, OffMaxX$OFFSET, fieldValue);
    }

    private static final OfFloat LineMinY$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("LineMinY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float LineMinY
     * }
     */
    public static final OfFloat LineMinY$layout() {
        return LineMinY$LAYOUT;
    }

    private static final long LineMinY$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float LineMinY
     * }
     */
    public static final long LineMinY$offset() {
        return LineMinY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float LineMinY
     * }
     */
    public static float LineMinY(MemorySegment struct) {
        return struct.get(LineMinY$LAYOUT, LineMinY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float LineMinY
     * }
     */
    public static void LineMinY(MemorySegment struct, float fieldValue) {
        struct.set(LineMinY$LAYOUT, LineMinY$OFFSET, fieldValue);
    }

    private static final OfFloat LineMaxY$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("LineMaxY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float LineMaxY
     * }
     */
    public static final OfFloat LineMaxY$layout() {
        return LineMaxY$LAYOUT;
    }

    private static final long LineMaxY$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float LineMaxY
     * }
     */
    public static final long LineMaxY$offset() {
        return LineMaxY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float LineMaxY
     * }
     */
    public static float LineMaxY(MemorySegment struct) {
        return struct.get(LineMaxY$LAYOUT, LineMaxY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float LineMaxY
     * }
     */
    public static void LineMaxY(MemorySegment struct, float fieldValue) {
        struct.set(LineMaxY$LAYOUT, LineMaxY$OFFSET, fieldValue);
    }

    private static final OfFloat HostCursorPosY$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("HostCursorPosY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float HostCursorPosY
     * }
     */
    public static final OfFloat HostCursorPosY$layout() {
        return HostCursorPosY$LAYOUT;
    }

    private static final long HostCursorPosY$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float HostCursorPosY
     * }
     */
    public static final long HostCursorPosY$offset() {
        return HostCursorPosY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float HostCursorPosY
     * }
     */
    public static float HostCursorPosY(MemorySegment struct) {
        return struct.get(HostCursorPosY$LAYOUT, HostCursorPosY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float HostCursorPosY
     * }
     */
    public static void HostCursorPosY(MemorySegment struct, float fieldValue) {
        struct.set(HostCursorPosY$LAYOUT, HostCursorPosY$OFFSET, fieldValue);
    }

    private static final OfFloat HostCursorMaxPosX$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("HostCursorMaxPosX"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float HostCursorMaxPosX
     * }
     */
    public static final OfFloat HostCursorMaxPosX$layout() {
        return HostCursorMaxPosX$LAYOUT;
    }

    private static final long HostCursorMaxPosX$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float HostCursorMaxPosX
     * }
     */
    public static final long HostCursorMaxPosX$offset() {
        return HostCursorMaxPosX$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float HostCursorMaxPosX
     * }
     */
    public static float HostCursorMaxPosX(MemorySegment struct) {
        return struct.get(HostCursorMaxPosX$LAYOUT, HostCursorMaxPosX$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float HostCursorMaxPosX
     * }
     */
    public static void HostCursorMaxPosX(MemorySegment struct, float fieldValue) {
        struct.set(HostCursorMaxPosX$LAYOUT, HostCursorMaxPosX$OFFSET, fieldValue);
    }

    private static final GroupLayout HostInitialClipRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostInitialClipRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect HostInitialClipRect
     * }
     */
    public static final GroupLayout HostInitialClipRect$layout() {
        return HostInitialClipRect$LAYOUT;
    }

    private static final long HostInitialClipRect$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect HostInitialClipRect
     * }
     */
    public static final long HostInitialClipRect$offset() {
        return HostInitialClipRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect HostInitialClipRect
     * }
     */
    public static MemorySegment HostInitialClipRect(MemorySegment struct) {
        return struct.asSlice(HostInitialClipRect$OFFSET, HostInitialClipRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect HostInitialClipRect
     * }
     */
    public static void HostInitialClipRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostInitialClipRect$OFFSET, HostInitialClipRect$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupClipRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupClipRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect HostBackupClipRect
     * }
     */
    public static final GroupLayout HostBackupClipRect$layout() {
        return HostBackupClipRect$LAYOUT;
    }

    private static final long HostBackupClipRect$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect HostBackupClipRect
     * }
     */
    public static final long HostBackupClipRect$offset() {
        return HostBackupClipRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect HostBackupClipRect
     * }
     */
    public static MemorySegment HostBackupClipRect(MemorySegment struct) {
        return struct.asSlice(HostBackupClipRect$OFFSET, HostBackupClipRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect HostBackupClipRect
     * }
     */
    public static void HostBackupClipRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupClipRect$OFFSET, HostBackupClipRect$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupParentWorkRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupParentWorkRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static final GroupLayout HostBackupParentWorkRect$layout() {
        return HostBackupParentWorkRect$LAYOUT;
    }

    private static final long HostBackupParentWorkRect$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static final long HostBackupParentWorkRect$offset() {
        return HostBackupParentWorkRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static MemorySegment HostBackupParentWorkRect(MemorySegment struct) {
        return struct.asSlice(HostBackupParentWorkRect$OFFSET, HostBackupParentWorkRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static void HostBackupParentWorkRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupParentWorkRect$OFFSET, HostBackupParentWorkRect$LAYOUT.byteSize());
    }

    private static final GroupLayout Columns$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Columns"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVector_ImGuiOldColumnData Columns
     * }
     */
    public static final GroupLayout Columns$layout() {
        return Columns$LAYOUT;
    }

    private static final long Columns$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVector_ImGuiOldColumnData Columns
     * }
     */
    public static final long Columns$offset() {
        return Columns$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiOldColumnData Columns
     * }
     */
    public static MemorySegment Columns(MemorySegment struct) {
        return struct.asSlice(Columns$OFFSET, Columns$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiOldColumnData Columns
     * }
     */
    public static void Columns(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Columns$OFFSET, Columns$LAYOUT.byteSize());
    }

    private static final GroupLayout Splitter$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Splitter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImDrawListSplitter Splitter
     * }
     */
    public static final GroupLayout Splitter$layout() {
        return Splitter$LAYOUT;
    }

    private static final long Splitter$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImDrawListSplitter Splitter
     * }
     */
    public static final long Splitter$offset() {
        return Splitter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImDrawListSplitter Splitter
     * }
     */
    public static MemorySegment Splitter(MemorySegment struct) {
        return struct.asSlice(Splitter$OFFSET, Splitter$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImDrawListSplitter Splitter
     * }
     */
    public static void Splitter(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Splitter$OFFSET, Splitter$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

