// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiTableTempData {
 *     int TableIndex;
 *     float LastTimeActive;
 *     float AngledHeadersExtraWidth;
 *     ImVector_ImGuiTableHeaderData AngledHeadersRequests;
 *     ImVec2 UserOuterSize;
 *     ImDrawListSplitter DrawSplitter;
 *     ImRect HostBackupWorkRect;
 *     ImRect HostBackupParentWorkRect;
 *     ImVec2 HostBackupPrevLineSize;
 *     ImVec2 HostBackupCurrLineSize;
 *     ImVec2 HostBackupCursorMaxPos;
 *     ImVec1 HostBackupColumnsOffset;
 *     float HostBackupItemWidth;
 *     int HostBackupItemWidthStackSize;
 * }
 * }
 */
public class ImGuiTableTempData {

    ImGuiTableTempData() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        imgui.C_INT.withName("TableIndex"),
        imgui.C_FLOAT.withName("LastTimeActive"),
        imgui.C_FLOAT.withName("AngledHeadersExtraWidth"),
        MemoryLayout.paddingLayout(4),
        ImVector_ImGuiTableHeaderData.layout().withName("AngledHeadersRequests"),
        ImVec2.layout().withName("UserOuterSize"),
        ImDrawListSplitter.layout().withName("DrawSplitter"),
        ImRect.layout().withName("HostBackupWorkRect"),
        ImRect.layout().withName("HostBackupParentWorkRect"),
        ImVec2.layout().withName("HostBackupPrevLineSize"),
        ImVec2.layout().withName("HostBackupCurrLineSize"),
        ImVec2.layout().withName("HostBackupCursorMaxPos"),
        ImVec1.layout().withName("HostBackupColumnsOffset"),
        imgui.C_FLOAT.withName("HostBackupItemWidth"),
        imgui.C_INT.withName("HostBackupItemWidthStackSize"),
        MemoryLayout.paddingLayout(4)
    ).withName("ImGuiTableTempData");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt TableIndex$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TableIndex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int TableIndex
     * }
     */
    public static final OfInt TableIndex$layout() {
        return TableIndex$LAYOUT;
    }

    private static final long TableIndex$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int TableIndex
     * }
     */
    public static final long TableIndex$offset() {
        return TableIndex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int TableIndex
     * }
     */
    public static int TableIndex(MemorySegment struct) {
        return struct.get(TableIndex$LAYOUT, TableIndex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int TableIndex
     * }
     */
    public static void TableIndex(MemorySegment struct, int fieldValue) {
        struct.set(TableIndex$LAYOUT, TableIndex$OFFSET, fieldValue);
    }

    private static final OfFloat LastTimeActive$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("LastTimeActive"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float LastTimeActive
     * }
     */
    public static final OfFloat LastTimeActive$layout() {
        return LastTimeActive$LAYOUT;
    }

    private static final long LastTimeActive$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float LastTimeActive
     * }
     */
    public static final long LastTimeActive$offset() {
        return LastTimeActive$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float LastTimeActive
     * }
     */
    public static float LastTimeActive(MemorySegment struct) {
        return struct.get(LastTimeActive$LAYOUT, LastTimeActive$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float LastTimeActive
     * }
     */
    public static void LastTimeActive(MemorySegment struct, float fieldValue) {
        struct.set(LastTimeActive$LAYOUT, LastTimeActive$OFFSET, fieldValue);
    }

    private static final OfFloat AngledHeadersExtraWidth$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("AngledHeadersExtraWidth"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float AngledHeadersExtraWidth
     * }
     */
    public static final OfFloat AngledHeadersExtraWidth$layout() {
        return AngledHeadersExtraWidth$LAYOUT;
    }

    private static final long AngledHeadersExtraWidth$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float AngledHeadersExtraWidth
     * }
     */
    public static final long AngledHeadersExtraWidth$offset() {
        return AngledHeadersExtraWidth$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float AngledHeadersExtraWidth
     * }
     */
    public static float AngledHeadersExtraWidth(MemorySegment struct) {
        return struct.get(AngledHeadersExtraWidth$LAYOUT, AngledHeadersExtraWidth$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float AngledHeadersExtraWidth
     * }
     */
    public static void AngledHeadersExtraWidth(MemorySegment struct, float fieldValue) {
        struct.set(AngledHeadersExtraWidth$LAYOUT, AngledHeadersExtraWidth$OFFSET, fieldValue);
    }

    private static final GroupLayout AngledHeadersRequests$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("AngledHeadersRequests"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVector_ImGuiTableHeaderData AngledHeadersRequests
     * }
     */
    public static final GroupLayout AngledHeadersRequests$layout() {
        return AngledHeadersRequests$LAYOUT;
    }

    private static final long AngledHeadersRequests$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVector_ImGuiTableHeaderData AngledHeadersRequests
     * }
     */
    public static final long AngledHeadersRequests$offset() {
        return AngledHeadersRequests$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiTableHeaderData AngledHeadersRequests
     * }
     */
    public static MemorySegment AngledHeadersRequests(MemorySegment struct) {
        return struct.asSlice(AngledHeadersRequests$OFFSET, AngledHeadersRequests$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiTableHeaderData AngledHeadersRequests
     * }
     */
    public static void AngledHeadersRequests(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, AngledHeadersRequests$OFFSET, AngledHeadersRequests$LAYOUT.byteSize());
    }

    private static final GroupLayout UserOuterSize$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("UserOuterSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 UserOuterSize
     * }
     */
    public static final GroupLayout UserOuterSize$layout() {
        return UserOuterSize$LAYOUT;
    }

    private static final long UserOuterSize$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 UserOuterSize
     * }
     */
    public static final long UserOuterSize$offset() {
        return UserOuterSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 UserOuterSize
     * }
     */
    public static MemorySegment UserOuterSize(MemorySegment struct) {
        return struct.asSlice(UserOuterSize$OFFSET, UserOuterSize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 UserOuterSize
     * }
     */
    public static void UserOuterSize(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, UserOuterSize$OFFSET, UserOuterSize$LAYOUT.byteSize());
    }

    private static final GroupLayout DrawSplitter$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("DrawSplitter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImDrawListSplitter DrawSplitter
     * }
     */
    public static final GroupLayout DrawSplitter$layout() {
        return DrawSplitter$LAYOUT;
    }

    private static final long DrawSplitter$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImDrawListSplitter DrawSplitter
     * }
     */
    public static final long DrawSplitter$offset() {
        return DrawSplitter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImDrawListSplitter DrawSplitter
     * }
     */
    public static MemorySegment DrawSplitter(MemorySegment struct) {
        return struct.asSlice(DrawSplitter$OFFSET, DrawSplitter$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImDrawListSplitter DrawSplitter
     * }
     */
    public static void DrawSplitter(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, DrawSplitter$OFFSET, DrawSplitter$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupWorkRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupWorkRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect HostBackupWorkRect
     * }
     */
    public static final GroupLayout HostBackupWorkRect$layout() {
        return HostBackupWorkRect$LAYOUT;
    }

    private static final long HostBackupWorkRect$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect HostBackupWorkRect
     * }
     */
    public static final long HostBackupWorkRect$offset() {
        return HostBackupWorkRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect HostBackupWorkRect
     * }
     */
    public static MemorySegment HostBackupWorkRect(MemorySegment struct) {
        return struct.asSlice(HostBackupWorkRect$OFFSET, HostBackupWorkRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect HostBackupWorkRect
     * }
     */
    public static void HostBackupWorkRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupWorkRect$OFFSET, HostBackupWorkRect$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupParentWorkRect$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupParentWorkRect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static final GroupLayout HostBackupParentWorkRect$layout() {
        return HostBackupParentWorkRect$LAYOUT;
    }

    private static final long HostBackupParentWorkRect$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static final long HostBackupParentWorkRect$offset() {
        return HostBackupParentWorkRect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static MemorySegment HostBackupParentWorkRect(MemorySegment struct) {
        return struct.asSlice(HostBackupParentWorkRect$OFFSET, HostBackupParentWorkRect$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImRect HostBackupParentWorkRect
     * }
     */
    public static void HostBackupParentWorkRect(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupParentWorkRect$OFFSET, HostBackupParentWorkRect$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupPrevLineSize$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupPrevLineSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupPrevLineSize
     * }
     */
    public static final GroupLayout HostBackupPrevLineSize$layout() {
        return HostBackupPrevLineSize$LAYOUT;
    }

    private static final long HostBackupPrevLineSize$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupPrevLineSize
     * }
     */
    public static final long HostBackupPrevLineSize$offset() {
        return HostBackupPrevLineSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupPrevLineSize
     * }
     */
    public static MemorySegment HostBackupPrevLineSize(MemorySegment struct) {
        return struct.asSlice(HostBackupPrevLineSize$OFFSET, HostBackupPrevLineSize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupPrevLineSize
     * }
     */
    public static void HostBackupPrevLineSize(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupPrevLineSize$OFFSET, HostBackupPrevLineSize$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupCurrLineSize$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupCurrLineSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCurrLineSize
     * }
     */
    public static final GroupLayout HostBackupCurrLineSize$layout() {
        return HostBackupCurrLineSize$LAYOUT;
    }

    private static final long HostBackupCurrLineSize$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCurrLineSize
     * }
     */
    public static final long HostBackupCurrLineSize$offset() {
        return HostBackupCurrLineSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCurrLineSize
     * }
     */
    public static MemorySegment HostBackupCurrLineSize(MemorySegment struct) {
        return struct.asSlice(HostBackupCurrLineSize$OFFSET, HostBackupCurrLineSize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCurrLineSize
     * }
     */
    public static void HostBackupCurrLineSize(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupCurrLineSize$OFFSET, HostBackupCurrLineSize$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupCursorMaxPos$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupCursorMaxPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCursorMaxPos
     * }
     */
    public static final GroupLayout HostBackupCursorMaxPos$layout() {
        return HostBackupCursorMaxPos$LAYOUT;
    }

    private static final long HostBackupCursorMaxPos$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCursorMaxPos
     * }
     */
    public static final long HostBackupCursorMaxPos$offset() {
        return HostBackupCursorMaxPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCursorMaxPos
     * }
     */
    public static MemorySegment HostBackupCursorMaxPos(MemorySegment struct) {
        return struct.asSlice(HostBackupCursorMaxPos$OFFSET, HostBackupCursorMaxPos$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 HostBackupCursorMaxPos
     * }
     */
    public static void HostBackupCursorMaxPos(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupCursorMaxPos$OFFSET, HostBackupCursorMaxPos$LAYOUT.byteSize());
    }

    private static final GroupLayout HostBackupColumnsOffset$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("HostBackupColumnsOffset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec1 HostBackupColumnsOffset
     * }
     */
    public static final GroupLayout HostBackupColumnsOffset$layout() {
        return HostBackupColumnsOffset$LAYOUT;
    }

    private static final long HostBackupColumnsOffset$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec1 HostBackupColumnsOffset
     * }
     */
    public static final long HostBackupColumnsOffset$offset() {
        return HostBackupColumnsOffset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec1 HostBackupColumnsOffset
     * }
     */
    public static MemorySegment HostBackupColumnsOffset(MemorySegment struct) {
        return struct.asSlice(HostBackupColumnsOffset$OFFSET, HostBackupColumnsOffset$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec1 HostBackupColumnsOffset
     * }
     */
    public static void HostBackupColumnsOffset(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, HostBackupColumnsOffset$OFFSET, HostBackupColumnsOffset$LAYOUT.byteSize());
    }

    private static final OfFloat HostBackupItemWidth$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("HostBackupItemWidth"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float HostBackupItemWidth
     * }
     */
    public static final OfFloat HostBackupItemWidth$layout() {
        return HostBackupItemWidth$LAYOUT;
    }

    private static final long HostBackupItemWidth$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float HostBackupItemWidth
     * }
     */
    public static final long HostBackupItemWidth$offset() {
        return HostBackupItemWidth$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float HostBackupItemWidth
     * }
     */
    public static float HostBackupItemWidth(MemorySegment struct) {
        return struct.get(HostBackupItemWidth$LAYOUT, HostBackupItemWidth$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float HostBackupItemWidth
     * }
     */
    public static void HostBackupItemWidth(MemorySegment struct, float fieldValue) {
        struct.set(HostBackupItemWidth$LAYOUT, HostBackupItemWidth$OFFSET, fieldValue);
    }

    private static final OfInt HostBackupItemWidthStackSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("HostBackupItemWidthStackSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int HostBackupItemWidthStackSize
     * }
     */
    public static final OfInt HostBackupItemWidthStackSize$layout() {
        return HostBackupItemWidthStackSize$LAYOUT;
    }

    private static final long HostBackupItemWidthStackSize$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int HostBackupItemWidthStackSize
     * }
     */
    public static final long HostBackupItemWidthStackSize$offset() {
        return HostBackupItemWidthStackSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int HostBackupItemWidthStackSize
     * }
     */
    public static int HostBackupItemWidthStackSize(MemorySegment struct) {
        return struct.get(HostBackupItemWidthStackSize$LAYOUT, HostBackupItemWidthStackSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int HostBackupItemWidthStackSize
     * }
     */
    public static void HostBackupItemWidthStackSize(MemorySegment struct, int fieldValue) {
        struct.set(HostBackupItemWidthStackSize$LAYOUT, HostBackupItemWidthStackSize$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

