// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiWindowClass {
 *     ImGuiID ClassId;
 *     ImGuiID ParentViewportId;
 *     ImGuiID FocusRouteParentWindowId;
 *     ImGuiViewportFlags ViewportFlagsOverrideSet;
 *     ImGuiViewportFlags ViewportFlagsOverrideClear;
 *     ImGuiTabItemFlags TabItemFlagsOverrideSet;
 *     ImGuiDockNodeFlags DockNodeFlagsOverrideSet;
 *     bool DockingAlwaysTabBar;
 *     bool DockingAllowUnclassed;
 * }
 * }
 */
public class ImGuiWindowClass {

    ImGuiWindowClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        imgui.C_INT.withName("ClassId"),
        imgui.C_INT.withName("ParentViewportId"),
        imgui.C_INT.withName("FocusRouteParentWindowId"),
        imgui.C_INT.withName("ViewportFlagsOverrideSet"),
        imgui.C_INT.withName("ViewportFlagsOverrideClear"),
        imgui.C_INT.withName("TabItemFlagsOverrideSet"),
        imgui.C_INT.withName("DockNodeFlagsOverrideSet"),
        imgui.C_BOOL.withName("DockingAlwaysTabBar"),
        imgui.C_BOOL.withName("DockingAllowUnclassed"),
        MemoryLayout.paddingLayout(2)
    ).withName("ImGuiWindowClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt ClassId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ClassId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiID ClassId
     * }
     */
    public static final OfInt ClassId$layout() {
        return ClassId$LAYOUT;
    }

    private static final long ClassId$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiID ClassId
     * }
     */
    public static final long ClassId$offset() {
        return ClassId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiID ClassId
     * }
     */
    public static int ClassId(MemorySegment struct) {
        return struct.get(ClassId$LAYOUT, ClassId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiID ClassId
     * }
     */
    public static void ClassId(MemorySegment struct, int fieldValue) {
        struct.set(ClassId$LAYOUT, ClassId$OFFSET, fieldValue);
    }

    private static final OfInt ParentViewportId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ParentViewportId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiID ParentViewportId
     * }
     */
    public static final OfInt ParentViewportId$layout() {
        return ParentViewportId$LAYOUT;
    }

    private static final long ParentViewportId$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiID ParentViewportId
     * }
     */
    public static final long ParentViewportId$offset() {
        return ParentViewportId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiID ParentViewportId
     * }
     */
    public static int ParentViewportId(MemorySegment struct) {
        return struct.get(ParentViewportId$LAYOUT, ParentViewportId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiID ParentViewportId
     * }
     */
    public static void ParentViewportId(MemorySegment struct, int fieldValue) {
        struct.set(ParentViewportId$LAYOUT, ParentViewportId$OFFSET, fieldValue);
    }

    private static final OfInt FocusRouteParentWindowId$LAYOUT = (OfInt)$LAYOUT.select(groupElement("FocusRouteParentWindowId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiID FocusRouteParentWindowId
     * }
     */
    public static final OfInt FocusRouteParentWindowId$layout() {
        return FocusRouteParentWindowId$LAYOUT;
    }

    private static final long FocusRouteParentWindowId$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiID FocusRouteParentWindowId
     * }
     */
    public static final long FocusRouteParentWindowId$offset() {
        return FocusRouteParentWindowId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiID FocusRouteParentWindowId
     * }
     */
    public static int FocusRouteParentWindowId(MemorySegment struct) {
        return struct.get(FocusRouteParentWindowId$LAYOUT, FocusRouteParentWindowId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiID FocusRouteParentWindowId
     * }
     */
    public static void FocusRouteParentWindowId(MemorySegment struct, int fieldValue) {
        struct.set(FocusRouteParentWindowId$LAYOUT, FocusRouteParentWindowId$OFFSET, fieldValue);
    }

    private static final OfInt ViewportFlagsOverrideSet$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ViewportFlagsOverrideSet"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideSet
     * }
     */
    public static final OfInt ViewportFlagsOverrideSet$layout() {
        return ViewportFlagsOverrideSet$LAYOUT;
    }

    private static final long ViewportFlagsOverrideSet$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideSet
     * }
     */
    public static final long ViewportFlagsOverrideSet$offset() {
        return ViewportFlagsOverrideSet$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideSet
     * }
     */
    public static int ViewportFlagsOverrideSet(MemorySegment struct) {
        return struct.get(ViewportFlagsOverrideSet$LAYOUT, ViewportFlagsOverrideSet$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideSet
     * }
     */
    public static void ViewportFlagsOverrideSet(MemorySegment struct, int fieldValue) {
        struct.set(ViewportFlagsOverrideSet$LAYOUT, ViewportFlagsOverrideSet$OFFSET, fieldValue);
    }

    private static final OfInt ViewportFlagsOverrideClear$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ViewportFlagsOverrideClear"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideClear
     * }
     */
    public static final OfInt ViewportFlagsOverrideClear$layout() {
        return ViewportFlagsOverrideClear$LAYOUT;
    }

    private static final long ViewportFlagsOverrideClear$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideClear
     * }
     */
    public static final long ViewportFlagsOverrideClear$offset() {
        return ViewportFlagsOverrideClear$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideClear
     * }
     */
    public static int ViewportFlagsOverrideClear(MemorySegment struct) {
        return struct.get(ViewportFlagsOverrideClear$LAYOUT, ViewportFlagsOverrideClear$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiViewportFlags ViewportFlagsOverrideClear
     * }
     */
    public static void ViewportFlagsOverrideClear(MemorySegment struct, int fieldValue) {
        struct.set(ViewportFlagsOverrideClear$LAYOUT, ViewportFlagsOverrideClear$OFFSET, fieldValue);
    }

    private static final OfInt TabItemFlagsOverrideSet$LAYOUT = (OfInt)$LAYOUT.select(groupElement("TabItemFlagsOverrideSet"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiTabItemFlags TabItemFlagsOverrideSet
     * }
     */
    public static final OfInt TabItemFlagsOverrideSet$layout() {
        return TabItemFlagsOverrideSet$LAYOUT;
    }

    private static final long TabItemFlagsOverrideSet$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiTabItemFlags TabItemFlagsOverrideSet
     * }
     */
    public static final long TabItemFlagsOverrideSet$offset() {
        return TabItemFlagsOverrideSet$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiTabItemFlags TabItemFlagsOverrideSet
     * }
     */
    public static int TabItemFlagsOverrideSet(MemorySegment struct) {
        return struct.get(TabItemFlagsOverrideSet$LAYOUT, TabItemFlagsOverrideSet$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiTabItemFlags TabItemFlagsOverrideSet
     * }
     */
    public static void TabItemFlagsOverrideSet(MemorySegment struct, int fieldValue) {
        struct.set(TabItemFlagsOverrideSet$LAYOUT, TabItemFlagsOverrideSet$OFFSET, fieldValue);
    }

    private static final OfInt DockNodeFlagsOverrideSet$LAYOUT = (OfInt)$LAYOUT.select(groupElement("DockNodeFlagsOverrideSet"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImGuiDockNodeFlags DockNodeFlagsOverrideSet
     * }
     */
    public static final OfInt DockNodeFlagsOverrideSet$layout() {
        return DockNodeFlagsOverrideSet$LAYOUT;
    }

    private static final long DockNodeFlagsOverrideSet$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImGuiDockNodeFlags DockNodeFlagsOverrideSet
     * }
     */
    public static final long DockNodeFlagsOverrideSet$offset() {
        return DockNodeFlagsOverrideSet$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImGuiDockNodeFlags DockNodeFlagsOverrideSet
     * }
     */
    public static int DockNodeFlagsOverrideSet(MemorySegment struct) {
        return struct.get(DockNodeFlagsOverrideSet$LAYOUT, DockNodeFlagsOverrideSet$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImGuiDockNodeFlags DockNodeFlagsOverrideSet
     * }
     */
    public static void DockNodeFlagsOverrideSet(MemorySegment struct, int fieldValue) {
        struct.set(DockNodeFlagsOverrideSet$LAYOUT, DockNodeFlagsOverrideSet$OFFSET, fieldValue);
    }

    private static final OfBoolean DockingAlwaysTabBar$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("DockingAlwaysTabBar"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool DockingAlwaysTabBar
     * }
     */
    public static final OfBoolean DockingAlwaysTabBar$layout() {
        return DockingAlwaysTabBar$LAYOUT;
    }

    private static final long DockingAlwaysTabBar$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool DockingAlwaysTabBar
     * }
     */
    public static final long DockingAlwaysTabBar$offset() {
        return DockingAlwaysTabBar$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool DockingAlwaysTabBar
     * }
     */
    public static boolean DockingAlwaysTabBar(MemorySegment struct) {
        return struct.get(DockingAlwaysTabBar$LAYOUT, DockingAlwaysTabBar$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool DockingAlwaysTabBar
     * }
     */
    public static void DockingAlwaysTabBar(MemorySegment struct, boolean fieldValue) {
        struct.set(DockingAlwaysTabBar$LAYOUT, DockingAlwaysTabBar$OFFSET, fieldValue);
    }

    private static final OfBoolean DockingAllowUnclassed$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("DockingAllowUnclassed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool DockingAllowUnclassed
     * }
     */
    public static final OfBoolean DockingAllowUnclassed$layout() {
        return DockingAllowUnclassed$LAYOUT;
    }

    private static final long DockingAllowUnclassed$OFFSET = 29;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool DockingAllowUnclassed
     * }
     */
    public static final long DockingAllowUnclassed$offset() {
        return DockingAllowUnclassed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool DockingAllowUnclassed
     * }
     */
    public static boolean DockingAllowUnclassed(MemorySegment struct) {
        return struct.get(DockingAllowUnclassed$LAYOUT, DockingAllowUnclassed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool DockingAllowUnclassed
     * }
     */
    public static void DockingAllowUnclassed(MemorySegment struct, boolean fieldValue) {
        struct.set(DockingAllowUnclassed$LAYOUT, DockingAllowUnclassed$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

