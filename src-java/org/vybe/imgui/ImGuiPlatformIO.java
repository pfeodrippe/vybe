// Generated by jextract

package org.vybe.imgui;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ImGuiPlatformIO {
 *     void (*Platform_CreateWindow)(ImGuiViewport *);
 *     void (*Platform_DestroyWindow)(ImGuiViewport *);
 *     void (*Platform_ShowWindow)(ImGuiViewport *);
 *     void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2);
 *     ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *);
 *     void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2);
 *     ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *);
 *     void (*Platform_SetWindowFocus)(ImGuiViewport *);
 *     bool (*Platform_GetWindowFocus)(ImGuiViewport *);
 *     bool (*Platform_GetWindowMinimized)(ImGuiViewport *);
 *     void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *);
 *     void (*Platform_SetWindowAlpha)(ImGuiViewport *, float);
 *     void (*Platform_UpdateWindow)(ImGuiViewport *);
 *     void (*Platform_RenderWindow)(ImGuiViewport *, void *);
 *     void (*Platform_SwapBuffers)(ImGuiViewport *, void *);
 *     float (*Platform_GetWindowDpiScale)(ImGuiViewport *);
 *     void (*Platform_OnChangedViewport)(ImGuiViewport *);
 *     int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *);
 *     void (*Renderer_CreateWindow)(ImGuiViewport *);
 *     void (*Renderer_DestroyWindow)(ImGuiViewport *);
 *     void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2);
 *     void (*Renderer_RenderWindow)(ImGuiViewport *, void *);
 *     void (*Renderer_SwapBuffers)(ImGuiViewport *, void *);
 *     ImVector_ImGuiPlatformMonitor Monitors;
 *     ImVector_ImGuiViewportPtr Viewports;
 * }
 * }
 */
public class ImGuiPlatformIO {

    ImGuiPlatformIO() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        imgui.C_POINTER.withName("Platform_CreateWindow"),
        imgui.C_POINTER.withName("Platform_DestroyWindow"),
        imgui.C_POINTER.withName("Platform_ShowWindow"),
        imgui.C_POINTER.withName("Platform_SetWindowPos"),
        imgui.C_POINTER.withName("Platform_GetWindowPos"),
        imgui.C_POINTER.withName("Platform_SetWindowSize"),
        imgui.C_POINTER.withName("Platform_GetWindowSize"),
        imgui.C_POINTER.withName("Platform_SetWindowFocus"),
        imgui.C_POINTER.withName("Platform_GetWindowFocus"),
        imgui.C_POINTER.withName("Platform_GetWindowMinimized"),
        imgui.C_POINTER.withName("Platform_SetWindowTitle"),
        imgui.C_POINTER.withName("Platform_SetWindowAlpha"),
        imgui.C_POINTER.withName("Platform_UpdateWindow"),
        imgui.C_POINTER.withName("Platform_RenderWindow"),
        imgui.C_POINTER.withName("Platform_SwapBuffers"),
        imgui.C_POINTER.withName("Platform_GetWindowDpiScale"),
        imgui.C_POINTER.withName("Platform_OnChangedViewport"),
        imgui.C_POINTER.withName("Platform_CreateVkSurface"),
        imgui.C_POINTER.withName("Renderer_CreateWindow"),
        imgui.C_POINTER.withName("Renderer_DestroyWindow"),
        imgui.C_POINTER.withName("Renderer_SetWindowSize"),
        imgui.C_POINTER.withName("Renderer_RenderWindow"),
        imgui.C_POINTER.withName("Renderer_SwapBuffers"),
        ImVector_ImGuiPlatformMonitor.layout().withName("Monitors"),
        ImVector_ImGuiViewportPtr.layout().withName("Viewports")
    ).withName("ImGuiPlatformIO");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static class Platform_CreateWindow {

        Platform_CreateWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_CreateWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_CreateWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_CreateWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_CreateWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_CreateWindow$layout() {
        return Platform_CreateWindow$LAYOUT;
    }

    private static final long Platform_CreateWindow$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static final long Platform_CreateWindow$offset() {
        return Platform_CreateWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_CreateWindow(MemorySegment struct) {
        return struct.get(Platform_CreateWindow$LAYOUT, Platform_CreateWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static void Platform_CreateWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_CreateWindow$LAYOUT, Platform_CreateWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static class Platform_DestroyWindow {

        Platform_DestroyWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_DestroyWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_DestroyWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_DestroyWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_DestroyWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_DestroyWindow$layout() {
        return Platform_DestroyWindow$LAYOUT;
    }

    private static final long Platform_DestroyWindow$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static final long Platform_DestroyWindow$offset() {
        return Platform_DestroyWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_DestroyWindow(MemorySegment struct) {
        return struct.get(Platform_DestroyWindow$LAYOUT, Platform_DestroyWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static void Platform_DestroyWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_DestroyWindow$LAYOUT, Platform_DestroyWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_ShowWindow)(ImGuiViewport *)
     * }
     */
    public static class Platform_ShowWindow {

        Platform_ShowWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_ShowWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_ShowWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_ShowWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_ShowWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_ShowWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_ShowWindow$layout() {
        return Platform_ShowWindow$LAYOUT;
    }

    private static final long Platform_ShowWindow$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_ShowWindow)(ImGuiViewport *)
     * }
     */
    public static final long Platform_ShowWindow$offset() {
        return Platform_ShowWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_ShowWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_ShowWindow(MemorySegment struct) {
        return struct.get(Platform_ShowWindow$LAYOUT, Platform_ShowWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_ShowWindow)(ImGuiViewport *)
     * }
     */
    public static void Platform_ShowWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_ShowWindow$LAYOUT, Platform_ShowWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2)
     * }
     */
    public static class Platform_SetWindowPos {

        Platform_SetWindowPos() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            ImVec2.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SetWindowPos.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SetWindowPos.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SetWindowPos$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SetWindowPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final AddressLayout Platform_SetWindowPos$layout() {
        return Platform_SetWindowPos$LAYOUT;
    }

    private static final long Platform_SetWindowPos$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final long Platform_SetWindowPos$offset() {
        return Platform_SetWindowPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2)
     * }
     */
    public static MemorySegment Platform_SetWindowPos(MemorySegment struct) {
        return struct.get(Platform_SetWindowPos$LAYOUT, Platform_SetWindowPos$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowPos)(ImGuiViewport *, ImVec2)
     * }
     */
    public static void Platform_SetWindowPos(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SetWindowPos$LAYOUT, Platform_SetWindowPos$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *)
     * }
     */
    public static class Platform_GetWindowPos {

        Platform_GetWindowPos() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ImVec2.layout(),
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_GetWindowPos.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_GetWindowPos.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, SegmentAllocator alloc,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, alloc, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_GetWindowPos$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_GetWindowPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_GetWindowPos$layout() {
        return Platform_GetWindowPos$LAYOUT;
    }

    private static final long Platform_GetWindowPos$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *)
     * }
     */
    public static final long Platform_GetWindowPos$offset() {
        return Platform_GetWindowPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_GetWindowPos(MemorySegment struct) {
        return struct.get(Platform_GetWindowPos$LAYOUT, Platform_GetWindowPos$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowPos)(ImGuiViewport *)
     * }
     */
    public static void Platform_GetWindowPos(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_GetWindowPos$LAYOUT, Platform_GetWindowPos$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static class Platform_SetWindowSize {

        Platform_SetWindowSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            ImVec2.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SetWindowSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SetWindowSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SetWindowSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SetWindowSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final AddressLayout Platform_SetWindowSize$layout() {
        return Platform_SetWindowSize$LAYOUT;
    }

    private static final long Platform_SetWindowSize$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final long Platform_SetWindowSize$offset() {
        return Platform_SetWindowSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static MemorySegment Platform_SetWindowSize(MemorySegment struct) {
        return struct.get(Platform_SetWindowSize$LAYOUT, Platform_SetWindowSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static void Platform_SetWindowSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SetWindowSize$LAYOUT, Platform_SetWindowSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *)
     * }
     */
    public static class Platform_GetWindowSize {

        Platform_GetWindowSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ImVec2.layout(),
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_GetWindowSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_GetWindowSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, SegmentAllocator alloc,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, alloc, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_GetWindowSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_GetWindowSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_GetWindowSize$layout() {
        return Platform_GetWindowSize$LAYOUT;
    }

    private static final long Platform_GetWindowSize$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *)
     * }
     */
    public static final long Platform_GetWindowSize$offset() {
        return Platform_GetWindowSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_GetWindowSize(MemorySegment struct) {
        return struct.get(Platform_GetWindowSize$LAYOUT, Platform_GetWindowSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVec2 (*Platform_GetWindowSize)(ImGuiViewport *)
     * }
     */
    public static void Platform_GetWindowSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_GetWindowSize$LAYOUT, Platform_GetWindowSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static class Platform_SetWindowFocus {

        Platform_SetWindowFocus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SetWindowFocus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SetWindowFocus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SetWindowFocus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SetWindowFocus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_SetWindowFocus$layout() {
        return Platform_SetWindowFocus$LAYOUT;
    }

    private static final long Platform_SetWindowFocus$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static final long Platform_SetWindowFocus$offset() {
        return Platform_SetWindowFocus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_SetWindowFocus(MemorySegment struct) {
        return struct.get(Platform_SetWindowFocus$LAYOUT, Platform_SetWindowFocus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static void Platform_SetWindowFocus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SetWindowFocus$LAYOUT, Platform_SetWindowFocus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * bool (*Platform_GetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static class Platform_GetWindowFocus {

        Platform_GetWindowFocus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            imgui.C_BOOL,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_GetWindowFocus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_GetWindowFocus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_GetWindowFocus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_GetWindowFocus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_GetWindowFocus$layout() {
        return Platform_GetWindowFocus$LAYOUT;
    }

    private static final long Platform_GetWindowFocus$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static final long Platform_GetWindowFocus$offset() {
        return Platform_GetWindowFocus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_GetWindowFocus(MemorySegment struct) {
        return struct.get(Platform_GetWindowFocus$LAYOUT, Platform_GetWindowFocus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowFocus)(ImGuiViewport *)
     * }
     */
    public static void Platform_GetWindowFocus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_GetWindowFocus$LAYOUT, Platform_GetWindowFocus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * bool (*Platform_GetWindowMinimized)(ImGuiViewport *)
     * }
     */
    public static class Platform_GetWindowMinimized {

        Platform_GetWindowMinimized() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            imgui.C_BOOL,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_GetWindowMinimized.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_GetWindowMinimized.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_GetWindowMinimized$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_GetWindowMinimized"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowMinimized)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_GetWindowMinimized$layout() {
        return Platform_GetWindowMinimized$LAYOUT;
    }

    private static final long Platform_GetWindowMinimized$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowMinimized)(ImGuiViewport *)
     * }
     */
    public static final long Platform_GetWindowMinimized$offset() {
        return Platform_GetWindowMinimized$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowMinimized)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_GetWindowMinimized(MemorySegment struct) {
        return struct.get(Platform_GetWindowMinimized$LAYOUT, Platform_GetWindowMinimized$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool (*Platform_GetWindowMinimized)(ImGuiViewport *)
     * }
     */
    public static void Platform_GetWindowMinimized(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_GetWindowMinimized$LAYOUT, Platform_GetWindowMinimized$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *)
     * }
     */
    public static class Platform_SetWindowTitle {

        Platform_SetWindowTitle() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SetWindowTitle.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SetWindowTitle.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SetWindowTitle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SetWindowTitle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *)
     * }
     */
    public static final AddressLayout Platform_SetWindowTitle$layout() {
        return Platform_SetWindowTitle$LAYOUT;
    }

    private static final long Platform_SetWindowTitle$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *)
     * }
     */
    public static final long Platform_SetWindowTitle$offset() {
        return Platform_SetWindowTitle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *)
     * }
     */
    public static MemorySegment Platform_SetWindowTitle(MemorySegment struct) {
        return struct.get(Platform_SetWindowTitle$LAYOUT, Platform_SetWindowTitle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowTitle)(ImGuiViewport *, const char *)
     * }
     */
    public static void Platform_SetWindowTitle(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SetWindowTitle$LAYOUT, Platform_SetWindowTitle$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SetWindowAlpha)(ImGuiViewport *, float)
     * }
     */
    public static class Platform_SetWindowAlpha {

        Platform_SetWindowAlpha() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, float _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SetWindowAlpha.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SetWindowAlpha.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SetWindowAlpha$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SetWindowAlpha"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowAlpha)(ImGuiViewport *, float)
     * }
     */
    public static final AddressLayout Platform_SetWindowAlpha$layout() {
        return Platform_SetWindowAlpha$LAYOUT;
    }

    private static final long Platform_SetWindowAlpha$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowAlpha)(ImGuiViewport *, float)
     * }
     */
    public static final long Platform_SetWindowAlpha$offset() {
        return Platform_SetWindowAlpha$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowAlpha)(ImGuiViewport *, float)
     * }
     */
    public static MemorySegment Platform_SetWindowAlpha(MemorySegment struct) {
        return struct.get(Platform_SetWindowAlpha$LAYOUT, Platform_SetWindowAlpha$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SetWindowAlpha)(ImGuiViewport *, float)
     * }
     */
    public static void Platform_SetWindowAlpha(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SetWindowAlpha$LAYOUT, Platform_SetWindowAlpha$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_UpdateWindow)(ImGuiViewport *)
     * }
     */
    public static class Platform_UpdateWindow {

        Platform_UpdateWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_UpdateWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_UpdateWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_UpdateWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_UpdateWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_UpdateWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_UpdateWindow$layout() {
        return Platform_UpdateWindow$LAYOUT;
    }

    private static final long Platform_UpdateWindow$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_UpdateWindow)(ImGuiViewport *)
     * }
     */
    public static final long Platform_UpdateWindow$offset() {
        return Platform_UpdateWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_UpdateWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_UpdateWindow(MemorySegment struct) {
        return struct.get(Platform_UpdateWindow$LAYOUT, Platform_UpdateWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_UpdateWindow)(ImGuiViewport *)
     * }
     */
    public static void Platform_UpdateWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_UpdateWindow$LAYOUT, Platform_UpdateWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static class Platform_RenderWindow {

        Platform_RenderWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_RenderWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_RenderWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_RenderWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_RenderWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static final AddressLayout Platform_RenderWindow$layout() {
        return Platform_RenderWindow$LAYOUT;
    }

    private static final long Platform_RenderWindow$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static final long Platform_RenderWindow$offset() {
        return Platform_RenderWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static MemorySegment Platform_RenderWindow(MemorySegment struct) {
        return struct.get(Platform_RenderWindow$LAYOUT, Platform_RenderWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static void Platform_RenderWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_RenderWindow$LAYOUT, Platform_RenderWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static class Platform_SwapBuffers {

        Platform_SwapBuffers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_SwapBuffers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_SwapBuffers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_SwapBuffers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_SwapBuffers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static final AddressLayout Platform_SwapBuffers$layout() {
        return Platform_SwapBuffers$LAYOUT;
    }

    private static final long Platform_SwapBuffers$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static final long Platform_SwapBuffers$offset() {
        return Platform_SwapBuffers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static MemorySegment Platform_SwapBuffers(MemorySegment struct) {
        return struct.get(Platform_SwapBuffers$LAYOUT, Platform_SwapBuffers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static void Platform_SwapBuffers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_SwapBuffers$LAYOUT, Platform_SwapBuffers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*Platform_GetWindowDpiScale)(ImGuiViewport *)
     * }
     */
    public static class Platform_GetWindowDpiScale {

        Platform_GetWindowDpiScale() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            imgui.C_FLOAT,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_GetWindowDpiScale.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_GetWindowDpiScale.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_GetWindowDpiScale$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_GetWindowDpiScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*Platform_GetWindowDpiScale)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_GetWindowDpiScale$layout() {
        return Platform_GetWindowDpiScale$LAYOUT;
    }

    private static final long Platform_GetWindowDpiScale$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*Platform_GetWindowDpiScale)(ImGuiViewport *)
     * }
     */
    public static final long Platform_GetWindowDpiScale$offset() {
        return Platform_GetWindowDpiScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*Platform_GetWindowDpiScale)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_GetWindowDpiScale(MemorySegment struct) {
        return struct.get(Platform_GetWindowDpiScale$LAYOUT, Platform_GetWindowDpiScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*Platform_GetWindowDpiScale)(ImGuiViewport *)
     * }
     */
    public static void Platform_GetWindowDpiScale(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_GetWindowDpiScale$LAYOUT, Platform_GetWindowDpiScale$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Platform_OnChangedViewport)(ImGuiViewport *)
     * }
     */
    public static class Platform_OnChangedViewport {

        Platform_OnChangedViewport() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_OnChangedViewport.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_OnChangedViewport.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_OnChangedViewport$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_OnChangedViewport"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Platform_OnChangedViewport)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Platform_OnChangedViewport$layout() {
        return Platform_OnChangedViewport$LAYOUT;
    }

    private static final long Platform_OnChangedViewport$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Platform_OnChangedViewport)(ImGuiViewport *)
     * }
     */
    public static final long Platform_OnChangedViewport$offset() {
        return Platform_OnChangedViewport$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Platform_OnChangedViewport)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Platform_OnChangedViewport(MemorySegment struct) {
        return struct.get(Platform_OnChangedViewport$LAYOUT, Platform_OnChangedViewport$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Platform_OnChangedViewport)(ImGuiViewport *)
     * }
     */
    public static void Platform_OnChangedViewport(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_OnChangedViewport$LAYOUT, Platform_OnChangedViewport$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *)
     * }
     */
    public static class Platform_CreateVkSurface {

        Platform_CreateVkSurface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            imgui.C_INT,
            imgui.C_POINTER,
            imgui.C_LONG_LONG,
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Platform_CreateVkSurface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Platform_CreateVkSurface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Platform_CreateVkSurface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Platform_CreateVkSurface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *)
     * }
     */
    public static final AddressLayout Platform_CreateVkSurface$layout() {
        return Platform_CreateVkSurface$LAYOUT;
    }

    private static final long Platform_CreateVkSurface$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *)
     * }
     */
    public static final long Platform_CreateVkSurface$offset() {
        return Platform_CreateVkSurface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *)
     * }
     */
    public static MemorySegment Platform_CreateVkSurface(MemorySegment struct) {
        return struct.get(Platform_CreateVkSurface$LAYOUT, Platform_CreateVkSurface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*Platform_CreateVkSurface)(ImGuiViewport *, ImU64, const void *, ImU64 *)
     * }
     */
    public static void Platform_CreateVkSurface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Platform_CreateVkSurface$LAYOUT, Platform_CreateVkSurface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Renderer_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static class Renderer_CreateWindow {

        Renderer_CreateWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Renderer_CreateWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Renderer_CreateWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Renderer_CreateWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Renderer_CreateWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Renderer_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Renderer_CreateWindow$layout() {
        return Renderer_CreateWindow$LAYOUT;
    }

    private static final long Renderer_CreateWindow$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Renderer_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static final long Renderer_CreateWindow$offset() {
        return Renderer_CreateWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Renderer_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Renderer_CreateWindow(MemorySegment struct) {
        return struct.get(Renderer_CreateWindow$LAYOUT, Renderer_CreateWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Renderer_CreateWindow)(ImGuiViewport *)
     * }
     */
    public static void Renderer_CreateWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Renderer_CreateWindow$LAYOUT, Renderer_CreateWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Renderer_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static class Renderer_DestroyWindow {

        Renderer_DestroyWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Renderer_DestroyWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Renderer_DestroyWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Renderer_DestroyWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Renderer_DestroyWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Renderer_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static final AddressLayout Renderer_DestroyWindow$layout() {
        return Renderer_DestroyWindow$LAYOUT;
    }

    private static final long Renderer_DestroyWindow$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Renderer_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static final long Renderer_DestroyWindow$offset() {
        return Renderer_DestroyWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Renderer_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static MemorySegment Renderer_DestroyWindow(MemorySegment struct) {
        return struct.get(Renderer_DestroyWindow$LAYOUT, Renderer_DestroyWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Renderer_DestroyWindow)(ImGuiViewport *)
     * }
     */
    public static void Renderer_DestroyWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Renderer_DestroyWindow$LAYOUT, Renderer_DestroyWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static class Renderer_SetWindowSize {

        Renderer_SetWindowSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            ImVec2.layout()
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Renderer_SetWindowSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Renderer_SetWindowSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Renderer_SetWindowSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Renderer_SetWindowSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final AddressLayout Renderer_SetWindowSize$layout() {
        return Renderer_SetWindowSize$LAYOUT;
    }

    private static final long Renderer_SetWindowSize$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static final long Renderer_SetWindowSize$offset() {
        return Renderer_SetWindowSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static MemorySegment Renderer_SetWindowSize(MemorySegment struct) {
        return struct.get(Renderer_SetWindowSize$LAYOUT, Renderer_SetWindowSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Renderer_SetWindowSize)(ImGuiViewport *, ImVec2)
     * }
     */
    public static void Renderer_SetWindowSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Renderer_SetWindowSize$LAYOUT, Renderer_SetWindowSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Renderer_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static class Renderer_RenderWindow {

        Renderer_RenderWindow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Renderer_RenderWindow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Renderer_RenderWindow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Renderer_RenderWindow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Renderer_RenderWindow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Renderer_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static final AddressLayout Renderer_RenderWindow$layout() {
        return Renderer_RenderWindow$LAYOUT;
    }

    private static final long Renderer_RenderWindow$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Renderer_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static final long Renderer_RenderWindow$offset() {
        return Renderer_RenderWindow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Renderer_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static MemorySegment Renderer_RenderWindow(MemorySegment struct) {
        return struct.get(Renderer_RenderWindow$LAYOUT, Renderer_RenderWindow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Renderer_RenderWindow)(ImGuiViewport *, void *)
     * }
     */
    public static void Renderer_RenderWindow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Renderer_RenderWindow$LAYOUT, Renderer_RenderWindow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*Renderer_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static class Renderer_SwapBuffers {

        Renderer_SwapBuffers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            imgui.C_POINTER,
            imgui.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = imgui.upcallHandle(Renderer_SwapBuffers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Renderer_SwapBuffers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Renderer_SwapBuffers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Renderer_SwapBuffers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*Renderer_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static final AddressLayout Renderer_SwapBuffers$layout() {
        return Renderer_SwapBuffers$LAYOUT;
    }

    private static final long Renderer_SwapBuffers$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*Renderer_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static final long Renderer_SwapBuffers$offset() {
        return Renderer_SwapBuffers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*Renderer_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static MemorySegment Renderer_SwapBuffers(MemorySegment struct) {
        return struct.get(Renderer_SwapBuffers$LAYOUT, Renderer_SwapBuffers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*Renderer_SwapBuffers)(ImGuiViewport *, void *)
     * }
     */
    public static void Renderer_SwapBuffers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Renderer_SwapBuffers$LAYOUT, Renderer_SwapBuffers$OFFSET, fieldValue);
    }

    private static final GroupLayout Monitors$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Monitors"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVector_ImGuiPlatformMonitor Monitors
     * }
     */
    public static final GroupLayout Monitors$layout() {
        return Monitors$LAYOUT;
    }

    private static final long Monitors$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVector_ImGuiPlatformMonitor Monitors
     * }
     */
    public static final long Monitors$offset() {
        return Monitors$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiPlatformMonitor Monitors
     * }
     */
    public static MemorySegment Monitors(MemorySegment struct) {
        return struct.asSlice(Monitors$OFFSET, Monitors$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiPlatformMonitor Monitors
     * }
     */
    public static void Monitors(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Monitors$OFFSET, Monitors$LAYOUT.byteSize());
    }

    private static final GroupLayout Viewports$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("Viewports"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ImVector_ImGuiViewportPtr Viewports
     * }
     */
    public static final GroupLayout Viewports$layout() {
        return Viewports$LAYOUT;
    }

    private static final long Viewports$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ImVector_ImGuiViewportPtr Viewports
     * }
     */
    public static final long Viewports$offset() {
        return Viewports$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiViewportPtr Viewports
     * }
     */
    public static MemorySegment Viewports(MemorySegment struct) {
        return struct.asSlice(Viewports$OFFSET, Viewports$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ImVector_ImGuiViewportPtr Viewports
     * }
     */
    public static void Viewports(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Viewports$OFFSET, Viewports$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

