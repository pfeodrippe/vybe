// Generated by jextract

package org.vybe.jolt_cs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct JPH_PhysicsSettings {
 *     int maxInFlightBodyPairs;
 *     int stepListenersBatchSize;
 *     int stepListenerBatchesPerJob;
 *     float baumgarte;
 *     float speculativeContactDistance;
 *     float penetrationSlop;
 *     float linearCastThreshold;
 *     float linearCastMaxPenetration;
 *     float manifoldToleranceSq;
 *     float maxPenetrationDistance;
 *     float bodyPairCacheMaxDeltaPositionSq;
 *     float bodyPairCacheCosMaxDeltaRotationDiv2;
 *     float contactNormalCosMaxDeltaRotation;
 *     float contactPointPreserveLambdaMaxDistSq;
 *     uint32_t numVelocitySteps;
 *     uint32_t numPositionSteps;
 *     float minVelocityForRestitution;
 *     float timeBeforeSleep;
 *     float pointVelocitySleepThreshold;
 *     JPH_Bool32 deterministicSimulation;
 *     JPH_Bool32 constraintWarmStart;
 *     JPH_Bool32 useBodyPairContactCache;
 *     JPH_Bool32 useManifoldReduction;
 *     JPH_Bool32 useLargeIslandSplitter;
 *     JPH_Bool32 allowSleeping;
 *     JPH_Bool32 checkActiveEdges;
 * }
 * }
 */
public class JPH_PhysicsSettings {

    JPH_PhysicsSettings() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        jolt_cs.C_INT.withName("maxInFlightBodyPairs"),
        jolt_cs.C_INT.withName("stepListenersBatchSize"),
        jolt_cs.C_INT.withName("stepListenerBatchesPerJob"),
        jolt_cs.C_FLOAT.withName("baumgarte"),
        jolt_cs.C_FLOAT.withName("speculativeContactDistance"),
        jolt_cs.C_FLOAT.withName("penetrationSlop"),
        jolt_cs.C_FLOAT.withName("linearCastThreshold"),
        jolt_cs.C_FLOAT.withName("linearCastMaxPenetration"),
        jolt_cs.C_FLOAT.withName("manifoldToleranceSq"),
        jolt_cs.C_FLOAT.withName("maxPenetrationDistance"),
        jolt_cs.C_FLOAT.withName("bodyPairCacheMaxDeltaPositionSq"),
        jolt_cs.C_FLOAT.withName("bodyPairCacheCosMaxDeltaRotationDiv2"),
        jolt_cs.C_FLOAT.withName("contactNormalCosMaxDeltaRotation"),
        jolt_cs.C_FLOAT.withName("contactPointPreserveLambdaMaxDistSq"),
        jolt_cs.C_INT.withName("numVelocitySteps"),
        jolt_cs.C_INT.withName("numPositionSteps"),
        jolt_cs.C_FLOAT.withName("minVelocityForRestitution"),
        jolt_cs.C_FLOAT.withName("timeBeforeSleep"),
        jolt_cs.C_FLOAT.withName("pointVelocitySleepThreshold"),
        jolt_cs.C_INT.withName("deterministicSimulation"),
        jolt_cs.C_INT.withName("constraintWarmStart"),
        jolt_cs.C_INT.withName("useBodyPairContactCache"),
        jolt_cs.C_INT.withName("useManifoldReduction"),
        jolt_cs.C_INT.withName("useLargeIslandSplitter"),
        jolt_cs.C_INT.withName("allowSleeping"),
        jolt_cs.C_INT.withName("checkActiveEdges")
    ).withName("JPH_PhysicsSettings");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt maxInFlightBodyPairs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxInFlightBodyPairs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxInFlightBodyPairs
     * }
     */
    public static final OfInt maxInFlightBodyPairs$layout() {
        return maxInFlightBodyPairs$LAYOUT;
    }

    private static final long maxInFlightBodyPairs$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxInFlightBodyPairs
     * }
     */
    public static final long maxInFlightBodyPairs$offset() {
        return maxInFlightBodyPairs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxInFlightBodyPairs
     * }
     */
    public static int maxInFlightBodyPairs(MemorySegment struct) {
        return struct.get(maxInFlightBodyPairs$LAYOUT, maxInFlightBodyPairs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxInFlightBodyPairs
     * }
     */
    public static void maxInFlightBodyPairs(MemorySegment struct, int fieldValue) {
        struct.set(maxInFlightBodyPairs$LAYOUT, maxInFlightBodyPairs$OFFSET, fieldValue);
    }

    private static final OfInt stepListenersBatchSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("stepListenersBatchSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int stepListenersBatchSize
     * }
     */
    public static final OfInt stepListenersBatchSize$layout() {
        return stepListenersBatchSize$LAYOUT;
    }

    private static final long stepListenersBatchSize$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int stepListenersBatchSize
     * }
     */
    public static final long stepListenersBatchSize$offset() {
        return stepListenersBatchSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int stepListenersBatchSize
     * }
     */
    public static int stepListenersBatchSize(MemorySegment struct) {
        return struct.get(stepListenersBatchSize$LAYOUT, stepListenersBatchSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int stepListenersBatchSize
     * }
     */
    public static void stepListenersBatchSize(MemorySegment struct, int fieldValue) {
        struct.set(stepListenersBatchSize$LAYOUT, stepListenersBatchSize$OFFSET, fieldValue);
    }

    private static final OfInt stepListenerBatchesPerJob$LAYOUT = (OfInt)$LAYOUT.select(groupElement("stepListenerBatchesPerJob"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int stepListenerBatchesPerJob
     * }
     */
    public static final OfInt stepListenerBatchesPerJob$layout() {
        return stepListenerBatchesPerJob$LAYOUT;
    }

    private static final long stepListenerBatchesPerJob$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int stepListenerBatchesPerJob
     * }
     */
    public static final long stepListenerBatchesPerJob$offset() {
        return stepListenerBatchesPerJob$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int stepListenerBatchesPerJob
     * }
     */
    public static int stepListenerBatchesPerJob(MemorySegment struct) {
        return struct.get(stepListenerBatchesPerJob$LAYOUT, stepListenerBatchesPerJob$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int stepListenerBatchesPerJob
     * }
     */
    public static void stepListenerBatchesPerJob(MemorySegment struct, int fieldValue) {
        struct.set(stepListenerBatchesPerJob$LAYOUT, stepListenerBatchesPerJob$OFFSET, fieldValue);
    }

    private static final OfFloat baumgarte$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("baumgarte"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float baumgarte
     * }
     */
    public static final OfFloat baumgarte$layout() {
        return baumgarte$LAYOUT;
    }

    private static final long baumgarte$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float baumgarte
     * }
     */
    public static final long baumgarte$offset() {
        return baumgarte$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float baumgarte
     * }
     */
    public static float baumgarte(MemorySegment struct) {
        return struct.get(baumgarte$LAYOUT, baumgarte$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float baumgarte
     * }
     */
    public static void baumgarte(MemorySegment struct, float fieldValue) {
        struct.set(baumgarte$LAYOUT, baumgarte$OFFSET, fieldValue);
    }

    private static final OfFloat speculativeContactDistance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("speculativeContactDistance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float speculativeContactDistance
     * }
     */
    public static final OfFloat speculativeContactDistance$layout() {
        return speculativeContactDistance$LAYOUT;
    }

    private static final long speculativeContactDistance$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float speculativeContactDistance
     * }
     */
    public static final long speculativeContactDistance$offset() {
        return speculativeContactDistance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float speculativeContactDistance
     * }
     */
    public static float speculativeContactDistance(MemorySegment struct) {
        return struct.get(speculativeContactDistance$LAYOUT, speculativeContactDistance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float speculativeContactDistance
     * }
     */
    public static void speculativeContactDistance(MemorySegment struct, float fieldValue) {
        struct.set(speculativeContactDistance$LAYOUT, speculativeContactDistance$OFFSET, fieldValue);
    }

    private static final OfFloat penetrationSlop$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("penetrationSlop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float penetrationSlop
     * }
     */
    public static final OfFloat penetrationSlop$layout() {
        return penetrationSlop$LAYOUT;
    }

    private static final long penetrationSlop$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float penetrationSlop
     * }
     */
    public static final long penetrationSlop$offset() {
        return penetrationSlop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float penetrationSlop
     * }
     */
    public static float penetrationSlop(MemorySegment struct) {
        return struct.get(penetrationSlop$LAYOUT, penetrationSlop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float penetrationSlop
     * }
     */
    public static void penetrationSlop(MemorySegment struct, float fieldValue) {
        struct.set(penetrationSlop$LAYOUT, penetrationSlop$OFFSET, fieldValue);
    }

    private static final OfFloat linearCastThreshold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("linearCastThreshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float linearCastThreshold
     * }
     */
    public static final OfFloat linearCastThreshold$layout() {
        return linearCastThreshold$LAYOUT;
    }

    private static final long linearCastThreshold$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float linearCastThreshold
     * }
     */
    public static final long linearCastThreshold$offset() {
        return linearCastThreshold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float linearCastThreshold
     * }
     */
    public static float linearCastThreshold(MemorySegment struct) {
        return struct.get(linearCastThreshold$LAYOUT, linearCastThreshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float linearCastThreshold
     * }
     */
    public static void linearCastThreshold(MemorySegment struct, float fieldValue) {
        struct.set(linearCastThreshold$LAYOUT, linearCastThreshold$OFFSET, fieldValue);
    }

    private static final OfFloat linearCastMaxPenetration$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("linearCastMaxPenetration"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float linearCastMaxPenetration
     * }
     */
    public static final OfFloat linearCastMaxPenetration$layout() {
        return linearCastMaxPenetration$LAYOUT;
    }

    private static final long linearCastMaxPenetration$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float linearCastMaxPenetration
     * }
     */
    public static final long linearCastMaxPenetration$offset() {
        return linearCastMaxPenetration$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float linearCastMaxPenetration
     * }
     */
    public static float linearCastMaxPenetration(MemorySegment struct) {
        return struct.get(linearCastMaxPenetration$LAYOUT, linearCastMaxPenetration$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float linearCastMaxPenetration
     * }
     */
    public static void linearCastMaxPenetration(MemorySegment struct, float fieldValue) {
        struct.set(linearCastMaxPenetration$LAYOUT, linearCastMaxPenetration$OFFSET, fieldValue);
    }

    private static final OfFloat manifoldToleranceSq$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("manifoldToleranceSq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float manifoldToleranceSq
     * }
     */
    public static final OfFloat manifoldToleranceSq$layout() {
        return manifoldToleranceSq$LAYOUT;
    }

    private static final long manifoldToleranceSq$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float manifoldToleranceSq
     * }
     */
    public static final long manifoldToleranceSq$offset() {
        return manifoldToleranceSq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float manifoldToleranceSq
     * }
     */
    public static float manifoldToleranceSq(MemorySegment struct) {
        return struct.get(manifoldToleranceSq$LAYOUT, manifoldToleranceSq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float manifoldToleranceSq
     * }
     */
    public static void manifoldToleranceSq(MemorySegment struct, float fieldValue) {
        struct.set(manifoldToleranceSq$LAYOUT, manifoldToleranceSq$OFFSET, fieldValue);
    }

    private static final OfFloat maxPenetrationDistance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxPenetrationDistance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxPenetrationDistance
     * }
     */
    public static final OfFloat maxPenetrationDistance$layout() {
        return maxPenetrationDistance$LAYOUT;
    }

    private static final long maxPenetrationDistance$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxPenetrationDistance
     * }
     */
    public static final long maxPenetrationDistance$offset() {
        return maxPenetrationDistance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxPenetrationDistance
     * }
     */
    public static float maxPenetrationDistance(MemorySegment struct) {
        return struct.get(maxPenetrationDistance$LAYOUT, maxPenetrationDistance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxPenetrationDistance
     * }
     */
    public static void maxPenetrationDistance(MemorySegment struct, float fieldValue) {
        struct.set(maxPenetrationDistance$LAYOUT, maxPenetrationDistance$OFFSET, fieldValue);
    }

    private static final OfFloat bodyPairCacheMaxDeltaPositionSq$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("bodyPairCacheMaxDeltaPositionSq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float bodyPairCacheMaxDeltaPositionSq
     * }
     */
    public static final OfFloat bodyPairCacheMaxDeltaPositionSq$layout() {
        return bodyPairCacheMaxDeltaPositionSq$LAYOUT;
    }

    private static final long bodyPairCacheMaxDeltaPositionSq$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float bodyPairCacheMaxDeltaPositionSq
     * }
     */
    public static final long bodyPairCacheMaxDeltaPositionSq$offset() {
        return bodyPairCacheMaxDeltaPositionSq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float bodyPairCacheMaxDeltaPositionSq
     * }
     */
    public static float bodyPairCacheMaxDeltaPositionSq(MemorySegment struct) {
        return struct.get(bodyPairCacheMaxDeltaPositionSq$LAYOUT, bodyPairCacheMaxDeltaPositionSq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float bodyPairCacheMaxDeltaPositionSq
     * }
     */
    public static void bodyPairCacheMaxDeltaPositionSq(MemorySegment struct, float fieldValue) {
        struct.set(bodyPairCacheMaxDeltaPositionSq$LAYOUT, bodyPairCacheMaxDeltaPositionSq$OFFSET, fieldValue);
    }

    private static final OfFloat bodyPairCacheCosMaxDeltaRotationDiv2$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("bodyPairCacheCosMaxDeltaRotationDiv2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float bodyPairCacheCosMaxDeltaRotationDiv2
     * }
     */
    public static final OfFloat bodyPairCacheCosMaxDeltaRotationDiv2$layout() {
        return bodyPairCacheCosMaxDeltaRotationDiv2$LAYOUT;
    }

    private static final long bodyPairCacheCosMaxDeltaRotationDiv2$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float bodyPairCacheCosMaxDeltaRotationDiv2
     * }
     */
    public static final long bodyPairCacheCosMaxDeltaRotationDiv2$offset() {
        return bodyPairCacheCosMaxDeltaRotationDiv2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float bodyPairCacheCosMaxDeltaRotationDiv2
     * }
     */
    public static float bodyPairCacheCosMaxDeltaRotationDiv2(MemorySegment struct) {
        return struct.get(bodyPairCacheCosMaxDeltaRotationDiv2$LAYOUT, bodyPairCacheCosMaxDeltaRotationDiv2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float bodyPairCacheCosMaxDeltaRotationDiv2
     * }
     */
    public static void bodyPairCacheCosMaxDeltaRotationDiv2(MemorySegment struct, float fieldValue) {
        struct.set(bodyPairCacheCosMaxDeltaRotationDiv2$LAYOUT, bodyPairCacheCosMaxDeltaRotationDiv2$OFFSET, fieldValue);
    }

    private static final OfFloat contactNormalCosMaxDeltaRotation$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("contactNormalCosMaxDeltaRotation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float contactNormalCosMaxDeltaRotation
     * }
     */
    public static final OfFloat contactNormalCosMaxDeltaRotation$layout() {
        return contactNormalCosMaxDeltaRotation$LAYOUT;
    }

    private static final long contactNormalCosMaxDeltaRotation$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float contactNormalCosMaxDeltaRotation
     * }
     */
    public static final long contactNormalCosMaxDeltaRotation$offset() {
        return contactNormalCosMaxDeltaRotation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float contactNormalCosMaxDeltaRotation
     * }
     */
    public static float contactNormalCosMaxDeltaRotation(MemorySegment struct) {
        return struct.get(contactNormalCosMaxDeltaRotation$LAYOUT, contactNormalCosMaxDeltaRotation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float contactNormalCosMaxDeltaRotation
     * }
     */
    public static void contactNormalCosMaxDeltaRotation(MemorySegment struct, float fieldValue) {
        struct.set(contactNormalCosMaxDeltaRotation$LAYOUT, contactNormalCosMaxDeltaRotation$OFFSET, fieldValue);
    }

    private static final OfFloat contactPointPreserveLambdaMaxDistSq$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("contactPointPreserveLambdaMaxDistSq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float contactPointPreserveLambdaMaxDistSq
     * }
     */
    public static final OfFloat contactPointPreserveLambdaMaxDistSq$layout() {
        return contactPointPreserveLambdaMaxDistSq$LAYOUT;
    }

    private static final long contactPointPreserveLambdaMaxDistSq$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float contactPointPreserveLambdaMaxDistSq
     * }
     */
    public static final long contactPointPreserveLambdaMaxDistSq$offset() {
        return contactPointPreserveLambdaMaxDistSq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float contactPointPreserveLambdaMaxDistSq
     * }
     */
    public static float contactPointPreserveLambdaMaxDistSq(MemorySegment struct) {
        return struct.get(contactPointPreserveLambdaMaxDistSq$LAYOUT, contactPointPreserveLambdaMaxDistSq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float contactPointPreserveLambdaMaxDistSq
     * }
     */
    public static void contactPointPreserveLambdaMaxDistSq(MemorySegment struct, float fieldValue) {
        struct.set(contactPointPreserveLambdaMaxDistSq$LAYOUT, contactPointPreserveLambdaMaxDistSq$OFFSET, fieldValue);
    }

    private static final OfInt numVelocitySteps$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numVelocitySteps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t numVelocitySteps
     * }
     */
    public static final OfInt numVelocitySteps$layout() {
        return numVelocitySteps$LAYOUT;
    }

    private static final long numVelocitySteps$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t numVelocitySteps
     * }
     */
    public static final long numVelocitySteps$offset() {
        return numVelocitySteps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t numVelocitySteps
     * }
     */
    public static int numVelocitySteps(MemorySegment struct) {
        return struct.get(numVelocitySteps$LAYOUT, numVelocitySteps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t numVelocitySteps
     * }
     */
    public static void numVelocitySteps(MemorySegment struct, int fieldValue) {
        struct.set(numVelocitySteps$LAYOUT, numVelocitySteps$OFFSET, fieldValue);
    }

    private static final OfInt numPositionSteps$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numPositionSteps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t numPositionSteps
     * }
     */
    public static final OfInt numPositionSteps$layout() {
        return numPositionSteps$LAYOUT;
    }

    private static final long numPositionSteps$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t numPositionSteps
     * }
     */
    public static final long numPositionSteps$offset() {
        return numPositionSteps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t numPositionSteps
     * }
     */
    public static int numPositionSteps(MemorySegment struct) {
        return struct.get(numPositionSteps$LAYOUT, numPositionSteps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t numPositionSteps
     * }
     */
    public static void numPositionSteps(MemorySegment struct, int fieldValue) {
        struct.set(numPositionSteps$LAYOUT, numPositionSteps$OFFSET, fieldValue);
    }

    private static final OfFloat minVelocityForRestitution$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minVelocityForRestitution"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minVelocityForRestitution
     * }
     */
    public static final OfFloat minVelocityForRestitution$layout() {
        return minVelocityForRestitution$LAYOUT;
    }

    private static final long minVelocityForRestitution$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minVelocityForRestitution
     * }
     */
    public static final long minVelocityForRestitution$offset() {
        return minVelocityForRestitution$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minVelocityForRestitution
     * }
     */
    public static float minVelocityForRestitution(MemorySegment struct) {
        return struct.get(minVelocityForRestitution$LAYOUT, minVelocityForRestitution$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minVelocityForRestitution
     * }
     */
    public static void minVelocityForRestitution(MemorySegment struct, float fieldValue) {
        struct.set(minVelocityForRestitution$LAYOUT, minVelocityForRestitution$OFFSET, fieldValue);
    }

    private static final OfFloat timeBeforeSleep$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("timeBeforeSleep"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float timeBeforeSleep
     * }
     */
    public static final OfFloat timeBeforeSleep$layout() {
        return timeBeforeSleep$LAYOUT;
    }

    private static final long timeBeforeSleep$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float timeBeforeSleep
     * }
     */
    public static final long timeBeforeSleep$offset() {
        return timeBeforeSleep$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float timeBeforeSleep
     * }
     */
    public static float timeBeforeSleep(MemorySegment struct) {
        return struct.get(timeBeforeSleep$LAYOUT, timeBeforeSleep$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float timeBeforeSleep
     * }
     */
    public static void timeBeforeSleep(MemorySegment struct, float fieldValue) {
        struct.set(timeBeforeSleep$LAYOUT, timeBeforeSleep$OFFSET, fieldValue);
    }

    private static final OfFloat pointVelocitySleepThreshold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("pointVelocitySleepThreshold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float pointVelocitySleepThreshold
     * }
     */
    public static final OfFloat pointVelocitySleepThreshold$layout() {
        return pointVelocitySleepThreshold$LAYOUT;
    }

    private static final long pointVelocitySleepThreshold$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float pointVelocitySleepThreshold
     * }
     */
    public static final long pointVelocitySleepThreshold$offset() {
        return pointVelocitySleepThreshold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float pointVelocitySleepThreshold
     * }
     */
    public static float pointVelocitySleepThreshold(MemorySegment struct) {
        return struct.get(pointVelocitySleepThreshold$LAYOUT, pointVelocitySleepThreshold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float pointVelocitySleepThreshold
     * }
     */
    public static void pointVelocitySleepThreshold(MemorySegment struct, float fieldValue) {
        struct.set(pointVelocitySleepThreshold$LAYOUT, pointVelocitySleepThreshold$OFFSET, fieldValue);
    }

    private static final OfInt deterministicSimulation$LAYOUT = (OfInt)$LAYOUT.select(groupElement("deterministicSimulation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 deterministicSimulation
     * }
     */
    public static final OfInt deterministicSimulation$layout() {
        return deterministicSimulation$LAYOUT;
    }

    private static final long deterministicSimulation$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 deterministicSimulation
     * }
     */
    public static final long deterministicSimulation$offset() {
        return deterministicSimulation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 deterministicSimulation
     * }
     */
    public static int deterministicSimulation(MemorySegment struct) {
        return struct.get(deterministicSimulation$LAYOUT, deterministicSimulation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 deterministicSimulation
     * }
     */
    public static void deterministicSimulation(MemorySegment struct, int fieldValue) {
        struct.set(deterministicSimulation$LAYOUT, deterministicSimulation$OFFSET, fieldValue);
    }

    private static final OfInt constraintWarmStart$LAYOUT = (OfInt)$LAYOUT.select(groupElement("constraintWarmStart"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 constraintWarmStart
     * }
     */
    public static final OfInt constraintWarmStart$layout() {
        return constraintWarmStart$LAYOUT;
    }

    private static final long constraintWarmStart$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 constraintWarmStart
     * }
     */
    public static final long constraintWarmStart$offset() {
        return constraintWarmStart$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 constraintWarmStart
     * }
     */
    public static int constraintWarmStart(MemorySegment struct) {
        return struct.get(constraintWarmStart$LAYOUT, constraintWarmStart$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 constraintWarmStart
     * }
     */
    public static void constraintWarmStart(MemorySegment struct, int fieldValue) {
        struct.set(constraintWarmStart$LAYOUT, constraintWarmStart$OFFSET, fieldValue);
    }

    private static final OfInt useBodyPairContactCache$LAYOUT = (OfInt)$LAYOUT.select(groupElement("useBodyPairContactCache"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 useBodyPairContactCache
     * }
     */
    public static final OfInt useBodyPairContactCache$layout() {
        return useBodyPairContactCache$LAYOUT;
    }

    private static final long useBodyPairContactCache$OFFSET = 84;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 useBodyPairContactCache
     * }
     */
    public static final long useBodyPairContactCache$offset() {
        return useBodyPairContactCache$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useBodyPairContactCache
     * }
     */
    public static int useBodyPairContactCache(MemorySegment struct) {
        return struct.get(useBodyPairContactCache$LAYOUT, useBodyPairContactCache$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useBodyPairContactCache
     * }
     */
    public static void useBodyPairContactCache(MemorySegment struct, int fieldValue) {
        struct.set(useBodyPairContactCache$LAYOUT, useBodyPairContactCache$OFFSET, fieldValue);
    }

    private static final OfInt useManifoldReduction$LAYOUT = (OfInt)$LAYOUT.select(groupElement("useManifoldReduction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 useManifoldReduction
     * }
     */
    public static final OfInt useManifoldReduction$layout() {
        return useManifoldReduction$LAYOUT;
    }

    private static final long useManifoldReduction$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 useManifoldReduction
     * }
     */
    public static final long useManifoldReduction$offset() {
        return useManifoldReduction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useManifoldReduction
     * }
     */
    public static int useManifoldReduction(MemorySegment struct) {
        return struct.get(useManifoldReduction$LAYOUT, useManifoldReduction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useManifoldReduction
     * }
     */
    public static void useManifoldReduction(MemorySegment struct, int fieldValue) {
        struct.set(useManifoldReduction$LAYOUT, useManifoldReduction$OFFSET, fieldValue);
    }

    private static final OfInt useLargeIslandSplitter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("useLargeIslandSplitter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 useLargeIslandSplitter
     * }
     */
    public static final OfInt useLargeIslandSplitter$layout() {
        return useLargeIslandSplitter$LAYOUT;
    }

    private static final long useLargeIslandSplitter$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 useLargeIslandSplitter
     * }
     */
    public static final long useLargeIslandSplitter$offset() {
        return useLargeIslandSplitter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useLargeIslandSplitter
     * }
     */
    public static int useLargeIslandSplitter(MemorySegment struct) {
        return struct.get(useLargeIslandSplitter$LAYOUT, useLargeIslandSplitter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 useLargeIslandSplitter
     * }
     */
    public static void useLargeIslandSplitter(MemorySegment struct, int fieldValue) {
        struct.set(useLargeIslandSplitter$LAYOUT, useLargeIslandSplitter$OFFSET, fieldValue);
    }

    private static final OfInt allowSleeping$LAYOUT = (OfInt)$LAYOUT.select(groupElement("allowSleeping"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 allowSleeping
     * }
     */
    public static final OfInt allowSleeping$layout() {
        return allowSleeping$LAYOUT;
    }

    private static final long allowSleeping$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 allowSleeping
     * }
     */
    public static final long allowSleeping$offset() {
        return allowSleeping$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 allowSleeping
     * }
     */
    public static int allowSleeping(MemorySegment struct) {
        return struct.get(allowSleeping$LAYOUT, allowSleeping$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 allowSleeping
     * }
     */
    public static void allowSleeping(MemorySegment struct, int fieldValue) {
        struct.set(allowSleeping$LAYOUT, allowSleeping$OFFSET, fieldValue);
    }

    private static final OfInt checkActiveEdges$LAYOUT = (OfInt)$LAYOUT.select(groupElement("checkActiveEdges"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPH_Bool32 checkActiveEdges
     * }
     */
    public static final OfInt checkActiveEdges$layout() {
        return checkActiveEdges$LAYOUT;
    }

    private static final long checkActiveEdges$OFFSET = 100;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPH_Bool32 checkActiveEdges
     * }
     */
    public static final long checkActiveEdges$offset() {
        return checkActiveEdges$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPH_Bool32 checkActiveEdges
     * }
     */
    public static int checkActiveEdges(MemorySegment struct) {
        return struct.get(checkActiveEdges$LAYOUT, checkActiveEdges$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPH_Bool32 checkActiveEdges
     * }
     */
    public static void checkActiveEdges(MemorySegment struct, int fieldValue) {
        struct.set(checkActiveEdges$LAYOUT, checkActiveEdges$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

