// Generated by jextract

package org.vybe.raylib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class raylib extends raylib_1 {

    raylib() {
        // Should not be called directly
    }
    private static final int RL_LOG_FATAL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_FATAL = 6
     * }
     */
    public static int RL_LOG_FATAL() {
        return RL_LOG_FATAL;
    }
    private static final int RL_LOG_NONE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_NONE = 7
     * }
     */
    public static int RL_LOG_NONE() {
        return RL_LOG_NONE;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE() {
        return RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA() {
        return RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16 = 11
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 14
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT1_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_DXT1_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 18
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC1_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_ETC1_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 19
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC2_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_ETC2_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 21
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_PVRT_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_PVRT_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA;
    }
    private static final int RL_TEXTURE_FILTER_POINT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_POINT = 0
     * }
     */
    public static int RL_TEXTURE_FILTER_POINT() {
        return RL_TEXTURE_FILTER_POINT;
    }
    private static final int RL_TEXTURE_FILTER_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_BILINEAR = 1
     * }
     */
    public static int RL_TEXTURE_FILTER_BILINEAR() {
        return RL_TEXTURE_FILTER_BILINEAR;
    }
    private static final int RL_TEXTURE_FILTER_TRILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_TRILINEAR = 2
     * }
     */
    public static int RL_TEXTURE_FILTER_TRILINEAR() {
        return RL_TEXTURE_FILTER_TRILINEAR;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_4X = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_4X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_4X;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_8X = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_8X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_8X;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_16X = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_16X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_16X;
    }
    private static final int RL_BLEND_ALPHA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ALPHA = 0
     * }
     */
    public static int RL_BLEND_ALPHA() {
        return RL_BLEND_ALPHA;
    }
    private static final int RL_BLEND_ADDITIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ADDITIVE = 1
     * }
     */
    public static int RL_BLEND_ADDITIVE() {
        return RL_BLEND_ADDITIVE;
    }
    private static final int RL_BLEND_MULTIPLIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_MULTIPLIED = 2
     * }
     */
    public static int RL_BLEND_MULTIPLIED() {
        return RL_BLEND_MULTIPLIED;
    }
    private static final int RL_BLEND_ADD_COLORS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ADD_COLORS = 3
     * }
     */
    public static int RL_BLEND_ADD_COLORS() {
        return RL_BLEND_ADD_COLORS;
    }
    private static final int RL_BLEND_SUBTRACT_COLORS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_SUBTRACT_COLORS = 4
     * }
     */
    public static int RL_BLEND_SUBTRACT_COLORS() {
        return RL_BLEND_SUBTRACT_COLORS;
    }
    private static final int RL_BLEND_ALPHA_PREMULTIPLY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ALPHA_PREMULTIPLY = 5
     * }
     */
    public static int RL_BLEND_ALPHA_PREMULTIPLY() {
        return RL_BLEND_ALPHA_PREMULTIPLY;
    }
    private static final int RL_BLEND_CUSTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_CUSTOM = 6
     * }
     */
    public static int RL_BLEND_CUSTOM() {
        return RL_BLEND_CUSTOM;
    }
    private static final int RL_BLEND_CUSTOM_SEPARATE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_CUSTOM_SEPARATE = 7
     * }
     */
    public static int RL_BLEND_CUSTOM_SEPARATE() {
        return RL_BLEND_CUSTOM_SEPARATE;
    }
    private static final int RL_SHADER_LOC_VERTEX_POSITION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_POSITION = 0
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_POSITION() {
        return RL_SHADER_LOC_VERTEX_POSITION;
    }
    private static final int RL_SHADER_LOC_VERTEX_TEXCOORD01 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TEXCOORD01() {
        return RL_SHADER_LOC_VERTEX_TEXCOORD01;
    }
    private static final int RL_SHADER_LOC_VERTEX_TEXCOORD02 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TEXCOORD02() {
        return RL_SHADER_LOC_VERTEX_TEXCOORD02;
    }
    private static final int RL_SHADER_LOC_VERTEX_NORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_NORMAL = 3
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_NORMAL() {
        return RL_SHADER_LOC_VERTEX_NORMAL;
    }
    private static final int RL_SHADER_LOC_VERTEX_TANGENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TANGENT = 4
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TANGENT() {
        return RL_SHADER_LOC_VERTEX_TANGENT;
    }
    private static final int RL_SHADER_LOC_VERTEX_COLOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_COLOR = 5
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_COLOR() {
        return RL_SHADER_LOC_VERTEX_COLOR;
    }
    private static final int RL_SHADER_LOC_MATRIX_MVP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_MVP = 6
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_MVP() {
        return RL_SHADER_LOC_MATRIX_MVP;
    }
    private static final int RL_SHADER_LOC_MATRIX_VIEW = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_VIEW = 7
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_VIEW() {
        return RL_SHADER_LOC_MATRIX_VIEW;
    }
    private static final int RL_SHADER_LOC_MATRIX_PROJECTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_PROJECTION = 8
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_PROJECTION() {
        return RL_SHADER_LOC_MATRIX_PROJECTION;
    }
    private static final int RL_SHADER_LOC_MATRIX_MODEL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_MODEL = 9
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_MODEL() {
        return RL_SHADER_LOC_MATRIX_MODEL;
    }
    private static final int RL_SHADER_LOC_MATRIX_NORMAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_NORMAL = 10
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_NORMAL() {
        return RL_SHADER_LOC_MATRIX_NORMAL;
    }
    private static final int RL_SHADER_LOC_VECTOR_VIEW = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VECTOR_VIEW = 11
     * }
     */
    public static int RL_SHADER_LOC_VECTOR_VIEW() {
        return RL_SHADER_LOC_VECTOR_VIEW;
    }
    private static final int RL_SHADER_LOC_COLOR_DIFFUSE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_DIFFUSE = 12
     * }
     */
    public static int RL_SHADER_LOC_COLOR_DIFFUSE() {
        return RL_SHADER_LOC_COLOR_DIFFUSE;
    }
    private static final int RL_SHADER_LOC_COLOR_SPECULAR = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_SPECULAR = 13
     * }
     */
    public static int RL_SHADER_LOC_COLOR_SPECULAR() {
        return RL_SHADER_LOC_COLOR_SPECULAR;
    }
    private static final int RL_SHADER_LOC_COLOR_AMBIENT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_AMBIENT = 14
     * }
     */
    public static int RL_SHADER_LOC_COLOR_AMBIENT() {
        return RL_SHADER_LOC_COLOR_AMBIENT;
    }
    private static final int RL_SHADER_LOC_MAP_ALBEDO = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_ALBEDO = 15
     * }
     */
    public static int RL_SHADER_LOC_MAP_ALBEDO() {
        return RL_SHADER_LOC_MAP_ALBEDO;
    }
    private static final int RL_SHADER_LOC_MAP_METALNESS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_METALNESS = 16
     * }
     */
    public static int RL_SHADER_LOC_MAP_METALNESS() {
        return RL_SHADER_LOC_MAP_METALNESS;
    }
    private static final int RL_SHADER_LOC_MAP_NORMAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_NORMAL = 17
     * }
     */
    public static int RL_SHADER_LOC_MAP_NORMAL() {
        return RL_SHADER_LOC_MAP_NORMAL;
    }
    private static final int RL_SHADER_LOC_MAP_ROUGHNESS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_ROUGHNESS = 18
     * }
     */
    public static int RL_SHADER_LOC_MAP_ROUGHNESS() {
        return RL_SHADER_LOC_MAP_ROUGHNESS;
    }
    private static final int RL_SHADER_LOC_MAP_OCCLUSION = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_OCCLUSION = 19
     * }
     */
    public static int RL_SHADER_LOC_MAP_OCCLUSION() {
        return RL_SHADER_LOC_MAP_OCCLUSION;
    }
    private static final int RL_SHADER_LOC_MAP_EMISSION = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_EMISSION = 20
     * }
     */
    public static int RL_SHADER_LOC_MAP_EMISSION() {
        return RL_SHADER_LOC_MAP_EMISSION;
    }
    private static final int RL_SHADER_LOC_MAP_HEIGHT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_HEIGHT = 21
     * }
     */
    public static int RL_SHADER_LOC_MAP_HEIGHT() {
        return RL_SHADER_LOC_MAP_HEIGHT;
    }
    private static final int RL_SHADER_LOC_MAP_CUBEMAP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_CUBEMAP = 22
     * }
     */
    public static int RL_SHADER_LOC_MAP_CUBEMAP() {
        return RL_SHADER_LOC_MAP_CUBEMAP;
    }
    private static final int RL_SHADER_LOC_MAP_IRRADIANCE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_IRRADIANCE = 23
     * }
     */
    public static int RL_SHADER_LOC_MAP_IRRADIANCE() {
        return RL_SHADER_LOC_MAP_IRRADIANCE;
    }
    private static final int RL_SHADER_LOC_MAP_PREFILTER = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_PREFILTER = 24
     * }
     */
    public static int RL_SHADER_LOC_MAP_PREFILTER() {
        return RL_SHADER_LOC_MAP_PREFILTER;
    }
    private static final int RL_SHADER_LOC_MAP_BRDF = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_BRDF = 25
     * }
     */
    public static int RL_SHADER_LOC_MAP_BRDF() {
        return RL_SHADER_LOC_MAP_BRDF;
    }
    private static final int RL_SHADER_UNIFORM_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_FLOAT = 0
     * }
     */
    public static int RL_SHADER_UNIFORM_FLOAT() {
        return RL_SHADER_UNIFORM_FLOAT;
    }
    private static final int RL_SHADER_UNIFORM_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC2 = 1
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC2() {
        return RL_SHADER_UNIFORM_VEC2;
    }
    private static final int RL_SHADER_UNIFORM_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC3 = 2
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC3() {
        return RL_SHADER_UNIFORM_VEC3;
    }
    private static final int RL_SHADER_UNIFORM_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC4 = 3
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC4() {
        return RL_SHADER_UNIFORM_VEC4;
    }
    private static final int RL_SHADER_UNIFORM_INT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_INT = 4
     * }
     */
    public static int RL_SHADER_UNIFORM_INT() {
        return RL_SHADER_UNIFORM_INT;
    }
    private static final int RL_SHADER_UNIFORM_IVEC2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC2 = 5
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC2() {
        return RL_SHADER_UNIFORM_IVEC2;
    }
    private static final int RL_SHADER_UNIFORM_IVEC3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC3 = 6
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC3() {
        return RL_SHADER_UNIFORM_IVEC3;
    }
    private static final int RL_SHADER_UNIFORM_IVEC4 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC4 = 7
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC4() {
        return RL_SHADER_UNIFORM_IVEC4;
    }
    private static final int RL_SHADER_UNIFORM_SAMPLER2D = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_SAMPLER2D = 8
     * }
     */
    public static int RL_SHADER_UNIFORM_SAMPLER2D() {
        return RL_SHADER_UNIFORM_SAMPLER2D;
    }
    private static final int RL_SHADER_ATTRIB_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_FLOAT = 0
     * }
     */
    public static int RL_SHADER_ATTRIB_FLOAT() {
        return RL_SHADER_ATTRIB_FLOAT;
    }
    private static final int RL_SHADER_ATTRIB_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC2 = 1
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC2() {
        return RL_SHADER_ATTRIB_VEC2;
    }
    private static final int RL_SHADER_ATTRIB_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC3 = 2
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC3() {
        return RL_SHADER_ATTRIB_VEC3;
    }
    private static final int RL_SHADER_ATTRIB_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC4 = 3
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC4() {
        return RL_SHADER_ATTRIB_VEC4;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL0 = 0
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL0() {
        return RL_ATTACHMENT_COLOR_CHANNEL0;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL1 = 1
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL1() {
        return RL_ATTACHMENT_COLOR_CHANNEL1;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL2 = 2
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL2() {
        return RL_ATTACHMENT_COLOR_CHANNEL2;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL3 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL3 = 3
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL3() {
        return RL_ATTACHMENT_COLOR_CHANNEL3;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL4 = 4
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL4() {
        return RL_ATTACHMENT_COLOR_CHANNEL4;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL5 = 5
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL5() {
        return RL_ATTACHMENT_COLOR_CHANNEL5;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL6 = 6
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL6() {
        return RL_ATTACHMENT_COLOR_CHANNEL6;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL7 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL7 = 7
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL7() {
        return RL_ATTACHMENT_COLOR_CHANNEL7;
    }
    private static final int RL_ATTACHMENT_DEPTH = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_DEPTH = 100
     * }
     */
    public static int RL_ATTACHMENT_DEPTH() {
        return RL_ATTACHMENT_DEPTH;
    }
    private static final int RL_ATTACHMENT_STENCIL = (int)200L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_STENCIL = 200
     * }
     */
    public static int RL_ATTACHMENT_STENCIL() {
        return RL_ATTACHMENT_STENCIL;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_X = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_X() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_X;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_X() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_X;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_Y() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_Y;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_Z() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_Z;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z;
    }
    private static final int RL_ATTACHMENT_TEXTURE2D = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_TEXTURE2D = 100
     * }
     */
    public static int RL_ATTACHMENT_TEXTURE2D() {
        return RL_ATTACHMENT_TEXTURE2D;
    }
    private static final int RL_ATTACHMENT_RENDERBUFFER = (int)200L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_RENDERBUFFER = 200
     * }
     */
    public static int RL_ATTACHMENT_RENDERBUFFER() {
        return RL_ATTACHMENT_RENDERBUFFER;
    }
    private static final int RL_CULL_FACE_FRONT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_CULL_FACE_FRONT = 0
     * }
     */
    public static int RL_CULL_FACE_FRONT() {
        return RL_CULL_FACE_FRONT;
    }
    private static final int RL_CULL_FACE_BACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_CULL_FACE_BACK = 1
     * }
     */
    public static int RL_CULL_FACE_BACK() {
        return RL_CULL_FACE_BACK;
    }

    private static class rlMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static FunctionDescriptor rlMatrixMode$descriptor() {
        return rlMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static MethodHandle rlMatrixMode$handle() {
        return rlMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static MemorySegment rlMatrixMode$address() {
        return rlMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static void rlMatrixMode(int mode) {
        var mh$ = rlMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static FunctionDescriptor rlPushMatrix$descriptor() {
        return rlPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static MethodHandle rlPushMatrix$handle() {
        return rlPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static MemorySegment rlPushMatrix$address() {
        return rlPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static void rlPushMatrix() {
        var mh$ = rlPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static FunctionDescriptor rlPopMatrix$descriptor() {
        return rlPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static MethodHandle rlPopMatrix$handle() {
        return rlPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static MemorySegment rlPopMatrix$address() {
        return rlPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static void rlPopMatrix() {
        var mh$ = rlPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static FunctionDescriptor rlLoadIdentity$descriptor() {
        return rlLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static MethodHandle rlLoadIdentity$handle() {
        return rlLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static MemorySegment rlLoadIdentity$address() {
        return rlLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static void rlLoadIdentity() {
        var mh$ = rlLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlTranslatef$descriptor() {
        return rlTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static MethodHandle rlTranslatef$handle() {
        return rlTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static MemorySegment rlTranslatef$address() {
        return rlTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static void rlTranslatef(float x, float y, float z) {
        var mh$ = rlTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlRotatef$descriptor() {
        return rlRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static MethodHandle rlRotatef$handle() {
        return rlRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static MemorySegment rlRotatef$address() {
        return rlRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static void rlRotatef(float angle, float x, float y, float z) {
        var mh$ = rlRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlScalef$descriptor() {
        return rlScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static MethodHandle rlScalef$handle() {
        return rlScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static MemorySegment rlScalef$address() {
        return rlScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static void rlScalef(float x, float y, float z) {
        var mh$ = rlScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static FunctionDescriptor rlMultMatrixf$descriptor() {
        return rlMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static MethodHandle rlMultMatrixf$handle() {
        return rlMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static MemorySegment rlMultMatrixf$address() {
        return rlMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static void rlMultMatrixf(MemorySegment matf) {
        var mh$ = rlMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlMultMatrixf", matf);
            }
            mh$.invokeExact(matf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static FunctionDescriptor rlFrustum$descriptor() {
        return rlFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MethodHandle rlFrustum$handle() {
        return rlFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MemorySegment rlFrustum$address() {
        return rlFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar) {
        var mh$ = rlFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFrustum", left, right, bottom, top, znear, zfar);
            }
            mh$.invokeExact(left, right, bottom, top, znear, zfar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static FunctionDescriptor rlOrtho$descriptor() {
        return rlOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MethodHandle rlOrtho$handle() {
        return rlOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MemorySegment rlOrtho$address() {
        return rlOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar) {
        var mh$ = rlOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlOrtho", left, right, bottom, top, znear, zfar);
            }
            mh$.invokeExact(left, right, bottom, top, znear, zfar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor rlViewport$descriptor() {
        return rlViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle rlViewport$handle() {
        return rlViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment rlViewport$address() {
        return rlViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static void rlViewport(int x, int y, int width, int height) {
        var mh$ = rlViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetClipPlanes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetClipPlanes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static FunctionDescriptor rlSetClipPlanes$descriptor() {
        return rlSetClipPlanes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static MethodHandle rlSetClipPlanes$handle() {
        return rlSetClipPlanes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static MemorySegment rlSetClipPlanes$address() {
        return rlSetClipPlanes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static void rlSetClipPlanes(double near, double far) {
        var mh$ = rlSetClipPlanes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetClipPlanes", near, far);
            }
            mh$.invokeExact(near, far);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetCullDistanceNear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetCullDistanceNear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static FunctionDescriptor rlGetCullDistanceNear$descriptor() {
        return rlGetCullDistanceNear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static MethodHandle rlGetCullDistanceNear$handle() {
        return rlGetCullDistanceNear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static MemorySegment rlGetCullDistanceNear$address() {
        return rlGetCullDistanceNear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static double rlGetCullDistanceNear() {
        var mh$ = rlGetCullDistanceNear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetCullDistanceNear");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetCullDistanceFar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetCullDistanceFar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static FunctionDescriptor rlGetCullDistanceFar$descriptor() {
        return rlGetCullDistanceFar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static MethodHandle rlGetCullDistanceFar$handle() {
        return rlGetCullDistanceFar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static MemorySegment rlGetCullDistanceFar$address() {
        return rlGetCullDistanceFar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static double rlGetCullDistanceFar() {
        var mh$ = rlGetCullDistanceFar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetCullDistanceFar");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static FunctionDescriptor rlBegin$descriptor() {
        return rlBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static MethodHandle rlBegin$handle() {
        return rlBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static MemorySegment rlBegin$address() {
        return rlBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static void rlBegin(int mode) {
        var mh$ = rlBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static FunctionDescriptor rlEnd$descriptor() {
        return rlEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static MethodHandle rlEnd$handle() {
        return rlEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static MemorySegment rlEnd$address() {
        return rlEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static void rlEnd() {
        var mh$ = rlEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static FunctionDescriptor rlVertex2i$descriptor() {
        return rlVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static MethodHandle rlVertex2i$handle() {
        return rlVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static MemorySegment rlVertex2i$address() {
        return rlVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static void rlVertex2i(int x, int y) {
        var mh$ = rlVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static FunctionDescriptor rlVertex2f$descriptor() {
        return rlVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static MethodHandle rlVertex2f$handle() {
        return rlVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static MemorySegment rlVertex2f$address() {
        return rlVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static void rlVertex2f(float x, float y) {
        var mh$ = rlVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlVertex3f$descriptor() {
        return rlVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlVertex3f$handle() {
        return rlVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlVertex3f$address() {
        return rlVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static void rlVertex3f(float x, float y, float z) {
        var mh$ = rlVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static FunctionDescriptor rlTexCoord2f$descriptor() {
        return rlTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static MethodHandle rlTexCoord2f$handle() {
        return rlTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static MemorySegment rlTexCoord2f$address() {
        return rlTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static void rlTexCoord2f(float x, float y) {
        var mh$ = rlTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTexCoord2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlNormal3f$descriptor() {
        return rlNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlNormal3f$handle() {
        return rlNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlNormal3f$address() {
        return rlNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static void rlNormal3f(float x, float y, float z) {
        var mh$ = rlNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlNormal3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static FunctionDescriptor rlColor4ub$descriptor() {
        return rlColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MethodHandle rlColor4ub$handle() {
        return rlColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MemorySegment rlColor4ub$address() {
        return rlColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static void rlColor4ub(byte r, byte g, byte b, byte a) {
        var mh$ = rlColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor4ub", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlColor3f$descriptor() {
        return rlColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlColor3f$handle() {
        return rlColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlColor3f$address() {
        return rlColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static void rlColor3f(float x, float y, float z) {
        var mh$ = rlColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static FunctionDescriptor rlColor4f$descriptor() {
        return rlColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static MethodHandle rlColor4f$handle() {
        return rlColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static MemorySegment rlColor4f$address() {
        return rlColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static void rlColor4f(float x, float y, float z, float w) {
        var mh$ = rlColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static FunctionDescriptor rlEnableVertexArray$descriptor() {
        return rlEnableVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static MethodHandle rlEnableVertexArray$handle() {
        return rlEnableVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static MemorySegment rlEnableVertexArray$address() {
        return rlEnableVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static boolean rlEnableVertexArray(int vaoId) {
        var mh$ = rlEnableVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexArray", vaoId);
            }
            return (boolean)mh$.invokeExact(vaoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static FunctionDescriptor rlDisableVertexArray$descriptor() {
        return rlDisableVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static MethodHandle rlDisableVertexArray$handle() {
        return rlDisableVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static MemorySegment rlDisableVertexArray$address() {
        return rlDisableVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static void rlDisableVertexArray() {
        var mh$ = rlDisableVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexArray");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableVertexBuffer$descriptor() {
        return rlEnableVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableVertexBuffer$handle() {
        return rlEnableVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableVertexBuffer$address() {
        return rlEnableVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static void rlEnableVertexBuffer(int id) {
        var mh$ = rlEnableVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexBuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static FunctionDescriptor rlDisableVertexBuffer$descriptor() {
        return rlDisableVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static MethodHandle rlDisableVertexBuffer$handle() {
        return rlDisableVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static MemorySegment rlDisableVertexBuffer$address() {
        return rlDisableVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static void rlDisableVertexBuffer() {
        var mh$ = rlDisableVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexBuffer");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableVertexBufferElement$descriptor() {
        return rlEnableVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableVertexBufferElement$handle() {
        return rlEnableVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableVertexBufferElement$address() {
        return rlEnableVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static void rlEnableVertexBufferElement(int id) {
        var mh$ = rlEnableVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexBufferElement", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static FunctionDescriptor rlDisableVertexBufferElement$descriptor() {
        return rlDisableVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static MethodHandle rlDisableVertexBufferElement$handle() {
        return rlDisableVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static MemorySegment rlDisableVertexBufferElement$address() {
        return rlDisableVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static void rlDisableVertexBufferElement() {
        var mh$ = rlDisableVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexBufferElement");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static FunctionDescriptor rlEnableVertexAttribute$descriptor() {
        return rlEnableVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static MethodHandle rlEnableVertexAttribute$handle() {
        return rlEnableVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static MemorySegment rlEnableVertexAttribute$address() {
        return rlEnableVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static void rlEnableVertexAttribute(int index) {
        var mh$ = rlEnableVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexAttribute", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static FunctionDescriptor rlDisableVertexAttribute$descriptor() {
        return rlDisableVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static MethodHandle rlDisableVertexAttribute$handle() {
        return rlDisableVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static MemorySegment rlDisableVertexAttribute$address() {
        return rlDisableVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static void rlDisableVertexAttribute(int index) {
        var mh$ = rlDisableVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexAttribute", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlActiveTextureSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlActiveTextureSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static FunctionDescriptor rlActiveTextureSlot$descriptor() {
        return rlActiveTextureSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static MethodHandle rlActiveTextureSlot$handle() {
        return rlActiveTextureSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static MemorySegment rlActiveTextureSlot$address() {
        return rlActiveTextureSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static void rlActiveTextureSlot(int slot) {
        var mh$ = rlActiveTextureSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlActiveTextureSlot", slot);
            }
            mh$.invokeExact(slot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableTexture$descriptor() {
        return rlEnableTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableTexture$handle() {
        return rlEnableTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableTexture$address() {
        return rlEnableTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static void rlEnableTexture(int id) {
        var mh$ = rlEnableTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static FunctionDescriptor rlDisableTexture$descriptor() {
        return rlDisableTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static MethodHandle rlDisableTexture$handle() {
        return rlDisableTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static MemorySegment rlDisableTexture$address() {
        return rlDisableTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static void rlDisableTexture() {
        var mh$ = rlDisableTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableTexture");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableTextureCubemap$descriptor() {
        return rlEnableTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableTextureCubemap$handle() {
        return rlEnableTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableTextureCubemap$address() {
        return rlEnableTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static void rlEnableTextureCubemap(int id) {
        var mh$ = rlEnableTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableTextureCubemap", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static FunctionDescriptor rlDisableTextureCubemap$descriptor() {
        return rlDisableTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static MethodHandle rlDisableTextureCubemap$handle() {
        return rlDisableTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static MemorySegment rlDisableTextureCubemap$address() {
        return rlDisableTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static void rlDisableTextureCubemap() {
        var mh$ = rlDisableTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableTextureCubemap");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTextureParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTextureParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static FunctionDescriptor rlTextureParameters$descriptor() {
        return rlTextureParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static MethodHandle rlTextureParameters$handle() {
        return rlTextureParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static MemorySegment rlTextureParameters$address() {
        return rlTextureParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static void rlTextureParameters(int id, int param, int value) {
        var mh$ = rlTextureParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTextureParameters", id, param, value);
            }
            mh$.invokeExact(id, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCubemapParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCubemapParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static FunctionDescriptor rlCubemapParameters$descriptor() {
        return rlCubemapParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static MethodHandle rlCubemapParameters$handle() {
        return rlCubemapParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static MemorySegment rlCubemapParameters$address() {
        return rlCubemapParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static void rlCubemapParameters(int id, int param, int value) {
        var mh$ = rlCubemapParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCubemapParameters", id, param, value);
            }
            mh$.invokeExact(id, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableShader$descriptor() {
        return rlEnableShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableShader$handle() {
        return rlEnableShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableShader$address() {
        return rlEnableShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static void rlEnableShader(int id) {
        var mh$ = rlEnableShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableShader", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static FunctionDescriptor rlDisableShader$descriptor() {
        return rlDisableShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static MethodHandle rlDisableShader$handle() {
        return rlDisableShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static MemorySegment rlDisableShader$address() {
        return rlDisableShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static void rlDisableShader() {
        var mh$ = rlDisableShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableShader");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableFramebuffer$descriptor() {
        return rlEnableFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableFramebuffer$handle() {
        return rlEnableFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableFramebuffer$address() {
        return rlEnableFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static void rlEnableFramebuffer(int id) {
        var mh$ = rlEnableFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableFramebuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static FunctionDescriptor rlDisableFramebuffer$descriptor() {
        return rlDisableFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static MethodHandle rlDisableFramebuffer$handle() {
        return rlDisableFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static MemorySegment rlDisableFramebuffer$address() {
        return rlDisableFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static void rlDisableFramebuffer() {
        var mh$ = rlDisableFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableFramebuffer");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetActiveFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetActiveFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static FunctionDescriptor rlGetActiveFramebuffer$descriptor() {
        return rlGetActiveFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static MethodHandle rlGetActiveFramebuffer$handle() {
        return rlGetActiveFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static MemorySegment rlGetActiveFramebuffer$address() {
        return rlGetActiveFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static int rlGetActiveFramebuffer() {
        var mh$ = rlGetActiveFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetActiveFramebuffer");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlActiveDrawBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlActiveDrawBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static FunctionDescriptor rlActiveDrawBuffers$descriptor() {
        return rlActiveDrawBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static MethodHandle rlActiveDrawBuffers$handle() {
        return rlActiveDrawBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static MemorySegment rlActiveDrawBuffers$address() {
        return rlActiveDrawBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static void rlActiveDrawBuffers(int count) {
        var mh$ = rlActiveDrawBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlActiveDrawBuffers", count);
            }
            mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBlitFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBlitFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static FunctionDescriptor rlBlitFramebuffer$descriptor() {
        return rlBlitFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static MethodHandle rlBlitFramebuffer$handle() {
        return rlBlitFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static MemorySegment rlBlitFramebuffer$address() {
        return rlBlitFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask) {
        var mh$ = rlBlitFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBlitFramebuffer", srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask);
            }
            mh$.invokeExact(srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static FunctionDescriptor rlBindFramebuffer$descriptor() {
        return rlBindFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static MethodHandle rlBindFramebuffer$handle() {
        return rlBindFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static MemorySegment rlBindFramebuffer$address() {
        return rlBindFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static void rlBindFramebuffer(int target, int framebuffer) {
        var mh$ = rlBindFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindFramebuffer", target, framebuffer);
            }
            mh$.invokeExact(target, framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableColorBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableColorBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static FunctionDescriptor rlEnableColorBlend$descriptor() {
        return rlEnableColorBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static MethodHandle rlEnableColorBlend$handle() {
        return rlEnableColorBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static MemorySegment rlEnableColorBlend$address() {
        return rlEnableColorBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static void rlEnableColorBlend() {
        var mh$ = rlEnableColorBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableColorBlend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableColorBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableColorBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static FunctionDescriptor rlDisableColorBlend$descriptor() {
        return rlDisableColorBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static MethodHandle rlDisableColorBlend$handle() {
        return rlDisableColorBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static MemorySegment rlDisableColorBlend$address() {
        return rlDisableColorBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static void rlDisableColorBlend() {
        var mh$ = rlDisableColorBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableColorBlend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableDepthTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableDepthTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static FunctionDescriptor rlEnableDepthTest$descriptor() {
        return rlEnableDepthTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static MethodHandle rlEnableDepthTest$handle() {
        return rlEnableDepthTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static MemorySegment rlEnableDepthTest$address() {
        return rlEnableDepthTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static void rlEnableDepthTest() {
        var mh$ = rlEnableDepthTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableDepthTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableDepthTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableDepthTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static FunctionDescriptor rlDisableDepthTest$descriptor() {
        return rlDisableDepthTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static MethodHandle rlDisableDepthTest$handle() {
        return rlDisableDepthTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static MemorySegment rlDisableDepthTest$address() {
        return rlDisableDepthTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static void rlDisableDepthTest() {
        var mh$ = rlDisableDepthTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableDepthTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static FunctionDescriptor rlEnableDepthMask$descriptor() {
        return rlEnableDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static MethodHandle rlEnableDepthMask$handle() {
        return rlEnableDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static MemorySegment rlEnableDepthMask$address() {
        return rlEnableDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static void rlEnableDepthMask() {
        var mh$ = rlEnableDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableDepthMask");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static FunctionDescriptor rlDisableDepthMask$descriptor() {
        return rlDisableDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static MethodHandle rlDisableDepthMask$handle() {
        return rlDisableDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static MemorySegment rlDisableDepthMask$address() {
        return rlDisableDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static void rlDisableDepthMask() {
        var mh$ = rlDisableDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableDepthMask");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableBackfaceCulling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableBackfaceCulling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static FunctionDescriptor rlEnableBackfaceCulling$descriptor() {
        return rlEnableBackfaceCulling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static MethodHandle rlEnableBackfaceCulling$handle() {
        return rlEnableBackfaceCulling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static MemorySegment rlEnableBackfaceCulling$address() {
        return rlEnableBackfaceCulling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static void rlEnableBackfaceCulling() {
        var mh$ = rlEnableBackfaceCulling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableBackfaceCulling");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableBackfaceCulling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableBackfaceCulling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static FunctionDescriptor rlDisableBackfaceCulling$descriptor() {
        return rlDisableBackfaceCulling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static MethodHandle rlDisableBackfaceCulling$handle() {
        return rlDisableBackfaceCulling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static MemorySegment rlDisableBackfaceCulling$address() {
        return rlDisableBackfaceCulling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static void rlDisableBackfaceCulling() {
        var mh$ = rlDisableBackfaceCulling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableBackfaceCulling");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_BOOL,
            raylib.C_BOOL,
            raylib.C_BOOL,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static FunctionDescriptor rlColorMask$descriptor() {
        return rlColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static MethodHandle rlColorMask$handle() {
        return rlColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static MemorySegment rlColorMask$address() {
        return rlColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static void rlColorMask(boolean r, boolean g, boolean b, boolean a) {
        var mh$ = rlColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColorMask", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static FunctionDescriptor rlSetCullFace$descriptor() {
        return rlSetCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static MethodHandle rlSetCullFace$handle() {
        return rlSetCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static MemorySegment rlSetCullFace$address() {
        return rlSetCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static void rlSetCullFace(int mode) {
        var mh$ = rlSetCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableScissorTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableScissorTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static FunctionDescriptor rlEnableScissorTest$descriptor() {
        return rlEnableScissorTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static MethodHandle rlEnableScissorTest$handle() {
        return rlEnableScissorTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static MemorySegment rlEnableScissorTest$address() {
        return rlEnableScissorTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static void rlEnableScissorTest() {
        var mh$ = rlEnableScissorTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableScissorTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableScissorTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableScissorTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static FunctionDescriptor rlDisableScissorTest$descriptor() {
        return rlDisableScissorTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static MethodHandle rlDisableScissorTest$handle() {
        return rlDisableScissorTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static MemorySegment rlDisableScissorTest$address() {
        return rlDisableScissorTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static void rlDisableScissorTest() {
        var mh$ = rlDisableScissorTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableScissorTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor rlScissor$descriptor() {
        return rlScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle rlScissor$handle() {
        return rlScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment rlScissor$address() {
        return rlScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static void rlScissor(int x, int y, int width, int height) {
        var mh$ = rlScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableWireMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableWireMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static FunctionDescriptor rlEnableWireMode$descriptor() {
        return rlEnableWireMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static MethodHandle rlEnableWireMode$handle() {
        return rlEnableWireMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static MemorySegment rlEnableWireMode$address() {
        return rlEnableWireMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static void rlEnableWireMode() {
        var mh$ = rlEnableWireMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableWireMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnablePointMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnablePointMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static FunctionDescriptor rlEnablePointMode$descriptor() {
        return rlEnablePointMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static MethodHandle rlEnablePointMode$handle() {
        return rlEnablePointMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static MemorySegment rlEnablePointMode$address() {
        return rlEnablePointMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static void rlEnablePointMode() {
        var mh$ = rlEnablePointMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnablePointMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableWireMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableWireMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static FunctionDescriptor rlDisableWireMode$descriptor() {
        return rlDisableWireMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static MethodHandle rlDisableWireMode$handle() {
        return rlDisableWireMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static MemorySegment rlDisableWireMode$address() {
        return rlDisableWireMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static void rlDisableWireMode() {
        var mh$ = rlDisableWireMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableWireMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static FunctionDescriptor rlSetLineWidth$descriptor() {
        return rlSetLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static MethodHandle rlSetLineWidth$handle() {
        return rlSetLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static MemorySegment rlSetLineWidth$address() {
        return rlSetLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static void rlSetLineWidth(float width) {
        var mh$ = rlSetLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static FunctionDescriptor rlGetLineWidth$descriptor() {
        return rlGetLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static MethodHandle rlGetLineWidth$handle() {
        return rlGetLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static MemorySegment rlGetLineWidth$address() {
        return rlGetLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static float rlGetLineWidth() {
        var mh$ = rlGetLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLineWidth");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableSmoothLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableSmoothLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static FunctionDescriptor rlEnableSmoothLines$descriptor() {
        return rlEnableSmoothLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static MethodHandle rlEnableSmoothLines$handle() {
        return rlEnableSmoothLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static MemorySegment rlEnableSmoothLines$address() {
        return rlEnableSmoothLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static void rlEnableSmoothLines() {
        var mh$ = rlEnableSmoothLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableSmoothLines");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableSmoothLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableSmoothLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static FunctionDescriptor rlDisableSmoothLines$descriptor() {
        return rlDisableSmoothLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static MethodHandle rlDisableSmoothLines$handle() {
        return rlDisableSmoothLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static MemorySegment rlDisableSmoothLines$address() {
        return rlDisableSmoothLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static void rlDisableSmoothLines() {
        var mh$ = rlDisableSmoothLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableSmoothLines");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableStereoRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableStereoRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static FunctionDescriptor rlEnableStereoRender$descriptor() {
        return rlEnableStereoRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static MethodHandle rlEnableStereoRender$handle() {
        return rlEnableStereoRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static MemorySegment rlEnableStereoRender$address() {
        return rlEnableStereoRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static void rlEnableStereoRender() {
        var mh$ = rlEnableStereoRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableStereoRender");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableStereoRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableStereoRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static FunctionDescriptor rlDisableStereoRender$descriptor() {
        return rlDisableStereoRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static MethodHandle rlDisableStereoRender$handle() {
        return rlDisableStereoRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static MemorySegment rlDisableStereoRender$address() {
        return rlDisableStereoRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static void rlDisableStereoRender() {
        var mh$ = rlDisableStereoRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableStereoRender");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlIsStereoRenderEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlIsStereoRenderEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static FunctionDescriptor rlIsStereoRenderEnabled$descriptor() {
        return rlIsStereoRenderEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static MethodHandle rlIsStereoRenderEnabled$handle() {
        return rlIsStereoRenderEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static MemorySegment rlIsStereoRenderEnabled$address() {
        return rlIsStereoRenderEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static boolean rlIsStereoRenderEnabled() {
        var mh$ = rlIsStereoRenderEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlIsStereoRenderEnabled");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static FunctionDescriptor rlClearColor$descriptor() {
        return rlClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MethodHandle rlClearColor$handle() {
        return rlClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MemorySegment rlClearColor$address() {
        return rlClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static void rlClearColor(byte r, byte g, byte b, byte a) {
        var mh$ = rlClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlClearColor", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlClearScreenBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlClearScreenBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static FunctionDescriptor rlClearScreenBuffers$descriptor() {
        return rlClearScreenBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static MethodHandle rlClearScreenBuffers$handle() {
        return rlClearScreenBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static MemorySegment rlClearScreenBuffers$address() {
        return rlClearScreenBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static void rlClearScreenBuffers() {
        var mh$ = rlClearScreenBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlClearScreenBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCheckErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCheckErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static FunctionDescriptor rlCheckErrors$descriptor() {
        return rlCheckErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static MethodHandle rlCheckErrors$handle() {
        return rlCheckErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static MemorySegment rlCheckErrors$address() {
        return rlCheckErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static void rlCheckErrors() {
        var mh$ = rlCheckErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCheckErrors");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static FunctionDescriptor rlSetBlendMode$descriptor() {
        return rlSetBlendMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static MethodHandle rlSetBlendMode$handle() {
        return rlSetBlendMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static MemorySegment rlSetBlendMode$address() {
        return rlSetBlendMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static void rlSetBlendMode(int mode) {
        var mh$ = rlSetBlendMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendFactors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendFactors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static FunctionDescriptor rlSetBlendFactors$descriptor() {
        return rlSetBlendFactors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static MethodHandle rlSetBlendFactors$handle() {
        return rlSetBlendFactors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static MemorySegment rlSetBlendFactors$address() {
        return rlSetBlendFactors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation) {
        var mh$ = rlSetBlendFactors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendFactors", glSrcFactor, glDstFactor, glEquation);
            }
            mh$.invokeExact(glSrcFactor, glDstFactor, glEquation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendFactorsSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendFactorsSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static FunctionDescriptor rlSetBlendFactorsSeparate$descriptor() {
        return rlSetBlendFactorsSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static MethodHandle rlSetBlendFactorsSeparate$handle() {
        return rlSetBlendFactorsSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static MemorySegment rlSetBlendFactorsSeparate$address() {
        return rlSetBlendFactorsSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha) {
        var mh$ = rlSetBlendFactorsSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendFactorsSeparate", glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha);
            }
            mh$.invokeExact(glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlglInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlglInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static FunctionDescriptor rlglInit$descriptor() {
        return rlglInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static MethodHandle rlglInit$handle() {
        return rlglInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static MemorySegment rlglInit$address() {
        return rlglInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static void rlglInit(int width, int height) {
        var mh$ = rlglInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlglInit", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlglClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlglClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static FunctionDescriptor rlglClose$descriptor() {
        return rlglClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static MethodHandle rlglClose$handle() {
        return rlglClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static MemorySegment rlglClose$address() {
        return rlglClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static void rlglClose() {
        var mh$ = rlglClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlglClose");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadExtensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadExtensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static FunctionDescriptor rlLoadExtensions$descriptor() {
        return rlLoadExtensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static MethodHandle rlLoadExtensions$handle() {
        return rlLoadExtensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static MemorySegment rlLoadExtensions$address() {
        return rlLoadExtensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static void rlLoadExtensions(MemorySegment loader) {
        var mh$ = rlLoadExtensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadExtensions", loader);
            }
            mh$.invokeExact(loader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static FunctionDescriptor rlGetVersion$descriptor() {
        return rlGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static MethodHandle rlGetVersion$handle() {
        return rlGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static MemorySegment rlGetVersion$address() {
        return rlGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static int rlGetVersion() {
        var mh$ = rlGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetFramebufferWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetFramebufferWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static FunctionDescriptor rlSetFramebufferWidth$descriptor() {
        return rlSetFramebufferWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static MethodHandle rlSetFramebufferWidth$handle() {
        return rlSetFramebufferWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static MemorySegment rlSetFramebufferWidth$address() {
        return rlSetFramebufferWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static void rlSetFramebufferWidth(int width) {
        var mh$ = rlSetFramebufferWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetFramebufferWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetFramebufferWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetFramebufferWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static FunctionDescriptor rlGetFramebufferWidth$descriptor() {
        return rlGetFramebufferWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static MethodHandle rlGetFramebufferWidth$handle() {
        return rlGetFramebufferWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static MemorySegment rlGetFramebufferWidth$address() {
        return rlGetFramebufferWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static int rlGetFramebufferWidth() {
        var mh$ = rlGetFramebufferWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetFramebufferWidth");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetFramebufferHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetFramebufferHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static FunctionDescriptor rlSetFramebufferHeight$descriptor() {
        return rlSetFramebufferHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static MethodHandle rlSetFramebufferHeight$handle() {
        return rlSetFramebufferHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static MemorySegment rlSetFramebufferHeight$address() {
        return rlSetFramebufferHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static void rlSetFramebufferHeight(int height) {
        var mh$ = rlSetFramebufferHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetFramebufferHeight", height);
            }
            mh$.invokeExact(height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetFramebufferHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetFramebufferHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static FunctionDescriptor rlGetFramebufferHeight$descriptor() {
        return rlGetFramebufferHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static MethodHandle rlGetFramebufferHeight$handle() {
        return rlGetFramebufferHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static MemorySegment rlGetFramebufferHeight$address() {
        return rlGetFramebufferHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static int rlGetFramebufferHeight() {
        var mh$ = rlGetFramebufferHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetFramebufferHeight");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetTextureIdDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetTextureIdDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static FunctionDescriptor rlGetTextureIdDefault$descriptor() {
        return rlGetTextureIdDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static MethodHandle rlGetTextureIdDefault$handle() {
        return rlGetTextureIdDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static MemorySegment rlGetTextureIdDefault$address() {
        return rlGetTextureIdDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static int rlGetTextureIdDefault() {
        var mh$ = rlGetTextureIdDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetTextureIdDefault");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderIdDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderIdDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static FunctionDescriptor rlGetShaderIdDefault$descriptor() {
        return rlGetShaderIdDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static MethodHandle rlGetShaderIdDefault$handle() {
        return rlGetShaderIdDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static MemorySegment rlGetShaderIdDefault$address() {
        return rlGetShaderIdDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static int rlGetShaderIdDefault() {
        var mh$ = rlGetShaderIdDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderIdDefault");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderLocsDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderLocsDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static FunctionDescriptor rlGetShaderLocsDefault$descriptor() {
        return rlGetShaderLocsDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MethodHandle rlGetShaderLocsDefault$handle() {
        return rlGetShaderLocsDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MemorySegment rlGetShaderLocsDefault$address() {
        return rlGetShaderLocsDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MemorySegment rlGetShaderLocsDefault() {
        var mh$ = rlGetShaderLocsDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderLocsDefault");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rlRenderBatch.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static FunctionDescriptor rlLoadRenderBatch$descriptor() {
        return rlLoadRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MethodHandle rlLoadRenderBatch$handle() {
        return rlLoadRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MemorySegment rlLoadRenderBatch$address() {
        return rlLoadRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MemorySegment rlLoadRenderBatch(SegmentAllocator allocator, int numBuffers, int bufferElements) {
        var mh$ = rlLoadRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadRenderBatch", allocator, numBuffers, bufferElements);
            }
            return (MemorySegment)mh$.invokeExact(allocator, numBuffers, bufferElements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            rlRenderBatch.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static FunctionDescriptor rlUnloadRenderBatch$descriptor() {
        return rlUnloadRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static MethodHandle rlUnloadRenderBatch$handle() {
        return rlUnloadRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static MemorySegment rlUnloadRenderBatch$address() {
        return rlUnloadRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static void rlUnloadRenderBatch(MemorySegment batch) {
        var mh$ = rlUnloadRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadRenderBatch", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static FunctionDescriptor rlDrawRenderBatch$descriptor() {
        return rlDrawRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static MethodHandle rlDrawRenderBatch$handle() {
        return rlDrawRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static MemorySegment rlDrawRenderBatch$address() {
        return rlDrawRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static void rlDrawRenderBatch(MemorySegment batch) {
        var mh$ = rlDrawRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawRenderBatch", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetRenderBatchActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetRenderBatchActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static FunctionDescriptor rlSetRenderBatchActive$descriptor() {
        return rlSetRenderBatchActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static MethodHandle rlSetRenderBatchActive$handle() {
        return rlSetRenderBatchActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static MemorySegment rlSetRenderBatchActive$address() {
        return rlSetRenderBatchActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static void rlSetRenderBatchActive(MemorySegment batch) {
        var mh$ = rlSetRenderBatchActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetRenderBatchActive", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawRenderBatchActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawRenderBatchActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static FunctionDescriptor rlDrawRenderBatchActive$descriptor() {
        return rlDrawRenderBatchActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static MethodHandle rlDrawRenderBatchActive$handle() {
        return rlDrawRenderBatchActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static MemorySegment rlDrawRenderBatchActive$address() {
        return rlDrawRenderBatchActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static void rlDrawRenderBatchActive() {
        var mh$ = rlDrawRenderBatchActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawRenderBatchActive");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCheckRenderBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCheckRenderBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static FunctionDescriptor rlCheckRenderBatchLimit$descriptor() {
        return rlCheckRenderBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static MethodHandle rlCheckRenderBatchLimit$handle() {
        return rlCheckRenderBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static MemorySegment rlCheckRenderBatchLimit$address() {
        return rlCheckRenderBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static boolean rlCheckRenderBatchLimit(int vCount) {
        var mh$ = rlCheckRenderBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCheckRenderBatchLimit", vCount);
            }
            return (boolean)mh$.invokeExact(vCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlSetTexture$descriptor() {
        return rlSetTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlSetTexture$handle() {
        return rlSetTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlSetTexture$address() {
        return rlSetTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static void rlSetTexture(int id) {
        var mh$ = rlSetTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static FunctionDescriptor rlLoadVertexArray$descriptor() {
        return rlLoadVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static MethodHandle rlLoadVertexArray$handle() {
        return rlLoadVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static MemorySegment rlLoadVertexArray$address() {
        return rlLoadVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static int rlLoadVertexArray() {
        var mh$ = rlLoadVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexArray");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static FunctionDescriptor rlLoadVertexBuffer$descriptor() {
        return rlLoadVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MethodHandle rlLoadVertexBuffer$handle() {
        return rlLoadVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MemorySegment rlLoadVertexBuffer$address() {
        return rlLoadVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static int rlLoadVertexBuffer(MemorySegment buffer, int size, boolean dynamic) {
        var mh$ = rlLoadVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexBuffer", buffer, size, dynamic);
            }
            return (int)mh$.invokeExact(buffer, size, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static FunctionDescriptor rlLoadVertexBufferElement$descriptor() {
        return rlLoadVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MethodHandle rlLoadVertexBufferElement$handle() {
        return rlLoadVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MemorySegment rlLoadVertexBufferElement$address() {
        return rlLoadVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static int rlLoadVertexBufferElement(MemorySegment buffer, int size, boolean dynamic) {
        var mh$ = rlLoadVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexBufferElement", buffer, size, dynamic);
            }
            return (int)mh$.invokeExact(buffer, size, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateVertexBuffer$descriptor() {
        return rlUpdateVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle rlUpdateVertexBuffer$handle() {
        return rlUpdateVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment rlUpdateVertexBuffer$address() {
        return rlUpdateVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static void rlUpdateVertexBuffer(int bufferId, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateVertexBuffer", bufferId, data, dataSize, offset);
            }
            mh$.invokeExact(bufferId, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateVertexBufferElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateVertexBufferElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateVertexBufferElements$descriptor() {
        return rlUpdateVertexBufferElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle rlUpdateVertexBufferElements$handle() {
        return rlUpdateVertexBufferElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment rlUpdateVertexBufferElements$address() {
        return rlUpdateVertexBufferElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static void rlUpdateVertexBufferElements(int id, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateVertexBufferElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateVertexBufferElements", id, data, dataSize, offset);
            }
            mh$.invokeExact(id, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static FunctionDescriptor rlUnloadVertexArray$descriptor() {
        return rlUnloadVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static MethodHandle rlUnloadVertexArray$handle() {
        return rlUnloadVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static MemorySegment rlUnloadVertexArray$address() {
        return rlUnloadVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static void rlUnloadVertexArray(int vaoId) {
        var mh$ = rlUnloadVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadVertexArray", vaoId);
            }
            mh$.invokeExact(vaoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static FunctionDescriptor rlUnloadVertexBuffer$descriptor() {
        return rlUnloadVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static MethodHandle rlUnloadVertexBuffer$handle() {
        return rlUnloadVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static MemorySegment rlUnloadVertexBuffer$address() {
        return rlUnloadVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static void rlUnloadVertexBuffer(int vboId) {
        var mh$ = rlUnloadVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadVertexBuffer", vboId);
            }
            mh$.invokeExact(vboId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttribute$descriptor() {
        return rlSetVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static MethodHandle rlSetVertexAttribute$handle() {
        return rlSetVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static MemorySegment rlSetVertexAttribute$address() {
        return rlSetVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static void rlSetVertexAttribute(int index, int compSize, int type, boolean normalized, int stride, int offset) {
        var mh$ = rlSetVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttribute", index, compSize, type, normalized, stride, offset);
            }
            mh$.invokeExact(index, compSize, type, normalized, stride, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttributeDivisor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttributeDivisor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttributeDivisor$descriptor() {
        return rlSetVertexAttributeDivisor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static MethodHandle rlSetVertexAttributeDivisor$handle() {
        return rlSetVertexAttributeDivisor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static MemorySegment rlSetVertexAttributeDivisor$address() {
        return rlSetVertexAttributeDivisor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static void rlSetVertexAttributeDivisor(int index, int divisor) {
        var mh$ = rlSetVertexAttributeDivisor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttributeDivisor", index, divisor);
            }
            mh$.invokeExact(index, divisor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttributeDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttributeDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttributeDefault$descriptor() {
        return rlSetVertexAttributeDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static MethodHandle rlSetVertexAttributeDefault$handle() {
        return rlSetVertexAttributeDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static MemorySegment rlSetVertexAttributeDefault$address() {
        return rlSetVertexAttributeDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static void rlSetVertexAttributeDefault(int locIndex, MemorySegment value, int attribType, int count) {
        var mh$ = rlSetVertexAttributeDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttributeDefault", locIndex, value, attribType, count);
            }
            mh$.invokeExact(locIndex, value, attribType, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArray$descriptor() {
        return rlDrawVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static MethodHandle rlDrawVertexArray$handle() {
        return rlDrawVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static MemorySegment rlDrawVertexArray$address() {
        return rlDrawVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static void rlDrawVertexArray(int offset, int count) {
        var mh$ = rlDrawVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArray", offset, count);
            }
            mh$.invokeExact(offset, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayElements$descriptor() {
        return rlDrawVertexArrayElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static MethodHandle rlDrawVertexArrayElements$handle() {
        return rlDrawVertexArrayElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static MemorySegment rlDrawVertexArrayElements$address() {
        return rlDrawVertexArrayElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static void rlDrawVertexArrayElements(int offset, int count, MemorySegment buffer) {
        var mh$ = rlDrawVertexArrayElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayElements", offset, count, buffer);
            }
            mh$.invokeExact(offset, count, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayInstanced$descriptor() {
        return rlDrawVertexArrayInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static MethodHandle rlDrawVertexArrayInstanced$handle() {
        return rlDrawVertexArrayInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static MemorySegment rlDrawVertexArrayInstanced$address() {
        return rlDrawVertexArrayInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static void rlDrawVertexArrayInstanced(int offset, int count, int instances) {
        var mh$ = rlDrawVertexArrayInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayInstanced", offset, count, instances);
            }
            mh$.invokeExact(offset, count, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayElementsInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayElementsInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayElementsInstanced$descriptor() {
        return rlDrawVertexArrayElementsInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static MethodHandle rlDrawVertexArrayElementsInstanced$handle() {
        return rlDrawVertexArrayElementsInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static MemorySegment rlDrawVertexArrayElementsInstanced$address() {
        return rlDrawVertexArrayElementsInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static void rlDrawVertexArrayElementsInstanced(int offset, int count, MemorySegment buffer, int instances) {
        var mh$ = rlDrawVertexArrayElementsInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayElementsInstanced", offset, count, buffer, instances);
            }
            mh$.invokeExact(offset, count, buffer, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static FunctionDescriptor rlLoadTexture$descriptor() {
        return rlLoadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static MethodHandle rlLoadTexture$handle() {
        return rlLoadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static MemorySegment rlLoadTexture$address() {
        return rlLoadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static int rlLoadTexture(MemorySegment data, int width, int height, int format, int mipmapCount) {
        var mh$ = rlLoadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTexture", data, width, height, format, mipmapCount);
            }
            return (int)mh$.invokeExact(data, width, height, format, mipmapCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTextureDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTextureDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static FunctionDescriptor rlLoadTextureDepth$descriptor() {
        return rlLoadTextureDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static MethodHandle rlLoadTextureDepth$handle() {
        return rlLoadTextureDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static MemorySegment rlLoadTextureDepth$address() {
        return rlLoadTextureDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static int rlLoadTextureDepth(int width, int height, boolean useRenderBuffer) {
        var mh$ = rlLoadTextureDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTextureDepth", width, height, useRenderBuffer);
            }
            return (int)mh$.invokeExact(width, height, useRenderBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static FunctionDescriptor rlLoadTextureCubemap$descriptor() {
        return rlLoadTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static MethodHandle rlLoadTextureCubemap$handle() {
        return rlLoadTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static MemorySegment rlLoadTextureCubemap$address() {
        return rlLoadTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static int rlLoadTextureCubemap(MemorySegment data, int size, int format) {
        var mh$ = rlLoadTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTextureCubemap", data, size, format);
            }
            return (int)mh$.invokeExact(data, size, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static FunctionDescriptor rlUpdateTexture$descriptor() {
        return rlUpdateTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static MethodHandle rlUpdateTexture$handle() {
        return rlUpdateTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static MemorySegment rlUpdateTexture$address() {
        return rlUpdateTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static void rlUpdateTexture(int id, int offsetX, int offsetY, int width, int height, int format, MemorySegment data) {
        var mh$ = rlUpdateTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateTexture", id, offsetX, offsetY, width, height, format, data);
            }
            mh$.invokeExact(id, offsetX, offsetY, width, height, format, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetGlTextureFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetGlTextureFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static FunctionDescriptor rlGetGlTextureFormats$descriptor() {
        return rlGetGlTextureFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static MethodHandle rlGetGlTextureFormats$handle() {
        return rlGetGlTextureFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static MemorySegment rlGetGlTextureFormats$address() {
        return rlGetGlTextureFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static void rlGetGlTextureFormats(int format, MemorySegment glInternalFormat, MemorySegment glFormat, MemorySegment glType) {
        var mh$ = rlGetGlTextureFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetGlTextureFormats", format, glInternalFormat, glFormat, glType);
            }
            mh$.invokeExact(format, glInternalFormat, glFormat, glType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetPixelFormatName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetPixelFormatName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static FunctionDescriptor rlGetPixelFormatName$descriptor() {
        return rlGetPixelFormatName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MethodHandle rlGetPixelFormatName$handle() {
        return rlGetPixelFormatName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MemorySegment rlGetPixelFormatName$address() {
        return rlGetPixelFormatName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MemorySegment rlGetPixelFormatName(int format) {
        var mh$ = rlGetPixelFormatName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetPixelFormatName", format);
            }
            return (MemorySegment)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadTexture$descriptor() {
        return rlUnloadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadTexture$handle() {
        return rlUnloadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadTexture$address() {
        return rlUnloadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static void rlUnloadTexture(int id) {
        var mh$ = rlUnloadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGenTextureMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGenTextureMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static FunctionDescriptor rlGenTextureMipmaps$descriptor() {
        return rlGenTextureMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static MethodHandle rlGenTextureMipmaps$handle() {
        return rlGenTextureMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static MemorySegment rlGenTextureMipmaps$address() {
        return rlGenTextureMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static void rlGenTextureMipmaps(int id, int width, int height, int format, MemorySegment mipmaps) {
        var mh$ = rlGenTextureMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGenTextureMipmaps", id, width, height, format, mipmaps);
            }
            mh$.invokeExact(id, width, height, format, mipmaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadTexturePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadTexturePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static FunctionDescriptor rlReadTexturePixels$descriptor() {
        return rlReadTexturePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MethodHandle rlReadTexturePixels$handle() {
        return rlReadTexturePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MemorySegment rlReadTexturePixels$address() {
        return rlReadTexturePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MemorySegment rlReadTexturePixels(int id, int width, int height, int format) {
        var mh$ = rlReadTexturePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadTexturePixels", id, width, height, format);
            }
            return (MemorySegment)mh$.invokeExact(id, width, height, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadScreenPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadScreenPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static FunctionDescriptor rlReadScreenPixels$descriptor() {
        return rlReadScreenPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MethodHandle rlReadScreenPixels$handle() {
        return rlReadScreenPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MemorySegment rlReadScreenPixels$address() {
        return rlReadScreenPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MemorySegment rlReadScreenPixels(int width, int height) {
        var mh$ = rlReadScreenPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadScreenPixels", width, height);
            }
            return (MemorySegment)mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static FunctionDescriptor rlLoadFramebuffer$descriptor() {
        return rlLoadFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static MethodHandle rlLoadFramebuffer$handle() {
        return rlLoadFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static MemorySegment rlLoadFramebuffer$address() {
        return rlLoadFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static int rlLoadFramebuffer() {
        var mh$ = rlLoadFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadFramebuffer");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFramebufferAttach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFramebufferAttach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static FunctionDescriptor rlFramebufferAttach$descriptor() {
        return rlFramebufferAttach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static MethodHandle rlFramebufferAttach$handle() {
        return rlFramebufferAttach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static MemorySegment rlFramebufferAttach$address() {
        return rlFramebufferAttach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static void rlFramebufferAttach(int fboId, int texId, int attachType, int texType, int mipLevel) {
        var mh$ = rlFramebufferAttach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFramebufferAttach", fboId, texId, attachType, texType, mipLevel);
            }
            mh$.invokeExact(fboId, texId, attachType, texType, mipLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFramebufferComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFramebufferComplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlFramebufferComplete$descriptor() {
        return rlFramebufferComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static MethodHandle rlFramebufferComplete$handle() {
        return rlFramebufferComplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static MemorySegment rlFramebufferComplete$address() {
        return rlFramebufferComplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static boolean rlFramebufferComplete(int id) {
        var mh$ = rlFramebufferComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFramebufferComplete", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadFramebuffer$descriptor() {
        return rlUnloadFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadFramebuffer$handle() {
        return rlUnloadFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadFramebuffer$address() {
        return rlUnloadFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static void rlUnloadFramebuffer(int id) {
        var mh$ = rlUnloadFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadFramebuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static FunctionDescriptor rlLoadShaderCode$descriptor() {
        return rlLoadShaderCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static MethodHandle rlLoadShaderCode$handle() {
        return rlLoadShaderCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static MemorySegment rlLoadShaderCode$address() {
        return rlLoadShaderCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static int rlLoadShaderCode(MemorySegment vsCode, MemorySegment fsCode) {
        var mh$ = rlLoadShaderCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderCode", vsCode, fsCode);
            }
            return (int)mh$.invokeExact(vsCode, fsCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCompileShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCompileShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static FunctionDescriptor rlCompileShader$descriptor() {
        return rlCompileShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static MethodHandle rlCompileShader$handle() {
        return rlCompileShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static MemorySegment rlCompileShader$address() {
        return rlCompileShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static int rlCompileShader(MemorySegment shaderCode, int type) {
        var mh$ = rlCompileShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCompileShader", shaderCode, type);
            }
            return (int)mh$.invokeExact(shaderCode, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static FunctionDescriptor rlLoadShaderProgram$descriptor() {
        return rlLoadShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static MethodHandle rlLoadShaderProgram$handle() {
        return rlLoadShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static MemorySegment rlLoadShaderProgram$address() {
        return rlLoadShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static int rlLoadShaderProgram(int vShaderId, int fShaderId) {
        var mh$ = rlLoadShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderProgram", vShaderId, fShaderId);
            }
            return (int)mh$.invokeExact(vShaderId, fShaderId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadShaderProgram$descriptor() {
        return rlUnloadShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadShaderProgram$handle() {
        return rlUnloadShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadShaderProgram$address() {
        return rlUnloadShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static void rlUnloadShaderProgram(int id) {
        var mh$ = rlUnloadShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadShaderProgram", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLocationUniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLocationUniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static FunctionDescriptor rlGetLocationUniform$descriptor() {
        return rlGetLocationUniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static MethodHandle rlGetLocationUniform$handle() {
        return rlGetLocationUniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static MemorySegment rlGetLocationUniform$address() {
        return rlGetLocationUniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static int rlGetLocationUniform(int shaderId, MemorySegment uniformName) {
        var mh$ = rlGetLocationUniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLocationUniform", shaderId, uniformName);
            }
            return (int)mh$.invokeExact(shaderId, uniformName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLocationAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLocationAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static FunctionDescriptor rlGetLocationAttrib$descriptor() {
        return rlGetLocationAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static MethodHandle rlGetLocationAttrib$handle() {
        return rlGetLocationAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static MemorySegment rlGetLocationAttrib$address() {
        return rlGetLocationAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static int rlGetLocationAttrib(int shaderId, MemorySegment attribName) {
        var mh$ = rlGetLocationAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLocationAttrib", shaderId, attribName);
            }
            return (int)mh$.invokeExact(shaderId, attribName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static FunctionDescriptor rlSetUniform$descriptor() {
        return rlSetUniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MethodHandle rlSetUniform$handle() {
        return rlSetUniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MemorySegment rlSetUniform$address() {
        return rlSetUniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static void rlSetUniform(int locIndex, MemorySegment value, int uniformType, int count) {
        var mh$ = rlSetUniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniform", locIndex, value, uniformType, count);
            }
            mh$.invokeExact(locIndex, value, uniformType, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniformMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniformMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static FunctionDescriptor rlSetUniformMatrix$descriptor() {
        return rlSetUniformMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static MethodHandle rlSetUniformMatrix$handle() {
        return rlSetUniformMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static MemorySegment rlSetUniformMatrix$address() {
        return rlSetUniformMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static void rlSetUniformMatrix(int locIndex, MemorySegment mat) {
        var mh$ = rlSetUniformMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniformMatrix", locIndex, mat);
            }
            mh$.invokeExact(locIndex, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniformSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniformSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static FunctionDescriptor rlSetUniformSampler$descriptor() {
        return rlSetUniformSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static MethodHandle rlSetUniformSampler$handle() {
        return rlSetUniformSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static MemorySegment rlSetUniformSampler$address() {
        return rlSetUniformSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static void rlSetUniformSampler(int locIndex, int textureId) {
        var mh$ = rlSetUniformSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniformSampler", locIndex, textureId);
            }
            mh$.invokeExact(locIndex, textureId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static FunctionDescriptor rlSetShader$descriptor() {
        return rlSetShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static MethodHandle rlSetShader$handle() {
        return rlSetShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static MemorySegment rlSetShader$address() {
        return rlSetShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static void rlSetShader(int id, MemorySegment locs) {
        var mh$ = rlSetShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetShader", id, locs);
            }
            mh$.invokeExact(id, locs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadComputeShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadComputeShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static FunctionDescriptor rlLoadComputeShaderProgram$descriptor() {
        return rlLoadComputeShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static MethodHandle rlLoadComputeShaderProgram$handle() {
        return rlLoadComputeShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static MemorySegment rlLoadComputeShaderProgram$address() {
        return rlLoadComputeShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static int rlLoadComputeShaderProgram(int shaderId) {
        var mh$ = rlLoadComputeShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadComputeShaderProgram", shaderId);
            }
            return (int)mh$.invokeExact(shaderId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlComputeShaderDispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlComputeShaderDispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static FunctionDescriptor rlComputeShaderDispatch$descriptor() {
        return rlComputeShaderDispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static MethodHandle rlComputeShaderDispatch$handle() {
        return rlComputeShaderDispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static MemorySegment rlComputeShaderDispatch$address() {
        return rlComputeShaderDispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static void rlComputeShaderDispatch(int groupX, int groupY, int groupZ) {
        var mh$ = rlComputeShaderDispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlComputeShaderDispatch", groupX, groupY, groupZ);
            }
            mh$.invokeExact(groupX, groupY, groupZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static FunctionDescriptor rlLoadShaderBuffer$descriptor() {
        return rlLoadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static MethodHandle rlLoadShaderBuffer$handle() {
        return rlLoadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static MemorySegment rlLoadShaderBuffer$address() {
        return rlLoadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static int rlLoadShaderBuffer(int size, MemorySegment data, int usageHint) {
        var mh$ = rlLoadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderBuffer", size, data, usageHint);
            }
            return (int)mh$.invokeExact(size, data, usageHint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static FunctionDescriptor rlUnloadShaderBuffer$descriptor() {
        return rlUnloadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static MethodHandle rlUnloadShaderBuffer$handle() {
        return rlUnloadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static MemorySegment rlUnloadShaderBuffer$address() {
        return rlUnloadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static void rlUnloadShaderBuffer(int ssboId) {
        var mh$ = rlUnloadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadShaderBuffer", ssboId);
            }
            mh$.invokeExact(ssboId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateShaderBuffer$descriptor() {
        return rlUpdateShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static MethodHandle rlUpdateShaderBuffer$handle() {
        return rlUpdateShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static MemorySegment rlUpdateShaderBuffer$address() {
        return rlUpdateShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static void rlUpdateShaderBuffer(int id, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateShaderBuffer", id, data, dataSize, offset);
            }
            mh$.invokeExact(id, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static FunctionDescriptor rlBindShaderBuffer$descriptor() {
        return rlBindShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static MethodHandle rlBindShaderBuffer$handle() {
        return rlBindShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static MemorySegment rlBindShaderBuffer$address() {
        return rlBindShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static void rlBindShaderBuffer(int id, int index) {
        var mh$ = rlBindShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindShaderBuffer", id, index);
            }
            mh$.invokeExact(id, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static FunctionDescriptor rlReadShaderBuffer$descriptor() {
        return rlReadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static MethodHandle rlReadShaderBuffer$handle() {
        return rlReadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static MemorySegment rlReadShaderBuffer$address() {
        return rlReadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static void rlReadShaderBuffer(int id, MemorySegment dest, int count, int offset) {
        var mh$ = rlReadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadShaderBuffer", id, dest, count, offset);
            }
            mh$.invokeExact(id, dest, count, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCopyShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCopyShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static FunctionDescriptor rlCopyShaderBuffer$descriptor() {
        return rlCopyShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static MethodHandle rlCopyShaderBuffer$handle() {
        return rlCopyShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static MemorySegment rlCopyShaderBuffer$address() {
        return rlCopyShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static void rlCopyShaderBuffer(int destId, int srcId, int destOffset, int srcOffset, int count) {
        var mh$ = rlCopyShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCopyShaderBuffer", destId, srcId, destOffset, srcOffset, count);
            }
            mh$.invokeExact(destId, srcId, destOffset, srcOffset, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlGetShaderBufferSize$descriptor() {
        return rlGetShaderBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static MethodHandle rlGetShaderBufferSize$handle() {
        return rlGetShaderBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static MemorySegment rlGetShaderBufferSize$address() {
        return rlGetShaderBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static int rlGetShaderBufferSize(int id) {
        var mh$ = rlGetShaderBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderBufferSize", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindImageTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindImageTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static FunctionDescriptor rlBindImageTexture$descriptor() {
        return rlBindImageTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static MethodHandle rlBindImageTexture$handle() {
        return rlBindImageTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static MemorySegment rlBindImageTexture$address() {
        return rlBindImageTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static void rlBindImageTexture(int id, int index, int format, boolean readonly) {
        var mh$ = rlBindImageTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindImageTexture", id, index, format, readonly);
            }
            mh$.invokeExact(id, index, format, readonly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixModelview {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixModelview");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static FunctionDescriptor rlGetMatrixModelview$descriptor() {
        return rlGetMatrixModelview.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MethodHandle rlGetMatrixModelview$handle() {
        return rlGetMatrixModelview.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MemorySegment rlGetMatrixModelview$address() {
        return rlGetMatrixModelview.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MemorySegment rlGetMatrixModelview(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixModelview.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixModelview", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixProjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixProjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static FunctionDescriptor rlGetMatrixProjection$descriptor() {
        return rlGetMatrixProjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MethodHandle rlGetMatrixProjection$handle() {
        return rlGetMatrixProjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MemorySegment rlGetMatrixProjection$address() {
        return rlGetMatrixProjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MemorySegment rlGetMatrixProjection(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixProjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixProjection", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static FunctionDescriptor rlGetMatrixTransform$descriptor() {
        return rlGetMatrixTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MethodHandle rlGetMatrixTransform$handle() {
        return rlGetMatrixTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MemorySegment rlGetMatrixTransform$address() {
        return rlGetMatrixTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MemorySegment rlGetMatrixTransform(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixTransform", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixProjectionStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixProjectionStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static FunctionDescriptor rlGetMatrixProjectionStereo$descriptor() {
        return rlGetMatrixProjectionStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MethodHandle rlGetMatrixProjectionStereo$handle() {
        return rlGetMatrixProjectionStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixProjectionStereo$address() {
        return rlGetMatrixProjectionStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixProjectionStereo(SegmentAllocator allocator, int eye) {
        var mh$ = rlGetMatrixProjectionStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixProjectionStereo", allocator, eye);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixViewOffsetStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixViewOffsetStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static FunctionDescriptor rlGetMatrixViewOffsetStereo$descriptor() {
        return rlGetMatrixViewOffsetStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MethodHandle rlGetMatrixViewOffsetStereo$handle() {
        return rlGetMatrixViewOffsetStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixViewOffsetStereo$address() {
        return rlGetMatrixViewOffsetStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixViewOffsetStereo(SegmentAllocator allocator, int eye) {
        var mh$ = rlGetMatrixViewOffsetStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixViewOffsetStereo", allocator, eye);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixProjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixProjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static FunctionDescriptor rlSetMatrixProjection$descriptor() {
        return rlSetMatrixProjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static MethodHandle rlSetMatrixProjection$handle() {
        return rlSetMatrixProjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static MemorySegment rlSetMatrixProjection$address() {
        return rlSetMatrixProjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static void rlSetMatrixProjection(MemorySegment proj) {
        var mh$ = rlSetMatrixProjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixProjection", proj);
            }
            mh$.invokeExact(proj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixModelview {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixModelview");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static FunctionDescriptor rlSetMatrixModelview$descriptor() {
        return rlSetMatrixModelview.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static MethodHandle rlSetMatrixModelview$handle() {
        return rlSetMatrixModelview.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static MemorySegment rlSetMatrixModelview$address() {
        return rlSetMatrixModelview.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static void rlSetMatrixModelview(MemorySegment view) {
        var mh$ = rlSetMatrixModelview.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixModelview", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixProjectionStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixProjectionStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static FunctionDescriptor rlSetMatrixProjectionStereo$descriptor() {
        return rlSetMatrixProjectionStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static MethodHandle rlSetMatrixProjectionStereo$handle() {
        return rlSetMatrixProjectionStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static MemorySegment rlSetMatrixProjectionStereo$address() {
        return rlSetMatrixProjectionStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static void rlSetMatrixProjectionStereo(MemorySegment right, MemorySegment left) {
        var mh$ = rlSetMatrixProjectionStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixProjectionStereo", right, left);
            }
            mh$.invokeExact(right, left);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixViewOffsetStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixViewOffsetStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static FunctionDescriptor rlSetMatrixViewOffsetStereo$descriptor() {
        return rlSetMatrixViewOffsetStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static MethodHandle rlSetMatrixViewOffsetStereo$handle() {
        return rlSetMatrixViewOffsetStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static MemorySegment rlSetMatrixViewOffsetStereo$address() {
        return rlSetMatrixViewOffsetStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static void rlSetMatrixViewOffsetStereo(MemorySegment right, MemorySegment left) {
        var mh$ = rlSetMatrixViewOffsetStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixViewOffsetStereo", right, left);
            }
            mh$.invokeExact(right, left);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadDrawCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadDrawCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static FunctionDescriptor rlLoadDrawCube$descriptor() {
        return rlLoadDrawCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static MethodHandle rlLoadDrawCube$handle() {
        return rlLoadDrawCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static MemorySegment rlLoadDrawCube$address() {
        return rlLoadDrawCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static void rlLoadDrawCube() {
        var mh$ = rlLoadDrawCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadDrawCube");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadDrawQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadDrawQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static FunctionDescriptor rlLoadDrawQuad$descriptor() {
        return rlLoadDrawQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static MethodHandle rlLoadDrawQuad$handle() {
        return rlLoadDrawQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static MemorySegment rlLoadDrawQuad$address() {
        return rlLoadDrawQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static void rlLoadDrawQuad() {
        var mh$ = rlLoadDrawQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadDrawQuad");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static FunctionDescriptor Clamp$descriptor() {
        return Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static MethodHandle Clamp$handle() {
        return Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static MemorySegment Clamp$address() {
        return Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static float Clamp(float value, float min, float max) {
        var mh$ = Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Clamp", value, min, max);
            }
            return (float)mh$.invokeExact(value, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static FunctionDescriptor Lerp$descriptor() {
        return Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static MethodHandle Lerp$handle() {
        return Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static MemorySegment Lerp$address() {
        return Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static float Lerp(float start, float end, float amount) {
        var mh$ = Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Lerp", start, end, amount);
            }
            return (float)mh$.invokeExact(start, end, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static FunctionDescriptor Normalize$descriptor() {
        return Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static MethodHandle Normalize$handle() {
        return Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static MemorySegment Normalize$address() {
        return Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static float Normalize(float value, float start, float end) {
        var mh$ = Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Normalize", value, start, end);
            }
            return (float)mh$.invokeExact(value, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Remap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Remap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static FunctionDescriptor Remap$descriptor() {
        return Remap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static MethodHandle Remap$handle() {
        return Remap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static MemorySegment Remap$address() {
        return Remap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd) {
        var mh$ = Remap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Remap", value, inputStart, inputEnd, outputStart, outputEnd);
            }
            return (float)mh$.invokeExact(value, inputStart, inputEnd, outputStart, outputEnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wrap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Wrap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static FunctionDescriptor Wrap$descriptor() {
        return Wrap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static MethodHandle Wrap$handle() {
        return Wrap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static MemorySegment Wrap$address() {
        return Wrap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static float Wrap(float value, float min, float max) {
        var mh$ = Wrap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wrap", value, min, max);
            }
            return (float)mh$.invokeExact(value, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloatEquals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("FloatEquals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static FunctionDescriptor FloatEquals$descriptor() {
        return FloatEquals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static MethodHandle FloatEquals$handle() {
        return FloatEquals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static MemorySegment FloatEquals$address() {
        return FloatEquals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static int FloatEquals(float x, float y) {
        var mh$ = FloatEquals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloatEquals", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static FunctionDescriptor Vector2Zero$descriptor() {
        return Vector2Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MethodHandle Vector2Zero$handle() {
        return Vector2Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MemorySegment Vector2Zero$address() {
        return Vector2Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MemorySegment Vector2Zero(SegmentAllocator allocator) {
        var mh$ = Vector2Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static FunctionDescriptor Vector2One$descriptor() {
        return Vector2One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MethodHandle Vector2One$handle() {
        return Vector2One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MemorySegment Vector2One$address() {
        return Vector2One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MemorySegment Vector2One(SegmentAllocator allocator) {
        var mh$ = Vector2One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Add$descriptor() {
        return Vector2Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Add$handle() {
        return Vector2Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Add$address() {
        return Vector2Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static FunctionDescriptor Vector2AddValue$descriptor() {
        return Vector2AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MethodHandle Vector2AddValue$handle() {
        return Vector2AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MemorySegment Vector2AddValue$address() {
        return Vector2AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MemorySegment Vector2AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector2AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Subtract$descriptor() {
        return Vector2Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Subtract$handle() {
        return Vector2Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Subtract$address() {
        return Vector2Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static FunctionDescriptor Vector2SubtractValue$descriptor() {
        return Vector2SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MethodHandle Vector2SubtractValue$handle() {
        return Vector2SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MemorySegment Vector2SubtractValue$address() {
        return Vector2SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MemorySegment Vector2SubtractValue(SegmentAllocator allocator, MemorySegment v, float sub) {
        var mh$ = Vector2SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2SubtractValue", allocator, v, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Length$descriptor() {
        return Vector2Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Length$handle() {
        return Vector2Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Length$address() {
        return Vector2Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static float Vector2Length(MemorySegment v) {
        var mh$ = Vector2Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2LengthSqr$descriptor() {
        return Vector2LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static MethodHandle Vector2LengthSqr$handle() {
        return Vector2LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static MemorySegment Vector2LengthSqr$address() {
        return Vector2LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static float Vector2LengthSqr(MemorySegment v) {
        var mh$ = Vector2LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2DotProduct$descriptor() {
        return Vector2DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2DotProduct$handle() {
        return Vector2DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2DotProduct$address() {
        return Vector2DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Distance$descriptor() {
        return Vector2Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Distance$handle() {
        return Vector2Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Distance$address() {
        return Vector2Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2DistanceSqr$descriptor() {
        return Vector2DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2DistanceSqr$handle() {
        return Vector2DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2DistanceSqr$address() {
        return Vector2DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Angle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Angle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Angle$descriptor() {
        return Vector2Angle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Angle$handle() {
        return Vector2Angle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Angle$address() {
        return Vector2Angle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2Angle(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Angle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Angle", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2LineAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2LineAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static FunctionDescriptor Vector2LineAngle$descriptor() {
        return Vector2LineAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static MethodHandle Vector2LineAngle$handle() {
        return Vector2LineAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static MemorySegment Vector2LineAngle$address() {
        return Vector2LineAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static float Vector2LineAngle(MemorySegment start, MemorySegment end) {
        var mh$ = Vector2LineAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2LineAngle", start, end);
            }
            return (float)mh$.invokeExact(start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static FunctionDescriptor Vector2Scale$descriptor() {
        return Vector2Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MethodHandle Vector2Scale$handle() {
        return Vector2Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MemorySegment Vector2Scale$address() {
        return Vector2Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MemorySegment Vector2Scale(SegmentAllocator allocator, MemorySegment v, float scale) {
        var mh$ = Vector2Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Scale", allocator, v, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Multiply$descriptor() {
        return Vector2Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Multiply$handle() {
        return Vector2Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Multiply$address() {
        return Vector2Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Negate$descriptor() {
        return Vector2Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Negate$handle() {
        return Vector2Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Negate$address() {
        return Vector2Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Divide$descriptor() {
        return Vector2Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Divide$handle() {
        return Vector2Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Divide$address() {
        return Vector2Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Normalize$descriptor() {
        return Vector2Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Normalize$handle() {
        return Vector2Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Normalize$address() {
        return Vector2Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static FunctionDescriptor Vector2Transform$descriptor() {
        return Vector2Transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MethodHandle Vector2Transform$handle() {
        return Vector2Transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector2Transform$address() {
        return Vector2Transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector2Transform(SegmentAllocator allocator, MemorySegment v, MemorySegment mat) {
        var mh$ = Vector2Transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Transform", allocator, v, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector2Lerp$descriptor() {
        return Vector2Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MethodHandle Vector2Lerp$handle() {
        return Vector2Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MemorySegment Vector2Lerp$address() {
        return Vector2Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MemorySegment Vector2Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector2Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Reflect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Reflect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static FunctionDescriptor Vector2Reflect$descriptor() {
        return Vector2Reflect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MethodHandle Vector2Reflect$handle() {
        return Vector2Reflect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MemorySegment Vector2Reflect$address() {
        return Vector2Reflect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MemorySegment Vector2Reflect(SegmentAllocator allocator, MemorySegment v, MemorySegment normal) {
        var mh$ = Vector2Reflect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Reflect", allocator, v, normal);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Min$descriptor() {
        return Vector2Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Min$handle() {
        return Vector2Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Min$address() {
        return Vector2Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Max$descriptor() {
        return Vector2Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Max$handle() {
        return Vector2Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Max$address() {
        return Vector2Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static FunctionDescriptor Vector2Rotate$descriptor() {
        return Vector2Rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MethodHandle Vector2Rotate$handle() {
        return Vector2Rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MemorySegment Vector2Rotate$address() {
        return Vector2Rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MemorySegment Vector2Rotate(SegmentAllocator allocator, MemorySegment v, float angle) {
        var mh$ = Vector2Rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Rotate", allocator, v, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector2MoveTowards$descriptor() {
        return Vector2MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector2MoveTowards$handle() {
        return Vector2MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector2MoveTowards$address() {
        return Vector2MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector2MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector2MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Invert$descriptor() {
        return Vector2Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Invert$handle() {
        return Vector2Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Invert$address() {
        return Vector2Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static FunctionDescriptor Vector2Clamp$descriptor() {
        return Vector2Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MethodHandle Vector2Clamp$handle() {
        return Vector2Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MemorySegment Vector2Clamp$address() {
        return Vector2Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MemorySegment Vector2Clamp(SegmentAllocator allocator, MemorySegment v, MemorySegment min, MemorySegment max) {
        var mh$ = Vector2Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Clamp", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2ClampValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2ClampValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static FunctionDescriptor Vector2ClampValue$descriptor() {
        return Vector2ClampValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MethodHandle Vector2ClampValue$handle() {
        return Vector2ClampValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MemorySegment Vector2ClampValue$address() {
        return Vector2ClampValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MemorySegment Vector2ClampValue(SegmentAllocator allocator, MemorySegment v, float min, float max) {
        var mh$ = Vector2ClampValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2ClampValue", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static FunctionDescriptor Vector2Equals$descriptor() {
        return Vector2Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static MethodHandle Vector2Equals$handle() {
        return Vector2Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static MemorySegment Vector2Equals$address() {
        return Vector2Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static int Vector2Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector2Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Refract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Refract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static FunctionDescriptor Vector2Refract$descriptor() {
        return Vector2Refract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MethodHandle Vector2Refract$handle() {
        return Vector2Refract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MemorySegment Vector2Refract$address() {
        return Vector2Refract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MemorySegment Vector2Refract(SegmentAllocator allocator, MemorySegment v, MemorySegment n, float r) {
        var mh$ = Vector2Refract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Refract", allocator, v, n, r);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, n, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static FunctionDescriptor Vector3Zero$descriptor() {
        return Vector3Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MethodHandle Vector3Zero$handle() {
        return Vector3Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MemorySegment Vector3Zero$address() {
        return Vector3Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MemorySegment Vector3Zero(SegmentAllocator allocator) {
        var mh$ = Vector3Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static FunctionDescriptor Vector3One$descriptor() {
        return Vector3One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MethodHandle Vector3One$handle() {
        return Vector3One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MemorySegment Vector3One$address() {
        return Vector3One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MemorySegment Vector3One(SegmentAllocator allocator) {
        var mh$ = Vector3One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Add$descriptor() {
        return Vector3Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Add$handle() {
        return Vector3Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Add$address() {
        return Vector3Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static FunctionDescriptor Vector3AddValue$descriptor() {
        return Vector3AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MethodHandle Vector3AddValue$handle() {
        return Vector3AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MemorySegment Vector3AddValue$address() {
        return Vector3AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MemorySegment Vector3AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector3AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Subtract$descriptor() {
        return Vector3Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Subtract$handle() {
        return Vector3Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract$address() {
        return Vector3Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static FunctionDescriptor Vector3SubtractValue$descriptor() {
        return Vector3SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MethodHandle Vector3SubtractValue$handle() {
        return Vector3SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MemorySegment Vector3SubtractValue$address() {
        return Vector3SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MemorySegment Vector3SubtractValue(SegmentAllocator allocator, MemorySegment v, float sub) {
        var mh$ = Vector3SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3SubtractValue", allocator, v, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static FunctionDescriptor Vector3Scale$descriptor() {
        return Vector3Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MethodHandle Vector3Scale$handle() {
        return Vector3Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MemorySegment Vector3Scale$address() {
        return Vector3Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MemorySegment Vector3Scale(SegmentAllocator allocator, MemorySegment v, float scalar) {
        var mh$ = Vector3Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Scale", allocator, v, scalar);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scalar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Multiply$descriptor() {
        return Vector3Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Multiply$handle() {
        return Vector3Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Multiply$address() {
        return Vector3Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3CrossProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3CrossProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3CrossProduct$descriptor() {
        return Vector3CrossProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3CrossProduct$handle() {
        return Vector3CrossProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3CrossProduct$address() {
        return Vector3CrossProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3CrossProduct(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3CrossProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3CrossProduct", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Perpendicular {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Perpendicular");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Perpendicular$descriptor() {
        return Vector3Perpendicular.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Perpendicular$handle() {
        return Vector3Perpendicular.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Perpendicular$address() {
        return Vector3Perpendicular.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Perpendicular(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Perpendicular.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Perpendicular", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Length$descriptor() {
        return Vector3Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static MethodHandle Vector3Length$handle() {
        return Vector3Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static MemorySegment Vector3Length$address() {
        return Vector3Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static float Vector3Length(MemorySegment v) {
        var mh$ = Vector3Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3LengthSqr$descriptor() {
        return Vector3LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static MethodHandle Vector3LengthSqr$handle() {
        return Vector3LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static MemorySegment Vector3LengthSqr$address() {
        return Vector3LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static float Vector3LengthSqr(MemorySegment v) {
        var mh$ = Vector3LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3DotProduct$descriptor() {
        return Vector3DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3DotProduct$handle() {
        return Vector3DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3DotProduct$address() {
        return Vector3DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Distance$descriptor() {
        return Vector3Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Distance$handle() {
        return Vector3Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Distance$address() {
        return Vector3Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3DistanceSqr$descriptor() {
        return Vector3DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3DistanceSqr$handle() {
        return Vector3DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3DistanceSqr$address() {
        return Vector3DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Angle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Angle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Angle$descriptor() {
        return Vector3Angle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Angle$handle() {
        return Vector3Angle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Angle$address() {
        return Vector3Angle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3Angle(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Angle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Angle", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Negate$descriptor() {
        return Vector3Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Negate$handle() {
        return Vector3Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Negate$address() {
        return Vector3Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Divide$descriptor() {
        return Vector3Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Divide$handle() {
        return Vector3Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Divide$address() {
        return Vector3Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Normalize$descriptor() {
        return Vector3Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Normalize$handle() {
        return Vector3Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize$address() {
        return Vector3Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Project {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Project");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Project$descriptor() {
        return Vector3Project.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Project$handle() {
        return Vector3Project.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Project$address() {
        return Vector3Project.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Project(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Project.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Project", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Reject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Reject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Reject$descriptor() {
        return Vector3Reject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Reject$handle() {
        return Vector3Reject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Reject$address() {
        return Vector3Reject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Reject(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Reject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Reject", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3OrthoNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3OrthoNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static FunctionDescriptor Vector3OrthoNormalize$descriptor() {
        return Vector3OrthoNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static MethodHandle Vector3OrthoNormalize$handle() {
        return Vector3OrthoNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static MemorySegment Vector3OrthoNormalize$address() {
        return Vector3OrthoNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static void Vector3OrthoNormalize(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3OrthoNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3OrthoNormalize", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static FunctionDescriptor Vector3Transform$descriptor() {
        return Vector3Transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MethodHandle Vector3Transform$handle() {
        return Vector3Transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector3Transform$address() {
        return Vector3Transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector3Transform(SegmentAllocator allocator, MemorySegment v, MemorySegment mat) {
        var mh$ = Vector3Transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Transform", allocator, v, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3RotateByQuaternion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3RotateByQuaternion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static FunctionDescriptor Vector3RotateByQuaternion$descriptor() {
        return Vector3RotateByQuaternion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MethodHandle Vector3RotateByQuaternion$handle() {
        return Vector3RotateByQuaternion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MemorySegment Vector3RotateByQuaternion$address() {
        return Vector3RotateByQuaternion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MemorySegment Vector3RotateByQuaternion(SegmentAllocator allocator, MemorySegment v, MemorySegment q) {
        var mh$ = Vector3RotateByQuaternion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3RotateByQuaternion", allocator, v, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3RotateByAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3RotateByAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor Vector3RotateByAxisAngle$descriptor() {
        return Vector3RotateByAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MethodHandle Vector3RotateByAxisAngle$handle() {
        return Vector3RotateByAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MemorySegment Vector3RotateByAxisAngle$address() {
        return Vector3RotateByAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MemorySegment Vector3RotateByAxisAngle(SegmentAllocator allocator, MemorySegment v, MemorySegment axis, float angle) {
        var mh$ = Vector3RotateByAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3RotateByAxisAngle", allocator, v, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector3MoveTowards$descriptor() {
        return Vector3MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector3MoveTowards$handle() {
        return Vector3MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector3MoveTowards$address() {
        return Vector3MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector3MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector3MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector3Lerp$descriptor() {
        return Vector3Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MethodHandle Vector3Lerp$handle() {
        return Vector3Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MemorySegment Vector3Lerp$address() {
        return Vector3Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MemorySegment Vector3Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector3Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3CubicHermite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3CubicHermite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static FunctionDescriptor Vector3CubicHermite$descriptor() {
        return Vector3CubicHermite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MethodHandle Vector3CubicHermite$handle() {
        return Vector3CubicHermite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MemorySegment Vector3CubicHermite$address() {
        return Vector3CubicHermite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MemorySegment Vector3CubicHermite(SegmentAllocator allocator, MemorySegment v1, MemorySegment tangent1, MemorySegment v2, MemorySegment tangent2, float amount) {
        var mh$ = Vector3CubicHermite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3CubicHermite", allocator, v1, tangent1, v2, tangent2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, tangent1, v2, tangent2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Reflect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Reflect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static FunctionDescriptor Vector3Reflect$descriptor() {
        return Vector3Reflect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MethodHandle Vector3Reflect$handle() {
        return Vector3Reflect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MemorySegment Vector3Reflect$address() {
        return Vector3Reflect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MemorySegment Vector3Reflect(SegmentAllocator allocator, MemorySegment v, MemorySegment normal) {
        var mh$ = Vector3Reflect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Reflect", allocator, v, normal);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Min$descriptor() {
        return Vector3Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Min$handle() {
        return Vector3Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Min$address() {
        return Vector3Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Max$descriptor() {
        return Vector3Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Max$handle() {
        return Vector3Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Max$address() {
        return Vector3Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Barycenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Barycenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static FunctionDescriptor Vector3Barycenter$descriptor() {
        return Vector3Barycenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MethodHandle Vector3Barycenter$handle() {
        return Vector3Barycenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MemorySegment Vector3Barycenter$address() {
        return Vector3Barycenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MemorySegment Vector3Barycenter(SegmentAllocator allocator, MemorySegment p, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = Vector3Barycenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Barycenter", allocator, p, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Unproject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Unproject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static FunctionDescriptor Vector3Unproject$descriptor() {
        return Vector3Unproject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MethodHandle Vector3Unproject$handle() {
        return Vector3Unproject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject$address() {
        return Vector3Unproject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject(SegmentAllocator allocator, MemorySegment source, MemorySegment projection, MemorySegment view) {
        var mh$ = Vector3Unproject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Unproject", allocator, source, projection, view);
            }
            return (MemorySegment)mh$.invokeExact(allocator, source, projection, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3ToFloatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            float3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3ToFloatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3ToFloatV$descriptor() {
        return Vector3ToFloatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MethodHandle Vector3ToFloatV$handle() {
        return Vector3ToFloatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MemorySegment Vector3ToFloatV$address() {
        return Vector3ToFloatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MemorySegment Vector3ToFloatV(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3ToFloatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3ToFloatV", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Invert$descriptor() {
        return Vector3Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Invert$handle() {
        return Vector3Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Invert$address() {
        return Vector3Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static FunctionDescriptor Vector3Clamp$descriptor() {
        return Vector3Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MethodHandle Vector3Clamp$handle() {
        return Vector3Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MemorySegment Vector3Clamp$address() {
        return Vector3Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MemorySegment Vector3Clamp(SegmentAllocator allocator, MemorySegment v, MemorySegment min, MemorySegment max) {
        var mh$ = Vector3Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Clamp", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3ClampValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3ClampValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static FunctionDescriptor Vector3ClampValue$descriptor() {
        return Vector3ClampValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MethodHandle Vector3ClampValue$handle() {
        return Vector3ClampValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MemorySegment Vector3ClampValue$address() {
        return Vector3ClampValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MemorySegment Vector3ClampValue(SegmentAllocator allocator, MemorySegment v, float min, float max) {
        var mh$ = Vector3ClampValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3ClampValue", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static FunctionDescriptor Vector3Equals$descriptor() {
        return Vector3Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static MethodHandle Vector3Equals$handle() {
        return Vector3Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static MemorySegment Vector3Equals$address() {
        return Vector3Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static int Vector3Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector3Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Refract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Refract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static FunctionDescriptor Vector3Refract$descriptor() {
        return Vector3Refract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MethodHandle Vector3Refract$handle() {
        return Vector3Refract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MemorySegment Vector3Refract$address() {
        return Vector3Refract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MemorySegment Vector3Refract(SegmentAllocator allocator, MemorySegment v, MemorySegment n, float r) {
        var mh$ = Vector3Refract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Refract", allocator, v, n, r);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, n, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static FunctionDescriptor Vector4Zero$descriptor() {
        return Vector4Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MethodHandle Vector4Zero$handle() {
        return Vector4Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MemorySegment Vector4Zero$address() {
        return Vector4Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MemorySegment Vector4Zero(SegmentAllocator allocator) {
        var mh$ = Vector4Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static FunctionDescriptor Vector4One$descriptor() {
        return Vector4One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MethodHandle Vector4One$handle() {
        return Vector4One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MemorySegment Vector4One$address() {
        return Vector4One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MemorySegment Vector4One(SegmentAllocator allocator) {
        var mh$ = Vector4One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Add$descriptor() {
        return Vector4Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Add$handle() {
        return Vector4Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Add$address() {
        return Vector4Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static FunctionDescriptor Vector4AddValue$descriptor() {
        return Vector4AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MethodHandle Vector4AddValue$handle() {
        return Vector4AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4AddValue$address() {
        return Vector4AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector4AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Subtract$descriptor() {
        return Vector4Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Subtract$handle() {
        return Vector4Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Subtract$address() {
        return Vector4Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static FunctionDescriptor Vector4SubtractValue$descriptor() {
        return Vector4SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MethodHandle Vector4SubtractValue$handle() {
        return Vector4SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4SubtractValue$address() {
        return Vector4SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4SubtractValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector4SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4SubtractValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Length$descriptor() {
        return Vector4Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Length$handle() {
        return Vector4Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Length$address() {
        return Vector4Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static float Vector4Length(MemorySegment v) {
        var mh$ = Vector4Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4LengthSqr$descriptor() {
        return Vector4LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static MethodHandle Vector4LengthSqr$handle() {
        return Vector4LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static MemorySegment Vector4LengthSqr$address() {
        return Vector4LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static float Vector4LengthSqr(MemorySegment v) {
        var mh$ = Vector4LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4DotProduct$descriptor() {
        return Vector4DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4DotProduct$handle() {
        return Vector4DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4DotProduct$address() {
        return Vector4DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Distance$descriptor() {
        return Vector4Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Distance$handle() {
        return Vector4Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Distance$address() {
        return Vector4Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4DistanceSqr$descriptor() {
        return Vector4DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4DistanceSqr$handle() {
        return Vector4DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4DistanceSqr$address() {
        return Vector4DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static FunctionDescriptor Vector4Scale$descriptor() {
        return Vector4Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MethodHandle Vector4Scale$handle() {
        return Vector4Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MemorySegment Vector4Scale$address() {
        return Vector4Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MemorySegment Vector4Scale(SegmentAllocator allocator, MemorySegment v, float scale) {
        var mh$ = Vector4Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Scale", allocator, v, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Multiply$descriptor() {
        return Vector4Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Multiply$handle() {
        return Vector4Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Multiply$address() {
        return Vector4Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Negate$descriptor() {
        return Vector4Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Negate$handle() {
        return Vector4Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Negate$address() {
        return Vector4Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Divide$descriptor() {
        return Vector4Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Divide$handle() {
        return Vector4Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Divide$address() {
        return Vector4Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Normalize$descriptor() {
        return Vector4Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Normalize$handle() {
        return Vector4Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Normalize$address() {
        return Vector4Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Min$descriptor() {
        return Vector4Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Min$handle() {
        return Vector4Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Min$address() {
        return Vector4Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Max$descriptor() {
        return Vector4Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Max$handle() {
        return Vector4Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Max$address() {
        return Vector4Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector4Lerp$descriptor() {
        return Vector4Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MethodHandle Vector4Lerp$handle() {
        return Vector4Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MemorySegment Vector4Lerp$address() {
        return Vector4Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MemorySegment Vector4Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector4Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector4MoveTowards$descriptor() {
        return Vector4MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector4MoveTowards$handle() {
        return Vector4MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector4MoveTowards$address() {
        return Vector4MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector4MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector4MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Invert$descriptor() {
        return Vector4Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Invert$handle() {
        return Vector4Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Invert$address() {
        return Vector4Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static FunctionDescriptor Vector4Equals$descriptor() {
        return Vector4Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static MethodHandle Vector4Equals$handle() {
        return Vector4Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static MemorySegment Vector4Equals$address() {
        return Vector4Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static int Vector4Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector4Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixDeterminant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixDeterminant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixDeterminant$descriptor() {
        return MatrixDeterminant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static MethodHandle MatrixDeterminant$handle() {
        return MatrixDeterminant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static MemorySegment MatrixDeterminant$address() {
        return MatrixDeterminant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static float MatrixDeterminant(MemorySegment mat) {
        var mh$ = MatrixDeterminant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixDeterminant", mat);
            }
            return (float)mh$.invokeExact(mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixTrace$descriptor() {
        return MatrixTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static MethodHandle MatrixTrace$handle() {
        return MatrixTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTrace$address() {
        return MatrixTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static float MatrixTrace(MemorySegment mat) {
        var mh$ = MatrixTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTrace", mat);
            }
            return (float)mh$.invokeExact(mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTranspose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTranspose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixTranspose$descriptor() {
        return MatrixTranspose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MethodHandle MatrixTranspose$handle() {
        return MatrixTranspose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTranspose$address() {
        return MatrixTranspose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTranspose(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixTranspose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTranspose", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixInvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixInvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixInvert$descriptor() {
        return MatrixInvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MethodHandle MatrixInvert$handle() {
        return MatrixInvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MemorySegment MatrixInvert$address() {
        return MatrixInvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MemorySegment MatrixInvert(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixInvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixInvert", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static FunctionDescriptor MatrixIdentity$descriptor() {
        return MatrixIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MethodHandle MatrixIdentity$handle() {
        return MatrixIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity$address() {
        return MatrixIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity(SegmentAllocator allocator) {
        var mh$ = MatrixIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixIdentity", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixAdd$descriptor() {
        return MatrixAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixAdd$handle() {
        return MatrixAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixAdd$address() {
        return MatrixAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixAdd(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixAdd", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixSubtract$descriptor() {
        return MatrixSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixSubtract$handle() {
        return MatrixSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixSubtract$address() {
        return MatrixSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixSubtract(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixSubtract", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixMultiply$descriptor() {
        return MatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixMultiply$handle() {
        return MatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixMultiply$address() {
        return MatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixMultiply(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixMultiply", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTranslate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTranslate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor MatrixTranslate$descriptor() {
        return MatrixTranslate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MethodHandle MatrixTranslate$handle() {
        return MatrixTranslate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixTranslate$address() {
        return MatrixTranslate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixTranslate(SegmentAllocator allocator, float x, float y, float z) {
        var mh$ = MatrixTranslate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTranslate", allocator, x, y, z);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotate$descriptor() {
        return MatrixRotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MethodHandle MatrixRotate$handle() {
        return MatrixRotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment MatrixRotate$address() {
        return MatrixRotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment MatrixRotate(SegmentAllocator allocator, MemorySegment axis, float angle) {
        var mh$ = MatrixRotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotate", allocator, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateX$descriptor() {
        return MatrixRotateX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MethodHandle MatrixRotateX$handle() {
        return MatrixRotateX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MemorySegment MatrixRotateX$address() {
        return MatrixRotateX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MemorySegment MatrixRotateX(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateX", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateY$descriptor() {
        return MatrixRotateY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MethodHandle MatrixRotateY$handle() {
        return MatrixRotateY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MemorySegment MatrixRotateY$address() {
        return MatrixRotateY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MemorySegment MatrixRotateY(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateY", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateZ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateZ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateZ$descriptor() {
        return MatrixRotateZ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MethodHandle MatrixRotateZ$handle() {
        return MatrixRotateZ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MemorySegment MatrixRotateZ$address() {
        return MatrixRotateZ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MemorySegment MatrixRotateZ(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateZ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateZ", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateXYZ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateXYZ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateXYZ$descriptor() {
        return MatrixRotateXYZ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MethodHandle MatrixRotateXYZ$handle() {
        return MatrixRotateXYZ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateXYZ$address() {
        return MatrixRotateXYZ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateXYZ(SegmentAllocator allocator, MemorySegment angle) {
        var mh$ = MatrixRotateXYZ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateXYZ", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateZYX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateZYX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateZYX$descriptor() {
        return MatrixRotateZYX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MethodHandle MatrixRotateZYX$handle() {
        return MatrixRotateZYX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateZYX$address() {
        return MatrixRotateZYX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateZYX(SegmentAllocator allocator, MemorySegment angle) {
        var mh$ = MatrixRotateZYX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateZYX", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor MatrixScale$descriptor() {
        return MatrixScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MethodHandle MatrixScale$handle() {
        return MatrixScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixScale$address() {
        return MatrixScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixScale(SegmentAllocator allocator, float x, float y, float z) {
        var mh$ = MatrixScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixScale", allocator, x, y, z);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static FunctionDescriptor MatrixFrustum$descriptor() {
        return MatrixFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MethodHandle MatrixFrustum$handle() {
        return MatrixFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MemorySegment MatrixFrustum$address() {
        return MatrixFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MemorySegment MatrixFrustum(SegmentAllocator allocator, double left, double right, double bottom, double top, double near, double far) {
        var mh$ = MatrixFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixFrustum", allocator, left, right, bottom, top, near, far);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right, bottom, top, near, far);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixPerspective$descriptor() {
        return MatrixPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixPerspective$handle() {
        return MatrixPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective$address() {
        return MatrixPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective(SegmentAllocator allocator, double fovY, double aspect, double nearPlane, double farPlane) {
        var mh$ = MatrixPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixPerspective", allocator, fovY, aspect, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fovY, aspect, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixOrtho$descriptor() {
        return MatrixOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixOrtho$handle() {
        return MatrixOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho$address() {
        return MatrixOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho(SegmentAllocator allocator, double left, double right, double bottom, double top, double nearPlane, double farPlane) {
        var mh$ = MatrixOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixOrtho", allocator, left, right, bottom, top, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right, bottom, top, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static FunctionDescriptor MatrixLookAt$descriptor() {
        return MatrixLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MethodHandle MatrixLookAt$handle() {
        return MatrixLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt$address() {
        return MatrixLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt(SegmentAllocator allocator, MemorySegment eye, MemorySegment target, MemorySegment up) {
        var mh$ = MatrixLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixLookAt", allocator, eye, target, up);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye, target, up);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixToFloatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            float16.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixToFloatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixToFloatV$descriptor() {
        return MatrixToFloatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MethodHandle MatrixToFloatV$handle() {
        return MatrixToFloatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MemorySegment MatrixToFloatV$address() {
        return MatrixToFloatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MemorySegment MatrixToFloatV(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixToFloatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixToFloatV", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionAdd$descriptor() {
        return QuaternionAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionAdd$handle() {
        return QuaternionAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionAdd$address() {
        return QuaternionAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionAdd(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionAdd", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionAddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionAddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static FunctionDescriptor QuaternionAddValue$descriptor() {
        return QuaternionAddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MethodHandle QuaternionAddValue$handle() {
        return QuaternionAddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MemorySegment QuaternionAddValue$address() {
        return QuaternionAddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MemorySegment QuaternionAddValue(SegmentAllocator allocator, MemorySegment q, float add) {
        var mh$ = QuaternionAddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionAddValue", allocator, q, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionSubtract$descriptor() {
        return QuaternionSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionSubtract$handle() {
        return QuaternionSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionSubtract$address() {
        return QuaternionSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionSubtract(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSubtract", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static FunctionDescriptor QuaternionSubtractValue$descriptor() {
        return QuaternionSubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MethodHandle QuaternionSubtractValue$handle() {
        return QuaternionSubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MemorySegment QuaternionSubtractValue$address() {
        return QuaternionSubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MemorySegment QuaternionSubtractValue(SegmentAllocator allocator, MemorySegment q, float sub) {
        var mh$ = QuaternionSubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSubtractValue", allocator, q, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static FunctionDescriptor QuaternionIdentity$descriptor() {
        return QuaternionIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MethodHandle QuaternionIdentity$handle() {
        return QuaternionIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MemorySegment QuaternionIdentity$address() {
        return QuaternionIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MemorySegment QuaternionIdentity(SegmentAllocator allocator) {
        var mh$ = QuaternionIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionIdentity", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionLength$descriptor() {
        return QuaternionLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionLength$handle() {
        return QuaternionLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionLength$address() {
        return QuaternionLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static float QuaternionLength(MemorySegment q) {
        var mh$ = QuaternionLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionLength", q);
            }
            return (float)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionNormalize$descriptor() {
        return QuaternionNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionNormalize$handle() {
        return QuaternionNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionNormalize$address() {
        return QuaternionNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionNormalize(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionNormalize", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionInvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionInvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionInvert$descriptor() {
        return QuaternionInvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionInvert$handle() {
        return QuaternionInvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionInvert$address() {
        return QuaternionInvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionInvert(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionInvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionInvert", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionMultiply$descriptor() {
        return QuaternionMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionMultiply$handle() {
        return QuaternionMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionMultiply$address() {
        return QuaternionMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionMultiply(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionMultiply", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static FunctionDescriptor QuaternionScale$descriptor() {
        return QuaternionScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MethodHandle QuaternionScale$handle() {
        return QuaternionScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MemorySegment QuaternionScale$address() {
        return QuaternionScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MemorySegment QuaternionScale(SegmentAllocator allocator, MemorySegment q, float mul) {
        var mh$ = QuaternionScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionScale", allocator, q, mul);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, mul);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionDivide$descriptor() {
        return QuaternionDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionDivide$handle() {
        return QuaternionDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionDivide$address() {
        return QuaternionDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionDivide(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionDivide", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionLerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionLerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionLerp$descriptor() {
        return QuaternionLerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionLerp$handle() {
        return QuaternionLerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionLerp$address() {
        return QuaternionLerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionLerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionLerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionLerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionNlerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionNlerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionNlerp$descriptor() {
        return QuaternionNlerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionNlerp$handle() {
        return QuaternionNlerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionNlerp$address() {
        return QuaternionNlerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionNlerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionNlerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionNlerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSlerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSlerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionSlerp$descriptor() {
        return QuaternionSlerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionSlerp$handle() {
        return QuaternionSlerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionSlerp$address() {
        return QuaternionSlerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionSlerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionSlerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSlerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionCubicHermiteSpline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionCubicHermiteSpline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static FunctionDescriptor QuaternionCubicHermiteSpline$descriptor() {
        return QuaternionCubicHermiteSpline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MethodHandle QuaternionCubicHermiteSpline$handle() {
        return QuaternionCubicHermiteSpline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MemorySegment QuaternionCubicHermiteSpline$address() {
        return QuaternionCubicHermiteSpline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MemorySegment QuaternionCubicHermiteSpline(SegmentAllocator allocator, MemorySegment q1, MemorySegment outTangent1, MemorySegment q2, MemorySegment inTangent2, float t) {
        var mh$ = QuaternionCubicHermiteSpline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionCubicHermiteSpline", allocator, q1, outTangent1, q2, inTangent2, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, outTangent1, q2, inTangent2, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromVector3ToVector3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromVector3ToVector3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static FunctionDescriptor QuaternionFromVector3ToVector3$descriptor() {
        return QuaternionFromVector3ToVector3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MethodHandle QuaternionFromVector3ToVector3$handle() {
        return QuaternionFromVector3ToVector3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MemorySegment QuaternionFromVector3ToVector3$address() {
        return QuaternionFromVector3ToVector3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MemorySegment QuaternionFromVector3ToVector3(SegmentAllocator allocator, MemorySegment from, MemorySegment to) {
        var mh$ = QuaternionFromVector3ToVector3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromVector3ToVector3", allocator, from, to);
            }
            return (MemorySegment)mh$.invokeExact(allocator, from, to);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static FunctionDescriptor QuaternionFromMatrix$descriptor() {
        return QuaternionFromMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MethodHandle QuaternionFromMatrix$handle() {
        return QuaternionFromMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MemorySegment QuaternionFromMatrix$address() {
        return QuaternionFromMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MemorySegment QuaternionFromMatrix(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = QuaternionFromMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromMatrix", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionToMatrix$descriptor() {
        return QuaternionToMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionToMatrix$handle() {
        return QuaternionToMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToMatrix$address() {
        return QuaternionToMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToMatrix(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionToMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToMatrix", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor QuaternionFromAxisAngle$descriptor() {
        return QuaternionFromAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MethodHandle QuaternionFromAxisAngle$handle() {
        return QuaternionFromAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment QuaternionFromAxisAngle$address() {
        return QuaternionFromAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment QuaternionFromAxisAngle(SegmentAllocator allocator, MemorySegment axis, float angle) {
        var mh$ = QuaternionFromAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromAxisAngle", allocator, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector4.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static FunctionDescriptor QuaternionToAxisAngle$descriptor() {
        return QuaternionToAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static MethodHandle QuaternionToAxisAngle$handle() {
        return QuaternionToAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static MemorySegment QuaternionToAxisAngle$address() {
        return QuaternionToAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static void QuaternionToAxisAngle(MemorySegment q, MemorySegment outAxis, MemorySegment outAngle) {
        var mh$ = QuaternionToAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToAxisAngle", q, outAxis, outAngle);
            }
            mh$.invokeExact(q, outAxis, outAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromEuler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromEuler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static FunctionDescriptor QuaternionFromEuler$descriptor() {
        return QuaternionFromEuler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MethodHandle QuaternionFromEuler$handle() {
        return QuaternionFromEuler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MemorySegment QuaternionFromEuler$address() {
        return QuaternionFromEuler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MemorySegment QuaternionFromEuler(SegmentAllocator allocator, float pitch, float yaw, float roll) {
        var mh$ = QuaternionFromEuler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromEuler", allocator, pitch, yaw, roll);
            }
            return (MemorySegment)mh$.invokeExact(allocator, pitch, yaw, roll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToEuler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToEuler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionToEuler$descriptor() {
        return QuaternionToEuler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionToEuler$handle() {
        return QuaternionToEuler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToEuler$address() {
        return QuaternionToEuler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToEuler(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionToEuler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToEuler", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static FunctionDescriptor QuaternionTransform$descriptor() {
        return QuaternionTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MethodHandle QuaternionTransform$handle() {
        return QuaternionTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MemorySegment QuaternionTransform$address() {
        return QuaternionTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MemorySegment QuaternionTransform(SegmentAllocator allocator, MemorySegment q, MemorySegment mat) {
        var mh$ = QuaternionTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionTransform", allocator, q, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionEquals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionEquals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionEquals$descriptor() {
        return QuaternionEquals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static MethodHandle QuaternionEquals$handle() {
        return QuaternionEquals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static MemorySegment QuaternionEquals$address() {
        return QuaternionEquals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static int QuaternionEquals(MemorySegment p, MemorySegment q) {
        var mh$ = QuaternionEquals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionEquals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int STATE_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STATE_NORMAL = 0
     * }
     */
    public static int STATE_NORMAL() {
        return STATE_NORMAL;
    }
    private static final int STATE_FOCUSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STATE_FOCUSED = 1
     * }
     */
    public static int STATE_FOCUSED() {
        return STATE_FOCUSED;
    }
    private static final int STATE_PRESSED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STATE_PRESSED = 2
     * }
     */
    public static int STATE_PRESSED() {
        return STATE_PRESSED;
    }
    private static final int STATE_DISABLED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STATE_DISABLED = 3
     * }
     */
    public static int STATE_DISABLED() {
        return STATE_DISABLED;
    }
    private static final int TEXT_ALIGN_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_LEFT = 0
     * }
     */
    public static int TEXT_ALIGN_LEFT() {
        return TEXT_ALIGN_LEFT;
    }
    private static final int TEXT_ALIGN_CENTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_CENTER = 1
     * }
     */
    public static int TEXT_ALIGN_CENTER() {
        return TEXT_ALIGN_CENTER;
    }
    private static final int TEXT_ALIGN_RIGHT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_RIGHT = 2
     * }
     */
    public static int TEXT_ALIGN_RIGHT() {
        return TEXT_ALIGN_RIGHT;
    }
    private static final int TEXT_ALIGN_TOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_TOP = 0
     * }
     */
    public static int TEXT_ALIGN_TOP() {
        return TEXT_ALIGN_TOP;
    }
    private static final int TEXT_ALIGN_MIDDLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_MIDDLE = 1
     * }
     */
    public static int TEXT_ALIGN_MIDDLE() {
        return TEXT_ALIGN_MIDDLE;
    }
    private static final int TEXT_ALIGN_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGN_BOTTOM = 2
     * }
     */
    public static int TEXT_ALIGN_BOTTOM() {
        return TEXT_ALIGN_BOTTOM;
    }
    private static final int TEXT_WRAP_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_WRAP_NONE = 0
     * }
     */
    public static int TEXT_WRAP_NONE() {
        return TEXT_WRAP_NONE;
    }
    private static final int TEXT_WRAP_CHAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_WRAP_CHAR = 1
     * }
     */
    public static int TEXT_WRAP_CHAR() {
        return TEXT_WRAP_CHAR;
    }
    private static final int TEXT_WRAP_WORD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_WRAP_WORD = 2
     * }
     */
    public static int TEXT_WRAP_WORD() {
        return TEXT_WRAP_WORD;
    }
    private static final int DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DEFAULT = 0
     * }
     */
    public static int DEFAULT() {
        return DEFAULT;
    }
    private static final int LABEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LABEL = 1
     * }
     */
    public static int LABEL() {
        return LABEL;
    }
    private static final int BUTTON = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUTTON = 2
     * }
     */
    public static int BUTTON() {
        return BUTTON;
    }
    private static final int TOGGLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TOGGLE = 3
     * }
     */
    public static int TOGGLE() {
        return TOGGLE;
    }
    private static final int SLIDER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SLIDER = 4
     * }
     */
    public static int SLIDER() {
        return SLIDER;
    }
    private static final int PROGRESSBAR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROGRESSBAR = 5
     * }
     */
    public static int PROGRESSBAR() {
        return PROGRESSBAR;
    }
    private static final int CHECKBOX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CHECKBOX = 6
     * }
     */
    public static int CHECKBOX() {
        return CHECKBOX;
    }
    private static final int COMBOBOX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.COMBOBOX = 7
     * }
     */
    public static int COMBOBOX() {
        return COMBOBOX;
    }
    private static final int DROPDOWNBOX = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DROPDOWNBOX = 8
     * }
     */
    public static int DROPDOWNBOX() {
        return DROPDOWNBOX;
    }
    private static final int TEXTBOX = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTBOX = 9
     * }
     */
    public static int TEXTBOX() {
        return TEXTBOX;
    }
    private static final int VALUEBOX = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.VALUEBOX = 10
     * }
     */
    public static int VALUEBOX() {
        return VALUEBOX;
    }
    private static final int SPINNER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SPINNER = 11
     * }
     */
    public static int SPINNER() {
        return SPINNER;
    }
    private static final int LISTVIEW = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LISTVIEW = 12
     * }
     */
    public static int LISTVIEW() {
        return LISTVIEW;
    }
    private static final int COLORPICKER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.COLORPICKER = 13
     * }
     */
    public static int COLORPICKER() {
        return COLORPICKER;
    }
    private static final int SCROLLBAR = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLLBAR = 14
     * }
     */
    public static int SCROLLBAR() {
        return SCROLLBAR;
    }
    private static final int STATUSBAR = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STATUSBAR = 15
     * }
     */
    public static int STATUSBAR() {
        return STATUSBAR;
    }
    private static final int BORDER_COLOR_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER_COLOR_NORMAL = 0
     * }
     */
    public static int BORDER_COLOR_NORMAL() {
        return BORDER_COLOR_NORMAL;
    }
    private static final int BASE_COLOR_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_COLOR_NORMAL = 1
     * }
     */
    public static int BASE_COLOR_NORMAL() {
        return BASE_COLOR_NORMAL;
    }
    private static final int TEXT_COLOR_NORMAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_COLOR_NORMAL = 2
     * }
     */
    public static int TEXT_COLOR_NORMAL() {
        return TEXT_COLOR_NORMAL;
    }
    private static final int BORDER_COLOR_FOCUSED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER_COLOR_FOCUSED = 3
     * }
     */
    public static int BORDER_COLOR_FOCUSED() {
        return BORDER_COLOR_FOCUSED;
    }
    private static final int BASE_COLOR_FOCUSED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_COLOR_FOCUSED = 4
     * }
     */
    public static int BASE_COLOR_FOCUSED() {
        return BASE_COLOR_FOCUSED;
    }
    private static final int TEXT_COLOR_FOCUSED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_COLOR_FOCUSED = 5
     * }
     */
    public static int TEXT_COLOR_FOCUSED() {
        return TEXT_COLOR_FOCUSED;
    }
    private static final int BORDER_COLOR_PRESSED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER_COLOR_PRESSED = 6
     * }
     */
    public static int BORDER_COLOR_PRESSED() {
        return BORDER_COLOR_PRESSED;
    }
    private static final int BASE_COLOR_PRESSED = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_COLOR_PRESSED = 7
     * }
     */
    public static int BASE_COLOR_PRESSED() {
        return BASE_COLOR_PRESSED;
    }
    private static final int TEXT_COLOR_PRESSED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_COLOR_PRESSED = 8
     * }
     */
    public static int TEXT_COLOR_PRESSED() {
        return TEXT_COLOR_PRESSED;
    }
    private static final int BORDER_COLOR_DISABLED = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER_COLOR_DISABLED = 9
     * }
     */
    public static int BORDER_COLOR_DISABLED() {
        return BORDER_COLOR_DISABLED;
    }
    private static final int BASE_COLOR_DISABLED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_COLOR_DISABLED = 10
     * }
     */
    public static int BASE_COLOR_DISABLED() {
        return BASE_COLOR_DISABLED;
    }
    private static final int TEXT_COLOR_DISABLED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_COLOR_DISABLED = 11
     * }
     */
    public static int TEXT_COLOR_DISABLED() {
        return TEXT_COLOR_DISABLED;
    }
    private static final int BORDER_WIDTH = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER_WIDTH = 12
     * }
     */
    public static int BORDER_WIDTH() {
        return BORDER_WIDTH;
    }
    private static final int TEXT_PADDING = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_PADDING = 13
     * }
     */
    public static int TEXT_PADDING() {
        return TEXT_PADDING;
    }
    private static final int TEXT_ALIGNMENT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGNMENT = 14
     * }
     */
    public static int TEXT_ALIGNMENT() {
        return TEXT_ALIGNMENT;
    }
    private static final int TEXT_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_SIZE = 16
     * }
     */
    public static int TEXT_SIZE() {
        return TEXT_SIZE;
    }
    private static final int TEXT_SPACING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_SPACING = 17
     * }
     */
    public static int TEXT_SPACING() {
        return TEXT_SPACING;
    }
    private static final int LINE_COLOR = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LINE_COLOR = 18
     * }
     */
    public static int LINE_COLOR() {
        return LINE_COLOR;
    }
    private static final int BACKGROUND_COLOR = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BACKGROUND_COLOR = 19
     * }
     */
    public static int BACKGROUND_COLOR() {
        return BACKGROUND_COLOR;
    }
    private static final int TEXT_LINE_SPACING = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_LINE_SPACING = 20
     * }
     */
    public static int TEXT_LINE_SPACING() {
        return TEXT_LINE_SPACING;
    }
    private static final int TEXT_ALIGNMENT_VERTICAL = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_ALIGNMENT_VERTICAL = 21
     * }
     */
    public static int TEXT_ALIGNMENT_VERTICAL() {
        return TEXT_ALIGNMENT_VERTICAL;
    }
    private static final int TEXT_WRAP_MODE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_WRAP_MODE = 22
     * }
     */
    public static int TEXT_WRAP_MODE() {
        return TEXT_WRAP_MODE;
    }
    private static final int GROUP_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GROUP_PADDING = 16
     * }
     */
    public static int GROUP_PADDING() {
        return GROUP_PADDING;
    }
    private static final int SLIDER_WIDTH = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SLIDER_WIDTH = 16
     * }
     */
    public static int SLIDER_WIDTH() {
        return SLIDER_WIDTH;
    }
    private static final int SLIDER_PADDING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SLIDER_PADDING = 17
     * }
     */
    public static int SLIDER_PADDING() {
        return SLIDER_PADDING;
    }
    private static final int PROGRESS_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROGRESS_PADDING = 16
     * }
     */
    public static int PROGRESS_PADDING() {
        return PROGRESS_PADDING;
    }
    private static final int ARROWS_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARROWS_SIZE = 16
     * }
     */
    public static int ARROWS_SIZE() {
        return ARROWS_SIZE;
    }
    private static final int ARROWS_VISIBLE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARROWS_VISIBLE = 17
     * }
     */
    public static int ARROWS_VISIBLE() {
        return ARROWS_VISIBLE;
    }
    private static final int SCROLL_SLIDER_PADDING = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLL_SLIDER_PADDING = 18
     * }
     */
    public static int SCROLL_SLIDER_PADDING() {
        return SCROLL_SLIDER_PADDING;
    }
    private static final int SCROLL_SLIDER_SIZE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLL_SLIDER_SIZE = 19
     * }
     */
    public static int SCROLL_SLIDER_SIZE() {
        return SCROLL_SLIDER_SIZE;
    }
    private static final int SCROLL_PADDING = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLL_PADDING = 20
     * }
     */
    public static int SCROLL_PADDING() {
        return SCROLL_PADDING;
    }
    private static final int SCROLL_SPEED = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLL_SPEED = 21
     * }
     */
    public static int SCROLL_SPEED() {
        return SCROLL_SPEED;
    }
    private static final int CHECK_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CHECK_PADDING = 16
     * }
     */
    public static int CHECK_PADDING() {
        return CHECK_PADDING;
    }
    private static final int COMBO_BUTTON_WIDTH = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.COMBO_BUTTON_WIDTH = 16
     * }
     */
    public static int COMBO_BUTTON_WIDTH() {
        return COMBO_BUTTON_WIDTH;
    }
    private static final int COMBO_BUTTON_SPACING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.COMBO_BUTTON_SPACING = 17
     * }
     */
    public static int COMBO_BUTTON_SPACING() {
        return COMBO_BUTTON_SPACING;
    }
    private static final int ARROW_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARROW_PADDING = 16
     * }
     */
    public static int ARROW_PADDING() {
        return ARROW_PADDING;
    }
    private static final int DROPDOWN_ITEMS_SPACING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DROPDOWN_ITEMS_SPACING = 17
     * }
     */
    public static int DROPDOWN_ITEMS_SPACING() {
        return DROPDOWN_ITEMS_SPACING;
    }
    private static final int DROPDOWN_ARROW_HIDDEN = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DROPDOWN_ARROW_HIDDEN = 18
     * }
     */
    public static int DROPDOWN_ARROW_HIDDEN() {
        return DROPDOWN_ARROW_HIDDEN;
    }
    private static final int DROPDOWN_ROLL_UP = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DROPDOWN_ROLL_UP = 19
     * }
     */
    public static int DROPDOWN_ROLL_UP() {
        return DROPDOWN_ROLL_UP;
    }
    private static final int TEXT_READONLY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT_READONLY = 16
     * }
     */
    public static int TEXT_READONLY() {
        return TEXT_READONLY;
    }
    private static final int SPIN_BUTTON_WIDTH = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SPIN_BUTTON_WIDTH = 16
     * }
     */
    public static int SPIN_BUTTON_WIDTH() {
        return SPIN_BUTTON_WIDTH;
    }
    private static final int SPIN_BUTTON_SPACING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SPIN_BUTTON_SPACING = 17
     * }
     */
    public static int SPIN_BUTTON_SPACING() {
        return SPIN_BUTTON_SPACING;
    }
    private static final int LIST_ITEMS_HEIGHT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LIST_ITEMS_HEIGHT = 16
     * }
     */
    public static int LIST_ITEMS_HEIGHT() {
        return LIST_ITEMS_HEIGHT;
    }
    private static final int LIST_ITEMS_SPACING = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LIST_ITEMS_SPACING = 17
     * }
     */
    public static int LIST_ITEMS_SPACING() {
        return LIST_ITEMS_SPACING;
    }
    private static final int SCROLLBAR_WIDTH = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLLBAR_WIDTH = 18
     * }
     */
    public static int SCROLLBAR_WIDTH() {
        return SCROLLBAR_WIDTH;
    }
    private static final int SCROLLBAR_SIDE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCROLLBAR_SIDE = 19
     * }
     */
    public static int SCROLLBAR_SIDE() {
        return SCROLLBAR_SIDE;
    }
    private static final int LIST_ITEMS_BORDER_WIDTH = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LIST_ITEMS_BORDER_WIDTH = 20
     * }
     */
    public static int LIST_ITEMS_BORDER_WIDTH() {
        return LIST_ITEMS_BORDER_WIDTH;
    }
    private static final int COLOR_SELECTOR_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.COLOR_SELECTOR_SIZE = 16
     * }
     */
    public static int COLOR_SELECTOR_SIZE() {
        return COLOR_SELECTOR_SIZE;
    }
    private static final int HUEBAR_WIDTH = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HUEBAR_WIDTH = 17
     * }
     */
    public static int HUEBAR_WIDTH() {
        return HUEBAR_WIDTH;
    }
    private static final int HUEBAR_PADDING = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HUEBAR_PADDING = 18
     * }
     */
    public static int HUEBAR_PADDING() {
        return HUEBAR_PADDING;
    }
    private static final int HUEBAR_SELECTOR_HEIGHT = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HUEBAR_SELECTOR_HEIGHT = 19
     * }
     */
    public static int HUEBAR_SELECTOR_HEIGHT() {
        return HUEBAR_SELECTOR_HEIGHT;
    }
    private static final int HUEBAR_SELECTOR_OVERFLOW = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HUEBAR_SELECTOR_OVERFLOW = 20
     * }
     */
    public static int HUEBAR_SELECTOR_OVERFLOW() {
        return HUEBAR_SELECTOR_OVERFLOW;
    }

    private static class GuiEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiEnable()
     * }
     */
    public static FunctionDescriptor GuiEnable$descriptor() {
        return GuiEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiEnable()
     * }
     */
    public static MethodHandle GuiEnable$handle() {
        return GuiEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiEnable()
     * }
     */
    public static MemorySegment GuiEnable$address() {
        return GuiEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiEnable()
     * }
     */
    public static void GuiEnable() {
        var mh$ = GuiEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiEnable");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiDisable()
     * }
     */
    public static FunctionDescriptor GuiDisable$descriptor() {
        return GuiDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiDisable()
     * }
     */
    public static MethodHandle GuiDisable$handle() {
        return GuiDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiDisable()
     * }
     */
    public static MemorySegment GuiDisable$address() {
        return GuiDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiDisable()
     * }
     */
    public static void GuiDisable() {
        var mh$ = GuiDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiDisable");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiLock()
     * }
     */
    public static FunctionDescriptor GuiLock$descriptor() {
        return GuiLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiLock()
     * }
     */
    public static MethodHandle GuiLock$handle() {
        return GuiLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiLock()
     * }
     */
    public static MemorySegment GuiLock$address() {
        return GuiLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiLock()
     * }
     */
    public static void GuiLock() {
        var mh$ = GuiLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiUnlock()
     * }
     */
    public static FunctionDescriptor GuiUnlock$descriptor() {
        return GuiUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiUnlock()
     * }
     */
    public static MethodHandle GuiUnlock$handle() {
        return GuiUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiUnlock()
     * }
     */
    public static MemorySegment GuiUnlock$address() {
        return GuiUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiUnlock()
     * }
     */
    public static void GuiUnlock() {
        var mh$ = GuiUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiUnlock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiIsLocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiIsLocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool GuiIsLocked()
     * }
     */
    public static FunctionDescriptor GuiIsLocked$descriptor() {
        return GuiIsLocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool GuiIsLocked()
     * }
     */
    public static MethodHandle GuiIsLocked$handle() {
        return GuiIsLocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool GuiIsLocked()
     * }
     */
    public static MemorySegment GuiIsLocked$address() {
        return GuiIsLocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool GuiIsLocked()
     * }
     */
    public static boolean GuiIsLocked() {
        var mh$ = GuiIsLocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiIsLocked");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetAlpha(float alpha)
     * }
     */
    public static FunctionDescriptor GuiSetAlpha$descriptor() {
        return GuiSetAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetAlpha(float alpha)
     * }
     */
    public static MethodHandle GuiSetAlpha$handle() {
        return GuiSetAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetAlpha(float alpha)
     * }
     */
    public static MemorySegment GuiSetAlpha$address() {
        return GuiSetAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetAlpha(float alpha)
     * }
     */
    public static void GuiSetAlpha(float alpha) {
        var mh$ = GuiSetAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetAlpha", alpha);
            }
            mh$.invokeExact(alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetState(int state)
     * }
     */
    public static FunctionDescriptor GuiSetState$descriptor() {
        return GuiSetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetState(int state)
     * }
     */
    public static MethodHandle GuiSetState$handle() {
        return GuiSetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetState(int state)
     * }
     */
    public static MemorySegment GuiSetState$address() {
        return GuiSetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetState(int state)
     * }
     */
    public static void GuiSetState(int state) {
        var mh$ = GuiSetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetState", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiGetState()
     * }
     */
    public static FunctionDescriptor GuiGetState$descriptor() {
        return GuiGetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiGetState()
     * }
     */
    public static MethodHandle GuiGetState$handle() {
        return GuiGetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiGetState()
     * }
     */
    public static MemorySegment GuiGetState$address() {
        return GuiGetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiGetState()
     * }
     */
    public static int GuiGetState() {
        var mh$ = GuiGetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGetState");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetFont(Font font)
     * }
     */
    public static FunctionDescriptor GuiSetFont$descriptor() {
        return GuiSetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetFont(Font font)
     * }
     */
    public static MethodHandle GuiSetFont$handle() {
        return GuiSetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetFont(Font font)
     * }
     */
    public static MemorySegment GuiSetFont$address() {
        return GuiSetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetFont(Font font)
     * }
     */
    public static void GuiSetFont(MemorySegment font) {
        var mh$ = GuiSetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetFont", font);
            }
            mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font GuiGetFont()
     * }
     */
    public static FunctionDescriptor GuiGetFont$descriptor() {
        return GuiGetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font GuiGetFont()
     * }
     */
    public static MethodHandle GuiGetFont$handle() {
        return GuiGetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font GuiGetFont()
     * }
     */
    public static MemorySegment GuiGetFont$address() {
        return GuiGetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font GuiGetFont()
     * }
     */
    public static MemorySegment GuiGetFont(SegmentAllocator allocator) {
        var mh$ = GuiGetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGetFont", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetStyle(int control, int property, int value)
     * }
     */
    public static FunctionDescriptor GuiSetStyle$descriptor() {
        return GuiSetStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetStyle(int control, int property, int value)
     * }
     */
    public static MethodHandle GuiSetStyle$handle() {
        return GuiSetStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetStyle(int control, int property, int value)
     * }
     */
    public static MemorySegment GuiSetStyle$address() {
        return GuiSetStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetStyle(int control, int property, int value)
     * }
     */
    public static void GuiSetStyle(int control, int property, int value) {
        var mh$ = GuiSetStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetStyle", control, property, value);
            }
            mh$.invokeExact(control, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGetStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGetStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiGetStyle(int control, int property)
     * }
     */
    public static FunctionDescriptor GuiGetStyle$descriptor() {
        return GuiGetStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiGetStyle(int control, int property)
     * }
     */
    public static MethodHandle GuiGetStyle$handle() {
        return GuiGetStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiGetStyle(int control, int property)
     * }
     */
    public static MemorySegment GuiGetStyle$address() {
        return GuiGetStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiGetStyle(int control, int property)
     * }
     */
    public static int GuiGetStyle(int control, int property) {
        var mh$ = GuiGetStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGetStyle", control, property);
            }
            return (int)mh$.invokeExact(control, property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLoadStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLoadStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiLoadStyle(const char *fileName)
     * }
     */
    public static FunctionDescriptor GuiLoadStyle$descriptor() {
        return GuiLoadStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiLoadStyle(const char *fileName)
     * }
     */
    public static MethodHandle GuiLoadStyle$handle() {
        return GuiLoadStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiLoadStyle(const char *fileName)
     * }
     */
    public static MemorySegment GuiLoadStyle$address() {
        return GuiLoadStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiLoadStyle(const char *fileName)
     * }
     */
    public static void GuiLoadStyle(MemorySegment fileName) {
        var mh$ = GuiLoadStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLoadStyle", fileName);
            }
            mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLoadStyleDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLoadStyleDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiLoadStyleDefault()
     * }
     */
    public static FunctionDescriptor GuiLoadStyleDefault$descriptor() {
        return GuiLoadStyleDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiLoadStyleDefault()
     * }
     */
    public static MethodHandle GuiLoadStyleDefault$handle() {
        return GuiLoadStyleDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiLoadStyleDefault()
     * }
     */
    public static MemorySegment GuiLoadStyleDefault$address() {
        return GuiLoadStyleDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiLoadStyleDefault()
     * }
     */
    public static void GuiLoadStyleDefault() {
        var mh$ = GuiLoadStyleDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLoadStyleDefault");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiEnableTooltip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiEnableTooltip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiEnableTooltip()
     * }
     */
    public static FunctionDescriptor GuiEnableTooltip$descriptor() {
        return GuiEnableTooltip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiEnableTooltip()
     * }
     */
    public static MethodHandle GuiEnableTooltip$handle() {
        return GuiEnableTooltip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiEnableTooltip()
     * }
     */
    public static MemorySegment GuiEnableTooltip$address() {
        return GuiEnableTooltip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiEnableTooltip()
     * }
     */
    public static void GuiEnableTooltip() {
        var mh$ = GuiEnableTooltip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiEnableTooltip");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiDisableTooltip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiDisableTooltip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiDisableTooltip()
     * }
     */
    public static FunctionDescriptor GuiDisableTooltip$descriptor() {
        return GuiDisableTooltip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiDisableTooltip()
     * }
     */
    public static MethodHandle GuiDisableTooltip$handle() {
        return GuiDisableTooltip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiDisableTooltip()
     * }
     */
    public static MemorySegment GuiDisableTooltip$address() {
        return GuiDisableTooltip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiDisableTooltip()
     * }
     */
    public static void GuiDisableTooltip() {
        var mh$ = GuiDisableTooltip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiDisableTooltip");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetTooltip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetTooltip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetTooltip(const char *tooltip)
     * }
     */
    public static FunctionDescriptor GuiSetTooltip$descriptor() {
        return GuiSetTooltip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetTooltip(const char *tooltip)
     * }
     */
    public static MethodHandle GuiSetTooltip$handle() {
        return GuiSetTooltip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetTooltip(const char *tooltip)
     * }
     */
    public static MemorySegment GuiSetTooltip$address() {
        return GuiSetTooltip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetTooltip(const char *tooltip)
     * }
     */
    public static void GuiSetTooltip(MemorySegment tooltip) {
        var mh$ = GuiSetTooltip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetTooltip", tooltip);
            }
            mh$.invokeExact(tooltip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiIconText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiIconText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GuiIconText(int iconId, const char *text)
     * }
     */
    public static FunctionDescriptor GuiIconText$descriptor() {
        return GuiIconText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GuiIconText(int iconId, const char *text)
     * }
     */
    public static MethodHandle GuiIconText$handle() {
        return GuiIconText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GuiIconText(int iconId, const char *text)
     * }
     */
    public static MemorySegment GuiIconText$address() {
        return GuiIconText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GuiIconText(int iconId, const char *text)
     * }
     */
    public static MemorySegment GuiIconText(int iconId, MemorySegment text) {
        var mh$ = GuiIconText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiIconText", iconId, text);
            }
            return (MemorySegment)mh$.invokeExact(iconId, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSetIconScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSetIconScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiSetIconScale(int scale)
     * }
     */
    public static FunctionDescriptor GuiSetIconScale$descriptor() {
        return GuiSetIconScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiSetIconScale(int scale)
     * }
     */
    public static MethodHandle GuiSetIconScale$handle() {
        return GuiSetIconScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiSetIconScale(int scale)
     * }
     */
    public static MemorySegment GuiSetIconScale$address() {
        return GuiSetIconScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiSetIconScale(int scale)
     * }
     */
    public static void GuiSetIconScale(int scale) {
        var mh$ = GuiSetIconScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSetIconScale", scale);
            }
            mh$.invokeExact(scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGetIcons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGetIcons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int *GuiGetIcons()
     * }
     */
    public static FunctionDescriptor GuiGetIcons$descriptor() {
        return GuiGetIcons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int *GuiGetIcons()
     * }
     */
    public static MethodHandle GuiGetIcons$handle() {
        return GuiGetIcons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int *GuiGetIcons()
     * }
     */
    public static MemorySegment GuiGetIcons$address() {
        return GuiGetIcons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int *GuiGetIcons()
     * }
     */
    public static MemorySegment GuiGetIcons() {
        var mh$ = GuiGetIcons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGetIcons");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLoadIcons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLoadIcons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **GuiLoadIcons(const char *fileName, bool loadIconsName)
     * }
     */
    public static FunctionDescriptor GuiLoadIcons$descriptor() {
        return GuiLoadIcons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **GuiLoadIcons(const char *fileName, bool loadIconsName)
     * }
     */
    public static MethodHandle GuiLoadIcons$handle() {
        return GuiLoadIcons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **GuiLoadIcons(const char *fileName, bool loadIconsName)
     * }
     */
    public static MemorySegment GuiLoadIcons$address() {
        return GuiLoadIcons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **GuiLoadIcons(const char *fileName, bool loadIconsName)
     * }
     */
    public static MemorySegment GuiLoadIcons(MemorySegment fileName, boolean loadIconsName) {
        var mh$ = GuiLoadIcons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLoadIcons", fileName, loadIconsName);
            }
            return (MemorySegment)mh$.invokeExact(fileName, loadIconsName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiDrawIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiDrawIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GuiDrawIcon(int iconId, int posX, int posY, int pixelSize, Color color)
     * }
     */
    public static FunctionDescriptor GuiDrawIcon$descriptor() {
        return GuiDrawIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GuiDrawIcon(int iconId, int posX, int posY, int pixelSize, Color color)
     * }
     */
    public static MethodHandle GuiDrawIcon$handle() {
        return GuiDrawIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GuiDrawIcon(int iconId, int posX, int posY, int pixelSize, Color color)
     * }
     */
    public static MemorySegment GuiDrawIcon$address() {
        return GuiDrawIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GuiDrawIcon(int iconId, int posX, int posY, int pixelSize, Color color)
     * }
     */
    public static void GuiDrawIcon(int iconId, int posX, int posY, int pixelSize, MemorySegment color) {
        var mh$ = GuiDrawIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiDrawIcon", iconId, posX, posY, pixelSize, color);
            }
            mh$.invokeExact(iconId, posX, posY, pixelSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiWindowBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiWindowBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiWindowBox(Rectangle bounds, const char *title)
     * }
     */
    public static FunctionDescriptor GuiWindowBox$descriptor() {
        return GuiWindowBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiWindowBox(Rectangle bounds, const char *title)
     * }
     */
    public static MethodHandle GuiWindowBox$handle() {
        return GuiWindowBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiWindowBox(Rectangle bounds, const char *title)
     * }
     */
    public static MemorySegment GuiWindowBox$address() {
        return GuiWindowBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiWindowBox(Rectangle bounds, const char *title)
     * }
     */
    public static int GuiWindowBox(MemorySegment bounds, MemorySegment title) {
        var mh$ = GuiWindowBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiWindowBox", bounds, title);
            }
            return (int)mh$.invokeExact(bounds, title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGroupBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGroupBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiGroupBox(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiGroupBox$descriptor() {
        return GuiGroupBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiGroupBox(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiGroupBox$handle() {
        return GuiGroupBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiGroupBox(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiGroupBox$address() {
        return GuiGroupBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiGroupBox(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiGroupBox(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiGroupBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGroupBox", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiLine(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiLine$descriptor() {
        return GuiLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiLine(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiLine$handle() {
        return GuiLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiLine(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiLine$address() {
        return GuiLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiLine(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiLine(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLine", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiPanel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiPanel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiPanel(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiPanel$descriptor() {
        return GuiPanel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiPanel(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiPanel$handle() {
        return GuiPanel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiPanel(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiPanel$address() {
        return GuiPanel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiPanel(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiPanel(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiPanel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiPanel", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiTabBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiTabBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiTabBar(Rectangle bounds, const char **text, int count, int *active)
     * }
     */
    public static FunctionDescriptor GuiTabBar$descriptor() {
        return GuiTabBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiTabBar(Rectangle bounds, const char **text, int count, int *active)
     * }
     */
    public static MethodHandle GuiTabBar$handle() {
        return GuiTabBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiTabBar(Rectangle bounds, const char **text, int count, int *active)
     * }
     */
    public static MemorySegment GuiTabBar$address() {
        return GuiTabBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiTabBar(Rectangle bounds, const char **text, int count, int *active)
     * }
     */
    public static int GuiTabBar(MemorySegment bounds, MemorySegment text, int count, MemorySegment active) {
        var mh$ = GuiTabBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiTabBar", bounds, text, count, active);
            }
            return (int)mh$.invokeExact(bounds, text, count, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiScrollPanel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiScrollPanel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiScrollPanel(Rectangle bounds, const char *text, Rectangle content, Vector2 *scroll, Rectangle *view)
     * }
     */
    public static FunctionDescriptor GuiScrollPanel$descriptor() {
        return GuiScrollPanel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiScrollPanel(Rectangle bounds, const char *text, Rectangle content, Vector2 *scroll, Rectangle *view)
     * }
     */
    public static MethodHandle GuiScrollPanel$handle() {
        return GuiScrollPanel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiScrollPanel(Rectangle bounds, const char *text, Rectangle content, Vector2 *scroll, Rectangle *view)
     * }
     */
    public static MemorySegment GuiScrollPanel$address() {
        return GuiScrollPanel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiScrollPanel(Rectangle bounds, const char *text, Rectangle content, Vector2 *scroll, Rectangle *view)
     * }
     */
    public static int GuiScrollPanel(MemorySegment bounds, MemorySegment text, MemorySegment content, MemorySegment scroll, MemorySegment view) {
        var mh$ = GuiScrollPanel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiScrollPanel", bounds, text, content, scroll, view);
            }
            return (int)mh$.invokeExact(bounds, text, content, scroll, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLabel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLabel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiLabel(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiLabel$descriptor() {
        return GuiLabel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiLabel(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiLabel$handle() {
        return GuiLabel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiLabel(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiLabel$address() {
        return GuiLabel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiLabel(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiLabel(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiLabel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLabel", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiButton(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiButton$descriptor() {
        return GuiButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiButton(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiButton$handle() {
        return GuiButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiButton(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiButton$address() {
        return GuiButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiButton(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiButton(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiButton", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiLabelButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiLabelButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiLabelButton(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiLabelButton$descriptor() {
        return GuiLabelButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiLabelButton(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiLabelButton$handle() {
        return GuiLabelButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiLabelButton(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiLabelButton$address() {
        return GuiLabelButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiLabelButton(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiLabelButton(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiLabelButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiLabelButton", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiToggle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiToggle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiToggle(Rectangle bounds, const char *text, bool *active)
     * }
     */
    public static FunctionDescriptor GuiToggle$descriptor() {
        return GuiToggle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiToggle(Rectangle bounds, const char *text, bool *active)
     * }
     */
    public static MethodHandle GuiToggle$handle() {
        return GuiToggle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiToggle(Rectangle bounds, const char *text, bool *active)
     * }
     */
    public static MemorySegment GuiToggle$address() {
        return GuiToggle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiToggle(Rectangle bounds, const char *text, bool *active)
     * }
     */
    public static int GuiToggle(MemorySegment bounds, MemorySegment text, MemorySegment active) {
        var mh$ = GuiToggle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiToggle", bounds, text, active);
            }
            return (int)mh$.invokeExact(bounds, text, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiToggleGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiToggleGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiToggleGroup(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static FunctionDescriptor GuiToggleGroup$descriptor() {
        return GuiToggleGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiToggleGroup(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MethodHandle GuiToggleGroup$handle() {
        return GuiToggleGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiToggleGroup(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MemorySegment GuiToggleGroup$address() {
        return GuiToggleGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiToggleGroup(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static int GuiToggleGroup(MemorySegment bounds, MemorySegment text, MemorySegment active) {
        var mh$ = GuiToggleGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiToggleGroup", bounds, text, active);
            }
            return (int)mh$.invokeExact(bounds, text, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiToggleSlider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiToggleSlider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiToggleSlider(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static FunctionDescriptor GuiToggleSlider$descriptor() {
        return GuiToggleSlider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiToggleSlider(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MethodHandle GuiToggleSlider$handle() {
        return GuiToggleSlider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiToggleSlider(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MemorySegment GuiToggleSlider$address() {
        return GuiToggleSlider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiToggleSlider(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static int GuiToggleSlider(MemorySegment bounds, MemorySegment text, MemorySegment active) {
        var mh$ = GuiToggleSlider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiToggleSlider", bounds, text, active);
            }
            return (int)mh$.invokeExact(bounds, text, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiCheckBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiCheckBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiCheckBox(Rectangle bounds, const char *text, bool *checked)
     * }
     */
    public static FunctionDescriptor GuiCheckBox$descriptor() {
        return GuiCheckBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiCheckBox(Rectangle bounds, const char *text, bool *checked)
     * }
     */
    public static MethodHandle GuiCheckBox$handle() {
        return GuiCheckBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiCheckBox(Rectangle bounds, const char *text, bool *checked)
     * }
     */
    public static MemorySegment GuiCheckBox$address() {
        return GuiCheckBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiCheckBox(Rectangle bounds, const char *text, bool *checked)
     * }
     */
    public static int GuiCheckBox(MemorySegment bounds, MemorySegment text, MemorySegment checked) {
        var mh$ = GuiCheckBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiCheckBox", bounds, text, checked);
            }
            return (int)mh$.invokeExact(bounds, text, checked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiComboBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiComboBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiComboBox(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static FunctionDescriptor GuiComboBox$descriptor() {
        return GuiComboBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiComboBox(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MethodHandle GuiComboBox$handle() {
        return GuiComboBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiComboBox(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static MemorySegment GuiComboBox$address() {
        return GuiComboBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiComboBox(Rectangle bounds, const char *text, int *active)
     * }
     */
    public static int GuiComboBox(MemorySegment bounds, MemorySegment text, MemorySegment active) {
        var mh$ = GuiComboBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiComboBox", bounds, text, active);
            }
            return (int)mh$.invokeExact(bounds, text, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiDropdownBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiDropdownBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiDropdownBox(Rectangle bounds, const char *text, int *active, bool editMode)
     * }
     */
    public static FunctionDescriptor GuiDropdownBox$descriptor() {
        return GuiDropdownBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiDropdownBox(Rectangle bounds, const char *text, int *active, bool editMode)
     * }
     */
    public static MethodHandle GuiDropdownBox$handle() {
        return GuiDropdownBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiDropdownBox(Rectangle bounds, const char *text, int *active, bool editMode)
     * }
     */
    public static MemorySegment GuiDropdownBox$address() {
        return GuiDropdownBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiDropdownBox(Rectangle bounds, const char *text, int *active, bool editMode)
     * }
     */
    public static int GuiDropdownBox(MemorySegment bounds, MemorySegment text, MemorySegment active, boolean editMode) {
        var mh$ = GuiDropdownBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiDropdownBox", bounds, text, active, editMode);
            }
            return (int)mh$.invokeExact(bounds, text, active, editMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSpinner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSpinner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiSpinner(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static FunctionDescriptor GuiSpinner$descriptor() {
        return GuiSpinner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiSpinner(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static MethodHandle GuiSpinner$handle() {
        return GuiSpinner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiSpinner(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static MemorySegment GuiSpinner$address() {
        return GuiSpinner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiSpinner(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static int GuiSpinner(MemorySegment bounds, MemorySegment text, MemorySegment value, int minValue, int maxValue, boolean editMode) {
        var mh$ = GuiSpinner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSpinner", bounds, text, value, minValue, maxValue, editMode);
            }
            return (int)mh$.invokeExact(bounds, text, value, minValue, maxValue, editMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiValueBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiValueBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiValueBox(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static FunctionDescriptor GuiValueBox$descriptor() {
        return GuiValueBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiValueBox(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static MethodHandle GuiValueBox$handle() {
        return GuiValueBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiValueBox(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static MemorySegment GuiValueBox$address() {
        return GuiValueBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiValueBox(Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode)
     * }
     */
    public static int GuiValueBox(MemorySegment bounds, MemorySegment text, MemorySegment value, int minValue, int maxValue, boolean editMode) {
        var mh$ = GuiValueBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiValueBox", bounds, text, value, minValue, maxValue, editMode);
            }
            return (int)mh$.invokeExact(bounds, text, value, minValue, maxValue, editMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiValueBoxFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiValueBoxFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiValueBoxFloat(Rectangle bounds, const char *text, char *textValue, float *value, bool editMode)
     * }
     */
    public static FunctionDescriptor GuiValueBoxFloat$descriptor() {
        return GuiValueBoxFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiValueBoxFloat(Rectangle bounds, const char *text, char *textValue, float *value, bool editMode)
     * }
     */
    public static MethodHandle GuiValueBoxFloat$handle() {
        return GuiValueBoxFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiValueBoxFloat(Rectangle bounds, const char *text, char *textValue, float *value, bool editMode)
     * }
     */
    public static MemorySegment GuiValueBoxFloat$address() {
        return GuiValueBoxFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiValueBoxFloat(Rectangle bounds, const char *text, char *textValue, float *value, bool editMode)
     * }
     */
    public static int GuiValueBoxFloat(MemorySegment bounds, MemorySegment text, MemorySegment textValue, MemorySegment value, boolean editMode) {
        var mh$ = GuiValueBoxFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiValueBoxFloat", bounds, text, textValue, value, editMode);
            }
            return (int)mh$.invokeExact(bounds, text, textValue, value, editMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiTextBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiTextBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiTextBox(Rectangle bounds, char *text, int textSize, bool editMode)
     * }
     */
    public static FunctionDescriptor GuiTextBox$descriptor() {
        return GuiTextBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiTextBox(Rectangle bounds, char *text, int textSize, bool editMode)
     * }
     */
    public static MethodHandle GuiTextBox$handle() {
        return GuiTextBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiTextBox(Rectangle bounds, char *text, int textSize, bool editMode)
     * }
     */
    public static MemorySegment GuiTextBox$address() {
        return GuiTextBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiTextBox(Rectangle bounds, char *text, int textSize, bool editMode)
     * }
     */
    public static int GuiTextBox(MemorySegment bounds, MemorySegment text, int textSize, boolean editMode) {
        var mh$ = GuiTextBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiTextBox", bounds, text, textSize, editMode);
            }
            return (int)mh$.invokeExact(bounds, text, textSize, editMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSlider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSlider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiSlider(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static FunctionDescriptor GuiSlider$descriptor() {
        return GuiSlider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiSlider(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MethodHandle GuiSlider$handle() {
        return GuiSlider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiSlider(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MemorySegment GuiSlider$address() {
        return GuiSlider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiSlider(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static int GuiSlider(MemorySegment bounds, MemorySegment textLeft, MemorySegment textRight, MemorySegment value, float minValue, float maxValue) {
        var mh$ = GuiSlider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSlider", bounds, textLeft, textRight, value, minValue, maxValue);
            }
            return (int)mh$.invokeExact(bounds, textLeft, textRight, value, minValue, maxValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiSliderBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSliderBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiSliderBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static FunctionDescriptor GuiSliderBar$descriptor() {
        return GuiSliderBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiSliderBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MethodHandle GuiSliderBar$handle() {
        return GuiSliderBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiSliderBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MemorySegment GuiSliderBar$address() {
        return GuiSliderBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiSliderBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static int GuiSliderBar(MemorySegment bounds, MemorySegment textLeft, MemorySegment textRight, MemorySegment value, float minValue, float maxValue) {
        var mh$ = GuiSliderBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSliderBar", bounds, textLeft, textRight, value, minValue, maxValue);
            }
            return (int)mh$.invokeExact(bounds, textLeft, textRight, value, minValue, maxValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiProgressBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiProgressBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiProgressBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static FunctionDescriptor GuiProgressBar$descriptor() {
        return GuiProgressBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiProgressBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MethodHandle GuiProgressBar$handle() {
        return GuiProgressBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiProgressBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static MemorySegment GuiProgressBar$address() {
        return GuiProgressBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiProgressBar(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue)
     * }
     */
    public static int GuiProgressBar(MemorySegment bounds, MemorySegment textLeft, MemorySegment textRight, MemorySegment value, float minValue, float maxValue) {
        var mh$ = GuiProgressBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiProgressBar", bounds, textLeft, textRight, value, minValue, maxValue);
            }
            return (int)mh$.invokeExact(bounds, textLeft, textRight, value, minValue, maxValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiStatusBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiStatusBar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiStatusBar(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiStatusBar$descriptor() {
        return GuiStatusBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiStatusBar(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiStatusBar$handle() {
        return GuiStatusBar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiStatusBar(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiStatusBar$address() {
        return GuiStatusBar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiStatusBar(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiStatusBar(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiStatusBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiStatusBar", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiDummyRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiDummyRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiDummyRec(Rectangle bounds, const char *text)
     * }
     */
    public static FunctionDescriptor GuiDummyRec$descriptor() {
        return GuiDummyRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiDummyRec(Rectangle bounds, const char *text)
     * }
     */
    public static MethodHandle GuiDummyRec$handle() {
        return GuiDummyRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiDummyRec(Rectangle bounds, const char *text)
     * }
     */
    public static MemorySegment GuiDummyRec$address() {
        return GuiDummyRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiDummyRec(Rectangle bounds, const char *text)
     * }
     */
    public static int GuiDummyRec(MemorySegment bounds, MemorySegment text) {
        var mh$ = GuiDummyRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiDummyRec", bounds, text);
            }
            return (int)mh$.invokeExact(bounds, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiGrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiGrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiGrid(Rectangle bounds, const char *text, float spacing, int subdivs, Vector2 *mouseCell)
     * }
     */
    public static FunctionDescriptor GuiGrid$descriptor() {
        return GuiGrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiGrid(Rectangle bounds, const char *text, float spacing, int subdivs, Vector2 *mouseCell)
     * }
     */
    public static MethodHandle GuiGrid$handle() {
        return GuiGrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiGrid(Rectangle bounds, const char *text, float spacing, int subdivs, Vector2 *mouseCell)
     * }
     */
    public static MemorySegment GuiGrid$address() {
        return GuiGrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiGrid(Rectangle bounds, const char *text, float spacing, int subdivs, Vector2 *mouseCell)
     * }
     */
    public static int GuiGrid(MemorySegment bounds, MemorySegment text, float spacing, int subdivs, MemorySegment mouseCell) {
        var mh$ = GuiGrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiGrid", bounds, text, spacing, subdivs, mouseCell);
            }
            return (int)mh$.invokeExact(bounds, text, spacing, subdivs, mouseCell);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiListView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiListView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiListView(Rectangle bounds, const char *text, int *scrollIndex, int *active)
     * }
     */
    public static FunctionDescriptor GuiListView$descriptor() {
        return GuiListView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiListView(Rectangle bounds, const char *text, int *scrollIndex, int *active)
     * }
     */
    public static MethodHandle GuiListView$handle() {
        return GuiListView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiListView(Rectangle bounds, const char *text, int *scrollIndex, int *active)
     * }
     */
    public static MemorySegment GuiListView$address() {
        return GuiListView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiListView(Rectangle bounds, const char *text, int *scrollIndex, int *active)
     * }
     */
    public static int GuiListView(MemorySegment bounds, MemorySegment text, MemorySegment scrollIndex, MemorySegment active) {
        var mh$ = GuiListView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiListView", bounds, text, scrollIndex, active);
            }
            return (int)mh$.invokeExact(bounds, text, scrollIndex, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiListViewEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiListViewEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiListViewEx(Rectangle bounds, const char **text, int count, int *scrollIndex, int *active, int *focus)
     * }
     */
    public static FunctionDescriptor GuiListViewEx$descriptor() {
        return GuiListViewEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiListViewEx(Rectangle bounds, const char **text, int count, int *scrollIndex, int *active, int *focus)
     * }
     */
    public static MethodHandle GuiListViewEx$handle() {
        return GuiListViewEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiListViewEx(Rectangle bounds, const char **text, int count, int *scrollIndex, int *active, int *focus)
     * }
     */
    public static MemorySegment GuiListViewEx$address() {
        return GuiListViewEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiListViewEx(Rectangle bounds, const char **text, int count, int *scrollIndex, int *active, int *focus)
     * }
     */
    public static int GuiListViewEx(MemorySegment bounds, MemorySegment text, int count, MemorySegment scrollIndex, MemorySegment active, MemorySegment focus) {
        var mh$ = GuiListViewEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiListViewEx", bounds, text, count, scrollIndex, active, focus);
            }
            return (int)mh$.invokeExact(bounds, text, count, scrollIndex, active, focus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiMessageBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiMessageBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiMessageBox(Rectangle bounds, const char *title, const char *message, const char *buttons)
     * }
     */
    public static FunctionDescriptor GuiMessageBox$descriptor() {
        return GuiMessageBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiMessageBox(Rectangle bounds, const char *title, const char *message, const char *buttons)
     * }
     */
    public static MethodHandle GuiMessageBox$handle() {
        return GuiMessageBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiMessageBox(Rectangle bounds, const char *title, const char *message, const char *buttons)
     * }
     */
    public static MemorySegment GuiMessageBox$address() {
        return GuiMessageBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiMessageBox(Rectangle bounds, const char *title, const char *message, const char *buttons)
     * }
     */
    public static int GuiMessageBox(MemorySegment bounds, MemorySegment title, MemorySegment message, MemorySegment buttons) {
        var mh$ = GuiMessageBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiMessageBox", bounds, title, message, buttons);
            }
            return (int)mh$.invokeExact(bounds, title, message, buttons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiTextInputBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiTextInputBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiTextInputBox(Rectangle bounds, const char *title, const char *message, const char *buttons, char *text, int textMaxSize, bool *secretViewActive)
     * }
     */
    public static FunctionDescriptor GuiTextInputBox$descriptor() {
        return GuiTextInputBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiTextInputBox(Rectangle bounds, const char *title, const char *message, const char *buttons, char *text, int textMaxSize, bool *secretViewActive)
     * }
     */
    public static MethodHandle GuiTextInputBox$handle() {
        return GuiTextInputBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiTextInputBox(Rectangle bounds, const char *title, const char *message, const char *buttons, char *text, int textMaxSize, bool *secretViewActive)
     * }
     */
    public static MemorySegment GuiTextInputBox$address() {
        return GuiTextInputBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiTextInputBox(Rectangle bounds, const char *title, const char *message, const char *buttons, char *text, int textMaxSize, bool *secretViewActive)
     * }
     */
    public static int GuiTextInputBox(MemorySegment bounds, MemorySegment title, MemorySegment message, MemorySegment buttons, MemorySegment text, int textMaxSize, MemorySegment secretViewActive) {
        var mh$ = GuiTextInputBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiTextInputBox", bounds, title, message, buttons, text, textMaxSize, secretViewActive);
            }
            return (int)mh$.invokeExact(bounds, title, message, buttons, text, textMaxSize, secretViewActive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorPicker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorPicker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorPicker(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static FunctionDescriptor GuiColorPicker$descriptor() {
        return GuiColorPicker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorPicker(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static MethodHandle GuiColorPicker$handle() {
        return GuiColorPicker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorPicker(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static MemorySegment GuiColorPicker$address() {
        return GuiColorPicker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorPicker(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static int GuiColorPicker(MemorySegment bounds, MemorySegment text, MemorySegment color) {
        var mh$ = GuiColorPicker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorPicker", bounds, text, color);
            }
            return (int)mh$.invokeExact(bounds, text, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorPanel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorPanel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorPanel(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static FunctionDescriptor GuiColorPanel$descriptor() {
        return GuiColorPanel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorPanel(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static MethodHandle GuiColorPanel$handle() {
        return GuiColorPanel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorPanel(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static MemorySegment GuiColorPanel$address() {
        return GuiColorPanel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorPanel(Rectangle bounds, const char *text, Color *color)
     * }
     */
    public static int GuiColorPanel(MemorySegment bounds, MemorySegment text, MemorySegment color) {
        var mh$ = GuiColorPanel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorPanel", bounds, text, color);
            }
            return (int)mh$.invokeExact(bounds, text, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorBarAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorBarAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorBarAlpha(Rectangle bounds, const char *text, float *alpha)
     * }
     */
    public static FunctionDescriptor GuiColorBarAlpha$descriptor() {
        return GuiColorBarAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorBarAlpha(Rectangle bounds, const char *text, float *alpha)
     * }
     */
    public static MethodHandle GuiColorBarAlpha$handle() {
        return GuiColorBarAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorBarAlpha(Rectangle bounds, const char *text, float *alpha)
     * }
     */
    public static MemorySegment GuiColorBarAlpha$address() {
        return GuiColorBarAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorBarAlpha(Rectangle bounds, const char *text, float *alpha)
     * }
     */
    public static int GuiColorBarAlpha(MemorySegment bounds, MemorySegment text, MemorySegment alpha) {
        var mh$ = GuiColorBarAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorBarAlpha", bounds, text, alpha);
            }
            return (int)mh$.invokeExact(bounds, text, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorBarHue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorBarHue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorBarHue(Rectangle bounds, const char *text, float *value)
     * }
     */
    public static FunctionDescriptor GuiColorBarHue$descriptor() {
        return GuiColorBarHue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorBarHue(Rectangle bounds, const char *text, float *value)
     * }
     */
    public static MethodHandle GuiColorBarHue$handle() {
        return GuiColorBarHue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorBarHue(Rectangle bounds, const char *text, float *value)
     * }
     */
    public static MemorySegment GuiColorBarHue$address() {
        return GuiColorBarHue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorBarHue(Rectangle bounds, const char *text, float *value)
     * }
     */
    public static int GuiColorBarHue(MemorySegment bounds, MemorySegment text, MemorySegment value) {
        var mh$ = GuiColorBarHue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorBarHue", bounds, text, value);
            }
            return (int)mh$.invokeExact(bounds, text, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorPickerHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorPickerHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorPickerHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static FunctionDescriptor GuiColorPickerHSV$descriptor() {
        return GuiColorPickerHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorPickerHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static MethodHandle GuiColorPickerHSV$handle() {
        return GuiColorPickerHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorPickerHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static MemorySegment GuiColorPickerHSV$address() {
        return GuiColorPickerHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorPickerHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static int GuiColorPickerHSV(MemorySegment bounds, MemorySegment text, MemorySegment colorHsv) {
        var mh$ = GuiColorPickerHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorPickerHSV", bounds, text, colorHsv);
            }
            return (int)mh$.invokeExact(bounds, text, colorHsv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GuiColorPanelHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiColorPanelHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiColorPanelHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static FunctionDescriptor GuiColorPanelHSV$descriptor() {
        return GuiColorPanelHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiColorPanelHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static MethodHandle GuiColorPanelHSV$handle() {
        return GuiColorPanelHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiColorPanelHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static MemorySegment GuiColorPanelHSV$address() {
        return GuiColorPanelHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiColorPanelHSV(Rectangle bounds, const char *text, Vector3 *colorHsv)
     * }
     */
    public static int GuiColorPanelHSV(MemorySegment bounds, MemorySegment text, MemorySegment colorHsv) {
        var mh$ = GuiColorPanelHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiColorPanelHSV", bounds, text, colorHsv);
            }
            return (int)mh$.invokeExact(bounds, text, colorHsv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ICON_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_NONE = 0
     * }
     */
    public static int ICON_NONE() {
        return ICON_NONE;
    }
    private static final int ICON_FOLDER_FILE_OPEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOLDER_FILE_OPEN = 1
     * }
     */
    public static int ICON_FOLDER_FILE_OPEN() {
        return ICON_FOLDER_FILE_OPEN;
    }
    private static final int ICON_FILE_SAVE_CLASSIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_SAVE_CLASSIC = 2
     * }
     */
    public static int ICON_FILE_SAVE_CLASSIC() {
        return ICON_FILE_SAVE_CLASSIC;
    }
    private static final int ICON_FOLDER_OPEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOLDER_OPEN = 3
     * }
     */
    public static int ICON_FOLDER_OPEN() {
        return ICON_FOLDER_OPEN;
    }
    private static final int ICON_FOLDER_SAVE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOLDER_SAVE = 4
     * }
     */
    public static int ICON_FOLDER_SAVE() {
        return ICON_FOLDER_SAVE;
    }
    private static final int ICON_FILE_OPEN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_OPEN = 5
     * }
     */
    public static int ICON_FILE_OPEN() {
        return ICON_FILE_OPEN;
    }
    private static final int ICON_FILE_SAVE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_SAVE = 6
     * }
     */
    public static int ICON_FILE_SAVE() {
        return ICON_FILE_SAVE;
    }
    private static final int ICON_FILE_EXPORT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_EXPORT = 7
     * }
     */
    public static int ICON_FILE_EXPORT() {
        return ICON_FILE_EXPORT;
    }
    private static final int ICON_FILE_ADD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_ADD = 8
     * }
     */
    public static int ICON_FILE_ADD() {
        return ICON_FILE_ADD;
    }
    private static final int ICON_FILE_DELETE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_DELETE = 9
     * }
     */
    public static int ICON_FILE_DELETE() {
        return ICON_FILE_DELETE;
    }
    private static final int ICON_FILETYPE_TEXT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_TEXT = 10
     * }
     */
    public static int ICON_FILETYPE_TEXT() {
        return ICON_FILETYPE_TEXT;
    }
    private static final int ICON_FILETYPE_AUDIO = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_AUDIO = 11
     * }
     */
    public static int ICON_FILETYPE_AUDIO() {
        return ICON_FILETYPE_AUDIO;
    }
    private static final int ICON_FILETYPE_IMAGE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_IMAGE = 12
     * }
     */
    public static int ICON_FILETYPE_IMAGE() {
        return ICON_FILETYPE_IMAGE;
    }
    private static final int ICON_FILETYPE_PLAY = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_PLAY = 13
     * }
     */
    public static int ICON_FILETYPE_PLAY() {
        return ICON_FILETYPE_PLAY;
    }
    private static final int ICON_FILETYPE_VIDEO = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_VIDEO = 14
     * }
     */
    public static int ICON_FILETYPE_VIDEO() {
        return ICON_FILETYPE_VIDEO;
    }
    private static final int ICON_FILETYPE_INFO = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_INFO = 15
     * }
     */
    public static int ICON_FILETYPE_INFO() {
        return ICON_FILETYPE_INFO;
    }
    private static final int ICON_FILE_COPY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_COPY = 16
     * }
     */
    public static int ICON_FILE_COPY() {
        return ICON_FILE_COPY;
    }
    private static final int ICON_FILE_CUT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_CUT = 17
     * }
     */
    public static int ICON_FILE_CUT() {
        return ICON_FILE_CUT;
    }
    private static final int ICON_FILE_PASTE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_PASTE = 18
     * }
     */
    public static int ICON_FILE_PASTE() {
        return ICON_FILE_PASTE;
    }
    private static final int ICON_CURSOR_HAND = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_HAND = 19
     * }
     */
    public static int ICON_CURSOR_HAND() {
        return ICON_CURSOR_HAND;
    }
    private static final int ICON_CURSOR_POINTER = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_POINTER = 20
     * }
     */
    public static int ICON_CURSOR_POINTER() {
        return ICON_CURSOR_POINTER;
    }
    private static final int ICON_CURSOR_CLASSIC = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_CLASSIC = 21
     * }
     */
    public static int ICON_CURSOR_CLASSIC() {
        return ICON_CURSOR_CLASSIC;
    }
    private static final int ICON_PENCIL = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PENCIL = 22
     * }
     */
    public static int ICON_PENCIL() {
        return ICON_PENCIL;
    }
    private static final int ICON_PENCIL_BIG = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PENCIL_BIG = 23
     * }
     */
    public static int ICON_PENCIL_BIG() {
        return ICON_PENCIL_BIG;
    }
    private static final int ICON_BRUSH_CLASSIC = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BRUSH_CLASSIC = 24
     * }
     */
    public static int ICON_BRUSH_CLASSIC() {
        return ICON_BRUSH_CLASSIC;
    }
    private static final int ICON_BRUSH_PAINTER = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BRUSH_PAINTER = 25
     * }
     */
    public static int ICON_BRUSH_PAINTER() {
        return ICON_BRUSH_PAINTER;
    }
    private static final int ICON_WATER_DROP = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WATER_DROP = 26
     * }
     */
    public static int ICON_WATER_DROP() {
        return ICON_WATER_DROP;
    }
    private static final int ICON_COLOR_PICKER = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_COLOR_PICKER = 27
     * }
     */
    public static int ICON_COLOR_PICKER() {
        return ICON_COLOR_PICKER;
    }
    private static final int ICON_RUBBER = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_RUBBER = 28
     * }
     */
    public static int ICON_RUBBER() {
        return ICON_RUBBER;
    }
    private static final int ICON_COLOR_BUCKET = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_COLOR_BUCKET = 29
     * }
     */
    public static int ICON_COLOR_BUCKET() {
        return ICON_COLOR_BUCKET;
    }
    private static final int ICON_TEXT_T = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TEXT_T = 30
     * }
     */
    public static int ICON_TEXT_T() {
        return ICON_TEXT_T;
    }
    private static final int ICON_TEXT_A = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TEXT_A = 31
     * }
     */
    public static int ICON_TEXT_A() {
        return ICON_TEXT_A;
    }
    private static final int ICON_SCALE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SCALE = 32
     * }
     */
    public static int ICON_SCALE() {
        return ICON_SCALE;
    }
    private static final int ICON_RESIZE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_RESIZE = 33
     * }
     */
    public static int ICON_RESIZE() {
        return ICON_RESIZE;
    }
    private static final int ICON_FILTER_POINT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILTER_POINT = 34
     * }
     */
    public static int ICON_FILTER_POINT() {
        return ICON_FILTER_POINT;
    }
    private static final int ICON_FILTER_BILINEAR = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILTER_BILINEAR = 35
     * }
     */
    public static int ICON_FILTER_BILINEAR() {
        return ICON_FILTER_BILINEAR;
    }
    private static final int ICON_CROP = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CROP = 36
     * }
     */
    public static int ICON_CROP() {
        return ICON_CROP;
    }
    private static final int ICON_CROP_ALPHA = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CROP_ALPHA = 37
     * }
     */
    public static int ICON_CROP_ALPHA() {
        return ICON_CROP_ALPHA;
    }
    private static final int ICON_SQUARE_TOGGLE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SQUARE_TOGGLE = 38
     * }
     */
    public static int ICON_SQUARE_TOGGLE() {
        return ICON_SQUARE_TOGGLE;
    }
    private static final int ICON_SYMMETRY = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SYMMETRY = 39
     * }
     */
    public static int ICON_SYMMETRY() {
        return ICON_SYMMETRY;
    }
    private static final int ICON_SYMMETRY_HORIZONTAL = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SYMMETRY_HORIZONTAL = 40
     * }
     */
    public static int ICON_SYMMETRY_HORIZONTAL() {
        return ICON_SYMMETRY_HORIZONTAL;
    }
    private static final int ICON_SYMMETRY_VERTICAL = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SYMMETRY_VERTICAL = 41
     * }
     */
    public static int ICON_SYMMETRY_VERTICAL() {
        return ICON_SYMMETRY_VERTICAL;
    }
    private static final int ICON_LENS = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LENS = 42
     * }
     */
    public static int ICON_LENS() {
        return ICON_LENS;
    }
    private static final int ICON_LENS_BIG = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LENS_BIG = 43
     * }
     */
    public static int ICON_LENS_BIG() {
        return ICON_LENS_BIG;
    }
    private static final int ICON_EYE_ON = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EYE_ON = 44
     * }
     */
    public static int ICON_EYE_ON() {
        return ICON_EYE_ON;
    }
    private static final int ICON_EYE_OFF = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EYE_OFF = 45
     * }
     */
    public static int ICON_EYE_OFF() {
        return ICON_EYE_OFF;
    }
    private static final int ICON_FILTER_TOP = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILTER_TOP = 46
     * }
     */
    public static int ICON_FILTER_TOP() {
        return ICON_FILTER_TOP;
    }
    private static final int ICON_FILTER = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILTER = 47
     * }
     */
    public static int ICON_FILTER() {
        return ICON_FILTER;
    }
    private static final int ICON_TARGET_POINT = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_POINT = 48
     * }
     */
    public static int ICON_TARGET_POINT() {
        return ICON_TARGET_POINT;
    }
    private static final int ICON_TARGET_SMALL = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_SMALL = 49
     * }
     */
    public static int ICON_TARGET_SMALL() {
        return ICON_TARGET_SMALL;
    }
    private static final int ICON_TARGET_BIG = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_BIG = 50
     * }
     */
    public static int ICON_TARGET_BIG() {
        return ICON_TARGET_BIG;
    }
    private static final int ICON_TARGET_MOVE = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_MOVE = 51
     * }
     */
    public static int ICON_TARGET_MOVE() {
        return ICON_TARGET_MOVE;
    }
    private static final int ICON_CURSOR_MOVE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_MOVE = 52
     * }
     */
    public static int ICON_CURSOR_MOVE() {
        return ICON_CURSOR_MOVE;
    }
    private static final int ICON_CURSOR_SCALE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE = 53
     * }
     */
    public static int ICON_CURSOR_SCALE() {
        return ICON_CURSOR_SCALE;
    }
    private static final int ICON_CURSOR_SCALE_RIGHT = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE_RIGHT = 54
     * }
     */
    public static int ICON_CURSOR_SCALE_RIGHT() {
        return ICON_CURSOR_SCALE_RIGHT;
    }
    private static final int ICON_CURSOR_SCALE_LEFT = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE_LEFT = 55
     * }
     */
    public static int ICON_CURSOR_SCALE_LEFT() {
        return ICON_CURSOR_SCALE_LEFT;
    }
    private static final int ICON_UNDO = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_UNDO = 56
     * }
     */
    public static int ICON_UNDO() {
        return ICON_UNDO;
    }
    private static final int ICON_REDO = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REDO = 57
     * }
     */
    public static int ICON_REDO() {
        return ICON_REDO;
    }
    private static final int ICON_REREDO = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REREDO = 58
     * }
     */
    public static int ICON_REREDO() {
        return ICON_REREDO;
    }
    private static final int ICON_MUTATE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MUTATE = 59
     * }
     */
    public static int ICON_MUTATE() {
        return ICON_MUTATE;
    }
    private static final int ICON_ROTATE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ROTATE = 60
     * }
     */
    public static int ICON_ROTATE() {
        return ICON_ROTATE;
    }
    private static final int ICON_REPEAT = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REPEAT = 61
     * }
     */
    public static int ICON_REPEAT() {
        return ICON_REPEAT;
    }
    private static final int ICON_SHUFFLE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SHUFFLE = 62
     * }
     */
    public static int ICON_SHUFFLE() {
        return ICON_SHUFFLE;
    }
    private static final int ICON_EMPTYBOX = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EMPTYBOX = 63
     * }
     */
    public static int ICON_EMPTYBOX() {
        return ICON_EMPTYBOX;
    }
    private static final int ICON_TARGET = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET = 64
     * }
     */
    public static int ICON_TARGET() {
        return ICON_TARGET;
    }
    private static final int ICON_TARGET_SMALL_FILL = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_SMALL_FILL = 65
     * }
     */
    public static int ICON_TARGET_SMALL_FILL() {
        return ICON_TARGET_SMALL_FILL;
    }
    private static final int ICON_TARGET_BIG_FILL = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_BIG_FILL = 66
     * }
     */
    public static int ICON_TARGET_BIG_FILL() {
        return ICON_TARGET_BIG_FILL;
    }
    private static final int ICON_TARGET_MOVE_FILL = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TARGET_MOVE_FILL = 67
     * }
     */
    public static int ICON_TARGET_MOVE_FILL() {
        return ICON_TARGET_MOVE_FILL;
    }
    private static final int ICON_CURSOR_MOVE_FILL = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_MOVE_FILL = 68
     * }
     */
    public static int ICON_CURSOR_MOVE_FILL() {
        return ICON_CURSOR_MOVE_FILL;
    }
    private static final int ICON_CURSOR_SCALE_FILL = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE_FILL = 69
     * }
     */
    public static int ICON_CURSOR_SCALE_FILL() {
        return ICON_CURSOR_SCALE_FILL;
    }
    private static final int ICON_CURSOR_SCALE_RIGHT_FILL = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE_RIGHT_FILL = 70
     * }
     */
    public static int ICON_CURSOR_SCALE_RIGHT_FILL() {
        return ICON_CURSOR_SCALE_RIGHT_FILL;
    }
    private static final int ICON_CURSOR_SCALE_LEFT_FILL = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CURSOR_SCALE_LEFT_FILL = 71
     * }
     */
    public static int ICON_CURSOR_SCALE_LEFT_FILL() {
        return ICON_CURSOR_SCALE_LEFT_FILL;
    }
    private static final int ICON_UNDO_FILL = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_UNDO_FILL = 72
     * }
     */
    public static int ICON_UNDO_FILL() {
        return ICON_UNDO_FILL;
    }
    private static final int ICON_REDO_FILL = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REDO_FILL = 73
     * }
     */
    public static int ICON_REDO_FILL() {
        return ICON_REDO_FILL;
    }
    private static final int ICON_REREDO_FILL = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REREDO_FILL = 74
     * }
     */
    public static int ICON_REREDO_FILL() {
        return ICON_REREDO_FILL;
    }
    private static final int ICON_MUTATE_FILL = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MUTATE_FILL = 75
     * }
     */
    public static int ICON_MUTATE_FILL() {
        return ICON_MUTATE_FILL;
    }
    private static final int ICON_ROTATE_FILL = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ROTATE_FILL = 76
     * }
     */
    public static int ICON_ROTATE_FILL() {
        return ICON_ROTATE_FILL;
    }
    private static final int ICON_REPEAT_FILL = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REPEAT_FILL = 77
     * }
     */
    public static int ICON_REPEAT_FILL() {
        return ICON_REPEAT_FILL;
    }
    private static final int ICON_SHUFFLE_FILL = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SHUFFLE_FILL = 78
     * }
     */
    public static int ICON_SHUFFLE_FILL() {
        return ICON_SHUFFLE_FILL;
    }
    private static final int ICON_EMPTYBOX_SMALL = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EMPTYBOX_SMALL = 79
     * }
     */
    public static int ICON_EMPTYBOX_SMALL() {
        return ICON_EMPTYBOX_SMALL;
    }
    private static final int ICON_BOX = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX = 80
     * }
     */
    public static int ICON_BOX() {
        return ICON_BOX;
    }
    private static final int ICON_BOX_TOP = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_TOP = 81
     * }
     */
    public static int ICON_BOX_TOP() {
        return ICON_BOX_TOP;
    }
    private static final int ICON_BOX_TOP_RIGHT = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_TOP_RIGHT = 82
     * }
     */
    public static int ICON_BOX_TOP_RIGHT() {
        return ICON_BOX_TOP_RIGHT;
    }
    private static final int ICON_BOX_RIGHT = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_RIGHT = 83
     * }
     */
    public static int ICON_BOX_RIGHT() {
        return ICON_BOX_RIGHT;
    }
    private static final int ICON_BOX_BOTTOM_RIGHT = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_BOTTOM_RIGHT = 84
     * }
     */
    public static int ICON_BOX_BOTTOM_RIGHT() {
        return ICON_BOX_BOTTOM_RIGHT;
    }
    private static final int ICON_BOX_BOTTOM = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_BOTTOM = 85
     * }
     */
    public static int ICON_BOX_BOTTOM() {
        return ICON_BOX_BOTTOM;
    }
    private static final int ICON_BOX_BOTTOM_LEFT = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_BOTTOM_LEFT = 86
     * }
     */
    public static int ICON_BOX_BOTTOM_LEFT() {
        return ICON_BOX_BOTTOM_LEFT;
    }
    private static final int ICON_BOX_LEFT = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_LEFT = 87
     * }
     */
    public static int ICON_BOX_LEFT() {
        return ICON_BOX_LEFT;
    }
    private static final int ICON_BOX_TOP_LEFT = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_TOP_LEFT = 88
     * }
     */
    public static int ICON_BOX_TOP_LEFT() {
        return ICON_BOX_TOP_LEFT;
    }
    private static final int ICON_BOX_CENTER = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_CENTER = 89
     * }
     */
    public static int ICON_BOX_CENTER() {
        return ICON_BOX_CENTER;
    }
    private static final int ICON_BOX_CIRCLE_MASK = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_CIRCLE_MASK = 90
     * }
     */
    public static int ICON_BOX_CIRCLE_MASK() {
        return ICON_BOX_CIRCLE_MASK;
    }
    private static final int ICON_POT = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_POT = 91
     * }
     */
    public static int ICON_POT() {
        return ICON_POT;
    }
    private static final int ICON_ALPHA_MULTIPLY = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ALPHA_MULTIPLY = 92
     * }
     */
    public static int ICON_ALPHA_MULTIPLY() {
        return ICON_ALPHA_MULTIPLY;
    }
    private static final int ICON_ALPHA_CLEAR = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ALPHA_CLEAR = 93
     * }
     */
    public static int ICON_ALPHA_CLEAR() {
        return ICON_ALPHA_CLEAR;
    }
    private static final int ICON_DITHERING = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_DITHERING = 94
     * }
     */
    public static int ICON_DITHERING() {
        return ICON_DITHERING;
    }
    private static final int ICON_MIPMAPS = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MIPMAPS = 95
     * }
     */
    public static int ICON_MIPMAPS() {
        return ICON_MIPMAPS;
    }
    private static final int ICON_BOX_GRID = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_GRID = 96
     * }
     */
    public static int ICON_BOX_GRID() {
        return ICON_BOX_GRID;
    }
    private static final int ICON_GRID = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_GRID = 97
     * }
     */
    public static int ICON_GRID() {
        return ICON_GRID;
    }
    private static final int ICON_BOX_CORNERS_SMALL = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_CORNERS_SMALL = 98
     * }
     */
    public static int ICON_BOX_CORNERS_SMALL() {
        return ICON_BOX_CORNERS_SMALL;
    }
    private static final int ICON_BOX_CORNERS_BIG = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_CORNERS_BIG = 99
     * }
     */
    public static int ICON_BOX_CORNERS_BIG() {
        return ICON_BOX_CORNERS_BIG;
    }
    private static final int ICON_FOUR_BOXES = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOUR_BOXES = 100
     * }
     */
    public static int ICON_FOUR_BOXES() {
        return ICON_FOUR_BOXES;
    }
    private static final int ICON_GRID_FILL = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_GRID_FILL = 101
     * }
     */
    public static int ICON_GRID_FILL() {
        return ICON_GRID_FILL;
    }
    private static final int ICON_BOX_MULTISIZE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_MULTISIZE = 102
     * }
     */
    public static int ICON_BOX_MULTISIZE() {
        return ICON_BOX_MULTISIZE;
    }
    private static final int ICON_ZOOM_SMALL = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ZOOM_SMALL = 103
     * }
     */
    public static int ICON_ZOOM_SMALL() {
        return ICON_ZOOM_SMALL;
    }
    private static final int ICON_ZOOM_MEDIUM = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ZOOM_MEDIUM = 104
     * }
     */
    public static int ICON_ZOOM_MEDIUM() {
        return ICON_ZOOM_MEDIUM;
    }
    private static final int ICON_ZOOM_BIG = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ZOOM_BIG = 105
     * }
     */
    public static int ICON_ZOOM_BIG() {
        return ICON_ZOOM_BIG;
    }
    private static final int ICON_ZOOM_ALL = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ZOOM_ALL = 106
     * }
     */
    public static int ICON_ZOOM_ALL() {
        return ICON_ZOOM_ALL;
    }
    private static final int ICON_ZOOM_CENTER = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ZOOM_CENTER = 107
     * }
     */
    public static int ICON_ZOOM_CENTER() {
        return ICON_ZOOM_CENTER;
    }
    private static final int ICON_BOX_DOTS_SMALL = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_DOTS_SMALL = 108
     * }
     */
    public static int ICON_BOX_DOTS_SMALL() {
        return ICON_BOX_DOTS_SMALL;
    }
    private static final int ICON_BOX_DOTS_BIG = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_DOTS_BIG = 109
     * }
     */
    public static int ICON_BOX_DOTS_BIG() {
        return ICON_BOX_DOTS_BIG;
    }
    private static final int ICON_BOX_CONCENTRIC = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_CONCENTRIC = 110
     * }
     */
    public static int ICON_BOX_CONCENTRIC() {
        return ICON_BOX_CONCENTRIC;
    }
    private static final int ICON_BOX_GRID_BIG = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BOX_GRID_BIG = 111
     * }
     */
    public static int ICON_BOX_GRID_BIG() {
        return ICON_BOX_GRID_BIG;
    }
    private static final int ICON_OK_TICK = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_OK_TICK = 112
     * }
     */
    public static int ICON_OK_TICK() {
        return ICON_OK_TICK;
    }
    private static final int ICON_CROSS = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CROSS = 113
     * }
     */
    public static int ICON_CROSS() {
        return ICON_CROSS;
    }
    private static final int ICON_ARROW_LEFT = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_LEFT = 114
     * }
     */
    public static int ICON_ARROW_LEFT() {
        return ICON_ARROW_LEFT;
    }
    private static final int ICON_ARROW_RIGHT = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_RIGHT = 115
     * }
     */
    public static int ICON_ARROW_RIGHT() {
        return ICON_ARROW_RIGHT;
    }
    private static final int ICON_ARROW_DOWN = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_DOWN = 116
     * }
     */
    public static int ICON_ARROW_DOWN() {
        return ICON_ARROW_DOWN;
    }
    private static final int ICON_ARROW_UP = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_UP = 117
     * }
     */
    public static int ICON_ARROW_UP() {
        return ICON_ARROW_UP;
    }
    private static final int ICON_ARROW_LEFT_FILL = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_LEFT_FILL = 118
     * }
     */
    public static int ICON_ARROW_LEFT_FILL() {
        return ICON_ARROW_LEFT_FILL;
    }
    private static final int ICON_ARROW_RIGHT_FILL = (int)119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_RIGHT_FILL = 119
     * }
     */
    public static int ICON_ARROW_RIGHT_FILL() {
        return ICON_ARROW_RIGHT_FILL;
    }
    private static final int ICON_ARROW_DOWN_FILL = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_DOWN_FILL = 120
     * }
     */
    public static int ICON_ARROW_DOWN_FILL() {
        return ICON_ARROW_DOWN_FILL;
    }
    private static final int ICON_ARROW_UP_FILL = (int)121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ARROW_UP_FILL = 121
     * }
     */
    public static int ICON_ARROW_UP_FILL() {
        return ICON_ARROW_UP_FILL;
    }
    private static final int ICON_AUDIO = (int)122L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_AUDIO = 122
     * }
     */
    public static int ICON_AUDIO() {
        return ICON_AUDIO;
    }
    private static final int ICON_FX = (int)123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FX = 123
     * }
     */
    public static int ICON_FX() {
        return ICON_FX;
    }
    private static final int ICON_WAVE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WAVE = 124
     * }
     */
    public static int ICON_WAVE() {
        return ICON_WAVE;
    }
    private static final int ICON_WAVE_SINUS = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WAVE_SINUS = 125
     * }
     */
    public static int ICON_WAVE_SINUS() {
        return ICON_WAVE_SINUS;
    }
    private static final int ICON_WAVE_SQUARE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WAVE_SQUARE = 126
     * }
     */
    public static int ICON_WAVE_SQUARE() {
        return ICON_WAVE_SQUARE;
    }
    private static final int ICON_WAVE_TRIANGULAR = (int)127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WAVE_TRIANGULAR = 127
     * }
     */
    public static int ICON_WAVE_TRIANGULAR() {
        return ICON_WAVE_TRIANGULAR;
    }
    private static final int ICON_CROSS_SMALL = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CROSS_SMALL = 128
     * }
     */
    public static int ICON_CROSS_SMALL() {
        return ICON_CROSS_SMALL;
    }
    private static final int ICON_PLAYER_PREVIOUS = (int)129L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_PREVIOUS = 129
     * }
     */
    public static int ICON_PLAYER_PREVIOUS() {
        return ICON_PLAYER_PREVIOUS;
    }
    private static final int ICON_PLAYER_PLAY_BACK = (int)130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_PLAY_BACK = 130
     * }
     */
    public static int ICON_PLAYER_PLAY_BACK() {
        return ICON_PLAYER_PLAY_BACK;
    }
    private static final int ICON_PLAYER_PLAY = (int)131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_PLAY = 131
     * }
     */
    public static int ICON_PLAYER_PLAY() {
        return ICON_PLAYER_PLAY;
    }
    private static final int ICON_PLAYER_PAUSE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_PAUSE = 132
     * }
     */
    public static int ICON_PLAYER_PAUSE() {
        return ICON_PLAYER_PAUSE;
    }
    private static final int ICON_PLAYER_STOP = (int)133L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_STOP = 133
     * }
     */
    public static int ICON_PLAYER_STOP() {
        return ICON_PLAYER_STOP;
    }
    private static final int ICON_PLAYER_NEXT = (int)134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_NEXT = 134
     * }
     */
    public static int ICON_PLAYER_NEXT() {
        return ICON_PLAYER_NEXT;
    }
    private static final int ICON_PLAYER_RECORD = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_RECORD = 135
     * }
     */
    public static int ICON_PLAYER_RECORD() {
        return ICON_PLAYER_RECORD;
    }
    private static final int ICON_MAGNET = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MAGNET = 136
     * }
     */
    public static int ICON_MAGNET() {
        return ICON_MAGNET;
    }
    private static final int ICON_LOCK_CLOSE = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LOCK_CLOSE = 137
     * }
     */
    public static int ICON_LOCK_CLOSE() {
        return ICON_LOCK_CLOSE;
    }
    private static final int ICON_LOCK_OPEN = (int)138L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LOCK_OPEN = 138
     * }
     */
    public static int ICON_LOCK_OPEN() {
        return ICON_LOCK_OPEN;
    }
    private static final int ICON_CLOCK = (int)139L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CLOCK = 139
     * }
     */
    public static int ICON_CLOCK() {
        return ICON_CLOCK;
    }
    private static final int ICON_TOOLS = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TOOLS = 140
     * }
     */
    public static int ICON_TOOLS() {
        return ICON_TOOLS;
    }
    private static final int ICON_GEAR = (int)141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_GEAR = 141
     * }
     */
    public static int ICON_GEAR() {
        return ICON_GEAR;
    }
    private static final int ICON_GEAR_BIG = (int)142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_GEAR_BIG = 142
     * }
     */
    public static int ICON_GEAR_BIG() {
        return ICON_GEAR_BIG;
    }
    private static final int ICON_BIN = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BIN = 143
     * }
     */
    public static int ICON_BIN() {
        return ICON_BIN;
    }
    private static final int ICON_HAND_POINTER = (int)144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HAND_POINTER = 144
     * }
     */
    public static int ICON_HAND_POINTER() {
        return ICON_HAND_POINTER;
    }
    private static final int ICON_LASER = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LASER = 145
     * }
     */
    public static int ICON_LASER() {
        return ICON_LASER;
    }
    private static final int ICON_COIN = (int)146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_COIN = 146
     * }
     */
    public static int ICON_COIN() {
        return ICON_COIN;
    }
    private static final int ICON_EXPLOSION = (int)147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EXPLOSION = 147
     * }
     */
    public static int ICON_EXPLOSION() {
        return ICON_EXPLOSION;
    }
    private static final int ICON_1UP = (int)148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_1UP = 148
     * }
     */
    public static int ICON_1UP() {
        return ICON_1UP;
    }
    private static final int ICON_PLAYER = (int)149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER = 149
     * }
     */
    public static int ICON_PLAYER() {
        return ICON_PLAYER;
    }
    private static final int ICON_PLAYER_JUMP = (int)150L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PLAYER_JUMP = 150
     * }
     */
    public static int ICON_PLAYER_JUMP() {
        return ICON_PLAYER_JUMP;
    }
    private static final int ICON_KEY = (int)151L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_KEY = 151
     * }
     */
    public static int ICON_KEY() {
        return ICON_KEY;
    }
    private static final int ICON_DEMON = (int)152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_DEMON = 152
     * }
     */
    public static int ICON_DEMON() {
        return ICON_DEMON;
    }
    private static final int ICON_TEXT_POPUP = (int)153L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TEXT_POPUP = 153
     * }
     */
    public static int ICON_TEXT_POPUP() {
        return ICON_TEXT_POPUP;
    }
    private static final int ICON_GEAR_EX = (int)154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_GEAR_EX = 154
     * }
     */
    public static int ICON_GEAR_EX() {
        return ICON_GEAR_EX;
    }
    private static final int ICON_CRACK = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CRACK = 155
     * }
     */
    public static int ICON_CRACK() {
        return ICON_CRACK;
    }
    private static final int ICON_CRACK_POINTS = (int)156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CRACK_POINTS = 156
     * }
     */
    public static int ICON_CRACK_POINTS() {
        return ICON_CRACK_POINTS;
    }
    private static final int ICON_STAR = (int)157L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_STAR = 157
     * }
     */
    public static int ICON_STAR() {
        return ICON_STAR;
    }
    private static final int ICON_DOOR = (int)158L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_DOOR = 158
     * }
     */
    public static int ICON_DOOR() {
        return ICON_DOOR;
    }
    private static final int ICON_EXIT = (int)159L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_EXIT = 159
     * }
     */
    public static int ICON_EXIT() {
        return ICON_EXIT;
    }
    private static final int ICON_MODE_2D = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MODE_2D = 160
     * }
     */
    public static int ICON_MODE_2D() {
        return ICON_MODE_2D;
    }
    private static final int ICON_MODE_3D = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MODE_3D = 161
     * }
     */
    public static int ICON_MODE_3D() {
        return ICON_MODE_3D;
    }
    private static final int ICON_CUBE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE = 162
     * }
     */
    public static int ICON_CUBE() {
        return ICON_CUBE;
    }
    private static final int ICON_CUBE_FACE_TOP = (int)163L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_TOP = 163
     * }
     */
    public static int ICON_CUBE_FACE_TOP() {
        return ICON_CUBE_FACE_TOP;
    }
    private static final int ICON_CUBE_FACE_LEFT = (int)164L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_LEFT = 164
     * }
     */
    public static int ICON_CUBE_FACE_LEFT() {
        return ICON_CUBE_FACE_LEFT;
    }
    private static final int ICON_CUBE_FACE_FRONT = (int)165L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_FRONT = 165
     * }
     */
    public static int ICON_CUBE_FACE_FRONT() {
        return ICON_CUBE_FACE_FRONT;
    }
    private static final int ICON_CUBE_FACE_BOTTOM = (int)166L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_BOTTOM = 166
     * }
     */
    public static int ICON_CUBE_FACE_BOTTOM() {
        return ICON_CUBE_FACE_BOTTOM;
    }
    private static final int ICON_CUBE_FACE_RIGHT = (int)167L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_RIGHT = 167
     * }
     */
    public static int ICON_CUBE_FACE_RIGHT() {
        return ICON_CUBE_FACE_RIGHT;
    }
    private static final int ICON_CUBE_FACE_BACK = (int)168L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CUBE_FACE_BACK = 168
     * }
     */
    public static int ICON_CUBE_FACE_BACK() {
        return ICON_CUBE_FACE_BACK;
    }
    private static final int ICON_CAMERA = (int)169L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CAMERA = 169
     * }
     */
    public static int ICON_CAMERA() {
        return ICON_CAMERA;
    }
    private static final int ICON_SPECIAL = (int)170L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SPECIAL = 170
     * }
     */
    public static int ICON_SPECIAL() {
        return ICON_SPECIAL;
    }
    private static final int ICON_LINK_NET = (int)171L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LINK_NET = 171
     * }
     */
    public static int ICON_LINK_NET() {
        return ICON_LINK_NET;
    }
    private static final int ICON_LINK_BOXES = (int)172L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LINK_BOXES = 172
     * }
     */
    public static int ICON_LINK_BOXES() {
        return ICON_LINK_BOXES;
    }
    private static final int ICON_LINK_MULTI = (int)173L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LINK_MULTI = 173
     * }
     */
    public static int ICON_LINK_MULTI() {
        return ICON_LINK_MULTI;
    }
    private static final int ICON_LINK = (int)174L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LINK = 174
     * }
     */
    public static int ICON_LINK() {
        return ICON_LINK;
    }
    private static final int ICON_LINK_BROKE = (int)175L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LINK_BROKE = 175
     * }
     */
    public static int ICON_LINK_BROKE() {
        return ICON_LINK_BROKE;
    }
    private static final int ICON_TEXT_NOTES = (int)176L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_TEXT_NOTES = 176
     * }
     */
    public static int ICON_TEXT_NOTES() {
        return ICON_TEXT_NOTES;
    }
    private static final int ICON_NOTEBOOK = (int)177L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_NOTEBOOK = 177
     * }
     */
    public static int ICON_NOTEBOOK() {
        return ICON_NOTEBOOK;
    }
    private static final int ICON_SUITCASE = (int)178L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SUITCASE = 178
     * }
     */
    public static int ICON_SUITCASE() {
        return ICON_SUITCASE;
    }
    private static final int ICON_SUITCASE_ZIP = (int)179L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SUITCASE_ZIP = 179
     * }
     */
    public static int ICON_SUITCASE_ZIP() {
        return ICON_SUITCASE_ZIP;
    }
    private static final int ICON_MAILBOX = (int)180L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MAILBOX = 180
     * }
     */
    public static int ICON_MAILBOX() {
        return ICON_MAILBOX;
    }
    private static final int ICON_MONITOR = (int)181L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MONITOR = 181
     * }
     */
    public static int ICON_MONITOR() {
        return ICON_MONITOR;
    }
    private static final int ICON_PRINTER = (int)182L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PRINTER = 182
     * }
     */
    public static int ICON_PRINTER() {
        return ICON_PRINTER;
    }
    private static final int ICON_PHOTO_CAMERA = (int)183L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PHOTO_CAMERA = 183
     * }
     */
    public static int ICON_PHOTO_CAMERA() {
        return ICON_PHOTO_CAMERA;
    }
    private static final int ICON_PHOTO_CAMERA_FLASH = (int)184L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PHOTO_CAMERA_FLASH = 184
     * }
     */
    public static int ICON_PHOTO_CAMERA_FLASH() {
        return ICON_PHOTO_CAMERA_FLASH;
    }
    private static final int ICON_HOUSE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HOUSE = 185
     * }
     */
    public static int ICON_HOUSE() {
        return ICON_HOUSE;
    }
    private static final int ICON_HEART = (int)186L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HEART = 186
     * }
     */
    public static int ICON_HEART() {
        return ICON_HEART;
    }
    private static final int ICON_CORNER = (int)187L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CORNER = 187
     * }
     */
    public static int ICON_CORNER() {
        return ICON_CORNER;
    }
    private static final int ICON_VERTICAL_BARS = (int)188L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_VERTICAL_BARS = 188
     * }
     */
    public static int ICON_VERTICAL_BARS() {
        return ICON_VERTICAL_BARS;
    }
    private static final int ICON_VERTICAL_BARS_FILL = (int)189L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_VERTICAL_BARS_FILL = 189
     * }
     */
    public static int ICON_VERTICAL_BARS_FILL() {
        return ICON_VERTICAL_BARS_FILL;
    }
    private static final int ICON_LIFE_BARS = (int)190L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LIFE_BARS = 190
     * }
     */
    public static int ICON_LIFE_BARS() {
        return ICON_LIFE_BARS;
    }
    private static final int ICON_INFO = (int)191L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_INFO = 191
     * }
     */
    public static int ICON_INFO() {
        return ICON_INFO;
    }
    private static final int ICON_CROSSLINE = (int)192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CROSSLINE = 192
     * }
     */
    public static int ICON_CROSSLINE() {
        return ICON_CROSSLINE;
    }
    private static final int ICON_HELP = (int)193L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HELP = 193
     * }
     */
    public static int ICON_HELP() {
        return ICON_HELP;
    }
    private static final int ICON_FILETYPE_ALPHA = (int)194L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_ALPHA = 194
     * }
     */
    public static int ICON_FILETYPE_ALPHA() {
        return ICON_FILETYPE_ALPHA;
    }
    private static final int ICON_FILETYPE_HOME = (int)195L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_HOME = 195
     * }
     */
    public static int ICON_FILETYPE_HOME() {
        return ICON_FILETYPE_HOME;
    }
    private static final int ICON_LAYERS_VISIBLE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LAYERS_VISIBLE = 196
     * }
     */
    public static int ICON_LAYERS_VISIBLE() {
        return ICON_LAYERS_VISIBLE;
    }
    private static final int ICON_LAYERS = (int)197L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LAYERS = 197
     * }
     */
    public static int ICON_LAYERS() {
        return ICON_LAYERS;
    }
    private static final int ICON_WINDOW = (int)198L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WINDOW = 198
     * }
     */
    public static int ICON_WINDOW() {
        return ICON_WINDOW;
    }
    private static final int ICON_HIDPI = (int)199L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HIDPI = 199
     * }
     */
    public static int ICON_HIDPI() {
        return ICON_HIDPI;
    }
    private static final int ICON_FILETYPE_BINARY = (int)200L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILETYPE_BINARY = 200
     * }
     */
    public static int ICON_FILETYPE_BINARY() {
        return ICON_FILETYPE_BINARY;
    }
    private static final int ICON_HEX = (int)201L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HEX = 201
     * }
     */
    public static int ICON_HEX() {
        return ICON_HEX;
    }
    private static final int ICON_SHIELD = (int)202L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SHIELD = 202
     * }
     */
    public static int ICON_SHIELD() {
        return ICON_SHIELD;
    }
    private static final int ICON_FILE_NEW = (int)203L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE_NEW = 203
     * }
     */
    public static int ICON_FILE_NEW() {
        return ICON_FILE_NEW;
    }
    private static final int ICON_FOLDER_ADD = (int)204L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOLDER_ADD = 204
     * }
     */
    public static int ICON_FOLDER_ADD() {
        return ICON_FOLDER_ADD;
    }
    private static final int ICON_ALARM = (int)205L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ALARM = 205
     * }
     */
    public static int ICON_ALARM() {
        return ICON_ALARM;
    }
    private static final int ICON_CPU = (int)206L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CPU = 206
     * }
     */
    public static int ICON_CPU() {
        return ICON_CPU;
    }
    private static final int ICON_ROM = (int)207L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_ROM = 207
     * }
     */
    public static int ICON_ROM() {
        return ICON_ROM;
    }
    private static final int ICON_STEP_OVER = (int)208L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_STEP_OVER = 208
     * }
     */
    public static int ICON_STEP_OVER() {
        return ICON_STEP_OVER;
    }
    private static final int ICON_STEP_INTO = (int)209L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_STEP_INTO = 209
     * }
     */
    public static int ICON_STEP_INTO() {
        return ICON_STEP_INTO;
    }
    private static final int ICON_STEP_OUT = (int)210L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_STEP_OUT = 210
     * }
     */
    public static int ICON_STEP_OUT() {
        return ICON_STEP_OUT;
    }
    private static final int ICON_RESTART = (int)211L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_RESTART = 211
     * }
     */
    public static int ICON_RESTART() {
        return ICON_RESTART;
    }
    private static final int ICON_BREAKPOINT_ON = (int)212L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BREAKPOINT_ON = 212
     * }
     */
    public static int ICON_BREAKPOINT_ON() {
        return ICON_BREAKPOINT_ON;
    }
    private static final int ICON_BREAKPOINT_OFF = (int)213L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BREAKPOINT_OFF = 213
     * }
     */
    public static int ICON_BREAKPOINT_OFF() {
        return ICON_BREAKPOINT_OFF;
    }
    private static final int ICON_BURGER_MENU = (int)214L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_BURGER_MENU = 214
     * }
     */
    public static int ICON_BURGER_MENU() {
        return ICON_BURGER_MENU;
    }
    private static final int ICON_CASE_SENSITIVE = (int)215L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_CASE_SENSITIVE = 215
     * }
     */
    public static int ICON_CASE_SENSITIVE() {
        return ICON_CASE_SENSITIVE;
    }
    private static final int ICON_REG_EXP = (int)216L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_REG_EXP = 216
     * }
     */
    public static int ICON_REG_EXP() {
        return ICON_REG_EXP;
    }
    private static final int ICON_FOLDER = (int)217L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FOLDER = 217
     * }
     */
    public static int ICON_FOLDER() {
        return ICON_FOLDER;
    }
    private static final int ICON_FILE = (int)218L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_FILE = 218
     * }
     */
    public static int ICON_FILE() {
        return ICON_FILE;
    }
    private static final int ICON_SAND_TIMER = (int)219L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_SAND_TIMER = 219
     * }
     */
    public static int ICON_SAND_TIMER() {
        return ICON_SAND_TIMER;
    }
    private static final int ICON_WARNING = (int)220L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_WARNING = 220
     * }
     */
    public static int ICON_WARNING() {
        return ICON_WARNING;
    }
    private static final int ICON_HELP_BOX = (int)221L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_HELP_BOX = 221
     * }
     */
    public static int ICON_HELP_BOX() {
        return ICON_HELP_BOX;
    }
    private static final int ICON_INFO_BOX = (int)222L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_INFO_BOX = 222
     * }
     */
    public static int ICON_INFO_BOX() {
        return ICON_INFO_BOX;
    }
    private static final int ICON_PRIORITY = (int)223L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_PRIORITY = 223
     * }
     */
    public static int ICON_PRIORITY() {
        return ICON_PRIORITY;
    }
    private static final int ICON_LAYERS_ISO = (int)224L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LAYERS_ISO = 224
     * }
     */
    public static int ICON_LAYERS_ISO() {
        return ICON_LAYERS_ISO;
    }
    private static final int ICON_LAYERS2 = (int)225L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_LAYERS2 = 225
     * }
     */
    public static int ICON_LAYERS2() {
        return ICON_LAYERS2;
    }
    private static final int ICON_MLAYERS = (int)226L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MLAYERS = 226
     * }
     */
    public static int ICON_MLAYERS() {
        return ICON_MLAYERS;
    }
    private static final int ICON_MAPS = (int)227L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_MAPS = 227
     * }
     */
    public static int ICON_MAPS() {
        return ICON_MAPS;
    }
    private static final int ICON_228 = (int)228L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_228 = 228
     * }
     */
    public static int ICON_228() {
        return ICON_228;
    }
    private static final int ICON_229 = (int)229L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_229 = 229
     * }
     */
    public static int ICON_229() {
        return ICON_229;
    }
    private static final int ICON_230 = (int)230L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_230 = 230
     * }
     */
    public static int ICON_230() {
        return ICON_230;
    }
    private static final int ICON_231 = (int)231L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_231 = 231
     * }
     */
    public static int ICON_231() {
        return ICON_231;
    }
    private static final int ICON_232 = (int)232L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_232 = 232
     * }
     */
    public static int ICON_232() {
        return ICON_232;
    }
    private static final int ICON_233 = (int)233L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_233 = 233
     * }
     */
    public static int ICON_233() {
        return ICON_233;
    }
    private static final int ICON_234 = (int)234L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_234 = 234
     * }
     */
    public static int ICON_234() {
        return ICON_234;
    }
    private static final int ICON_235 = (int)235L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_235 = 235
     * }
     */
    public static int ICON_235() {
        return ICON_235;
    }
    private static final int ICON_236 = (int)236L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_236 = 236
     * }
     */
    public static int ICON_236() {
        return ICON_236;
    }
    private static final int ICON_237 = (int)237L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_237 = 237
     * }
     */
    public static int ICON_237() {
        return ICON_237;
    }
    private static final int ICON_238 = (int)238L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_238 = 238
     * }
     */
    public static int ICON_238() {
        return ICON_238;
    }
    private static final int ICON_239 = (int)239L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_239 = 239
     * }
     */
    public static int ICON_239() {
        return ICON_239;
    }
    private static final int ICON_240 = (int)240L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_240 = 240
     * }
     */
    public static int ICON_240() {
        return ICON_240;
    }
    private static final int ICON_241 = (int)241L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_241 = 241
     * }
     */
    public static int ICON_241() {
        return ICON_241;
    }
    private static final int ICON_242 = (int)242L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_242 = 242
     * }
     */
    public static int ICON_242() {
        return ICON_242;
    }
    private static final int ICON_243 = (int)243L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_243 = 243
     * }
     */
    public static int ICON_243() {
        return ICON_243;
    }
    private static final int ICON_244 = (int)244L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_244 = 244
     * }
     */
    public static int ICON_244() {
        return ICON_244;
    }
    private static final int ICON_245 = (int)245L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_245 = 245
     * }
     */
    public static int ICON_245() {
        return ICON_245;
    }
    private static final int ICON_246 = (int)246L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_246 = 246
     * }
     */
    public static int ICON_246() {
        return ICON_246;
    }
    private static final int ICON_247 = (int)247L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_247 = 247
     * }
     */
    public static int ICON_247() {
        return ICON_247;
    }
    private static final int ICON_248 = (int)248L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_248 = 248
     * }
     */
    public static int ICON_248() {
        return ICON_248;
    }
    private static final int ICON_249 = (int)249L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_249 = 249
     * }
     */
    public static int ICON_249() {
        return ICON_249;
    }
    private static final int ICON_250 = (int)250L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_250 = 250
     * }
     */
    public static int ICON_250() {
        return ICON_250;
    }
    private static final int ICON_251 = (int)251L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_251 = 251
     * }
     */
    public static int ICON_251() {
        return ICON_251;
    }
    private static final int ICON_252 = (int)252L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_252 = 252
     * }
     */
    public static int ICON_252() {
        return ICON_252;
    }
    private static final int ICON_253 = (int)253L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_253 = 253
     * }
     */
    public static int ICON_253() {
        return ICON_253;
    }
    private static final int ICON_254 = (int)254L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_254 = 254
     * }
     */
    public static int ICON_254() {
        return ICON_254;
    }
    private static final int ICON_255 = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ICON_255 = 255
     * }
     */
    public static int ICON_255() {
        return ICON_255;
    }
    private static final int BORDER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BORDER = 0
     * }
     */
    public static int BORDER() {
        return BORDER;
    }
    private static final int BASE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE = 1
     * }
     */
    public static int BASE() {
        return BASE;
    }
    private static final int TEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXT = 2
     * }
     */
    public static int TEXT() {
        return TEXT;
    }
    private static final int OTHER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTHER = 3
     * }
     */
    public static int OTHER() {
        return OTHER;
    }

    private static class GuiSliderPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Rectangle.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GuiSliderPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GuiSliderPro(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue, int sliderWidth)
     * }
     */
    public static FunctionDescriptor GuiSliderPro$descriptor() {
        return GuiSliderPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GuiSliderPro(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue, int sliderWidth)
     * }
     */
    public static MethodHandle GuiSliderPro$handle() {
        return GuiSliderPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GuiSliderPro(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue, int sliderWidth)
     * }
     */
    public static MemorySegment GuiSliderPro$address() {
        return GuiSliderPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GuiSliderPro(Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue, int sliderWidth)
     * }
     */
    public static int GuiSliderPro(MemorySegment bounds, MemorySegment textLeft, MemorySegment textRight, MemorySegment value, float minValue, float maxValue, int sliderWidth) {
        var mh$ = GuiSliderPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GuiSliderPro", bounds, textLeft, textRight, value, minValue, maxValue, sliderWidth);
            }
            return (int)mh$.invokeExact(bounds, textLeft, textRight, value, minValue, maxValue, sliderWidth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTextLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char **GetTextLines(const char *text, int *count)
     * }
     */
    public static FunctionDescriptor GetTextLines$descriptor() {
        return GetTextLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char **GetTextLines(const char *text, int *count)
     * }
     */
    public static MethodHandle GetTextLines$handle() {
        return GetTextLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char **GetTextLines(const char *text, int *count)
     * }
     */
    public static MemorySegment GetTextLines$address() {
        return GetTextLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char **GetTextLines(const char *text, int *count)
     * }
     */
    public static MemorySegment GetTextLines(MemorySegment text, MemorySegment count) {
        var mh$ = GetTextLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextLines", text, count);
            }
            return (MemorySegment)mh$.invokeExact(text, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define RAYLIB_VERSION "5.1-dev"
     * }
     */
    public static MemorySegment RAYLIB_VERSION() {
        class Holder {
            static final MemorySegment RAYLIB_VERSION
                = raylib.LIBRARY_ARENA.allocateFrom("5.1-dev");
        }
        return Holder.RAYLIB_VERSION;
    }
    private static final float PI = 3.1415927410125732f;
    /**
     * {@snippet lang=c :
     * #define PI 3.1415927410125732
     * }
     */
    public static float PI() {
        return PI;
    }
    private static final float DEG2RAD = 0.01745329238474369f;
    /**
     * {@snippet lang=c :
     * #define DEG2RAD 0.01745329238474369
     * }
     */
    public static float DEG2RAD() {
        return DEG2RAD;
    }
    private static final float RAD2DEG = 57.2957763671875f;
    /**
     * {@snippet lang=c :
     * #define RAD2DEG 57.2957763671875
     * }
     */
    public static float RAD2DEG() {
        return RAD2DEG;
    }
    private static final int MOUSE_LEFT_BUTTON = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_LEFT_BUTTON 0
     * }
     */
    public static int MOUSE_LEFT_BUTTON() {
        return MOUSE_LEFT_BUTTON;
    }
    private static final int MOUSE_RIGHT_BUTTON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_RIGHT_BUTTON 1
     * }
     */
    public static int MOUSE_RIGHT_BUTTON() {
        return MOUSE_RIGHT_BUTTON;
    }
    private static final int MOUSE_MIDDLE_BUTTON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_MIDDLE_BUTTON 2
     * }
     */
    public static int MOUSE_MIDDLE_BUTTON() {
        return MOUSE_MIDDLE_BUTTON;
    }
    private static final int MATERIAL_MAP_DIFFUSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MATERIAL_MAP_DIFFUSE 0
     * }
     */
    public static int MATERIAL_MAP_DIFFUSE() {
        return MATERIAL_MAP_DIFFUSE;
    }
    private static final int MATERIAL_MAP_SPECULAR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATERIAL_MAP_SPECULAR 1
     * }
     */
    public static int MATERIAL_MAP_SPECULAR() {
        return MATERIAL_MAP_SPECULAR;
    }
    private static final int SHADER_LOC_MAP_DIFFUSE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SHADER_LOC_MAP_DIFFUSE 15
     * }
     */
    public static int SHADER_LOC_MAP_DIFFUSE() {
        return SHADER_LOC_MAP_DIFFUSE;
    }
    private static final int SHADER_LOC_MAP_SPECULAR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SHADER_LOC_MAP_SPECULAR 16
     * }
     */
    public static int SHADER_LOC_MAP_SPECULAR() {
        return SHADER_LOC_MAP_SPECULAR;
    }
    /**
     * {@snippet lang=c :
     * #define RLGL_VERSION "5.0"
     * }
     */
    public static MemorySegment RLGL_VERSION() {
        class Holder {
            static final MemorySegment RLGL_VERSION
                = raylib.LIBRARY_ARENA.allocateFrom("5.0");
        }
        return Holder.RLGL_VERSION;
    }
    private static final double RL_CULL_DISTANCE_NEAR = 0.01d;
    /**
     * {@snippet lang=c :
     * #define RL_CULL_DISTANCE_NEAR 0.01
     * }
     */
    public static double RL_CULL_DISTANCE_NEAR() {
        return RL_CULL_DISTANCE_NEAR;
    }
    private static final double RL_CULL_DISTANCE_FAR = 1000.0d;
    /**
     * {@snippet lang=c :
     * #define RL_CULL_DISTANCE_FAR 1000.0
     * }
     */
    public static double RL_CULL_DISTANCE_FAR() {
        return RL_CULL_DISTANCE_FAR;
    }
    private static final int RL_SHADER_LOC_MAP_DIFFUSE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define RL_SHADER_LOC_MAP_DIFFUSE 15
     * }
     */
    public static int RL_SHADER_LOC_MAP_DIFFUSE() {
        return RL_SHADER_LOC_MAP_DIFFUSE;
    }
    private static final int RL_SHADER_LOC_MAP_SPECULAR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RL_SHADER_LOC_MAP_SPECULAR 16
     * }
     */
    public static int RL_SHADER_LOC_MAP_SPECULAR() {
        return RL_SHADER_LOC_MAP_SPECULAR;
    }
    private static final float EPSILON = 9.999999974752427E-7f;
    /**
     * {@snippet lang=c :
     * #define EPSILON 9.999999974752427E-7
     * }
     */
    public static float EPSILON() {
        return EPSILON;
    }
    /**
     * {@snippet lang=c :
     * #define RAYGUI_VERSION "4.5-dev"
     * }
     */
    public static MemorySegment RAYGUI_VERSION() {
        class Holder {
            static final MemorySegment RAYGUI_VERSION
                = raylib.LIBRARY_ARENA.allocateFrom("4.5-dev");
        }
        return Holder.RAYGUI_VERSION;
    }
    private static final int RAYGUI_ICON_DATA_ELEMENTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_ICON_DATA_ELEMENTS 8
     * }
     */
    public static int RAYGUI_ICON_DATA_ELEMENTS() {
        return RAYGUI_ICON_DATA_ELEMENTS;
    }
    private static final float RAYGUI_GRID_ALPHA = 0.15000000596046448f;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_GRID_ALPHA 0.15000000596046448
     * }
     */
    public static float RAYGUI_GRID_ALPHA() {
        return RAYGUI_GRID_ALPHA;
    }
}

