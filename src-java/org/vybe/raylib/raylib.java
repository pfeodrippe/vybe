// Generated by jextract

package org.vybe.raylib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class raylib extends raylib_1 {

    raylib() {
        // Should not be called directly
    }

    private static class LoadImagePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Image.layout(),
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImagePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static FunctionDescriptor LoadImagePalette$descriptor() {
        return LoadImagePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MethodHandle LoadImagePalette$handle() {
        return LoadImagePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MemorySegment LoadImagePalette$address() {
        return LoadImagePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MemorySegment LoadImagePalette(MemorySegment image, int maxPaletteSize, MemorySegment colorCount) {
        var mh$ = LoadImagePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImagePalette", image, maxPaletteSize, colorCount);
            }
            return (MemorySegment)mh$.invokeExact(image, maxPaletteSize, colorCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadImageColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadImageColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static FunctionDescriptor UnloadImageColors$descriptor() {
        return UnloadImageColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static MethodHandle UnloadImageColors$handle() {
        return UnloadImageColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static MemorySegment UnloadImageColors$address() {
        return UnloadImageColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static void UnloadImageColors(MemorySegment colors) {
        var mh$ = UnloadImageColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadImageColors", colors);
            }
            mh$.invokeExact(colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadImagePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadImagePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static FunctionDescriptor UnloadImagePalette$descriptor() {
        return UnloadImagePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static MethodHandle UnloadImagePalette$handle() {
        return UnloadImagePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static MemorySegment UnloadImagePalette$address() {
        return UnloadImagePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static void UnloadImagePalette(MemorySegment colors) {
        var mh$ = UnloadImagePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadImagePalette", colors);
            }
            mh$.invokeExact(colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageAlphaBorder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout(),
            Image.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetImageAlphaBorder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static FunctionDescriptor GetImageAlphaBorder$descriptor() {
        return GetImageAlphaBorder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MethodHandle GetImageAlphaBorder$handle() {
        return GetImageAlphaBorder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MemorySegment GetImageAlphaBorder$address() {
        return GetImageAlphaBorder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MemorySegment GetImageAlphaBorder(SegmentAllocator allocator, MemorySegment image, float threshold) {
        var mh$ = GetImageAlphaBorder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageAlphaBorder", allocator, image, threshold);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetImageColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static FunctionDescriptor GetImageColor$descriptor() {
        return GetImageColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MethodHandle GetImageColor$handle() {
        return GetImageColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MemorySegment GetImageColor$address() {
        return GetImageColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MemorySegment GetImageColor(SegmentAllocator allocator, MemorySegment image, int x, int y) {
        var mh$ = GetImageColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageColor", allocator, image, x, y);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageClearBackground {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageClearBackground");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static FunctionDescriptor ImageClearBackground$descriptor() {
        return ImageClearBackground.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static MethodHandle ImageClearBackground$handle() {
        return ImageClearBackground.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static MemorySegment ImageClearBackground$address() {
        return ImageClearBackground.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static void ImageClearBackground(MemorySegment dst, MemorySegment color) {
        var mh$ = ImageClearBackground.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageClearBackground", dst, color);
            }
            mh$.invokeExact(dst, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawPixel$descriptor() {
        return ImageDrawPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static MethodHandle ImageDrawPixel$handle() {
        return ImageDrawPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static MemorySegment ImageDrawPixel$address() {
        return ImageDrawPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static void ImageDrawPixel(MemorySegment dst, int posX, int posY, MemorySegment color) {
        var mh$ = ImageDrawPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawPixel", dst, posX, posY, color);
            }
            mh$.invokeExact(dst, posX, posY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawPixelV$descriptor() {
        return ImageDrawPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static MethodHandle ImageDrawPixelV$handle() {
        return ImageDrawPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static MemorySegment ImageDrawPixelV$address() {
        return ImageDrawPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static void ImageDrawPixelV(MemorySegment dst, MemorySegment position, MemorySegment color) {
        var mh$ = ImageDrawPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawPixelV", dst, position, color);
            }
            mh$.invokeExact(dst, position, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawLine$descriptor() {
        return ImageDrawLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MethodHandle ImageDrawLine$handle() {
        return ImageDrawLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MemorySegment ImageDrawLine$address() {
        return ImageDrawLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static void ImageDrawLine(MemorySegment dst, int startPosX, int startPosY, int endPosX, int endPosY, MemorySegment color) {
        var mh$ = ImageDrawLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawLine", dst, startPosX, startPosY, endPosX, endPosY, color);
            }
            mh$.invokeExact(dst, startPosX, startPosY, endPosX, endPosY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawLineV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawLineV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawLineV$descriptor() {
        return ImageDrawLineV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static MethodHandle ImageDrawLineV$handle() {
        return ImageDrawLineV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static MemorySegment ImageDrawLineV$address() {
        return ImageDrawLineV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static void ImageDrawLineV(MemorySegment dst, MemorySegment start, MemorySegment end, MemorySegment color) {
        var mh$ = ImageDrawLineV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawLineV", dst, start, end, color);
            }
            mh$.invokeExact(dst, start, end, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircle$descriptor() {
        return ImageDrawCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircle$handle() {
        return ImageDrawCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircle$address() {
        return ImageDrawCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static void ImageDrawCircle(MemorySegment dst, int centerX, int centerY, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircle", dst, centerX, centerY, radius, color);
            }
            mh$.invokeExact(dst, centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleV$descriptor() {
        return ImageDrawCircleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleV$handle() {
        return ImageDrawCircleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleV$address() {
        return ImageDrawCircleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleV(MemorySegment dst, MemorySegment center, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleV", dst, center, radius, color);
            }
            mh$.invokeExact(dst, center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleLines$descriptor() {
        return ImageDrawCircleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleLines$handle() {
        return ImageDrawCircleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleLines$address() {
        return ImageDrawCircleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleLines(MemorySegment dst, int centerX, int centerY, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleLines", dst, centerX, centerY, radius, color);
            }
            mh$.invokeExact(dst, centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleLinesV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleLinesV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleLinesV$descriptor() {
        return ImageDrawCircleLinesV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleLinesV$handle() {
        return ImageDrawCircleLinesV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleLinesV$address() {
        return ImageDrawCircleLinesV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleLinesV(MemorySegment dst, MemorySegment center, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleLinesV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleLinesV", dst, center, radius, color);
            }
            mh$.invokeExact(dst, center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangle$descriptor() {
        return ImageDrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangle$handle() {
        return ImageDrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangle$address() {
        return ImageDrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static void ImageDrawRectangle(MemorySegment dst, int posX, int posY, int width, int height, MemorySegment color) {
        var mh$ = ImageDrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangle", dst, posX, posY, width, height, color);
            }
            mh$.invokeExact(dst, posX, posY, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleV$descriptor() {
        return ImageDrawRectangleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleV$handle() {
        return ImageDrawRectangleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleV$address() {
        return ImageDrawRectangleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static void ImageDrawRectangleV(MemorySegment dst, MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = ImageDrawRectangleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleV", dst, position, size, color);
            }
            mh$.invokeExact(dst, position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Rectangle.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleRec$descriptor() {
        return ImageDrawRectangleRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleRec$handle() {
        return ImageDrawRectangleRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleRec$address() {
        return ImageDrawRectangleRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static void ImageDrawRectangleRec(MemorySegment dst, MemorySegment rec, MemorySegment color) {
        var mh$ = ImageDrawRectangleRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleRec", dst, rec, color);
            }
            mh$.invokeExact(dst, rec, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Rectangle.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleLines$descriptor() {
        return ImageDrawRectangleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleLines$handle() {
        return ImageDrawRectangleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleLines$address() {
        return ImageDrawRectangleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static void ImageDrawRectangleLines(MemorySegment dst, MemorySegment rec, int thick, MemorySegment color) {
        var mh$ = ImageDrawRectangleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleLines", dst, rec, thick, color);
            }
            mh$.invokeExact(dst, rec, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Image.layout(),
            Rectangle.layout(),
            Rectangle.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static FunctionDescriptor ImageDraw$descriptor() {
        return ImageDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static MethodHandle ImageDraw$handle() {
        return ImageDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static MemorySegment ImageDraw$address() {
        return ImageDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static void ImageDraw(MemorySegment dst, MemorySegment src, MemorySegment srcRec, MemorySegment dstRec, MemorySegment tint) {
        var mh$ = ImageDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDraw", dst, src, srcRec, dstRec, tint);
            }
            mh$.invokeExact(dst, src, srcRec, dstRec, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawText$descriptor() {
        return ImageDrawText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MethodHandle ImageDrawText$handle() {
        return ImageDrawText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MemorySegment ImageDrawText$address() {
        return ImageDrawText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static void ImageDrawText(MemorySegment dst, MemorySegment text, int posX, int posY, int fontSize, MemorySegment color) {
        var mh$ = ImageDrawText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawText", dst, text, posX, posY, fontSize, color);
            }
            mh$.invokeExact(dst, text, posX, posY, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor ImageDrawTextEx$descriptor() {
        return ImageDrawTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle ImageDrawTextEx$handle() {
        return ImageDrawTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment ImageDrawTextEx$address() {
        return ImageDrawTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void ImageDrawTextEx(MemorySegment dst, MemorySegment font, MemorySegment text, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = ImageDrawTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawTextEx", dst, font, text, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(dst, font, text, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadTexture$descriptor() {
        return LoadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MethodHandle LoadTexture$handle() {
        return LoadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MemorySegment LoadTexture$address() {
        return LoadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MemorySegment LoadTexture(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTexture", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTextureFromImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTextureFromImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static FunctionDescriptor LoadTextureFromImage$descriptor() {
        return LoadTextureFromImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MethodHandle LoadTextureFromImage$handle() {
        return LoadTextureFromImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MemorySegment LoadTextureFromImage$address() {
        return LoadTextureFromImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MemorySegment LoadTextureFromImage(SegmentAllocator allocator, MemorySegment image) {
        var mh$ = LoadTextureFromImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTextureFromImage", allocator, image);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            Image.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static FunctionDescriptor LoadTextureCubemap$descriptor() {
        return LoadTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MethodHandle LoadTextureCubemap$handle() {
        return LoadTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MemorySegment LoadTextureCubemap$address() {
        return LoadTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MemorySegment LoadTextureCubemap(SegmentAllocator allocator, MemorySegment image, int layout) {
        var mh$ = LoadTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTextureCubemap", allocator, image, layout);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadRenderTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RenderTexture.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadRenderTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static FunctionDescriptor LoadRenderTexture$descriptor() {
        return LoadRenderTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MethodHandle LoadRenderTexture$handle() {
        return LoadRenderTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MemorySegment LoadRenderTexture$address() {
        return LoadRenderTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MemorySegment LoadRenderTexture(SegmentAllocator allocator, int width, int height) {
        var mh$ = LoadRenderTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadRenderTexture", allocator, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTextureReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsTextureReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static FunctionDescriptor IsTextureReady$descriptor() {
        return IsTextureReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static MethodHandle IsTextureReady$handle() {
        return IsTextureReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static MemorySegment IsTextureReady$address() {
        return IsTextureReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static boolean IsTextureReady(MemorySegment texture) {
        var mh$ = IsTextureReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTextureReady", texture);
            }
            return (boolean)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static FunctionDescriptor UnloadTexture$descriptor() {
        return UnloadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static MethodHandle UnloadTexture$handle() {
        return UnloadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static MemorySegment UnloadTexture$address() {
        return UnloadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static void UnloadTexture(MemorySegment texture) {
        var mh$ = UnloadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsRenderTextureReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            RenderTexture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsRenderTextureReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static FunctionDescriptor IsRenderTextureReady$descriptor() {
        return IsRenderTextureReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static MethodHandle IsRenderTextureReady$handle() {
        return IsRenderTextureReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static MemorySegment IsRenderTextureReady$address() {
        return IsRenderTextureReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static boolean IsRenderTextureReady(MemorySegment target) {
        var mh$ = IsRenderTextureReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsRenderTextureReady", target);
            }
            return (boolean)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadRenderTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RenderTexture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadRenderTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static FunctionDescriptor UnloadRenderTexture$descriptor() {
        return UnloadRenderTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static MethodHandle UnloadRenderTexture$handle() {
        return UnloadRenderTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static MemorySegment UnloadRenderTexture$address() {
        return UnloadRenderTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static void UnloadRenderTexture(MemorySegment target) {
        var mh$ = UnloadRenderTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadRenderTexture", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static FunctionDescriptor UpdateTexture$descriptor() {
        return UpdateTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static MethodHandle UpdateTexture$handle() {
        return UpdateTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static MemorySegment UpdateTexture$address() {
        return UpdateTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static void UpdateTexture(MemorySegment texture, MemorySegment pixels) {
        var mh$ = UpdateTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateTexture", texture, pixels);
            }
            mh$.invokeExact(texture, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateTextureRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateTextureRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static FunctionDescriptor UpdateTextureRec$descriptor() {
        return UpdateTextureRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static MethodHandle UpdateTextureRec$handle() {
        return UpdateTextureRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static MemorySegment UpdateTextureRec$address() {
        return UpdateTextureRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static void UpdateTextureRec(MemorySegment texture, MemorySegment rec, MemorySegment pixels) {
        var mh$ = UpdateTextureRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateTextureRec", texture, rec, pixels);
            }
            mh$.invokeExact(texture, rec, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenTextureMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenTextureMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static FunctionDescriptor GenTextureMipmaps$descriptor() {
        return GenTextureMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static MethodHandle GenTextureMipmaps$handle() {
        return GenTextureMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static MemorySegment GenTextureMipmaps$address() {
        return GenTextureMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static void GenTextureMipmaps(MemorySegment texture) {
        var mh$ = GenTextureMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenTextureMipmaps", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextureFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextureFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static FunctionDescriptor SetTextureFilter$descriptor() {
        return SetTextureFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MethodHandle SetTextureFilter$handle() {
        return SetTextureFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MemorySegment SetTextureFilter$address() {
        return SetTextureFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static void SetTextureFilter(MemorySegment texture, int filter) {
        var mh$ = SetTextureFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextureFilter", texture, filter);
            }
            mh$.invokeExact(texture, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextureWrap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextureWrap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static FunctionDescriptor SetTextureWrap$descriptor() {
        return SetTextureWrap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static MethodHandle SetTextureWrap$handle() {
        return SetTextureWrap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static MemorySegment SetTextureWrap$address() {
        return SetTextureWrap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static void SetTextureWrap(MemorySegment texture, int wrap) {
        var mh$ = SetTextureWrap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextureWrap", texture, wrap);
            }
            mh$.invokeExact(texture, wrap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexture$descriptor() {
        return DrawTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MethodHandle DrawTexture$handle() {
        return DrawTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MemorySegment DrawTexture$address() {
        return DrawTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static void DrawTexture(MemorySegment texture, int posX, int posY, MemorySegment tint) {
        var mh$ = DrawTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexture", texture, posX, posY, tint);
            }
            mh$.invokeExact(texture, posX, posY, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureV$descriptor() {
        return DrawTextureV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static MethodHandle DrawTextureV$handle() {
        return DrawTextureV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static MemorySegment DrawTextureV$address() {
        return DrawTextureV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static void DrawTextureV(MemorySegment texture, MemorySegment position, MemorySegment tint) {
        var mh$ = DrawTextureV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureV", texture, position, tint);
            }
            mh$.invokeExact(texture, position, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureEx$descriptor() {
        return DrawTextureEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawTextureEx$handle() {
        return DrawTextureEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawTextureEx$address() {
        return DrawTextureEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static void DrawTextureEx(MemorySegment texture, MemorySegment position, float rotation, float scale, MemorySegment tint) {
        var mh$ = DrawTextureEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureEx", texture, position, rotation, scale, tint);
            }
            mh$.invokeExact(texture, position, rotation, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureRec$descriptor() {
        return DrawTextureRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static MethodHandle DrawTextureRec$handle() {
        return DrawTextureRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static MemorySegment DrawTextureRec$address() {
        return DrawTextureRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static void DrawTextureRec(MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment tint) {
        var mh$ = DrawTextureRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureRec", texture, source, position, tint);
            }
            mh$.invokeExact(texture, source, position, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexturePro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTexturePro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexturePro$descriptor() {
        return DrawTexturePro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawTexturePro$handle() {
        return DrawTexturePro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawTexturePro$address() {
        return DrawTexturePro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawTexturePro(MemorySegment texture, MemorySegment source, MemorySegment dest, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawTexturePro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexturePro", texture, source, dest, origin, rotation, tint);
            }
            mh$.invokeExact(texture, source, dest, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureNPatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            NPatchInfo.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureNPatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureNPatch$descriptor() {
        return DrawTextureNPatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawTextureNPatch$handle() {
        return DrawTextureNPatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawTextureNPatch$address() {
        return DrawTextureNPatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawTextureNPatch(MemorySegment texture, MemorySegment nPatchInfo, MemorySegment dest, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawTextureNPatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureNPatch", texture, nPatchInfo, dest, origin, rotation, tint);
            }
            mh$.invokeExact(texture, nPatchInfo, dest, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorIsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorIsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static FunctionDescriptor ColorIsEqual$descriptor() {
        return ColorIsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static MethodHandle ColorIsEqual$handle() {
        return ColorIsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static MemorySegment ColorIsEqual$address() {
        return ColorIsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static boolean ColorIsEqual(MemorySegment col1, MemorySegment col2) {
        var mh$ = ColorIsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorIsEqual", col1, col2);
            }
            return (boolean)mh$.invokeExact(col1, col2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Fade {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Fade");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static FunctionDescriptor Fade$descriptor() {
        return Fade.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MethodHandle Fade$handle() {
        return Fade.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MemorySegment Fade$address() {
        return Fade.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MemorySegment Fade(SegmentAllocator allocator, MemorySegment color, float alpha) {
        var mh$ = Fade.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Fade", allocator, color, alpha);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static FunctionDescriptor ColorToInt$descriptor() {
        return ColorToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static MethodHandle ColorToInt$handle() {
        return ColorToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static MemorySegment ColorToInt$address() {
        return ColorToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static int ColorToInt(MemorySegment color) {
        var mh$ = ColorToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorToInt", color);
            }
            return (int)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static FunctionDescriptor ColorNormalize$descriptor() {
        return ColorNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MethodHandle ColorNormalize$handle() {
        return ColorNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MemorySegment ColorNormalize$address() {
        return ColorNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MemorySegment ColorNormalize(SegmentAllocator allocator, MemorySegment color) {
        var mh$ = ColorNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorNormalize", allocator, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorFromNormalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorFromNormalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static FunctionDescriptor ColorFromNormalized$descriptor() {
        return ColorFromNormalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MethodHandle ColorFromNormalized$handle() {
        return ColorFromNormalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MemorySegment ColorFromNormalized$address() {
        return ColorFromNormalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MemorySegment ColorFromNormalized(SegmentAllocator allocator, MemorySegment normalized) {
        var mh$ = ColorFromNormalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorFromNormalized", allocator, normalized);
            }
            return (MemorySegment)mh$.invokeExact(allocator, normalized);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorToHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorToHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static FunctionDescriptor ColorToHSV$descriptor() {
        return ColorToHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MethodHandle ColorToHSV$handle() {
        return ColorToHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MemorySegment ColorToHSV$address() {
        return ColorToHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MemorySegment ColorToHSV(SegmentAllocator allocator, MemorySegment color) {
        var mh$ = ColorToHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorToHSV", allocator, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorFromHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorFromHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static FunctionDescriptor ColorFromHSV$descriptor() {
        return ColorFromHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MethodHandle ColorFromHSV$handle() {
        return ColorFromHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MemorySegment ColorFromHSV$address() {
        return ColorFromHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MemorySegment ColorFromHSV(SegmentAllocator allocator, float hue, float saturation, float value) {
        var mh$ = ColorFromHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorFromHSV", allocator, hue, saturation, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hue, saturation, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorTint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorTint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static FunctionDescriptor ColorTint$descriptor() {
        return ColorTint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MethodHandle ColorTint$handle() {
        return ColorTint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MemorySegment ColorTint$address() {
        return ColorTint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MemorySegment ColorTint(SegmentAllocator allocator, MemorySegment color, MemorySegment tint) {
        var mh$ = ColorTint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorTint", allocator, color, tint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorBrightness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorBrightness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static FunctionDescriptor ColorBrightness$descriptor() {
        return ColorBrightness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MethodHandle ColorBrightness$handle() {
        return ColorBrightness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MemorySegment ColorBrightness$address() {
        return ColorBrightness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MemorySegment ColorBrightness(SegmentAllocator allocator, MemorySegment color, float factor) {
        var mh$ = ColorBrightness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorBrightness", allocator, color, factor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, factor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorContrast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorContrast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static FunctionDescriptor ColorContrast$descriptor() {
        return ColorContrast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MethodHandle ColorContrast$handle() {
        return ColorContrast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MemorySegment ColorContrast$address() {
        return ColorContrast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MemorySegment ColorContrast(SegmentAllocator allocator, MemorySegment color, float contrast) {
        var mh$ = ColorContrast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorContrast", allocator, color, contrast);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, contrast);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static FunctionDescriptor ColorAlpha$descriptor() {
        return ColorAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MethodHandle ColorAlpha$handle() {
        return ColorAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MemorySegment ColorAlpha$address() {
        return ColorAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MemorySegment ColorAlpha(SegmentAllocator allocator, MemorySegment color, float alpha) {
        var mh$ = ColorAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorAlpha", allocator, color, alpha);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorAlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static FunctionDescriptor ColorAlphaBlend$descriptor() {
        return ColorAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MethodHandle ColorAlphaBlend$handle() {
        return ColorAlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MemorySegment ColorAlphaBlend$address() {
        return ColorAlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MemorySegment ColorAlphaBlend(SegmentAllocator allocator, MemorySegment dst, MemorySegment src, MemorySegment tint) {
        var mh$ = ColorAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorAlphaBlend", allocator, dst, src, tint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, dst, src, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static FunctionDescriptor GetColor$descriptor() {
        return GetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MethodHandle GetColor$handle() {
        return GetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MemorySegment GetColor$address() {
        return GetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MemorySegment GetColor(SegmentAllocator allocator, int hexValue) {
        var mh$ = GetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColor", allocator, hexValue);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hexValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetPixelColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static FunctionDescriptor GetPixelColor$descriptor() {
        return GetPixelColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MethodHandle GetPixelColor$handle() {
        return GetPixelColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MemorySegment GetPixelColor$address() {
        return GetPixelColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MemorySegment GetPixelColor(SegmentAllocator allocator, MemorySegment srcPtr, int format) {
        var mh$ = GetPixelColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelColor", allocator, srcPtr, format);
            }
            return (MemorySegment)mh$.invokeExact(allocator, srcPtr, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetPixelColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static FunctionDescriptor SetPixelColor$descriptor() {
        return SetPixelColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static MethodHandle SetPixelColor$handle() {
        return SetPixelColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static MemorySegment SetPixelColor$address() {
        return SetPixelColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static void SetPixelColor(MemorySegment dstPtr, MemorySegment color, int format) {
        var mh$ = SetPixelColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelColor", dstPtr, color, format);
            }
            mh$.invokeExact(dstPtr, color, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelDataSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetPixelDataSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static FunctionDescriptor GetPixelDataSize$descriptor() {
        return GetPixelDataSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static MethodHandle GetPixelDataSize$handle() {
        return GetPixelDataSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static MemorySegment GetPixelDataSize$address() {
        return GetPixelDataSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static int GetPixelDataSize(int width, int height, int format) {
        var mh$ = GetPixelDataSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelDataSize", width, height, format);
            }
            return (int)mh$.invokeExact(width, height, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFontDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static FunctionDescriptor GetFontDefault$descriptor() {
        return GetFontDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MethodHandle GetFontDefault$handle() {
        return GetFontDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault$address() {
        return GetFontDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault(SegmentAllocator allocator) {
        var mh$ = GetFontDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontDefault", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadFont$descriptor() {
        return LoadFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MethodHandle LoadFont$handle() {
        return LoadFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont$address() {
        return LoadFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFont", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static FunctionDescriptor LoadFontEx$descriptor() {
        return LoadFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MethodHandle LoadFontEx$handle() {
        return LoadFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx$address() {
        return LoadFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx(SegmentAllocator allocator, MemorySegment fileName, int fontSize, MemorySegment codepoints, int codepointCount) {
        var mh$ = LoadFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontEx", allocator, fileName, fontSize, codepoints, codepointCount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName, fontSize, codepoints, codepointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontFromImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            Image.layout(),
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontFromImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static FunctionDescriptor LoadFontFromImage$descriptor() {
        return LoadFontFromImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MethodHandle LoadFontFromImage$handle() {
        return LoadFontFromImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MemorySegment LoadFontFromImage$address() {
        return LoadFontFromImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MemorySegment LoadFontFromImage(SegmentAllocator allocator, MemorySegment image, MemorySegment key, int firstChar) {
        var mh$ = LoadFontFromImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontFromImage", allocator, image, key, firstChar);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, key, firstChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static FunctionDescriptor LoadFontFromMemory$descriptor() {
        return LoadFontFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MethodHandle LoadFontFromMemory$handle() {
        return LoadFontFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontFromMemory$address() {
        return LoadFontFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize, int fontSize, MemorySegment codepoints, int codepointCount) {
        var mh$ = LoadFontFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontFromMemory", allocator, fileType, fileData, dataSize, fontSize, codepoints, codepointCount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize, fontSize, codepoints, codepointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsFontReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Font.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsFontReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static FunctionDescriptor IsFontReady$descriptor() {
        return IsFontReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static MethodHandle IsFontReady$handle() {
        return IsFontReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static MemorySegment IsFontReady$address() {
        return IsFontReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static boolean IsFontReady(MemorySegment font) {
        var mh$ = IsFontReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsFontReady", font);
            }
            return (boolean)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static FunctionDescriptor LoadFontData$descriptor() {
        return LoadFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MethodHandle LoadFontData$handle() {
        return LoadFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MemorySegment LoadFontData$address() {
        return LoadFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MemorySegment LoadFontData(MemorySegment fileData, int dataSize, int fontSize, MemorySegment codepoints, int codepointCount, int type) {
        var mh$ = LoadFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontData", fileData, dataSize, fontSize, codepoints, codepointCount, type);
            }
            return (MemorySegment)mh$.invokeExact(fileData, dataSize, fontSize, codepoints, codepointCount, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageFontAtlas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageFontAtlas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static FunctionDescriptor GenImageFontAtlas$descriptor() {
        return GenImageFontAtlas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MethodHandle GenImageFontAtlas$handle() {
        return GenImageFontAtlas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MemorySegment GenImageFontAtlas$address() {
        return GenImageFontAtlas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MemorySegment GenImageFontAtlas(SegmentAllocator allocator, MemorySegment glyphs, MemorySegment glyphRecs, int glyphCount, int fontSize, int padding, int packMethod) {
        var mh$ = GenImageFontAtlas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageFontAtlas", allocator, glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);
            }
            return (MemorySegment)mh$.invokeExact(allocator, glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static FunctionDescriptor UnloadFontData$descriptor() {
        return UnloadFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static MethodHandle UnloadFontData$handle() {
        return UnloadFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static MemorySegment UnloadFontData$address() {
        return UnloadFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static void UnloadFontData(MemorySegment glyphs, int glyphCount) {
        var mh$ = UnloadFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFontData", glyphs, glyphCount);
            }
            mh$.invokeExact(glyphs, glyphCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static FunctionDescriptor UnloadFont$descriptor() {
        return UnloadFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static MethodHandle UnloadFont$handle() {
        return UnloadFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static MemorySegment UnloadFont$address() {
        return UnloadFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static void UnloadFont(MemorySegment font) {
        var mh$ = UnloadFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFont", font);
            }
            mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportFontAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Font.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportFontAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportFontAsCode$descriptor() {
        return ExportFontAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static MethodHandle ExportFontAsCode$handle() {
        return ExportFontAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static MemorySegment ExportFontAsCode$address() {
        return ExportFontAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static boolean ExportFontAsCode(MemorySegment font, MemorySegment fileName) {
        var mh$ = ExportFontAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportFontAsCode", font, fileName);
            }
            return (boolean)mh$.invokeExact(font, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFPS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawFPS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static FunctionDescriptor DrawFPS$descriptor() {
        return DrawFPS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static MethodHandle DrawFPS$handle() {
        return DrawFPS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static MemorySegment DrawFPS$address() {
        return DrawFPS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static void DrawFPS(int posX, int posY) {
        var mh$ = DrawFPS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFPS", posX, posY);
            }
            mh$.invokeExact(posX, posY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor DrawText$descriptor() {
        return DrawText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MethodHandle DrawText$handle() {
        return DrawText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MemorySegment DrawText$address() {
        return DrawText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static void DrawText(MemorySegment text, int posX, int posY, int fontSize, MemorySegment color) {
        var mh$ = DrawText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawText", text, posX, posY, fontSize, color);
            }
            mh$.invokeExact(text, posX, posY, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextEx$descriptor() {
        return DrawTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextEx$handle() {
        return DrawTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextEx$address() {
        return DrawTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextEx(MemorySegment font, MemorySegment text, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextEx", font, text, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, text, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextPro$descriptor() {
        return DrawTextPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextPro$handle() {
        return DrawTextPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextPro$address() {
        return DrawTextPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextPro(MemorySegment font, MemorySegment text, MemorySegment position, MemorySegment origin, float rotation, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextPro", font, text, position, origin, rotation, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, text, position, origin, rotation, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextCodepoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_INT,
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextCodepoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextCodepoint$descriptor() {
        return DrawTextCodepoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static MethodHandle DrawTextCodepoint$handle() {
        return DrawTextCodepoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static MemorySegment DrawTextCodepoint$address() {
        return DrawTextCodepoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static void DrawTextCodepoint(MemorySegment font, int codepoint, MemorySegment position, float fontSize, MemorySegment tint) {
        var mh$ = DrawTextCodepoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextCodepoint", font, codepoint, position, fontSize, tint);
            }
            mh$.invokeExact(font, codepoint, position, fontSize, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextCodepoints$descriptor() {
        return DrawTextCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextCodepoints$handle() {
        return DrawTextCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextCodepoints$address() {
        return DrawTextCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextCodepoints(MemorySegment font, MemorySegment codepoints, int codepointCount, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextCodepoints", font, codepoints, codepointCount, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, codepoints, codepointCount, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextLineSpacing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextLineSpacing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static FunctionDescriptor SetTextLineSpacing$descriptor() {
        return SetTextLineSpacing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static MethodHandle SetTextLineSpacing$handle() {
        return SetTextLineSpacing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static MemorySegment SetTextLineSpacing$address() {
        return SetTextLineSpacing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static void SetTextLineSpacing(int spacing) {
        var mh$ = SetTextLineSpacing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextLineSpacing", spacing);
            }
            mh$.invokeExact(spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MeasureText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MeasureText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static FunctionDescriptor MeasureText$descriptor() {
        return MeasureText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MethodHandle MeasureText$handle() {
        return MeasureText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MemorySegment MeasureText$address() {
        return MeasureText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static int MeasureText(MemorySegment text, int fontSize) {
        var mh$ = MeasureText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MeasureText", text, fontSize);
            }
            return (int)mh$.invokeExact(text, fontSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MeasureTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MeasureTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static FunctionDescriptor MeasureTextEx$descriptor() {
        return MeasureTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MethodHandle MeasureTextEx$handle() {
        return MeasureTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MemorySegment MeasureTextEx$address() {
        return MeasureTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MemorySegment MeasureTextEx(SegmentAllocator allocator, MemorySegment font, MemorySegment text, float fontSize, float spacing) {
        var mh$ = MeasureTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MeasureTextEx", allocator, font, text, fontSize, spacing);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, text, fontSize, spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphIndex$descriptor() {
        return GetGlyphIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphIndex$handle() {
        return GetGlyphIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphIndex$address() {
        return GetGlyphIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static int GetGlyphIndex(MemorySegment font, int codepoint) {
        var mh$ = GetGlyphIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndex", font, codepoint);
            }
            return (int)mh$.invokeExact(font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            GlyphInfo.layout(),
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphInfo$descriptor() {
        return GetGlyphInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphInfo$handle() {
        return GetGlyphInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphInfo$address() {
        return GetGlyphInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphInfo(SegmentAllocator allocator, MemorySegment font, int codepoint) {
        var mh$ = GetGlyphInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphInfo", allocator, font, codepoint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphAtlasRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout(),
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphAtlasRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphAtlasRec$descriptor() {
        return GetGlyphAtlasRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphAtlasRec$handle() {
        return GetGlyphAtlasRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphAtlasRec$address() {
        return GetGlyphAtlasRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphAtlasRec(SegmentAllocator allocator, MemorySegment font, int codepoint) {
        var mh$ = GetGlyphAtlasRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphAtlasRec", allocator, font, codepoint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static FunctionDescriptor LoadUTF8$descriptor() {
        return LoadUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MethodHandle LoadUTF8$handle() {
        return LoadUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MemorySegment LoadUTF8$address() {
        return LoadUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MemorySegment LoadUTF8(MemorySegment codepoints, int length) {
        var mh$ = LoadUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadUTF8", codepoints, length);
            }
            return (MemorySegment)mh$.invokeExact(codepoints, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static FunctionDescriptor UnloadUTF8$descriptor() {
        return UnloadUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static MethodHandle UnloadUTF8$handle() {
        return UnloadUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static MemorySegment UnloadUTF8$address() {
        return UnloadUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static void UnloadUTF8(MemorySegment text) {
        var mh$ = UnloadUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadUTF8", text);
            }
            mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static FunctionDescriptor LoadCodepoints$descriptor() {
        return LoadCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MethodHandle LoadCodepoints$handle() {
        return LoadCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MemorySegment LoadCodepoints$address() {
        return LoadCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MemorySegment LoadCodepoints(MemorySegment text, MemorySegment count) {
        var mh$ = LoadCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCodepoints", text, count);
            }
            return (MemorySegment)mh$.invokeExact(text, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static FunctionDescriptor UnloadCodepoints$descriptor() {
        return UnloadCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static MethodHandle UnloadCodepoints$handle() {
        return UnloadCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static MemorySegment UnloadCodepoints$address() {
        return UnloadCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static void UnloadCodepoints(MemorySegment codepoints) {
        var mh$ = UnloadCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadCodepoints", codepoints);
            }
            mh$.invokeExact(codepoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static FunctionDescriptor GetCodepointCount$descriptor() {
        return GetCodepointCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static MethodHandle GetCodepointCount$handle() {
        return GetCodepointCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static MemorySegment GetCodepointCount$address() {
        return GetCodepointCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static int GetCodepointCount(MemorySegment text) {
        var mh$ = GetCodepointCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointCount", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepoint$descriptor() {
        return GetCodepoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepoint$handle() {
        return GetCodepoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepoint$address() {
        return GetCodepoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepoint(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepoint", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointNext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepointNext$descriptor() {
        return GetCodepointNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepointNext$handle() {
        return GetCodepointNext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepointNext$address() {
        return GetCodepointNext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepointNext(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepointNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointNext", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointPrevious {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointPrevious");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepointPrevious$descriptor() {
        return GetCodepointPrevious.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepointPrevious$handle() {
        return GetCodepointPrevious.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepointPrevious$address() {
        return GetCodepointPrevious.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepointPrevious(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepointPrevious.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointPrevious", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CodepointToUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CodepointToUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static FunctionDescriptor CodepointToUTF8$descriptor() {
        return CodepointToUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MethodHandle CodepointToUTF8$handle() {
        return CodepointToUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MemorySegment CodepointToUTF8$address() {
        return CodepointToUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MemorySegment CodepointToUTF8(int codepoint, MemorySegment utf8Size) {
        var mh$ = CodepointToUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CodepointToUTF8", codepoint, utf8Size);
            }
            return (MemorySegment)mh$.invokeExact(codepoint, utf8Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static FunctionDescriptor TextCopy$descriptor() {
        return TextCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static MethodHandle TextCopy$handle() {
        return TextCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static MemorySegment TextCopy$address() {
        return TextCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static int TextCopy(MemorySegment dst, MemorySegment src) {
        var mh$ = TextCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextCopy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextIsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextIsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static FunctionDescriptor TextIsEqual$descriptor() {
        return TextIsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static MethodHandle TextIsEqual$handle() {
        return TextIsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static MemorySegment TextIsEqual$address() {
        return TextIsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static boolean TextIsEqual(MemorySegment text1, MemorySegment text2) {
        var mh$ = TextIsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextIsEqual", text1, text2);
            }
            return (boolean)mh$.invokeExact(text1, text2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static FunctionDescriptor TextLength$descriptor() {
        return TextLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static MethodHandle TextLength$handle() {
        return TextLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static MemorySegment TextLength$address() {
        return TextLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static int TextLength(MemorySegment text) {
        var mh$ = TextLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextLength", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * const char *TextFormat(const char *text, ...)
     * }
     */
    public static class TextFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                raylib.C_POINTER,
                raylib.C_POINTER
            );
        private static final MemorySegment ADDR = raylib.findOrThrow("TextFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private TextFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * const char *TextFormat(const char *text, ...)
         * }
         */
        public static TextFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new TextFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment text, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("TextFormat", text, x1);
                }
                return (MemorySegment)spreader.invokeExact(text, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class TextSubtext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextSubtext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static FunctionDescriptor TextSubtext$descriptor() {
        return TextSubtext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MethodHandle TextSubtext$handle() {
        return TextSubtext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MemorySegment TextSubtext$address() {
        return TextSubtext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MemorySegment TextSubtext(MemorySegment text, int position, int length) {
        var mh$ = TextSubtext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextSubtext", text, position, length);
            }
            return (MemorySegment)mh$.invokeExact(text, position, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextReplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextReplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static FunctionDescriptor TextReplace$descriptor() {
        return TextReplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MethodHandle TextReplace$handle() {
        return TextReplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MemorySegment TextReplace$address() {
        return TextReplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MemorySegment TextReplace(MemorySegment text, MemorySegment replace, MemorySegment by) {
        var mh$ = TextReplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextReplace", text, replace, by);
            }
            return (MemorySegment)mh$.invokeExact(text, replace, by);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextInsert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextInsert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static FunctionDescriptor TextInsert$descriptor() {
        return TextInsert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MethodHandle TextInsert$handle() {
        return TextInsert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MemorySegment TextInsert$address() {
        return TextInsert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MemorySegment TextInsert(MemorySegment text, MemorySegment insert, int position) {
        var mh$ = TextInsert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextInsert", text, insert, position);
            }
            return (MemorySegment)mh$.invokeExact(text, insert, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static FunctionDescriptor TextJoin$descriptor() {
        return TextJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MethodHandle TextJoin$handle() {
        return TextJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MemorySegment TextJoin$address() {
        return TextJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MemorySegment TextJoin(MemorySegment textList, int count, MemorySegment delimiter) {
        var mh$ = TextJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextJoin", textList, count, delimiter);
            }
            return (MemorySegment)mh$.invokeExact(textList, count, delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_CHAR,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static FunctionDescriptor TextSplit$descriptor() {
        return TextSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MethodHandle TextSplit$handle() {
        return TextSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MemorySegment TextSplit$address() {
        return TextSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MemorySegment TextSplit(MemorySegment text, byte delimiter, MemorySegment count) {
        var mh$ = TextSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextSplit", text, delimiter, count);
            }
            return (MemorySegment)mh$.invokeExact(text, delimiter, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextAppend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextAppend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static FunctionDescriptor TextAppend$descriptor() {
        return TextAppend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static MethodHandle TextAppend$handle() {
        return TextAppend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static MemorySegment TextAppend$address() {
        return TextAppend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static void TextAppend(MemorySegment text, MemorySegment append, MemorySegment position) {
        var mh$ = TextAppend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextAppend", text, append, position);
            }
            mh$.invokeExact(text, append, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextFindIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextFindIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static FunctionDescriptor TextFindIndex$descriptor() {
        return TextFindIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static MethodHandle TextFindIndex$handle() {
        return TextFindIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static MemorySegment TextFindIndex$address() {
        return TextFindIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static int TextFindIndex(MemorySegment text, MemorySegment find) {
        var mh$ = TextFindIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextFindIndex", text, find);
            }
            return (int)mh$.invokeExact(text, find);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToUpper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToUpper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static FunctionDescriptor TextToUpper$descriptor() {
        return TextToUpper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MethodHandle TextToUpper$handle() {
        return TextToUpper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MemorySegment TextToUpper$address() {
        return TextToUpper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MemorySegment TextToUpper(MemorySegment text) {
        var mh$ = TextToUpper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToUpper", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToLower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToLower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static FunctionDescriptor TextToLower$descriptor() {
        return TextToLower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MethodHandle TextToLower$handle() {
        return TextToLower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MemorySegment TextToLower$address() {
        return TextToLower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MemorySegment TextToLower(MemorySegment text) {
        var mh$ = TextToLower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToLower", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToPascal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToPascal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static FunctionDescriptor TextToPascal$descriptor() {
        return TextToPascal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MethodHandle TextToPascal$handle() {
        return TextToPascal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MemorySegment TextToPascal$address() {
        return TextToPascal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MemorySegment TextToPascal(MemorySegment text) {
        var mh$ = TextToPascal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToPascal", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToInteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToInteger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static FunctionDescriptor TextToInteger$descriptor() {
        return TextToInteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static MethodHandle TextToInteger$handle() {
        return TextToInteger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static MemorySegment TextToInteger$address() {
        return TextToInteger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static int TextToInteger(MemorySegment text) {
        var mh$ = TextToInteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToInteger", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static FunctionDescriptor TextToFloat$descriptor() {
        return TextToFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static MethodHandle TextToFloat$handle() {
        return TextToFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static MemorySegment TextToFloat$address() {
        return TextToFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static float TextToFloat(MemorySegment text) {
        var mh$ = TextToFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToFloat", text);
            }
            return (float)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLine3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLine3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static FunctionDescriptor DrawLine3D$descriptor() {
        return DrawLine3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static MethodHandle DrawLine3D$handle() {
        return DrawLine3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static MemorySegment DrawLine3D$address() {
        return DrawLine3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static void DrawLine3D(MemorySegment startPos, MemorySegment endPos, MemorySegment color) {
        var mh$ = DrawLine3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLine3D", startPos, endPos, color);
            }
            mh$.invokeExact(startPos, endPos, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPoint3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPoint3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static FunctionDescriptor DrawPoint3D$descriptor() {
        return DrawPoint3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static MethodHandle DrawPoint3D$handle() {
        return DrawPoint3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static MemorySegment DrawPoint3D$address() {
        return DrawPoint3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static void DrawPoint3D(MemorySegment position, MemorySegment color) {
        var mh$ = DrawPoint3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPoint3D", position, color);
            }
            mh$.invokeExact(position, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircle3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircle3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircle3D$descriptor() {
        return DrawCircle3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static MethodHandle DrawCircle3D$handle() {
        return DrawCircle3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static MemorySegment DrawCircle3D$address() {
        return DrawCircle3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static void DrawCircle3D(MemorySegment center, float radius, MemorySegment rotationAxis, float rotationAngle, MemorySegment color) {
        var mh$ = DrawCircle3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircle3D", center, radius, rotationAxis, rotationAngle, color);
            }
            mh$.invokeExact(center, radius, rotationAxis, rotationAngle, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangle3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangle3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangle3D$descriptor() {
        return DrawTriangle3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static MethodHandle DrawTriangle3D$handle() {
        return DrawTriangle3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static MemorySegment DrawTriangle3D$address() {
        return DrawTriangle3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static void DrawTriangle3D(MemorySegment v1, MemorySegment v2, MemorySegment v3, MemorySegment color) {
        var mh$ = DrawTriangle3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangle3D", v1, v2, v3, color);
            }
            mh$.invokeExact(v1, v2, v3, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangleStrip3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangleStrip3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangleStrip3D$descriptor() {
        return DrawTriangleStrip3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static MethodHandle DrawTriangleStrip3D$handle() {
        return DrawTriangleStrip3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static MemorySegment DrawTriangleStrip3D$address() {
        return DrawTriangleStrip3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static void DrawTriangleStrip3D(MemorySegment points, int pointCount, MemorySegment color) {
        var mh$ = DrawTriangleStrip3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangleStrip3D", points, pointCount, color);
            }
            mh$.invokeExact(points, pointCount, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static FunctionDescriptor DrawCube$descriptor() {
        return DrawCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MethodHandle DrawCube$handle() {
        return DrawCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MemorySegment DrawCube$address() {
        return DrawCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static void DrawCube(MemorySegment position, float width, float height, float length, MemorySegment color) {
        var mh$ = DrawCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCube", position, width, height, length, color);
            }
            mh$.invokeExact(position, width, height, length, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeV$descriptor() {
        return DrawCubeV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MethodHandle DrawCubeV$handle() {
        return DrawCubeV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MemorySegment DrawCubeV$address() {
        return DrawCubeV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static void DrawCubeV(MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = DrawCubeV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeV", position, size, color);
            }
            mh$.invokeExact(position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeWires$descriptor() {
        return DrawCubeWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MethodHandle DrawCubeWires$handle() {
        return DrawCubeWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MemorySegment DrawCubeWires$address() {
        return DrawCubeWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static void DrawCubeWires(MemorySegment position, float width, float height, float length, MemorySegment color) {
        var mh$ = DrawCubeWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeWires", position, width, height, length, color);
            }
            mh$.invokeExact(position, width, height, length, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeWiresV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeWiresV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeWiresV$descriptor() {
        return DrawCubeWiresV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MethodHandle DrawCubeWiresV$handle() {
        return DrawCubeWiresV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MemorySegment DrawCubeWiresV$address() {
        return DrawCubeWiresV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static void DrawCubeWiresV(MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = DrawCubeWiresV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeWiresV", position, size, color);
            }
            mh$.invokeExact(position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphere$descriptor() {
        return DrawSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static MethodHandle DrawSphere$handle() {
        return DrawSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static MemorySegment DrawSphere$address() {
        return DrawSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static void DrawSphere(MemorySegment centerPos, float radius, MemorySegment color) {
        var mh$ = DrawSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphere", centerPos, radius, color);
            }
            mh$.invokeExact(centerPos, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphereEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphereEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphereEx$descriptor() {
        return DrawSphereEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MethodHandle DrawSphereEx$handle() {
        return DrawSphereEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MemorySegment DrawSphereEx$address() {
        return DrawSphereEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static void DrawSphereEx(MemorySegment centerPos, float radius, int rings, int slices, MemorySegment color) {
        var mh$ = DrawSphereEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphereEx", centerPos, radius, rings, slices, color);
            }
            mh$.invokeExact(centerPos, radius, rings, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphereWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphereWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphereWires$descriptor() {
        return DrawSphereWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MethodHandle DrawSphereWires$handle() {
        return DrawSphereWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MemorySegment DrawSphereWires$address() {
        return DrawSphereWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static void DrawSphereWires(MemorySegment centerPos, float radius, int rings, int slices, MemorySegment color) {
        var mh$ = DrawSphereWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphereWires", centerPos, radius, rings, slices, color);
            }
            mh$.invokeExact(centerPos, radius, rings, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinder$descriptor() {
        return DrawCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MethodHandle DrawCylinder$handle() {
        return DrawCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MemorySegment DrawCylinder$address() {
        return DrawCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static void DrawCylinder(MemorySegment position, float radiusTop, float radiusBottom, float height, int slices, MemorySegment color) {
        var mh$ = DrawCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinder", position, radiusTop, radiusBottom, height, slices, color);
            }
            mh$.invokeExact(position, radiusTop, radiusBottom, height, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderEx$descriptor() {
        return DrawCylinderEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MethodHandle DrawCylinderEx$handle() {
        return DrawCylinderEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MemorySegment DrawCylinderEx$address() {
        return DrawCylinderEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static void DrawCylinderEx(MemorySegment startPos, MemorySegment endPos, float startRadius, float endRadius, int sides, MemorySegment color) {
        var mh$ = DrawCylinderEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderEx", startPos, endPos, startRadius, endRadius, sides, color);
            }
            mh$.invokeExact(startPos, endPos, startRadius, endRadius, sides, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderWires$descriptor() {
        return DrawCylinderWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MethodHandle DrawCylinderWires$handle() {
        return DrawCylinderWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MemorySegment DrawCylinderWires$address() {
        return DrawCylinderWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static void DrawCylinderWires(MemorySegment position, float radiusTop, float radiusBottom, float height, int slices, MemorySegment color) {
        var mh$ = DrawCylinderWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderWires", position, radiusTop, radiusBottom, height, slices, color);
            }
            mh$.invokeExact(position, radiusTop, radiusBottom, height, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderWiresEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderWiresEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderWiresEx$descriptor() {
        return DrawCylinderWiresEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MethodHandle DrawCylinderWiresEx$handle() {
        return DrawCylinderWiresEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MemorySegment DrawCylinderWiresEx$address() {
        return DrawCylinderWiresEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static void DrawCylinderWiresEx(MemorySegment startPos, MemorySegment endPos, float startRadius, float endRadius, int sides, MemorySegment color) {
        var mh$ = DrawCylinderWiresEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderWiresEx", startPos, endPos, startRadius, endRadius, sides, color);
            }
            mh$.invokeExact(startPos, endPos, startRadius, endRadius, sides, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCapsule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCapsule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static FunctionDescriptor DrawCapsule$descriptor() {
        return DrawCapsule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MethodHandle DrawCapsule$handle() {
        return DrawCapsule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MemorySegment DrawCapsule$address() {
        return DrawCapsule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static void DrawCapsule(MemorySegment startPos, MemorySegment endPos, float radius, int slices, int rings, MemorySegment color) {
        var mh$ = DrawCapsule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCapsule", startPos, endPos, radius, slices, rings, color);
            }
            mh$.invokeExact(startPos, endPos, radius, slices, rings, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCapsuleWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCapsuleWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static FunctionDescriptor DrawCapsuleWires$descriptor() {
        return DrawCapsuleWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MethodHandle DrawCapsuleWires$handle() {
        return DrawCapsuleWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MemorySegment DrawCapsuleWires$address() {
        return DrawCapsuleWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static void DrawCapsuleWires(MemorySegment startPos, MemorySegment endPos, float radius, int slices, int rings, MemorySegment color) {
        var mh$ = DrawCapsuleWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCapsuleWires", startPos, endPos, radius, slices, rings, color);
            }
            mh$.invokeExact(startPos, endPos, radius, slices, rings, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawPlane$descriptor() {
        return DrawPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static MethodHandle DrawPlane$handle() {
        return DrawPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static MemorySegment DrawPlane$address() {
        return DrawPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static void DrawPlane(MemorySegment centerPos, MemorySegment size, MemorySegment color) {
        var mh$ = DrawPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPlane", centerPos, size, color);
            }
            mh$.invokeExact(centerPos, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ray.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static FunctionDescriptor DrawRay$descriptor() {
        return DrawRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static MethodHandle DrawRay$handle() {
        return DrawRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static MemorySegment DrawRay$address() {
        return DrawRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static void DrawRay(MemorySegment ray, MemorySegment color) {
        var mh$ = DrawRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRay", ray, color);
            }
            mh$.invokeExact(ray, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawGrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static FunctionDescriptor DrawGrid$descriptor() {
        return DrawGrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static MethodHandle DrawGrid$handle() {
        return DrawGrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static MemorySegment DrawGrid$address() {
        return DrawGrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static void DrawGrid(int slices, float spacing) {
        var mh$ = DrawGrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGrid", slices, spacing);
            }
            mh$.invokeExact(slices, spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Model.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadModel$descriptor() {
        return LoadModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MethodHandle LoadModel$handle() {
        return LoadModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MemorySegment LoadModel$address() {
        return LoadModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MemorySegment LoadModel(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModel", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModelFromMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Model.layout(),
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModelFromMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static FunctionDescriptor LoadModelFromMesh$descriptor() {
        return LoadModelFromMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MethodHandle LoadModelFromMesh$handle() {
        return LoadModelFromMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MemorySegment LoadModelFromMesh$address() {
        return LoadModelFromMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MemorySegment LoadModelFromMesh(SegmentAllocator allocator, MemorySegment mesh) {
        var mh$ = LoadModelFromMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModelFromMesh", allocator, mesh);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsModelReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsModelReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static FunctionDescriptor IsModelReady$descriptor() {
        return IsModelReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static MethodHandle IsModelReady$handle() {
        return IsModelReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static MemorySegment IsModelReady$address() {
        return IsModelReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static boolean IsModelReady(MemorySegment model) {
        var mh$ = IsModelReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsModelReady", model);
            }
            return (boolean)mh$.invokeExact(model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static FunctionDescriptor UnloadModel$descriptor() {
        return UnloadModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static MethodHandle UnloadModel$handle() {
        return UnloadModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static MemorySegment UnloadModel$address() {
        return UnloadModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static void UnloadModel(MemorySegment model) {
        var mh$ = UnloadModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModel", model);
            }
            mh$.invokeExact(model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModelBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BoundingBox.layout(),
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetModelBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static FunctionDescriptor GetModelBoundingBox$descriptor() {
        return GetModelBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MethodHandle GetModelBoundingBox$handle() {
        return GetModelBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MemorySegment GetModelBoundingBox$address() {
        return GetModelBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MemorySegment GetModelBoundingBox(SegmentAllocator allocator, MemorySegment model) {
        var mh$ = GetModelBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModelBoundingBox", allocator, model);
            }
            return (MemorySegment)mh$.invokeExact(allocator, model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModel$descriptor() {
        return DrawModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawModel$handle() {
        return DrawModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawModel$address() {
        return DrawModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static void DrawModel(MemorySegment model, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = DrawModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModel", model, position, scale, tint);
            }
            mh$.invokeExact(model, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelEx$descriptor() {
        return DrawModelEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelEx$handle() {
        return DrawModelEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelEx$address() {
        return DrawModelEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void DrawModelEx(MemorySegment model, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = DrawModelEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelEx", model, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(model, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelWires$descriptor() {
        return DrawModelWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelWires$handle() {
        return DrawModelWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelWires$address() {
        return DrawModelWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static void DrawModelWires(MemorySegment model, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = DrawModelWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelWires", model, position, scale, tint);
            }
            mh$.invokeExact(model, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelWiresEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelWiresEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelWiresEx$descriptor() {
        return DrawModelWiresEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelWiresEx$handle() {
        return DrawModelWiresEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelWiresEx$address() {
        return DrawModelWiresEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void DrawModelWiresEx(MemorySegment model, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = DrawModelWiresEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelWiresEx", model, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(model, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            BoundingBox.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static FunctionDescriptor DrawBoundingBox$descriptor() {
        return DrawBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static MethodHandle DrawBoundingBox$handle() {
        return DrawBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static MemorySegment DrawBoundingBox$address() {
        return DrawBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static void DrawBoundingBox(MemorySegment box, MemorySegment color) {
        var mh$ = DrawBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBoundingBox", box, color);
            }
            mh$.invokeExact(box, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboard$descriptor() {
        return DrawBillboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static MethodHandle DrawBillboard$handle() {
        return DrawBillboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static MemorySegment DrawBillboard$address() {
        return DrawBillboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static void DrawBillboard(MemorySegment camera, MemorySegment texture, MemorySegment position, float size, MemorySegment tint) {
        var mh$ = DrawBillboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboard", camera, texture, position, size, tint);
            }
            mh$.invokeExact(camera, texture, position, size, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboardRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Rectangle.layout(),
            Vector3.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboardRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboardRec$descriptor() {
        return DrawBillboardRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static MethodHandle DrawBillboardRec$handle() {
        return DrawBillboardRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static MemorySegment DrawBillboardRec$address() {
        return DrawBillboardRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static void DrawBillboardRec(MemorySegment camera, MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment size, MemorySegment tint) {
        var mh$ = DrawBillboardRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboardRec", camera, texture, source, position, size, tint);
            }
            mh$.invokeExact(camera, texture, source, position, size, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboardPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Rectangle.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboardPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboardPro$descriptor() {
        return DrawBillboardPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawBillboardPro$handle() {
        return DrawBillboardPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawBillboardPro$address() {
        return DrawBillboardPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawBillboardPro(MemorySegment camera, MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment up, MemorySegment size, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawBillboardPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboardPro", camera, texture, source, position, up, size, origin, rotation, tint);
            }
            mh$.invokeExact(camera, texture, source, position, up, size, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UploadMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UploadMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static FunctionDescriptor UploadMesh$descriptor() {
        return UploadMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static MethodHandle UploadMesh$handle() {
        return UploadMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static MemorySegment UploadMesh$address() {
        return UploadMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static void UploadMesh(MemorySegment mesh, boolean dynamic) {
        var mh$ = UploadMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UploadMesh", mesh, dynamic);
            }
            mh$.invokeExact(mesh, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateMeshBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateMeshBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor UpdateMeshBuffer$descriptor() {
        return UpdateMeshBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle UpdateMeshBuffer$handle() {
        return UpdateMeshBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment UpdateMeshBuffer$address() {
        return UpdateMeshBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static void UpdateMeshBuffer(MemorySegment mesh, int index, MemorySegment data, int dataSize, int offset) {
        var mh$ = UpdateMeshBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateMeshBuffer", mesh, index, data, dataSize, offset);
            }
            mh$.invokeExact(mesh, index, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static FunctionDescriptor UnloadMesh$descriptor() {
        return UnloadMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static MethodHandle UnloadMesh$handle() {
        return UnloadMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static MemorySegment UnloadMesh$address() {
        return UnloadMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static void UnloadMesh(MemorySegment mesh) {
        var mh$ = UnloadMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMesh", mesh);
            }
            mh$.invokeExact(mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            Material.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static FunctionDescriptor DrawMesh$descriptor() {
        return DrawMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static MethodHandle DrawMesh$handle() {
        return DrawMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static MemorySegment DrawMesh$address() {
        return DrawMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static void DrawMesh(MemorySegment mesh, MemorySegment material, MemorySegment transform) {
        var mh$ = DrawMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMesh", mesh, material, transform);
            }
            mh$.invokeExact(mesh, material, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMeshInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            Material.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawMeshInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static FunctionDescriptor DrawMeshInstanced$descriptor() {
        return DrawMeshInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static MethodHandle DrawMeshInstanced$handle() {
        return DrawMeshInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static MemorySegment DrawMeshInstanced$address() {
        return DrawMeshInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static void DrawMeshInstanced(MemorySegment mesh, MemorySegment material, MemorySegment transforms, int instances) {
        var mh$ = DrawMeshInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMeshInstanced", mesh, material, transforms, instances);
            }
            mh$.invokeExact(mesh, material, transforms, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMeshBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BoundingBox.layout(),
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMeshBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static FunctionDescriptor GetMeshBoundingBox$descriptor() {
        return GetMeshBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MethodHandle GetMeshBoundingBox$handle() {
        return GetMeshBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MemorySegment GetMeshBoundingBox$address() {
        return GetMeshBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MemorySegment GetMeshBoundingBox(SegmentAllocator allocator, MemorySegment mesh) {
        var mh$ = GetMeshBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMeshBoundingBox", allocator, mesh);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshTangents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshTangents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static FunctionDescriptor GenMeshTangents$descriptor() {
        return GenMeshTangents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static MethodHandle GenMeshTangents$handle() {
        return GenMeshTangents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static MemorySegment GenMeshTangents$address() {
        return GenMeshTangents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static void GenMeshTangents(MemorySegment mesh) {
        var mh$ = GenMeshTangents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshTangents", mesh);
            }
            mh$.invokeExact(mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Mesh.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportMesh$descriptor() {
        return ExportMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static MethodHandle ExportMesh$handle() {
        return ExportMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static MemorySegment ExportMesh$address() {
        return ExportMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static boolean ExportMesh(MemorySegment mesh, MemorySegment fileName) {
        var mh$ = ExportMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportMesh", mesh, fileName);
            }
            return (boolean)mh$.invokeExact(mesh, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportMeshAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Mesh.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportMeshAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportMeshAsCode$descriptor() {
        return ExportMeshAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static MethodHandle ExportMeshAsCode$handle() {
        return ExportMeshAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static MemorySegment ExportMeshAsCode$address() {
        return ExportMeshAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static boolean ExportMeshAsCode(MemorySegment mesh, MemorySegment fileName) {
        var mh$ = ExportMeshAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportMeshAsCode", mesh, fileName);
            }
            return (boolean)mh$.invokeExact(mesh, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshPoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshPoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static FunctionDescriptor GenMeshPoly$descriptor() {
        return GenMeshPoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MethodHandle GenMeshPoly$handle() {
        return GenMeshPoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MemorySegment GenMeshPoly$address() {
        return GenMeshPoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MemorySegment GenMeshPoly(SegmentAllocator allocator, int sides, float radius) {
        var mh$ = GenMeshPoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshPoly", allocator, sides, radius);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sides, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static FunctionDescriptor GenMeshPlane$descriptor() {
        return GenMeshPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MethodHandle GenMeshPlane$handle() {
        return GenMeshPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MemorySegment GenMeshPlane$address() {
        return GenMeshPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MemorySegment GenMeshPlane(SegmentAllocator allocator, float width, float length, int resX, int resZ) {
        var mh$ = GenMeshPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshPlane", allocator, width, length, resX, resZ);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, length, resX, resZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static FunctionDescriptor GenMeshCube$descriptor() {
        return GenMeshCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MethodHandle GenMeshCube$handle() {
        return GenMeshCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MemorySegment GenMeshCube$address() {
        return GenMeshCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MemorySegment GenMeshCube(SegmentAllocator allocator, float width, float height, float length) {
        var mh$ = GenMeshCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCube", allocator, width, height, length);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshSphere$descriptor() {
        return GenMeshSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MethodHandle GenMeshSphere$handle() {
        return GenMeshSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshSphere$address() {
        return GenMeshSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshSphere(SegmentAllocator allocator, float radius, int rings, int slices) {
        var mh$ = GenMeshSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshSphere", allocator, radius, rings, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, rings, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshHemiSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshHemiSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshHemiSphere$descriptor() {
        return GenMeshHemiSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MethodHandle GenMeshHemiSphere$handle() {
        return GenMeshHemiSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshHemiSphere$address() {
        return GenMeshHemiSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshHemiSphere(SegmentAllocator allocator, float radius, int rings, int slices) {
        var mh$ = GenMeshHemiSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshHemiSphere", allocator, radius, rings, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, rings, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshCylinder$descriptor() {
        return GenMeshCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MethodHandle GenMeshCylinder$handle() {
        return GenMeshCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCylinder$address() {
        return GenMeshCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCylinder(SegmentAllocator allocator, float radius, float height, int slices) {
        var mh$ = GenMeshCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCylinder", allocator, radius, height, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, height, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshCone$descriptor() {
        return GenMeshCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MethodHandle GenMeshCone$handle() {
        return GenMeshCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCone$address() {
        return GenMeshCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCone(SegmentAllocator allocator, float radius, float height, int slices) {
        var mh$ = GenMeshCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCone", allocator, radius, height, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, height, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static FunctionDescriptor GenMeshTorus$descriptor() {
        return GenMeshTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MethodHandle GenMeshTorus$handle() {
        return GenMeshTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshTorus$address() {
        return GenMeshTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshTorus(SegmentAllocator allocator, float radius, float size, int radSeg, int sides) {
        var mh$ = GenMeshTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshTorus", allocator, radius, size, radSeg, sides);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, size, radSeg, sides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshKnot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshKnot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static FunctionDescriptor GenMeshKnot$descriptor() {
        return GenMeshKnot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MethodHandle GenMeshKnot$handle() {
        return GenMeshKnot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshKnot$address() {
        return GenMeshKnot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshKnot(SegmentAllocator allocator, float radius, float size, int radSeg, int sides) {
        var mh$ = GenMeshKnot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshKnot", allocator, radius, size, radSeg, sides);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, size, radSeg, sides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshHeightmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            Image.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshHeightmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static FunctionDescriptor GenMeshHeightmap$descriptor() {
        return GenMeshHeightmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MethodHandle GenMeshHeightmap$handle() {
        return GenMeshHeightmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MemorySegment GenMeshHeightmap$address() {
        return GenMeshHeightmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MemorySegment GenMeshHeightmap(SegmentAllocator allocator, MemorySegment heightmap, MemorySegment size) {
        var mh$ = GenMeshHeightmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshHeightmap", allocator, heightmap, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, heightmap, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCubicmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            Image.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCubicmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static FunctionDescriptor GenMeshCubicmap$descriptor() {
        return GenMeshCubicmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MethodHandle GenMeshCubicmap$handle() {
        return GenMeshCubicmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MemorySegment GenMeshCubicmap$address() {
        return GenMeshCubicmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MemorySegment GenMeshCubicmap(SegmentAllocator allocator, MemorySegment cubicmap, MemorySegment cubeSize) {
        var mh$ = GenMeshCubicmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCubicmap", allocator, cubicmap, cubeSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, cubicmap, cubeSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMaterials {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMaterials");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static FunctionDescriptor LoadMaterials$descriptor() {
        return LoadMaterials.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MethodHandle LoadMaterials$handle() {
        return LoadMaterials.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MemorySegment LoadMaterials$address() {
        return LoadMaterials.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MemorySegment LoadMaterials(MemorySegment fileName, MemorySegment materialCount) {
        var mh$ = LoadMaterials.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMaterials", fileName, materialCount);
            }
            return (MemorySegment)mh$.invokeExact(fileName, materialCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMaterialDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Material.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMaterialDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static FunctionDescriptor LoadMaterialDefault$descriptor() {
        return LoadMaterialDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MethodHandle LoadMaterialDefault$handle() {
        return LoadMaterialDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MemorySegment LoadMaterialDefault$address() {
        return LoadMaterialDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MemorySegment LoadMaterialDefault(SegmentAllocator allocator) {
        var mh$ = LoadMaterialDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMaterialDefault", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMaterialReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Material.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMaterialReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static FunctionDescriptor IsMaterialReady$descriptor() {
        return IsMaterialReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static MethodHandle IsMaterialReady$handle() {
        return IsMaterialReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static MemorySegment IsMaterialReady$address() {
        return IsMaterialReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static boolean IsMaterialReady(MemorySegment material) {
        var mh$ = IsMaterialReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMaterialReady", material);
            }
            return (boolean)mh$.invokeExact(material);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Material.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static FunctionDescriptor UnloadMaterial$descriptor() {
        return UnloadMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static MethodHandle UnloadMaterial$handle() {
        return UnloadMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static MemorySegment UnloadMaterial$address() {
        return UnloadMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static void UnloadMaterial(MemorySegment material) {
        var mh$ = UnloadMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMaterial", material);
            }
            mh$.invokeExact(material);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMaterialTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMaterialTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static FunctionDescriptor SetMaterialTexture$descriptor() {
        return SetMaterialTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static MethodHandle SetMaterialTexture$handle() {
        return SetMaterialTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static MemorySegment SetMaterialTexture$address() {
        return SetMaterialTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static void SetMaterialTexture(MemorySegment material, int mapType, MemorySegment texture) {
        var mh$ = SetMaterialTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMaterialTexture", material, mapType, texture);
            }
            mh$.invokeExact(material, mapType, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetModelMeshMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetModelMeshMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static FunctionDescriptor SetModelMeshMaterial$descriptor() {
        return SetModelMeshMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static MethodHandle SetModelMeshMaterial$handle() {
        return SetModelMeshMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static MemorySegment SetModelMeshMaterial$address() {
        return SetModelMeshMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static void SetModelMeshMaterial(MemorySegment model, int meshId, int materialId) {
        var mh$ = SetModelMeshMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetModelMeshMaterial", model, meshId, materialId);
            }
            mh$.invokeExact(model, meshId, materialId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModelAnimations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModelAnimations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static FunctionDescriptor LoadModelAnimations$descriptor() {
        return LoadModelAnimations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MethodHandle LoadModelAnimations$handle() {
        return LoadModelAnimations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MemorySegment LoadModelAnimations$address() {
        return LoadModelAnimations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MemorySegment LoadModelAnimations(MemorySegment fileName, MemorySegment animCount) {
        var mh$ = LoadModelAnimations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModelAnimations", fileName, animCount);
            }
            return (MemorySegment)mh$.invokeExact(fileName, animCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateModelAnimation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            ModelAnimation.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateModelAnimation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static FunctionDescriptor UpdateModelAnimation$descriptor() {
        return UpdateModelAnimation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static MethodHandle UpdateModelAnimation$handle() {
        return UpdateModelAnimation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static MemorySegment UpdateModelAnimation$address() {
        return UpdateModelAnimation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static void UpdateModelAnimation(MemorySegment model, MemorySegment anim, int frame) {
        var mh$ = UpdateModelAnimation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateModelAnimation", model, anim, frame);
            }
            mh$.invokeExact(model, anim, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModelAnimation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ModelAnimation.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModelAnimation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static FunctionDescriptor UnloadModelAnimation$descriptor() {
        return UnloadModelAnimation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static MethodHandle UnloadModelAnimation$handle() {
        return UnloadModelAnimation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static MemorySegment UnloadModelAnimation$address() {
        return UnloadModelAnimation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static void UnloadModelAnimation(MemorySegment anim) {
        var mh$ = UnloadModelAnimation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModelAnimation", anim);
            }
            mh$.invokeExact(anim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModelAnimations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModelAnimations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static FunctionDescriptor UnloadModelAnimations$descriptor() {
        return UnloadModelAnimations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static MethodHandle UnloadModelAnimations$handle() {
        return UnloadModelAnimations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static MemorySegment UnloadModelAnimations$address() {
        return UnloadModelAnimations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static void UnloadModelAnimations(MemorySegment animations, int animCount) {
        var mh$ = UnloadModelAnimations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModelAnimations", animations, animCount);
            }
            mh$.invokeExact(animations, animCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsModelAnimationValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Model.layout(),
            ModelAnimation.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsModelAnimationValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static FunctionDescriptor IsModelAnimationValid$descriptor() {
        return IsModelAnimationValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static MethodHandle IsModelAnimationValid$handle() {
        return IsModelAnimationValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static MemorySegment IsModelAnimationValid$address() {
        return IsModelAnimationValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static boolean IsModelAnimationValid(MemorySegment model, MemorySegment anim) {
        var mh$ = IsModelAnimationValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsModelAnimationValid", model, anim);
            }
            return (boolean)mh$.invokeExact(model, anim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionSpheres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionSpheres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static FunctionDescriptor CheckCollisionSpheres$descriptor() {
        return CheckCollisionSpheres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static MethodHandle CheckCollisionSpheres$handle() {
        return CheckCollisionSpheres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static MemorySegment CheckCollisionSpheres$address() {
        return CheckCollisionSpheres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static boolean CheckCollisionSpheres(MemorySegment center1, float radius1, MemorySegment center2, float radius2) {
        var mh$ = CheckCollisionSpheres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionSpheres", center1, radius1, center2, radius2);
            }
            return (boolean)mh$.invokeExact(center1, radius1, center2, radius2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionBoxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            BoundingBox.layout(),
            BoundingBox.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionBoxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static FunctionDescriptor CheckCollisionBoxes$descriptor() {
        return CheckCollisionBoxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static MethodHandle CheckCollisionBoxes$handle() {
        return CheckCollisionBoxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static MemorySegment CheckCollisionBoxes$address() {
        return CheckCollisionBoxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static boolean CheckCollisionBoxes(MemorySegment box1, MemorySegment box2) {
        var mh$ = CheckCollisionBoxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionBoxes", box1, box2);
            }
            return (boolean)mh$.invokeExact(box1, box2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionBoxSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            BoundingBox.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionBoxSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static FunctionDescriptor CheckCollisionBoxSphere$descriptor() {
        return CheckCollisionBoxSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static MethodHandle CheckCollisionBoxSphere$handle() {
        return CheckCollisionBoxSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static MemorySegment CheckCollisionBoxSphere$address() {
        return CheckCollisionBoxSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static boolean CheckCollisionBoxSphere(MemorySegment box, MemorySegment center, float radius) {
        var mh$ = CheckCollisionBoxSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionBoxSphere", box, center, radius);
            }
            return (boolean)mh$.invokeExact(box, center, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static FunctionDescriptor GetRayCollisionSphere$descriptor() {
        return GetRayCollisionSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MethodHandle GetRayCollisionSphere$handle() {
        return GetRayCollisionSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MemorySegment GetRayCollisionSphere$address() {
        return GetRayCollisionSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MemorySegment GetRayCollisionSphere(SegmentAllocator allocator, MemorySegment ray, MemorySegment center, float radius) {
        var mh$ = GetRayCollisionSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionSphere", allocator, ray, center, radius);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, center, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            BoundingBox.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static FunctionDescriptor GetRayCollisionBox$descriptor() {
        return GetRayCollisionBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MethodHandle GetRayCollisionBox$handle() {
        return GetRayCollisionBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MemorySegment GetRayCollisionBox$address() {
        return GetRayCollisionBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MemorySegment GetRayCollisionBox(SegmentAllocator allocator, MemorySegment ray, MemorySegment box) {
        var mh$ = GetRayCollisionBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionBox", allocator, ray, box);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Mesh.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static FunctionDescriptor GetRayCollisionMesh$descriptor() {
        return GetRayCollisionMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MethodHandle GetRayCollisionMesh$handle() {
        return GetRayCollisionMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MemorySegment GetRayCollisionMesh$address() {
        return GetRayCollisionMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MemorySegment GetRayCollisionMesh(SegmentAllocator allocator, MemorySegment ray, MemorySegment mesh, MemorySegment transform) {
        var mh$ = GetRayCollisionMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionMesh", allocator, ray, mesh, transform);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, mesh, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionTriangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionTriangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static FunctionDescriptor GetRayCollisionTriangle$descriptor() {
        return GetRayCollisionTriangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MethodHandle GetRayCollisionTriangle$handle() {
        return GetRayCollisionTriangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MemorySegment GetRayCollisionTriangle$address() {
        return GetRayCollisionTriangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MemorySegment GetRayCollisionTriangle(SegmentAllocator allocator, MemorySegment ray, MemorySegment p1, MemorySegment p2, MemorySegment p3) {
        var mh$ = GetRayCollisionTriangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionTriangle", allocator, ray, p1, p2, p3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, p1, p2, p3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static FunctionDescriptor GetRayCollisionQuad$descriptor() {
        return GetRayCollisionQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MethodHandle GetRayCollisionQuad$handle() {
        return GetRayCollisionQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MemorySegment GetRayCollisionQuad$address() {
        return GetRayCollisionQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MemorySegment GetRayCollisionQuad(SegmentAllocator allocator, MemorySegment ray, MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4) {
        var mh$ = GetRayCollisionQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionQuad", allocator, ray, p1, p2, p3, p4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, p1, p2, p3, p4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitAudioDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("InitAudioDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static FunctionDescriptor InitAudioDevice$descriptor() {
        return InitAudioDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static MethodHandle InitAudioDevice$handle() {
        return InitAudioDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static MemorySegment InitAudioDevice$address() {
        return InitAudioDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static void InitAudioDevice() {
        var mh$ = InitAudioDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitAudioDevice");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseAudioDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("CloseAudioDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static FunctionDescriptor CloseAudioDevice$descriptor() {
        return CloseAudioDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static MethodHandle CloseAudioDevice$handle() {
        return CloseAudioDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static MemorySegment CloseAudioDevice$address() {
        return CloseAudioDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static void CloseAudioDevice() {
        var mh$ = CloseAudioDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseAudioDevice");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioDeviceReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioDeviceReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static FunctionDescriptor IsAudioDeviceReady$descriptor() {
        return IsAudioDeviceReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static MethodHandle IsAudioDeviceReady$handle() {
        return IsAudioDeviceReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static MemorySegment IsAudioDeviceReady$address() {
        return IsAudioDeviceReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static boolean IsAudioDeviceReady() {
        var mh$ = IsAudioDeviceReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioDeviceReady");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMasterVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMasterVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static FunctionDescriptor SetMasterVolume$descriptor() {
        return SetMasterVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static MethodHandle SetMasterVolume$handle() {
        return SetMasterVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static MemorySegment SetMasterVolume$address() {
        return SetMasterVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static void SetMasterVolume(float volume) {
        var mh$ = SetMasterVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMasterVolume", volume);
            }
            mh$.invokeExact(volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMasterVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMasterVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static FunctionDescriptor GetMasterVolume$descriptor() {
        return GetMasterVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static MethodHandle GetMasterVolume$handle() {
        return GetMasterVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static MemorySegment GetMasterVolume$address() {
        return GetMasterVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static float GetMasterVolume() {
        var mh$ = GetMasterVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMasterVolume");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadWave$descriptor() {
        return LoadWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MethodHandle LoadWave$handle() {
        return LoadWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MemorySegment LoadWave$address() {
        return LoadWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MemorySegment LoadWave(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWave", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWaveFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWaveFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static FunctionDescriptor LoadWaveFromMemory$descriptor() {
        return LoadWaveFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MethodHandle LoadWaveFromMemory$handle() {
        return LoadWaveFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadWaveFromMemory$address() {
        return LoadWaveFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadWaveFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize) {
        var mh$ = LoadWaveFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWaveFromMemory", allocator, fileType, fileData, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWaveReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWaveReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static FunctionDescriptor IsWaveReady$descriptor() {
        return IsWaveReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static MethodHandle IsWaveReady$handle() {
        return IsWaveReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static MemorySegment IsWaveReady$address() {
        return IsWaveReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static boolean IsWaveReady(MemorySegment wave) {
        var mh$ = IsWaveReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWaveReady", wave);
            }
            return (boolean)mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadSound$descriptor() {
        return LoadSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MethodHandle LoadSound$handle() {
        return LoadSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MemorySegment LoadSound$address() {
        return LoadSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MemorySegment LoadSound(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSound", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSoundFromWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSoundFromWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static FunctionDescriptor LoadSoundFromWave$descriptor() {
        return LoadSoundFromWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MethodHandle LoadSoundFromWave$handle() {
        return LoadSoundFromWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MemorySegment LoadSoundFromWave$address() {
        return LoadSoundFromWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MemorySegment LoadSoundFromWave(SegmentAllocator allocator, MemorySegment wave) {
        var mh$ = LoadSoundFromWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSoundFromWave", allocator, wave);
            }
            return (MemorySegment)mh$.invokeExact(allocator, wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSoundAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSoundAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static FunctionDescriptor LoadSoundAlias$descriptor() {
        return LoadSoundAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MethodHandle LoadSoundAlias$handle() {
        return LoadSoundAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MemorySegment LoadSoundAlias$address() {
        return LoadSoundAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MemorySegment LoadSoundAlias(SegmentAllocator allocator, MemorySegment source) {
        var mh$ = LoadSoundAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSoundAlias", allocator, source);
            }
            return (MemorySegment)mh$.invokeExact(allocator, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSoundReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsSoundReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static FunctionDescriptor IsSoundReady$descriptor() {
        return IsSoundReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static MethodHandle IsSoundReady$handle() {
        return IsSoundReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static MemorySegment IsSoundReady$address() {
        return IsSoundReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static boolean IsSoundReady(MemorySegment sound) {
        var mh$ = IsSoundReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSoundReady", sound);
            }
            return (boolean)mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static FunctionDescriptor UpdateSound$descriptor() {
        return UpdateSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static MethodHandle UpdateSound$handle() {
        return UpdateSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static MemorySegment UpdateSound$address() {
        return UpdateSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static void UpdateSound(MemorySegment sound, MemorySegment data, int sampleCount) {
        var mh$ = UpdateSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateSound", sound, data, sampleCount);
            }
            mh$.invokeExact(sound, data, sampleCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static FunctionDescriptor UnloadWave$descriptor() {
        return UnloadWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static MethodHandle UnloadWave$handle() {
        return UnloadWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static MemorySegment UnloadWave$address() {
        return UnloadWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static void UnloadWave(MemorySegment wave) {
        var mh$ = UnloadWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadWave", wave);
            }
            mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static FunctionDescriptor UnloadSound$descriptor() {
        return UnloadSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static MethodHandle UnloadSound$handle() {
        return UnloadSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static MemorySegment UnloadSound$address() {
        return UnloadSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static void UnloadSound(MemorySegment sound) {
        var mh$ = UnloadSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadSoundAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadSoundAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static FunctionDescriptor UnloadSoundAlias$descriptor() {
        return UnloadSoundAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static MethodHandle UnloadSoundAlias$handle() {
        return UnloadSoundAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static MemorySegment UnloadSoundAlias$address() {
        return UnloadSoundAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static void UnloadSoundAlias(MemorySegment alias) {
        var mh$ = UnloadSoundAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadSoundAlias", alias);
            }
            mh$.invokeExact(alias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportWave$descriptor() {
        return ExportWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static MethodHandle ExportWave$handle() {
        return ExportWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static MemorySegment ExportWave$address() {
        return ExportWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static boolean ExportWave(MemorySegment wave, MemorySegment fileName) {
        var mh$ = ExportWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportWave", wave, fileName);
            }
            return (boolean)mh$.invokeExact(wave, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportWaveAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportWaveAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportWaveAsCode$descriptor() {
        return ExportWaveAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static MethodHandle ExportWaveAsCode$handle() {
        return ExportWaveAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static MemorySegment ExportWaveAsCode$address() {
        return ExportWaveAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static boolean ExportWaveAsCode(MemorySegment wave, MemorySegment fileName) {
        var mh$ = ExportWaveAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportWaveAsCode", wave, fileName);
            }
            return (boolean)mh$.invokeExact(wave, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlaySound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlaySound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static FunctionDescriptor PlaySound$descriptor() {
        return PlaySound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static MethodHandle PlaySound$handle() {
        return PlaySound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static MemorySegment PlaySound$address() {
        return PlaySound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static void PlaySound(MemorySegment sound) {
        var mh$ = PlaySound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlaySound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static FunctionDescriptor StopSound$descriptor() {
        return StopSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static MethodHandle StopSound$handle() {
        return StopSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static MemorySegment StopSound$address() {
        return StopSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static void StopSound(MemorySegment sound) {
        var mh$ = StopSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static FunctionDescriptor PauseSound$descriptor() {
        return PauseSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static MethodHandle PauseSound$handle() {
        return PauseSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static MemorySegment PauseSound$address() {
        return PauseSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static void PauseSound(MemorySegment sound) {
        var mh$ = PauseSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static FunctionDescriptor ResumeSound$descriptor() {
        return ResumeSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static MethodHandle ResumeSound$handle() {
        return ResumeSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static MemorySegment ResumeSound$address() {
        return ResumeSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static void ResumeSound(MemorySegment sound) {
        var mh$ = ResumeSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSoundPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsSoundPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static FunctionDescriptor IsSoundPlaying$descriptor() {
        return IsSoundPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static MethodHandle IsSoundPlaying$handle() {
        return IsSoundPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static MemorySegment IsSoundPlaying$address() {
        return IsSoundPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static boolean IsSoundPlaying(MemorySegment sound) {
        var mh$ = IsSoundPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSoundPlaying", sound);
            }
            return (boolean)mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static FunctionDescriptor SetSoundVolume$descriptor() {
        return SetSoundVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static MethodHandle SetSoundVolume$handle() {
        return SetSoundVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static MemorySegment SetSoundVolume$address() {
        return SetSoundVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static void SetSoundVolume(MemorySegment sound, float volume) {
        var mh$ = SetSoundVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundVolume", sound, volume);
            }
            mh$.invokeExact(sound, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static FunctionDescriptor SetSoundPitch$descriptor() {
        return SetSoundPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static MethodHandle SetSoundPitch$handle() {
        return SetSoundPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static MemorySegment SetSoundPitch$address() {
        return SetSoundPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static void SetSoundPitch(MemorySegment sound, float pitch) {
        var mh$ = SetSoundPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundPitch", sound, pitch);
            }
            mh$.invokeExact(sound, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static FunctionDescriptor SetSoundPan$descriptor() {
        return SetSoundPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static MethodHandle SetSoundPan$handle() {
        return SetSoundPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static MemorySegment SetSoundPan$address() {
        return SetSoundPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static void SetSoundPan(MemorySegment sound, float pan) {
        var mh$ = SetSoundPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundPan", sound, pan);
            }
            mh$.invokeExact(sound, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static FunctionDescriptor WaveCopy$descriptor() {
        return WaveCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MethodHandle WaveCopy$handle() {
        return WaveCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MemorySegment WaveCopy$address() {
        return WaveCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MemorySegment WaveCopy(SegmentAllocator allocator, MemorySegment wave) {
        var mh$ = WaveCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveCopy", allocator, wave);
            }
            return (MemorySegment)mh$.invokeExact(allocator, wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveCrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveCrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static FunctionDescriptor WaveCrop$descriptor() {
        return WaveCrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static MethodHandle WaveCrop$handle() {
        return WaveCrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static MemorySegment WaveCrop$address() {
        return WaveCrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static void WaveCrop(MemorySegment wave, int initSample, int finalSample) {
        var mh$ = WaveCrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveCrop", wave, initSample, finalSample);
            }
            mh$.invokeExact(wave, initSample, finalSample);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static FunctionDescriptor WaveFormat$descriptor() {
        return WaveFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static MethodHandle WaveFormat$handle() {
        return WaveFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static MemorySegment WaveFormat$address() {
        return WaveFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static void WaveFormat(MemorySegment wave, int sampleRate, int sampleSize, int channels) {
        var mh$ = WaveFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveFormat", wave, sampleRate, sampleSize, channels);
            }
            mh$.invokeExact(wave, sampleRate, sampleSize, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWaveSamples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWaveSamples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static FunctionDescriptor LoadWaveSamples$descriptor() {
        return LoadWaveSamples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MethodHandle LoadWaveSamples$handle() {
        return LoadWaveSamples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MemorySegment LoadWaveSamples$address() {
        return LoadWaveSamples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MemorySegment LoadWaveSamples(MemorySegment wave) {
        var mh$ = LoadWaveSamples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWaveSamples", wave);
            }
            return (MemorySegment)mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadWaveSamples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadWaveSamples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static FunctionDescriptor UnloadWaveSamples$descriptor() {
        return UnloadWaveSamples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static MethodHandle UnloadWaveSamples$handle() {
        return UnloadWaveSamples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static MemorySegment UnloadWaveSamples$address() {
        return UnloadWaveSamples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static void UnloadWaveSamples(MemorySegment samples) {
        var mh$ = UnloadWaveSamples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadWaveSamples", samples);
            }
            mh$.invokeExact(samples);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Music.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadMusicStream$descriptor() {
        return LoadMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MethodHandle LoadMusicStream$handle() {
        return LoadMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MemorySegment LoadMusicStream$address() {
        return LoadMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MemorySegment LoadMusicStream(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMusicStream", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMusicStreamFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Music.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMusicStreamFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static FunctionDescriptor LoadMusicStreamFromMemory$descriptor() {
        return LoadMusicStreamFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MethodHandle LoadMusicStreamFromMemory$handle() {
        return LoadMusicStreamFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MemorySegment LoadMusicStreamFromMemory$address() {
        return LoadMusicStreamFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MemorySegment LoadMusicStreamFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment data, int dataSize) {
        var mh$ = LoadMusicStreamFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMusicStreamFromMemory", allocator, fileType, data, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, data, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMusicReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMusicReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static FunctionDescriptor IsMusicReady$descriptor() {
        return IsMusicReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static MethodHandle IsMusicReady$handle() {
        return IsMusicReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static MemorySegment IsMusicReady$address() {
        return IsMusicReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static boolean IsMusicReady(MemorySegment music) {
        var mh$ = IsMusicReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMusicReady", music);
            }
            return (boolean)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor UnloadMusicStream$descriptor() {
        return UnloadMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static MethodHandle UnloadMusicStream$handle() {
        return UnloadMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static MemorySegment UnloadMusicStream$address() {
        return UnloadMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static void UnloadMusicStream(MemorySegment music) {
        var mh$ = UnloadMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlayMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor PlayMusicStream$descriptor() {
        return PlayMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static MethodHandle PlayMusicStream$handle() {
        return PlayMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static MemorySegment PlayMusicStream$address() {
        return PlayMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static void PlayMusicStream(MemorySegment music) {
        var mh$ = PlayMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMusicStreamPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMusicStreamPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static FunctionDescriptor IsMusicStreamPlaying$descriptor() {
        return IsMusicStreamPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static MethodHandle IsMusicStreamPlaying$handle() {
        return IsMusicStreamPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static MemorySegment IsMusicStreamPlaying$address() {
        return IsMusicStreamPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static boolean IsMusicStreamPlaying(MemorySegment music) {
        var mh$ = IsMusicStreamPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMusicStreamPlaying", music);
            }
            return (boolean)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor UpdateMusicStream$descriptor() {
        return UpdateMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static MethodHandle UpdateMusicStream$handle() {
        return UpdateMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static MemorySegment UpdateMusicStream$address() {
        return UpdateMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static void UpdateMusicStream(MemorySegment music) {
        var mh$ = UpdateMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor StopMusicStream$descriptor() {
        return StopMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static MethodHandle StopMusicStream$handle() {
        return StopMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static MemorySegment StopMusicStream$address() {
        return StopMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static void StopMusicStream(MemorySegment music) {
        var mh$ = StopMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor PauseMusicStream$descriptor() {
        return PauseMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static MethodHandle PauseMusicStream$handle() {
        return PauseMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static MemorySegment PauseMusicStream$address() {
        return PauseMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static void PauseMusicStream(MemorySegment music) {
        var mh$ = PauseMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor ResumeMusicStream$descriptor() {
        return ResumeMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static MethodHandle ResumeMusicStream$handle() {
        return ResumeMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static MemorySegment ResumeMusicStream$address() {
        return ResumeMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static void ResumeMusicStream(MemorySegment music) {
        var mh$ = ResumeMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SeekMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SeekMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static FunctionDescriptor SeekMusicStream$descriptor() {
        return SeekMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static MethodHandle SeekMusicStream$handle() {
        return SeekMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static MemorySegment SeekMusicStream$address() {
        return SeekMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static void SeekMusicStream(MemorySegment music, float position) {
        var mh$ = SeekMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SeekMusicStream", music, position);
            }
            mh$.invokeExact(music, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static FunctionDescriptor SetMusicVolume$descriptor() {
        return SetMusicVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static MethodHandle SetMusicVolume$handle() {
        return SetMusicVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static MemorySegment SetMusicVolume$address() {
        return SetMusicVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static void SetMusicVolume(MemorySegment music, float volume) {
        var mh$ = SetMusicVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicVolume", music, volume);
            }
            mh$.invokeExact(music, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static FunctionDescriptor SetMusicPitch$descriptor() {
        return SetMusicPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static MethodHandle SetMusicPitch$handle() {
        return SetMusicPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static MemorySegment SetMusicPitch$address() {
        return SetMusicPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static void SetMusicPitch(MemorySegment music, float pitch) {
        var mh$ = SetMusicPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicPitch", music, pitch);
            }
            mh$.invokeExact(music, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static FunctionDescriptor SetMusicPan$descriptor() {
        return SetMusicPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static MethodHandle SetMusicPan$handle() {
        return SetMusicPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static MemorySegment SetMusicPan$address() {
        return SetMusicPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static void SetMusicPan(MemorySegment music, float pan) {
        var mh$ = SetMusicPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicPan", music, pan);
            }
            mh$.invokeExact(music, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMusicTimeLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMusicTimeLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static FunctionDescriptor GetMusicTimeLength$descriptor() {
        return GetMusicTimeLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static MethodHandle GetMusicTimeLength$handle() {
        return GetMusicTimeLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static MemorySegment GetMusicTimeLength$address() {
        return GetMusicTimeLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static float GetMusicTimeLength(MemorySegment music) {
        var mh$ = GetMusicTimeLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMusicTimeLength", music);
            }
            return (float)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMusicTimePlayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMusicTimePlayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static FunctionDescriptor GetMusicTimePlayed$descriptor() {
        return GetMusicTimePlayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static MethodHandle GetMusicTimePlayed$handle() {
        return GetMusicTimePlayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static MemorySegment GetMusicTimePlayed$address() {
        return GetMusicTimePlayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static float GetMusicTimePlayed(MemorySegment music) {
        var mh$ = GetMusicTimePlayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMusicTimePlayed", music);
            }
            return (float)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AudioStream.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static FunctionDescriptor LoadAudioStream$descriptor() {
        return LoadAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MethodHandle LoadAudioStream$handle() {
        return LoadAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MemorySegment LoadAudioStream$address() {
        return LoadAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MemorySegment LoadAudioStream(SegmentAllocator allocator, int sampleRate, int sampleSize, int channels) {
        var mh$ = LoadAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAudioStream", allocator, sampleRate, sampleSize, channels);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sampleRate, sampleSize, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamReady$descriptor() {
        return IsAudioStreamReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamReady$handle() {
        return IsAudioStreamReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamReady$address() {
        return IsAudioStreamReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamReady(MemorySegment stream) {
        var mh$ = IsAudioStreamReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamReady", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor UnloadAudioStream$descriptor() {
        return UnloadAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle UnloadAudioStream$handle() {
        return UnloadAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment UnloadAudioStream$address() {
        return UnloadAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static void UnloadAudioStream(MemorySegment stream) {
        var mh$ = UnloadAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static FunctionDescriptor UpdateAudioStream$descriptor() {
        return UpdateAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static MethodHandle UpdateAudioStream$handle() {
        return UpdateAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static MemorySegment UpdateAudioStream$address() {
        return UpdateAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static void UpdateAudioStream(MemorySegment stream, MemorySegment data, int frameCount) {
        var mh$ = UpdateAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateAudioStream", stream, data, frameCount);
            }
            mh$.invokeExact(stream, data, frameCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamProcessed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamProcessed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamProcessed$descriptor() {
        return IsAudioStreamProcessed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamProcessed$handle() {
        return IsAudioStreamProcessed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamProcessed$address() {
        return IsAudioStreamProcessed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamProcessed(MemorySegment stream) {
        var mh$ = IsAudioStreamProcessed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamProcessed", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlayAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor PlayAudioStream$descriptor() {
        return PlayAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle PlayAudioStream$handle() {
        return PlayAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment PlayAudioStream$address() {
        return PlayAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static void PlayAudioStream(MemorySegment stream) {
        var mh$ = PlayAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor PauseAudioStream$descriptor() {
        return PauseAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle PauseAudioStream$handle() {
        return PauseAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment PauseAudioStream$address() {
        return PauseAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static void PauseAudioStream(MemorySegment stream) {
        var mh$ = PauseAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor ResumeAudioStream$descriptor() {
        return ResumeAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle ResumeAudioStream$handle() {
        return ResumeAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment ResumeAudioStream$address() {
        return ResumeAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static void ResumeAudioStream(MemorySegment stream) {
        var mh$ = ResumeAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamPlaying$descriptor() {
        return IsAudioStreamPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamPlaying$handle() {
        return IsAudioStreamPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamPlaying$address() {
        return IsAudioStreamPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamPlaying(MemorySegment stream) {
        var mh$ = IsAudioStreamPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamPlaying", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor StopAudioStream$descriptor() {
        return StopAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle StopAudioStream$handle() {
        return StopAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment StopAudioStream$address() {
        return StopAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static void StopAudioStream(MemorySegment stream) {
        var mh$ = StopAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static FunctionDescriptor SetAudioStreamVolume$descriptor() {
        return SetAudioStreamVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static MethodHandle SetAudioStreamVolume$handle() {
        return SetAudioStreamVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static MemorySegment SetAudioStreamVolume$address() {
        return SetAudioStreamVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static void SetAudioStreamVolume(MemorySegment stream, float volume) {
        var mh$ = SetAudioStreamVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamVolume", stream, volume);
            }
            mh$.invokeExact(stream, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static FunctionDescriptor SetAudioStreamPitch$descriptor() {
        return SetAudioStreamPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static MethodHandle SetAudioStreamPitch$handle() {
        return SetAudioStreamPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static MemorySegment SetAudioStreamPitch$address() {
        return SetAudioStreamPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static void SetAudioStreamPitch(MemorySegment stream, float pitch) {
        var mh$ = SetAudioStreamPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamPitch", stream, pitch);
            }
            mh$.invokeExact(stream, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static FunctionDescriptor SetAudioStreamPan$descriptor() {
        return SetAudioStreamPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static MethodHandle SetAudioStreamPan$handle() {
        return SetAudioStreamPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static MemorySegment SetAudioStreamPan$address() {
        return SetAudioStreamPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static void SetAudioStreamPan(MemorySegment stream, float pan) {
        var mh$ = SetAudioStreamPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamPan", stream, pan);
            }
            mh$.invokeExact(stream, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamBufferSizeDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamBufferSizeDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static FunctionDescriptor SetAudioStreamBufferSizeDefault$descriptor() {
        return SetAudioStreamBufferSizeDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static MethodHandle SetAudioStreamBufferSizeDefault$handle() {
        return SetAudioStreamBufferSizeDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static MemorySegment SetAudioStreamBufferSizeDefault$address() {
        return SetAudioStreamBufferSizeDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static void SetAudioStreamBufferSizeDefault(int size) {
        var mh$ = SetAudioStreamBufferSizeDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamBufferSizeDefault", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static FunctionDescriptor SetAudioStreamCallback$descriptor() {
        return SetAudioStreamCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static MethodHandle SetAudioStreamCallback$handle() {
        return SetAudioStreamCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static MemorySegment SetAudioStreamCallback$address() {
        return SetAudioStreamCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static void SetAudioStreamCallback(MemorySegment stream, MemorySegment callback) {
        var mh$ = SetAudioStreamCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamCallback", stream, callback);
            }
            mh$.invokeExact(stream, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachAudioStreamProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("AttachAudioStreamProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static FunctionDescriptor AttachAudioStreamProcessor$descriptor() {
        return AttachAudioStreamProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MethodHandle AttachAudioStreamProcessor$handle() {
        return AttachAudioStreamProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MemorySegment AttachAudioStreamProcessor$address() {
        return AttachAudioStreamProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static void AttachAudioStreamProcessor(MemorySegment stream, MemorySegment processor) {
        var mh$ = AttachAudioStreamProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachAudioStreamProcessor", stream, processor);
            }
            mh$.invokeExact(stream, processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DetachAudioStreamProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DetachAudioStreamProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static FunctionDescriptor DetachAudioStreamProcessor$descriptor() {
        return DetachAudioStreamProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MethodHandle DetachAudioStreamProcessor$handle() {
        return DetachAudioStreamProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MemorySegment DetachAudioStreamProcessor$address() {
        return DetachAudioStreamProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static void DetachAudioStreamProcessor(MemorySegment stream, MemorySegment processor) {
        var mh$ = DetachAudioStreamProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DetachAudioStreamProcessor", stream, processor);
            }
            mh$.invokeExact(stream, processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachAudioMixedProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("AttachAudioMixedProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static FunctionDescriptor AttachAudioMixedProcessor$descriptor() {
        return AttachAudioMixedProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MethodHandle AttachAudioMixedProcessor$handle() {
        return AttachAudioMixedProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MemorySegment AttachAudioMixedProcessor$address() {
        return AttachAudioMixedProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static void AttachAudioMixedProcessor(MemorySegment processor) {
        var mh$ = AttachAudioMixedProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachAudioMixedProcessor", processor);
            }
            mh$.invokeExact(processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DetachAudioMixedProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DetachAudioMixedProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static FunctionDescriptor DetachAudioMixedProcessor$descriptor() {
        return DetachAudioMixedProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MethodHandle DetachAudioMixedProcessor$handle() {
        return DetachAudioMixedProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MemorySegment DetachAudioMixedProcessor$address() {
        return DetachAudioMixedProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static void DetachAudioMixedProcessor(MemorySegment processor) {
        var mh$ = DetachAudioMixedProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DetachAudioMixedProcessor", processor);
            }
            mh$.invokeExact(processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModel$descriptor() {
        return VyDrawModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModel$handle() {
        return VyDrawModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModel$address() {
        return VyDrawModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static void VyDrawModel(MemorySegment vyModel, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = VyDrawModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModel", vyModel, position, scale, tint);
            }
            mh$.invokeExact(vyModel, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModelEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModelEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModelEx$descriptor() {
        return VyDrawModelEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModelEx$handle() {
        return VyDrawModelEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModelEx$address() {
        return VyDrawModelEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void VyDrawModelEx(MemorySegment vyModel, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = VyDrawModelEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModelEx", vyModel, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(vyModel, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModelExQuat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            Vector4.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModelExQuat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModelExQuat$descriptor() {
        return VyDrawModelExQuat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModelExQuat$handle() {
        return VyDrawModelExQuat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModelExQuat$address() {
        return VyDrawModelExQuat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static void VyDrawModelExQuat(MemorySegment vyModel, MemorySegment position, MemorySegment quaternion, MemorySegment scale, MemorySegment tint) {
        var mh$ = VyDrawModelExQuat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModelExQuat", vyModel, position, quaternion, scale, tint);
            }
            mh$.invokeExact(vyModel, position, quaternion, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyBeginMode3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyCamera.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyBeginMode3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static FunctionDescriptor VyBeginMode3D$descriptor() {
        return VyBeginMode3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static MethodHandle VyBeginMode3D$handle() {
        return VyBeginMode3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static MemorySegment VyBeginMode3D$address() {
        return VyBeginMode3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static void VyBeginMode3D(MemorySegment camera) {
        var mh$ = VyBeginMode3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyBeginMode3D", camera);
            }
            mh$.invokeExact(camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyQuaternionToAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyQuaternionToAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static FunctionDescriptor VyQuaternionToAxisAngle$descriptor() {
        return VyQuaternionToAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static MethodHandle VyQuaternionToAxisAngle$handle() {
        return VyQuaternionToAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisAngle$address() {
        return VyQuaternionToAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static float VyQuaternionToAxisAngle(MemorySegment q) {
        var mh$ = VyQuaternionToAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyQuaternionToAxisAngle", q);
            }
            return (float)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyQuaternionToAxisVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyQuaternionToAxisVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static FunctionDescriptor VyQuaternionToAxisVector$descriptor() {
        return VyQuaternionToAxisVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MethodHandle VyQuaternionToAxisVector$handle() {
        return VyQuaternionToAxisVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisVector$address() {
        return VyQuaternionToAxisVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisVector(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = VyQuaternionToAxisVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyQuaternionToAxisVector", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGetScreenToWorldRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            VyCamera.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGetScreenToWorldRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static FunctionDescriptor VyGetScreenToWorldRay$descriptor() {
        return VyGetScreenToWorldRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MethodHandle VyGetScreenToWorldRay$handle() {
        return VyGetScreenToWorldRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRay$address() {
        return VyGetScreenToWorldRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRay(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = VyGetScreenToWorldRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGetScreenToWorldRay", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGetScreenToWorldRayEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            VyCamera.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGetScreenToWorldRayEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static FunctionDescriptor VyGetScreenToWorldRayEx$descriptor() {
        return VyGetScreenToWorldRayEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MethodHandle VyGetScreenToWorldRayEx$handle() {
        return VyGetScreenToWorldRayEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRayEx$address() {
        return VyGetScreenToWorldRayEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRayEx(SegmentAllocator allocator, MemorySegment position, MemorySegment camera, int width, int height) {
        var mh$ = VyGetScreenToWorldRayEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGetScreenToWorldRayEx", allocator, position, camera, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            VyShaderParameters.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveParameters$descriptor() {
        return VyGlGetActiveParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveParameters$handle() {
        return VyGlGetActiveParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveParameters$address() {
        return VyGlGetActiveParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveParameters(SegmentAllocator allocator, int id) {
        var mh$ = VyGlGetActiveParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveParameters", allocator, id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveUniformsCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveUniformsCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveUniformsCount$descriptor() {
        return VyGlGetActiveUniformsCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveUniformsCount$handle() {
        return VyGlGetActiveUniformsCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveUniformsCount$address() {
        return VyGlGetActiveUniformsCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static int VyGlGetActiveUniformsCount(int id) {
        var mh$ = VyGlGetActiveUniformsCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveUniformsCount", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveAttributesCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveAttributesCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveAttributesCount$descriptor() {
        return VyGlGetActiveAttributesCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveAttributesCount$handle() {
        return VyGlGetActiveAttributesCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveAttributesCount$address() {
        return VyGlGetActiveAttributesCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static int VyGlGetActiveAttributesCount(int id) {
        var mh$ = VyGlGetActiveAttributesCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveAttributesCount", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RL_OPENGL_11 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_11 = 1
     * }
     */
    public static int RL_OPENGL_11() {
        return RL_OPENGL_11;
    }
    private static final int RL_OPENGL_21 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_21 = 2
     * }
     */
    public static int RL_OPENGL_21() {
        return RL_OPENGL_21;
    }
    private static final int RL_OPENGL_33 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_33 = 3
     * }
     */
    public static int RL_OPENGL_33() {
        return RL_OPENGL_33;
    }
    private static final int RL_OPENGL_43 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_43 = 4
     * }
     */
    public static int RL_OPENGL_43() {
        return RL_OPENGL_43;
    }
    private static final int RL_OPENGL_ES_20 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_ES_20 = 5
     * }
     */
    public static int RL_OPENGL_ES_20() {
        return RL_OPENGL_ES_20;
    }
    private static final int RL_OPENGL_ES_30 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_ES_30 = 6
     * }
     */
    public static int RL_OPENGL_ES_30() {
        return RL_OPENGL_ES_30;
    }
    private static final int RL_LOG_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_ALL = 0
     * }
     */
    public static int RL_LOG_ALL() {
        return RL_LOG_ALL;
    }
    private static final int RL_LOG_TRACE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_TRACE = 1
     * }
     */
    public static int RL_LOG_TRACE() {
        return RL_LOG_TRACE;
    }
    private static final int RL_LOG_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_DEBUG = 2
     * }
     */
    public static int RL_LOG_DEBUG() {
        return RL_LOG_DEBUG;
    }
    private static final int RL_LOG_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_INFO = 3
     * }
     */
    public static int RL_LOG_INFO() {
        return RL_LOG_INFO;
    }
    private static final int RL_LOG_WARNING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_WARNING = 4
     * }
     */
    public static int RL_LOG_WARNING() {
        return RL_LOG_WARNING;
    }
    private static final int RL_LOG_ERROR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_ERROR = 5
     * }
     */
    public static int RL_LOG_ERROR() {
        return RL_LOG_ERROR;
    }
    private static final int RL_LOG_FATAL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_FATAL = 6
     * }
     */
    public static int RL_LOG_FATAL() {
        return RL_LOG_FATAL;
    }
    private static final int RL_LOG_NONE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_NONE = 7
     * }
     */
    public static int RL_LOG_NONE() {
        return RL_LOG_NONE;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE() {
        return RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA() {
        return RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16 = 11
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16;
    }
    private static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13
     * }
     */
    public static int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16() {
        return RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 14
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT1_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_DXT1_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 18
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC1_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_ETC1_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 19
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC2_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_ETC2_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 21
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_PVRT_RGB() {
        return RL_PIXELFORMAT_COMPRESSED_PVRT_RGB;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA;
    }
    private static final int RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24
     * }
     */
    public static int RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA() {
        return RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA;
    }
    private static final int RL_TEXTURE_FILTER_POINT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_POINT = 0
     * }
     */
    public static int RL_TEXTURE_FILTER_POINT() {
        return RL_TEXTURE_FILTER_POINT;
    }
    private static final int RL_TEXTURE_FILTER_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_BILINEAR = 1
     * }
     */
    public static int RL_TEXTURE_FILTER_BILINEAR() {
        return RL_TEXTURE_FILTER_BILINEAR;
    }
    private static final int RL_TEXTURE_FILTER_TRILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_TRILINEAR = 2
     * }
     */
    public static int RL_TEXTURE_FILTER_TRILINEAR() {
        return RL_TEXTURE_FILTER_TRILINEAR;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_4X = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_4X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_4X;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_8X = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_8X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_8X;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC_16X = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC_16X() {
        return RL_TEXTURE_FILTER_ANISOTROPIC_16X;
    }
    private static final int RL_BLEND_ALPHA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ALPHA = 0
     * }
     */
    public static int RL_BLEND_ALPHA() {
        return RL_BLEND_ALPHA;
    }
    private static final int RL_BLEND_ADDITIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ADDITIVE = 1
     * }
     */
    public static int RL_BLEND_ADDITIVE() {
        return RL_BLEND_ADDITIVE;
    }
    private static final int RL_BLEND_MULTIPLIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_MULTIPLIED = 2
     * }
     */
    public static int RL_BLEND_MULTIPLIED() {
        return RL_BLEND_MULTIPLIED;
    }
    private static final int RL_BLEND_ADD_COLORS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ADD_COLORS = 3
     * }
     */
    public static int RL_BLEND_ADD_COLORS() {
        return RL_BLEND_ADD_COLORS;
    }
    private static final int RL_BLEND_SUBTRACT_COLORS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_SUBTRACT_COLORS = 4
     * }
     */
    public static int RL_BLEND_SUBTRACT_COLORS() {
        return RL_BLEND_SUBTRACT_COLORS;
    }
    private static final int RL_BLEND_ALPHA_PREMULTIPLY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_ALPHA_PREMULTIPLY = 5
     * }
     */
    public static int RL_BLEND_ALPHA_PREMULTIPLY() {
        return RL_BLEND_ALPHA_PREMULTIPLY;
    }
    private static final int RL_BLEND_CUSTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_CUSTOM = 6
     * }
     */
    public static int RL_BLEND_CUSTOM() {
        return RL_BLEND_CUSTOM;
    }
    private static final int RL_BLEND_CUSTOM_SEPARATE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_BLEND_CUSTOM_SEPARATE = 7
     * }
     */
    public static int RL_BLEND_CUSTOM_SEPARATE() {
        return RL_BLEND_CUSTOM_SEPARATE;
    }
    private static final int RL_SHADER_LOC_VERTEX_POSITION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_POSITION = 0
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_POSITION() {
        return RL_SHADER_LOC_VERTEX_POSITION;
    }
    private static final int RL_SHADER_LOC_VERTEX_TEXCOORD01 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TEXCOORD01() {
        return RL_SHADER_LOC_VERTEX_TEXCOORD01;
    }
    private static final int RL_SHADER_LOC_VERTEX_TEXCOORD02 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TEXCOORD02() {
        return RL_SHADER_LOC_VERTEX_TEXCOORD02;
    }
    private static final int RL_SHADER_LOC_VERTEX_NORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_NORMAL = 3
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_NORMAL() {
        return RL_SHADER_LOC_VERTEX_NORMAL;
    }
    private static final int RL_SHADER_LOC_VERTEX_TANGENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_TANGENT = 4
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_TANGENT() {
        return RL_SHADER_LOC_VERTEX_TANGENT;
    }
    private static final int RL_SHADER_LOC_VERTEX_COLOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VERTEX_COLOR = 5
     * }
     */
    public static int RL_SHADER_LOC_VERTEX_COLOR() {
        return RL_SHADER_LOC_VERTEX_COLOR;
    }
    private static final int RL_SHADER_LOC_MATRIX_MVP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_MVP = 6
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_MVP() {
        return RL_SHADER_LOC_MATRIX_MVP;
    }
    private static final int RL_SHADER_LOC_MATRIX_VIEW = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_VIEW = 7
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_VIEW() {
        return RL_SHADER_LOC_MATRIX_VIEW;
    }
    private static final int RL_SHADER_LOC_MATRIX_PROJECTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_PROJECTION = 8
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_PROJECTION() {
        return RL_SHADER_LOC_MATRIX_PROJECTION;
    }
    private static final int RL_SHADER_LOC_MATRIX_MODEL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_MODEL = 9
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_MODEL() {
        return RL_SHADER_LOC_MATRIX_MODEL;
    }
    private static final int RL_SHADER_LOC_MATRIX_NORMAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MATRIX_NORMAL = 10
     * }
     */
    public static int RL_SHADER_LOC_MATRIX_NORMAL() {
        return RL_SHADER_LOC_MATRIX_NORMAL;
    }
    private static final int RL_SHADER_LOC_VECTOR_VIEW = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_VECTOR_VIEW = 11
     * }
     */
    public static int RL_SHADER_LOC_VECTOR_VIEW() {
        return RL_SHADER_LOC_VECTOR_VIEW;
    }
    private static final int RL_SHADER_LOC_COLOR_DIFFUSE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_DIFFUSE = 12
     * }
     */
    public static int RL_SHADER_LOC_COLOR_DIFFUSE() {
        return RL_SHADER_LOC_COLOR_DIFFUSE;
    }
    private static final int RL_SHADER_LOC_COLOR_SPECULAR = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_SPECULAR = 13
     * }
     */
    public static int RL_SHADER_LOC_COLOR_SPECULAR() {
        return RL_SHADER_LOC_COLOR_SPECULAR;
    }
    private static final int RL_SHADER_LOC_COLOR_AMBIENT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_COLOR_AMBIENT = 14
     * }
     */
    public static int RL_SHADER_LOC_COLOR_AMBIENT() {
        return RL_SHADER_LOC_COLOR_AMBIENT;
    }
    private static final int RL_SHADER_LOC_MAP_ALBEDO = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_ALBEDO = 15
     * }
     */
    public static int RL_SHADER_LOC_MAP_ALBEDO() {
        return RL_SHADER_LOC_MAP_ALBEDO;
    }
    private static final int RL_SHADER_LOC_MAP_METALNESS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_METALNESS = 16
     * }
     */
    public static int RL_SHADER_LOC_MAP_METALNESS() {
        return RL_SHADER_LOC_MAP_METALNESS;
    }
    private static final int RL_SHADER_LOC_MAP_NORMAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_NORMAL = 17
     * }
     */
    public static int RL_SHADER_LOC_MAP_NORMAL() {
        return RL_SHADER_LOC_MAP_NORMAL;
    }
    private static final int RL_SHADER_LOC_MAP_ROUGHNESS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_ROUGHNESS = 18
     * }
     */
    public static int RL_SHADER_LOC_MAP_ROUGHNESS() {
        return RL_SHADER_LOC_MAP_ROUGHNESS;
    }
    private static final int RL_SHADER_LOC_MAP_OCCLUSION = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_OCCLUSION = 19
     * }
     */
    public static int RL_SHADER_LOC_MAP_OCCLUSION() {
        return RL_SHADER_LOC_MAP_OCCLUSION;
    }
    private static final int RL_SHADER_LOC_MAP_EMISSION = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_EMISSION = 20
     * }
     */
    public static int RL_SHADER_LOC_MAP_EMISSION() {
        return RL_SHADER_LOC_MAP_EMISSION;
    }
    private static final int RL_SHADER_LOC_MAP_HEIGHT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_HEIGHT = 21
     * }
     */
    public static int RL_SHADER_LOC_MAP_HEIGHT() {
        return RL_SHADER_LOC_MAP_HEIGHT;
    }
    private static final int RL_SHADER_LOC_MAP_CUBEMAP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_CUBEMAP = 22
     * }
     */
    public static int RL_SHADER_LOC_MAP_CUBEMAP() {
        return RL_SHADER_LOC_MAP_CUBEMAP;
    }
    private static final int RL_SHADER_LOC_MAP_IRRADIANCE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_IRRADIANCE = 23
     * }
     */
    public static int RL_SHADER_LOC_MAP_IRRADIANCE() {
        return RL_SHADER_LOC_MAP_IRRADIANCE;
    }
    private static final int RL_SHADER_LOC_MAP_PREFILTER = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_PREFILTER = 24
     * }
     */
    public static int RL_SHADER_LOC_MAP_PREFILTER() {
        return RL_SHADER_LOC_MAP_PREFILTER;
    }
    private static final int RL_SHADER_LOC_MAP_BRDF = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_LOC_MAP_BRDF = 25
     * }
     */
    public static int RL_SHADER_LOC_MAP_BRDF() {
        return RL_SHADER_LOC_MAP_BRDF;
    }
    private static final int RL_SHADER_UNIFORM_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_FLOAT = 0
     * }
     */
    public static int RL_SHADER_UNIFORM_FLOAT() {
        return RL_SHADER_UNIFORM_FLOAT;
    }
    private static final int RL_SHADER_UNIFORM_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC2 = 1
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC2() {
        return RL_SHADER_UNIFORM_VEC2;
    }
    private static final int RL_SHADER_UNIFORM_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC3 = 2
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC3() {
        return RL_SHADER_UNIFORM_VEC3;
    }
    private static final int RL_SHADER_UNIFORM_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_VEC4 = 3
     * }
     */
    public static int RL_SHADER_UNIFORM_VEC4() {
        return RL_SHADER_UNIFORM_VEC4;
    }
    private static final int RL_SHADER_UNIFORM_INT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_INT = 4
     * }
     */
    public static int RL_SHADER_UNIFORM_INT() {
        return RL_SHADER_UNIFORM_INT;
    }
    private static final int RL_SHADER_UNIFORM_IVEC2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC2 = 5
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC2() {
        return RL_SHADER_UNIFORM_IVEC2;
    }
    private static final int RL_SHADER_UNIFORM_IVEC3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC3 = 6
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC3() {
        return RL_SHADER_UNIFORM_IVEC3;
    }
    private static final int RL_SHADER_UNIFORM_IVEC4 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_IVEC4 = 7
     * }
     */
    public static int RL_SHADER_UNIFORM_IVEC4() {
        return RL_SHADER_UNIFORM_IVEC4;
    }
    private static final int RL_SHADER_UNIFORM_SAMPLER2D = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_UNIFORM_SAMPLER2D = 8
     * }
     */
    public static int RL_SHADER_UNIFORM_SAMPLER2D() {
        return RL_SHADER_UNIFORM_SAMPLER2D;
    }
    private static final int RL_SHADER_ATTRIB_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_FLOAT = 0
     * }
     */
    public static int RL_SHADER_ATTRIB_FLOAT() {
        return RL_SHADER_ATTRIB_FLOAT;
    }
    private static final int RL_SHADER_ATTRIB_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC2 = 1
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC2() {
        return RL_SHADER_ATTRIB_VEC2;
    }
    private static final int RL_SHADER_ATTRIB_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC3 = 2
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC3() {
        return RL_SHADER_ATTRIB_VEC3;
    }
    private static final int RL_SHADER_ATTRIB_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_SHADER_ATTRIB_VEC4 = 3
     * }
     */
    public static int RL_SHADER_ATTRIB_VEC4() {
        return RL_SHADER_ATTRIB_VEC4;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL0 = 0
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL0() {
        return RL_ATTACHMENT_COLOR_CHANNEL0;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL1 = 1
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL1() {
        return RL_ATTACHMENT_COLOR_CHANNEL1;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL2 = 2
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL2() {
        return RL_ATTACHMENT_COLOR_CHANNEL2;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL3 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL3 = 3
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL3() {
        return RL_ATTACHMENT_COLOR_CHANNEL3;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL4 = 4
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL4() {
        return RL_ATTACHMENT_COLOR_CHANNEL4;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL5 = 5
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL5() {
        return RL_ATTACHMENT_COLOR_CHANNEL5;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL6 = 6
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL6() {
        return RL_ATTACHMENT_COLOR_CHANNEL6;
    }
    private static final int RL_ATTACHMENT_COLOR_CHANNEL7 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_COLOR_CHANNEL7 = 7
     * }
     */
    public static int RL_ATTACHMENT_COLOR_CHANNEL7() {
        return RL_ATTACHMENT_COLOR_CHANNEL7;
    }
    private static final int RL_ATTACHMENT_DEPTH = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_DEPTH = 100
     * }
     */
    public static int RL_ATTACHMENT_DEPTH() {
        return RL_ATTACHMENT_DEPTH;
    }
    private static final int RL_ATTACHMENT_STENCIL = (int)200L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_STENCIL = 200
     * }
     */
    public static int RL_ATTACHMENT_STENCIL() {
        return RL_ATTACHMENT_STENCIL;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_X = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_X() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_X;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_X() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_X;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_Y() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_Y;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_POSITIVE_Z() {
        return RL_ATTACHMENT_CUBEMAP_POSITIVE_Z;
    }
    private static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5
     * }
     */
    public static int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z() {
        return RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z;
    }
    private static final int RL_ATTACHMENT_TEXTURE2D = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_TEXTURE2D = 100
     * }
     */
    public static int RL_ATTACHMENT_TEXTURE2D() {
        return RL_ATTACHMENT_TEXTURE2D;
    }
    private static final int RL_ATTACHMENT_RENDERBUFFER = (int)200L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_ATTACHMENT_RENDERBUFFER = 200
     * }
     */
    public static int RL_ATTACHMENT_RENDERBUFFER() {
        return RL_ATTACHMENT_RENDERBUFFER;
    }
    private static final int RL_CULL_FACE_FRONT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_CULL_FACE_FRONT = 0
     * }
     */
    public static int RL_CULL_FACE_FRONT() {
        return RL_CULL_FACE_FRONT;
    }
    private static final int RL_CULL_FACE_BACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_CULL_FACE_BACK = 1
     * }
     */
    public static int RL_CULL_FACE_BACK() {
        return RL_CULL_FACE_BACK;
    }

    private static class rlMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static FunctionDescriptor rlMatrixMode$descriptor() {
        return rlMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static MethodHandle rlMatrixMode$handle() {
        return rlMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static MemorySegment rlMatrixMode$address() {
        return rlMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlMatrixMode(int mode)
     * }
     */
    public static void rlMatrixMode(int mode) {
        var mh$ = rlMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static FunctionDescriptor rlPushMatrix$descriptor() {
        return rlPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static MethodHandle rlPushMatrix$handle() {
        return rlPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static MemorySegment rlPushMatrix$address() {
        return rlPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlPushMatrix()
     * }
     */
    public static void rlPushMatrix() {
        var mh$ = rlPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static FunctionDescriptor rlPopMatrix$descriptor() {
        return rlPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static MethodHandle rlPopMatrix$handle() {
        return rlPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static MemorySegment rlPopMatrix$address() {
        return rlPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlPopMatrix()
     * }
     */
    public static void rlPopMatrix() {
        var mh$ = rlPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static FunctionDescriptor rlLoadIdentity$descriptor() {
        return rlLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static MethodHandle rlLoadIdentity$handle() {
        return rlLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static MemorySegment rlLoadIdentity$address() {
        return rlLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadIdentity()
     * }
     */
    public static void rlLoadIdentity() {
        var mh$ = rlLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlTranslatef$descriptor() {
        return rlTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static MethodHandle rlTranslatef$handle() {
        return rlTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static MemorySegment rlTranslatef$address() {
        return rlTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTranslatef(float x, float y, float z)
     * }
     */
    public static void rlTranslatef(float x, float y, float z) {
        var mh$ = rlTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlRotatef$descriptor() {
        return rlRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static MethodHandle rlRotatef$handle() {
        return rlRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static MemorySegment rlRotatef$address() {
        return rlRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlRotatef(float angle, float x, float y, float z)
     * }
     */
    public static void rlRotatef(float angle, float x, float y, float z) {
        var mh$ = rlRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlScalef$descriptor() {
        return rlScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static MethodHandle rlScalef$handle() {
        return rlScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static MemorySegment rlScalef$address() {
        return rlScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlScalef(float x, float y, float z)
     * }
     */
    public static void rlScalef(float x, float y, float z) {
        var mh$ = rlScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static FunctionDescriptor rlMultMatrixf$descriptor() {
        return rlMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static MethodHandle rlMultMatrixf$handle() {
        return rlMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static MemorySegment rlMultMatrixf$address() {
        return rlMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlMultMatrixf(const float *matf)
     * }
     */
    public static void rlMultMatrixf(MemorySegment matf) {
        var mh$ = rlMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlMultMatrixf", matf);
            }
            mh$.invokeExact(matf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static FunctionDescriptor rlFrustum$descriptor() {
        return rlFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MethodHandle rlFrustum$handle() {
        return rlFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MemorySegment rlFrustum$address() {
        return rlFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar) {
        var mh$ = rlFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFrustum", left, right, bottom, top, znear, zfar);
            }
            mh$.invokeExact(left, right, bottom, top, znear, zfar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static FunctionDescriptor rlOrtho$descriptor() {
        return rlOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MethodHandle rlOrtho$handle() {
        return rlOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static MemorySegment rlOrtho$address() {
        return rlOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)
     * }
     */
    public static void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar) {
        var mh$ = rlOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlOrtho", left, right, bottom, top, znear, zfar);
            }
            mh$.invokeExact(left, right, bottom, top, znear, zfar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor rlViewport$descriptor() {
        return rlViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle rlViewport$handle() {
        return rlViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment rlViewport$address() {
        return rlViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlViewport(int x, int y, int width, int height)
     * }
     */
    public static void rlViewport(int x, int y, int width, int height) {
        var mh$ = rlViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetClipPlanes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetClipPlanes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static FunctionDescriptor rlSetClipPlanes$descriptor() {
        return rlSetClipPlanes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static MethodHandle rlSetClipPlanes$handle() {
        return rlSetClipPlanes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static MemorySegment rlSetClipPlanes$address() {
        return rlSetClipPlanes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetClipPlanes(double near, double far)
     * }
     */
    public static void rlSetClipPlanes(double near, double far) {
        var mh$ = rlSetClipPlanes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetClipPlanes", near, far);
            }
            mh$.invokeExact(near, far);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetCullDistanceNear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetCullDistanceNear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static FunctionDescriptor rlGetCullDistanceNear$descriptor() {
        return rlGetCullDistanceNear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static MethodHandle rlGetCullDistanceNear$handle() {
        return rlGetCullDistanceNear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static MemorySegment rlGetCullDistanceNear$address() {
        return rlGetCullDistanceNear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rlGetCullDistanceNear()
     * }
     */
    public static double rlGetCullDistanceNear() {
        var mh$ = rlGetCullDistanceNear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetCullDistanceNear");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetCullDistanceFar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetCullDistanceFar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static FunctionDescriptor rlGetCullDistanceFar$descriptor() {
        return rlGetCullDistanceFar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static MethodHandle rlGetCullDistanceFar$handle() {
        return rlGetCullDistanceFar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static MemorySegment rlGetCullDistanceFar$address() {
        return rlGetCullDistanceFar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rlGetCullDistanceFar()
     * }
     */
    public static double rlGetCullDistanceFar() {
        var mh$ = rlGetCullDistanceFar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetCullDistanceFar");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static FunctionDescriptor rlBegin$descriptor() {
        return rlBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static MethodHandle rlBegin$handle() {
        return rlBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static MemorySegment rlBegin$address() {
        return rlBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBegin(int mode)
     * }
     */
    public static void rlBegin(int mode) {
        var mh$ = rlBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static FunctionDescriptor rlEnd$descriptor() {
        return rlEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static MethodHandle rlEnd$handle() {
        return rlEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static MemorySegment rlEnd$address() {
        return rlEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnd()
     * }
     */
    public static void rlEnd() {
        var mh$ = rlEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static FunctionDescriptor rlVertex2i$descriptor() {
        return rlVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static MethodHandle rlVertex2i$handle() {
        return rlVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static MemorySegment rlVertex2i$address() {
        return rlVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex2i(int x, int y)
     * }
     */
    public static void rlVertex2i(int x, int y) {
        var mh$ = rlVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static FunctionDescriptor rlVertex2f$descriptor() {
        return rlVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static MethodHandle rlVertex2f$handle() {
        return rlVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static MemorySegment rlVertex2f$address() {
        return rlVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex2f(float x, float y)
     * }
     */
    public static void rlVertex2f(float x, float y) {
        var mh$ = rlVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlVertex3f$descriptor() {
        return rlVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlVertex3f$handle() {
        return rlVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlVertex3f$address() {
        return rlVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlVertex3f(float x, float y, float z)
     * }
     */
    public static void rlVertex3f(float x, float y, float z) {
        var mh$ = rlVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static FunctionDescriptor rlTexCoord2f$descriptor() {
        return rlTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static MethodHandle rlTexCoord2f$handle() {
        return rlTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static MemorySegment rlTexCoord2f$address() {
        return rlTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTexCoord2f(float x, float y)
     * }
     */
    public static void rlTexCoord2f(float x, float y) {
        var mh$ = rlTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTexCoord2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlNormal3f$descriptor() {
        return rlNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlNormal3f$handle() {
        return rlNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlNormal3f$address() {
        return rlNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlNormal3f(float x, float y, float z)
     * }
     */
    public static void rlNormal3f(float x, float y, float z) {
        var mh$ = rlNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlNormal3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static FunctionDescriptor rlColor4ub$descriptor() {
        return rlColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MethodHandle rlColor4ub$handle() {
        return rlColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MemorySegment rlColor4ub$address() {
        return rlColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static void rlColor4ub(byte r, byte g, byte b, byte a) {
        var mh$ = rlColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor4ub", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor rlColor3f$descriptor() {
        return rlColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static MethodHandle rlColor3f$handle() {
        return rlColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static MemorySegment rlColor3f$address() {
        return rlColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor3f(float x, float y, float z)
     * }
     */
    public static void rlColor3f(float x, float y, float z) {
        var mh$ = rlColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static FunctionDescriptor rlColor4f$descriptor() {
        return rlColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static MethodHandle rlColor4f$handle() {
        return rlColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static MemorySegment rlColor4f$address() {
        return rlColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColor4f(float x, float y, float z, float w)
     * }
     */
    public static void rlColor4f(float x, float y, float z, float w) {
        var mh$ = rlColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColor4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static FunctionDescriptor rlEnableVertexArray$descriptor() {
        return rlEnableVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static MethodHandle rlEnableVertexArray$handle() {
        return rlEnableVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static MemorySegment rlEnableVertexArray$address() {
        return rlEnableVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlEnableVertexArray(unsigned int vaoId)
     * }
     */
    public static boolean rlEnableVertexArray(int vaoId) {
        var mh$ = rlEnableVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexArray", vaoId);
            }
            return (boolean)mh$.invokeExact(vaoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static FunctionDescriptor rlDisableVertexArray$descriptor() {
        return rlDisableVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static MethodHandle rlDisableVertexArray$handle() {
        return rlDisableVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static MemorySegment rlDisableVertexArray$address() {
        return rlDisableVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexArray()
     * }
     */
    public static void rlDisableVertexArray() {
        var mh$ = rlDisableVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexArray");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableVertexBuffer$descriptor() {
        return rlEnableVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableVertexBuffer$handle() {
        return rlEnableVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableVertexBuffer$address() {
        return rlEnableVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexBuffer(unsigned int id)
     * }
     */
    public static void rlEnableVertexBuffer(int id) {
        var mh$ = rlEnableVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexBuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static FunctionDescriptor rlDisableVertexBuffer$descriptor() {
        return rlDisableVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static MethodHandle rlDisableVertexBuffer$handle() {
        return rlDisableVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static MemorySegment rlDisableVertexBuffer$address() {
        return rlDisableVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexBuffer()
     * }
     */
    public static void rlDisableVertexBuffer() {
        var mh$ = rlDisableVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexBuffer");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableVertexBufferElement$descriptor() {
        return rlEnableVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableVertexBufferElement$handle() {
        return rlEnableVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableVertexBufferElement$address() {
        return rlEnableVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexBufferElement(unsigned int id)
     * }
     */
    public static void rlEnableVertexBufferElement(int id) {
        var mh$ = rlEnableVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexBufferElement", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static FunctionDescriptor rlDisableVertexBufferElement$descriptor() {
        return rlDisableVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static MethodHandle rlDisableVertexBufferElement$handle() {
        return rlDisableVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static MemorySegment rlDisableVertexBufferElement$address() {
        return rlDisableVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexBufferElement()
     * }
     */
    public static void rlDisableVertexBufferElement() {
        var mh$ = rlDisableVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexBufferElement");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static FunctionDescriptor rlEnableVertexAttribute$descriptor() {
        return rlEnableVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static MethodHandle rlEnableVertexAttribute$handle() {
        return rlEnableVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static MemorySegment rlEnableVertexAttribute$address() {
        return rlEnableVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableVertexAttribute(unsigned int index)
     * }
     */
    public static void rlEnableVertexAttribute(int index) {
        var mh$ = rlEnableVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableVertexAttribute", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static FunctionDescriptor rlDisableVertexAttribute$descriptor() {
        return rlDisableVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static MethodHandle rlDisableVertexAttribute$handle() {
        return rlDisableVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static MemorySegment rlDisableVertexAttribute$address() {
        return rlDisableVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableVertexAttribute(unsigned int index)
     * }
     */
    public static void rlDisableVertexAttribute(int index) {
        var mh$ = rlDisableVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableVertexAttribute", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlActiveTextureSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlActiveTextureSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static FunctionDescriptor rlActiveTextureSlot$descriptor() {
        return rlActiveTextureSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static MethodHandle rlActiveTextureSlot$handle() {
        return rlActiveTextureSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static MemorySegment rlActiveTextureSlot$address() {
        return rlActiveTextureSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlActiveTextureSlot(int slot)
     * }
     */
    public static void rlActiveTextureSlot(int slot) {
        var mh$ = rlActiveTextureSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlActiveTextureSlot", slot);
            }
            mh$.invokeExact(slot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableTexture$descriptor() {
        return rlEnableTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableTexture$handle() {
        return rlEnableTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableTexture$address() {
        return rlEnableTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableTexture(unsigned int id)
     * }
     */
    public static void rlEnableTexture(int id) {
        var mh$ = rlEnableTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static FunctionDescriptor rlDisableTexture$descriptor() {
        return rlDisableTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static MethodHandle rlDisableTexture$handle() {
        return rlDisableTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static MemorySegment rlDisableTexture$address() {
        return rlDisableTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableTexture()
     * }
     */
    public static void rlDisableTexture() {
        var mh$ = rlDisableTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableTexture");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableTextureCubemap$descriptor() {
        return rlEnableTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableTextureCubemap$handle() {
        return rlEnableTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableTextureCubemap$address() {
        return rlEnableTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableTextureCubemap(unsigned int id)
     * }
     */
    public static void rlEnableTextureCubemap(int id) {
        var mh$ = rlEnableTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableTextureCubemap", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static FunctionDescriptor rlDisableTextureCubemap$descriptor() {
        return rlDisableTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static MethodHandle rlDisableTextureCubemap$handle() {
        return rlDisableTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static MemorySegment rlDisableTextureCubemap$address() {
        return rlDisableTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableTextureCubemap()
     * }
     */
    public static void rlDisableTextureCubemap() {
        var mh$ = rlDisableTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableTextureCubemap");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlTextureParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlTextureParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static FunctionDescriptor rlTextureParameters$descriptor() {
        return rlTextureParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static MethodHandle rlTextureParameters$handle() {
        return rlTextureParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static MemorySegment rlTextureParameters$address() {
        return rlTextureParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlTextureParameters(unsigned int id, int param, int value)
     * }
     */
    public static void rlTextureParameters(int id, int param, int value) {
        var mh$ = rlTextureParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlTextureParameters", id, param, value);
            }
            mh$.invokeExact(id, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCubemapParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCubemapParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static FunctionDescriptor rlCubemapParameters$descriptor() {
        return rlCubemapParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static MethodHandle rlCubemapParameters$handle() {
        return rlCubemapParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static MemorySegment rlCubemapParameters$address() {
        return rlCubemapParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCubemapParameters(unsigned int id, int param, int value)
     * }
     */
    public static void rlCubemapParameters(int id, int param, int value) {
        var mh$ = rlCubemapParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCubemapParameters", id, param, value);
            }
            mh$.invokeExact(id, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableShader$descriptor() {
        return rlEnableShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableShader$handle() {
        return rlEnableShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableShader$address() {
        return rlEnableShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableShader(unsigned int id)
     * }
     */
    public static void rlEnableShader(int id) {
        var mh$ = rlEnableShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableShader", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static FunctionDescriptor rlDisableShader$descriptor() {
        return rlDisableShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static MethodHandle rlDisableShader$handle() {
        return rlDisableShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static MemorySegment rlDisableShader$address() {
        return rlDisableShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableShader()
     * }
     */
    public static void rlDisableShader() {
        var mh$ = rlDisableShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableShader");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlEnableFramebuffer$descriptor() {
        return rlEnableFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlEnableFramebuffer$handle() {
        return rlEnableFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlEnableFramebuffer$address() {
        return rlEnableFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableFramebuffer(unsigned int id)
     * }
     */
    public static void rlEnableFramebuffer(int id) {
        var mh$ = rlEnableFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableFramebuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static FunctionDescriptor rlDisableFramebuffer$descriptor() {
        return rlDisableFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static MethodHandle rlDisableFramebuffer$handle() {
        return rlDisableFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static MemorySegment rlDisableFramebuffer$address() {
        return rlDisableFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableFramebuffer()
     * }
     */
    public static void rlDisableFramebuffer() {
        var mh$ = rlDisableFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableFramebuffer");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetActiveFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetActiveFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static FunctionDescriptor rlGetActiveFramebuffer$descriptor() {
        return rlGetActiveFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static MethodHandle rlGetActiveFramebuffer$handle() {
        return rlGetActiveFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static MemorySegment rlGetActiveFramebuffer$address() {
        return rlGetActiveFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetActiveFramebuffer()
     * }
     */
    public static int rlGetActiveFramebuffer() {
        var mh$ = rlGetActiveFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetActiveFramebuffer");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlActiveDrawBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlActiveDrawBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static FunctionDescriptor rlActiveDrawBuffers$descriptor() {
        return rlActiveDrawBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static MethodHandle rlActiveDrawBuffers$handle() {
        return rlActiveDrawBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static MemorySegment rlActiveDrawBuffers$address() {
        return rlActiveDrawBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlActiveDrawBuffers(int count)
     * }
     */
    public static void rlActiveDrawBuffers(int count) {
        var mh$ = rlActiveDrawBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlActiveDrawBuffers", count);
            }
            mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBlitFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBlitFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static FunctionDescriptor rlBlitFramebuffer$descriptor() {
        return rlBlitFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static MethodHandle rlBlitFramebuffer$handle() {
        return rlBlitFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static MemorySegment rlBlitFramebuffer$address() {
        return rlBlitFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)
     * }
     */
    public static void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask) {
        var mh$ = rlBlitFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBlitFramebuffer", srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask);
            }
            mh$.invokeExact(srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static FunctionDescriptor rlBindFramebuffer$descriptor() {
        return rlBindFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static MethodHandle rlBindFramebuffer$handle() {
        return rlBindFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static MemorySegment rlBindFramebuffer$address() {
        return rlBindFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindFramebuffer(unsigned int target, unsigned int framebuffer)
     * }
     */
    public static void rlBindFramebuffer(int target, int framebuffer) {
        var mh$ = rlBindFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindFramebuffer", target, framebuffer);
            }
            mh$.invokeExact(target, framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableColorBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableColorBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static FunctionDescriptor rlEnableColorBlend$descriptor() {
        return rlEnableColorBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static MethodHandle rlEnableColorBlend$handle() {
        return rlEnableColorBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static MemorySegment rlEnableColorBlend$address() {
        return rlEnableColorBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableColorBlend()
     * }
     */
    public static void rlEnableColorBlend() {
        var mh$ = rlEnableColorBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableColorBlend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableColorBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableColorBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static FunctionDescriptor rlDisableColorBlend$descriptor() {
        return rlDisableColorBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static MethodHandle rlDisableColorBlend$handle() {
        return rlDisableColorBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static MemorySegment rlDisableColorBlend$address() {
        return rlDisableColorBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableColorBlend()
     * }
     */
    public static void rlDisableColorBlend() {
        var mh$ = rlDisableColorBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableColorBlend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableDepthTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableDepthTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static FunctionDescriptor rlEnableDepthTest$descriptor() {
        return rlEnableDepthTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static MethodHandle rlEnableDepthTest$handle() {
        return rlEnableDepthTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static MemorySegment rlEnableDepthTest$address() {
        return rlEnableDepthTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableDepthTest()
     * }
     */
    public static void rlEnableDepthTest() {
        var mh$ = rlEnableDepthTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableDepthTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableDepthTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableDepthTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static FunctionDescriptor rlDisableDepthTest$descriptor() {
        return rlDisableDepthTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static MethodHandle rlDisableDepthTest$handle() {
        return rlDisableDepthTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static MemorySegment rlDisableDepthTest$address() {
        return rlDisableDepthTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableDepthTest()
     * }
     */
    public static void rlDisableDepthTest() {
        var mh$ = rlDisableDepthTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableDepthTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static FunctionDescriptor rlEnableDepthMask$descriptor() {
        return rlEnableDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static MethodHandle rlEnableDepthMask$handle() {
        return rlEnableDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static MemorySegment rlEnableDepthMask$address() {
        return rlEnableDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableDepthMask()
     * }
     */
    public static void rlEnableDepthMask() {
        var mh$ = rlEnableDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableDepthMask");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static FunctionDescriptor rlDisableDepthMask$descriptor() {
        return rlDisableDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static MethodHandle rlDisableDepthMask$handle() {
        return rlDisableDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static MemorySegment rlDisableDepthMask$address() {
        return rlDisableDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableDepthMask()
     * }
     */
    public static void rlDisableDepthMask() {
        var mh$ = rlDisableDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableDepthMask");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableBackfaceCulling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableBackfaceCulling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static FunctionDescriptor rlEnableBackfaceCulling$descriptor() {
        return rlEnableBackfaceCulling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static MethodHandle rlEnableBackfaceCulling$handle() {
        return rlEnableBackfaceCulling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static MemorySegment rlEnableBackfaceCulling$address() {
        return rlEnableBackfaceCulling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableBackfaceCulling()
     * }
     */
    public static void rlEnableBackfaceCulling() {
        var mh$ = rlEnableBackfaceCulling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableBackfaceCulling");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableBackfaceCulling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableBackfaceCulling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static FunctionDescriptor rlDisableBackfaceCulling$descriptor() {
        return rlDisableBackfaceCulling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static MethodHandle rlDisableBackfaceCulling$handle() {
        return rlDisableBackfaceCulling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static MemorySegment rlDisableBackfaceCulling$address() {
        return rlDisableBackfaceCulling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableBackfaceCulling()
     * }
     */
    public static void rlDisableBackfaceCulling() {
        var mh$ = rlDisableBackfaceCulling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableBackfaceCulling");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_BOOL,
            raylib.C_BOOL,
            raylib.C_BOOL,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static FunctionDescriptor rlColorMask$descriptor() {
        return rlColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static MethodHandle rlColorMask$handle() {
        return rlColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static MemorySegment rlColorMask$address() {
        return rlColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlColorMask(bool r, bool g, bool b, bool a)
     * }
     */
    public static void rlColorMask(boolean r, boolean g, boolean b, boolean a) {
        var mh$ = rlColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlColorMask", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static FunctionDescriptor rlSetCullFace$descriptor() {
        return rlSetCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static MethodHandle rlSetCullFace$handle() {
        return rlSetCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static MemorySegment rlSetCullFace$address() {
        return rlSetCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetCullFace(int mode)
     * }
     */
    public static void rlSetCullFace(int mode) {
        var mh$ = rlSetCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableScissorTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableScissorTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static FunctionDescriptor rlEnableScissorTest$descriptor() {
        return rlEnableScissorTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static MethodHandle rlEnableScissorTest$handle() {
        return rlEnableScissorTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static MemorySegment rlEnableScissorTest$address() {
        return rlEnableScissorTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableScissorTest()
     * }
     */
    public static void rlEnableScissorTest() {
        var mh$ = rlEnableScissorTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableScissorTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableScissorTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableScissorTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static FunctionDescriptor rlDisableScissorTest$descriptor() {
        return rlDisableScissorTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static MethodHandle rlDisableScissorTest$handle() {
        return rlDisableScissorTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static MemorySegment rlDisableScissorTest$address() {
        return rlDisableScissorTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableScissorTest()
     * }
     */
    public static void rlDisableScissorTest() {
        var mh$ = rlDisableScissorTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableScissorTest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor rlScissor$descriptor() {
        return rlScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle rlScissor$handle() {
        return rlScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment rlScissor$address() {
        return rlScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlScissor(int x, int y, int width, int height)
     * }
     */
    public static void rlScissor(int x, int y, int width, int height) {
        var mh$ = rlScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableWireMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableWireMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static FunctionDescriptor rlEnableWireMode$descriptor() {
        return rlEnableWireMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static MethodHandle rlEnableWireMode$handle() {
        return rlEnableWireMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static MemorySegment rlEnableWireMode$address() {
        return rlEnableWireMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableWireMode()
     * }
     */
    public static void rlEnableWireMode() {
        var mh$ = rlEnableWireMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableWireMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnablePointMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnablePointMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static FunctionDescriptor rlEnablePointMode$descriptor() {
        return rlEnablePointMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static MethodHandle rlEnablePointMode$handle() {
        return rlEnablePointMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static MemorySegment rlEnablePointMode$address() {
        return rlEnablePointMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnablePointMode()
     * }
     */
    public static void rlEnablePointMode() {
        var mh$ = rlEnablePointMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnablePointMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableWireMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableWireMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static FunctionDescriptor rlDisableWireMode$descriptor() {
        return rlDisableWireMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static MethodHandle rlDisableWireMode$handle() {
        return rlDisableWireMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static MemorySegment rlDisableWireMode$address() {
        return rlDisableWireMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableWireMode()
     * }
     */
    public static void rlDisableWireMode() {
        var mh$ = rlDisableWireMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableWireMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static FunctionDescriptor rlSetLineWidth$descriptor() {
        return rlSetLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static MethodHandle rlSetLineWidth$handle() {
        return rlSetLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static MemorySegment rlSetLineWidth$address() {
        return rlSetLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetLineWidth(float width)
     * }
     */
    public static void rlSetLineWidth(float width) {
        var mh$ = rlSetLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static FunctionDescriptor rlGetLineWidth$descriptor() {
        return rlGetLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static MethodHandle rlGetLineWidth$handle() {
        return rlGetLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static MemorySegment rlGetLineWidth$address() {
        return rlGetLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rlGetLineWidth()
     * }
     */
    public static float rlGetLineWidth() {
        var mh$ = rlGetLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLineWidth");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableSmoothLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableSmoothLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static FunctionDescriptor rlEnableSmoothLines$descriptor() {
        return rlEnableSmoothLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static MethodHandle rlEnableSmoothLines$handle() {
        return rlEnableSmoothLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static MemorySegment rlEnableSmoothLines$address() {
        return rlEnableSmoothLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableSmoothLines()
     * }
     */
    public static void rlEnableSmoothLines() {
        var mh$ = rlEnableSmoothLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableSmoothLines");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableSmoothLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableSmoothLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static FunctionDescriptor rlDisableSmoothLines$descriptor() {
        return rlDisableSmoothLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static MethodHandle rlDisableSmoothLines$handle() {
        return rlDisableSmoothLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static MemorySegment rlDisableSmoothLines$address() {
        return rlDisableSmoothLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableSmoothLines()
     * }
     */
    public static void rlDisableSmoothLines() {
        var mh$ = rlDisableSmoothLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableSmoothLines");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlEnableStereoRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlEnableStereoRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static FunctionDescriptor rlEnableStereoRender$descriptor() {
        return rlEnableStereoRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static MethodHandle rlEnableStereoRender$handle() {
        return rlEnableStereoRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static MemorySegment rlEnableStereoRender$address() {
        return rlEnableStereoRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlEnableStereoRender()
     * }
     */
    public static void rlEnableStereoRender() {
        var mh$ = rlEnableStereoRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlEnableStereoRender");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDisableStereoRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDisableStereoRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static FunctionDescriptor rlDisableStereoRender$descriptor() {
        return rlDisableStereoRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static MethodHandle rlDisableStereoRender$handle() {
        return rlDisableStereoRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static MemorySegment rlDisableStereoRender$address() {
        return rlDisableStereoRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDisableStereoRender()
     * }
     */
    public static void rlDisableStereoRender() {
        var mh$ = rlDisableStereoRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDisableStereoRender");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlIsStereoRenderEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlIsStereoRenderEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static FunctionDescriptor rlIsStereoRenderEnabled$descriptor() {
        return rlIsStereoRenderEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static MethodHandle rlIsStereoRenderEnabled$handle() {
        return rlIsStereoRenderEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static MemorySegment rlIsStereoRenderEnabled$address() {
        return rlIsStereoRenderEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlIsStereoRenderEnabled()
     * }
     */
    public static boolean rlIsStereoRenderEnabled() {
        var mh$ = rlIsStereoRenderEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlIsStereoRenderEnabled");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR,
            raylib.C_CHAR
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static FunctionDescriptor rlClearColor$descriptor() {
        return rlClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MethodHandle rlClearColor$handle() {
        return rlClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static MemorySegment rlClearColor$address() {
        return rlClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
     * }
     */
    public static void rlClearColor(byte r, byte g, byte b, byte a) {
        var mh$ = rlClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlClearColor", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlClearScreenBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlClearScreenBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static FunctionDescriptor rlClearScreenBuffers$descriptor() {
        return rlClearScreenBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static MethodHandle rlClearScreenBuffers$handle() {
        return rlClearScreenBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static MemorySegment rlClearScreenBuffers$address() {
        return rlClearScreenBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlClearScreenBuffers()
     * }
     */
    public static void rlClearScreenBuffers() {
        var mh$ = rlClearScreenBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlClearScreenBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCheckErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCheckErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static FunctionDescriptor rlCheckErrors$descriptor() {
        return rlCheckErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static MethodHandle rlCheckErrors$handle() {
        return rlCheckErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static MemorySegment rlCheckErrors$address() {
        return rlCheckErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCheckErrors()
     * }
     */
    public static void rlCheckErrors() {
        var mh$ = rlCheckErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCheckErrors");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static FunctionDescriptor rlSetBlendMode$descriptor() {
        return rlSetBlendMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static MethodHandle rlSetBlendMode$handle() {
        return rlSetBlendMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static MemorySegment rlSetBlendMode$address() {
        return rlSetBlendMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendMode(int mode)
     * }
     */
    public static void rlSetBlendMode(int mode) {
        var mh$ = rlSetBlendMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendFactors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendFactors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static FunctionDescriptor rlSetBlendFactors$descriptor() {
        return rlSetBlendFactors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static MethodHandle rlSetBlendFactors$handle() {
        return rlSetBlendFactors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static MemorySegment rlSetBlendFactors$address() {
        return rlSetBlendFactors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)
     * }
     */
    public static void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation) {
        var mh$ = rlSetBlendFactors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendFactors", glSrcFactor, glDstFactor, glEquation);
            }
            mh$.invokeExact(glSrcFactor, glDstFactor, glEquation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetBlendFactorsSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetBlendFactorsSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static FunctionDescriptor rlSetBlendFactorsSeparate$descriptor() {
        return rlSetBlendFactorsSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static MethodHandle rlSetBlendFactorsSeparate$handle() {
        return rlSetBlendFactorsSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static MemorySegment rlSetBlendFactorsSeparate$address() {
        return rlSetBlendFactorsSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)
     * }
     */
    public static void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha) {
        var mh$ = rlSetBlendFactorsSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetBlendFactorsSeparate", glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha);
            }
            mh$.invokeExact(glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlglInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlglInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static FunctionDescriptor rlglInit$descriptor() {
        return rlglInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static MethodHandle rlglInit$handle() {
        return rlglInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static MemorySegment rlglInit$address() {
        return rlglInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlglInit(int width, int height)
     * }
     */
    public static void rlglInit(int width, int height) {
        var mh$ = rlglInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlglInit", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlglClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlglClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static FunctionDescriptor rlglClose$descriptor() {
        return rlglClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static MethodHandle rlglClose$handle() {
        return rlglClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static MemorySegment rlglClose$address() {
        return rlglClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlglClose()
     * }
     */
    public static void rlglClose() {
        var mh$ = rlglClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlglClose");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadExtensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadExtensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static FunctionDescriptor rlLoadExtensions$descriptor() {
        return rlLoadExtensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static MethodHandle rlLoadExtensions$handle() {
        return rlLoadExtensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static MemorySegment rlLoadExtensions$address() {
        return rlLoadExtensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadExtensions(void *loader)
     * }
     */
    public static void rlLoadExtensions(MemorySegment loader) {
        var mh$ = rlLoadExtensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadExtensions", loader);
            }
            mh$.invokeExact(loader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static FunctionDescriptor rlGetVersion$descriptor() {
        return rlGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static MethodHandle rlGetVersion$handle() {
        return rlGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static MemorySegment rlGetVersion$address() {
        return rlGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetVersion()
     * }
     */
    public static int rlGetVersion() {
        var mh$ = rlGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetFramebufferWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetFramebufferWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static FunctionDescriptor rlSetFramebufferWidth$descriptor() {
        return rlSetFramebufferWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static MethodHandle rlSetFramebufferWidth$handle() {
        return rlSetFramebufferWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static MemorySegment rlSetFramebufferWidth$address() {
        return rlSetFramebufferWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetFramebufferWidth(int width)
     * }
     */
    public static void rlSetFramebufferWidth(int width) {
        var mh$ = rlSetFramebufferWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetFramebufferWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetFramebufferWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetFramebufferWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static FunctionDescriptor rlGetFramebufferWidth$descriptor() {
        return rlGetFramebufferWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static MethodHandle rlGetFramebufferWidth$handle() {
        return rlGetFramebufferWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static MemorySegment rlGetFramebufferWidth$address() {
        return rlGetFramebufferWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetFramebufferWidth()
     * }
     */
    public static int rlGetFramebufferWidth() {
        var mh$ = rlGetFramebufferWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetFramebufferWidth");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetFramebufferHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetFramebufferHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static FunctionDescriptor rlSetFramebufferHeight$descriptor() {
        return rlSetFramebufferHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static MethodHandle rlSetFramebufferHeight$handle() {
        return rlSetFramebufferHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static MemorySegment rlSetFramebufferHeight$address() {
        return rlSetFramebufferHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetFramebufferHeight(int height)
     * }
     */
    public static void rlSetFramebufferHeight(int height) {
        var mh$ = rlSetFramebufferHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetFramebufferHeight", height);
            }
            mh$.invokeExact(height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetFramebufferHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetFramebufferHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static FunctionDescriptor rlGetFramebufferHeight$descriptor() {
        return rlGetFramebufferHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static MethodHandle rlGetFramebufferHeight$handle() {
        return rlGetFramebufferHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static MemorySegment rlGetFramebufferHeight$address() {
        return rlGetFramebufferHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetFramebufferHeight()
     * }
     */
    public static int rlGetFramebufferHeight() {
        var mh$ = rlGetFramebufferHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetFramebufferHeight");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetTextureIdDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetTextureIdDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static FunctionDescriptor rlGetTextureIdDefault$descriptor() {
        return rlGetTextureIdDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static MethodHandle rlGetTextureIdDefault$handle() {
        return rlGetTextureIdDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static MemorySegment rlGetTextureIdDefault$address() {
        return rlGetTextureIdDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetTextureIdDefault()
     * }
     */
    public static int rlGetTextureIdDefault() {
        var mh$ = rlGetTextureIdDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetTextureIdDefault");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderIdDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderIdDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static FunctionDescriptor rlGetShaderIdDefault$descriptor() {
        return rlGetShaderIdDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static MethodHandle rlGetShaderIdDefault$handle() {
        return rlGetShaderIdDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static MemorySegment rlGetShaderIdDefault$address() {
        return rlGetShaderIdDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetShaderIdDefault()
     * }
     */
    public static int rlGetShaderIdDefault() {
        var mh$ = rlGetShaderIdDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderIdDefault");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderLocsDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderLocsDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static FunctionDescriptor rlGetShaderLocsDefault$descriptor() {
        return rlGetShaderLocsDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MethodHandle rlGetShaderLocsDefault$handle() {
        return rlGetShaderLocsDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MemorySegment rlGetShaderLocsDefault$address() {
        return rlGetShaderLocsDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *rlGetShaderLocsDefault()
     * }
     */
    public static MemorySegment rlGetShaderLocsDefault() {
        var mh$ = rlGetShaderLocsDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderLocsDefault");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            rlRenderBatch.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static FunctionDescriptor rlLoadRenderBatch$descriptor() {
        return rlLoadRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MethodHandle rlLoadRenderBatch$handle() {
        return rlLoadRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MemorySegment rlLoadRenderBatch$address() {
        return rlLoadRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)
     * }
     */
    public static MemorySegment rlLoadRenderBatch(SegmentAllocator allocator, int numBuffers, int bufferElements) {
        var mh$ = rlLoadRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadRenderBatch", allocator, numBuffers, bufferElements);
            }
            return (MemorySegment)mh$.invokeExact(allocator, numBuffers, bufferElements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            rlRenderBatch.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static FunctionDescriptor rlUnloadRenderBatch$descriptor() {
        return rlUnloadRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static MethodHandle rlUnloadRenderBatch$handle() {
        return rlUnloadRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static MemorySegment rlUnloadRenderBatch$address() {
        return rlUnloadRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadRenderBatch(rlRenderBatch batch)
     * }
     */
    public static void rlUnloadRenderBatch(MemorySegment batch) {
        var mh$ = rlUnloadRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadRenderBatch", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawRenderBatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawRenderBatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static FunctionDescriptor rlDrawRenderBatch$descriptor() {
        return rlDrawRenderBatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static MethodHandle rlDrawRenderBatch$handle() {
        return rlDrawRenderBatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static MemorySegment rlDrawRenderBatch$address() {
        return rlDrawRenderBatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawRenderBatch(rlRenderBatch *batch)
     * }
     */
    public static void rlDrawRenderBatch(MemorySegment batch) {
        var mh$ = rlDrawRenderBatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawRenderBatch", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetRenderBatchActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetRenderBatchActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static FunctionDescriptor rlSetRenderBatchActive$descriptor() {
        return rlSetRenderBatchActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static MethodHandle rlSetRenderBatchActive$handle() {
        return rlSetRenderBatchActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static MemorySegment rlSetRenderBatchActive$address() {
        return rlSetRenderBatchActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetRenderBatchActive(rlRenderBatch *batch)
     * }
     */
    public static void rlSetRenderBatchActive(MemorySegment batch) {
        var mh$ = rlSetRenderBatchActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetRenderBatchActive", batch);
            }
            mh$.invokeExact(batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawRenderBatchActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawRenderBatchActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static FunctionDescriptor rlDrawRenderBatchActive$descriptor() {
        return rlDrawRenderBatchActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static MethodHandle rlDrawRenderBatchActive$handle() {
        return rlDrawRenderBatchActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static MemorySegment rlDrawRenderBatchActive$address() {
        return rlDrawRenderBatchActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawRenderBatchActive()
     * }
     */
    public static void rlDrawRenderBatchActive() {
        var mh$ = rlDrawRenderBatchActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawRenderBatchActive");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCheckRenderBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCheckRenderBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static FunctionDescriptor rlCheckRenderBatchLimit$descriptor() {
        return rlCheckRenderBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static MethodHandle rlCheckRenderBatchLimit$handle() {
        return rlCheckRenderBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static MemorySegment rlCheckRenderBatchLimit$address() {
        return rlCheckRenderBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlCheckRenderBatchLimit(int vCount)
     * }
     */
    public static boolean rlCheckRenderBatchLimit(int vCount) {
        var mh$ = rlCheckRenderBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCheckRenderBatchLimit", vCount);
            }
            return (boolean)mh$.invokeExact(vCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlSetTexture$descriptor() {
        return rlSetTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlSetTexture$handle() {
        return rlSetTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlSetTexture$address() {
        return rlSetTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetTexture(unsigned int id)
     * }
     */
    public static void rlSetTexture(int id) {
        var mh$ = rlSetTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static FunctionDescriptor rlLoadVertexArray$descriptor() {
        return rlLoadVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static MethodHandle rlLoadVertexArray$handle() {
        return rlLoadVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static MemorySegment rlLoadVertexArray$address() {
        return rlLoadVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexArray()
     * }
     */
    public static int rlLoadVertexArray() {
        var mh$ = rlLoadVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexArray");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static FunctionDescriptor rlLoadVertexBuffer$descriptor() {
        return rlLoadVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MethodHandle rlLoadVertexBuffer$handle() {
        return rlLoadVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MemorySegment rlLoadVertexBuffer$address() {
        return rlLoadVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)
     * }
     */
    public static int rlLoadVertexBuffer(MemorySegment buffer, int size, boolean dynamic) {
        var mh$ = rlLoadVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexBuffer", buffer, size, dynamic);
            }
            return (int)mh$.invokeExact(buffer, size, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadVertexBufferElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadVertexBufferElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static FunctionDescriptor rlLoadVertexBufferElement$descriptor() {
        return rlLoadVertexBufferElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MethodHandle rlLoadVertexBufferElement$handle() {
        return rlLoadVertexBufferElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static MemorySegment rlLoadVertexBufferElement$address() {
        return rlLoadVertexBufferElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)
     * }
     */
    public static int rlLoadVertexBufferElement(MemorySegment buffer, int size, boolean dynamic) {
        var mh$ = rlLoadVertexBufferElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadVertexBufferElement", buffer, size, dynamic);
            }
            return (int)mh$.invokeExact(buffer, size, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateVertexBuffer$descriptor() {
        return rlUpdateVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle rlUpdateVertexBuffer$handle() {
        return rlUpdateVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment rlUpdateVertexBuffer$address() {
        return rlUpdateVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset)
     * }
     */
    public static void rlUpdateVertexBuffer(int bufferId, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateVertexBuffer", bufferId, data, dataSize, offset);
            }
            mh$.invokeExact(bufferId, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateVertexBufferElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateVertexBufferElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateVertexBufferElements$descriptor() {
        return rlUpdateVertexBufferElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle rlUpdateVertexBufferElements$handle() {
        return rlUpdateVertexBufferElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment rlUpdateVertexBufferElements$address() {
        return rlUpdateVertexBufferElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)
     * }
     */
    public static void rlUpdateVertexBufferElements(int id, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateVertexBufferElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateVertexBufferElements", id, data, dataSize, offset);
            }
            mh$.invokeExact(id, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static FunctionDescriptor rlUnloadVertexArray$descriptor() {
        return rlUnloadVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static MethodHandle rlUnloadVertexArray$handle() {
        return rlUnloadVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static MemorySegment rlUnloadVertexArray$address() {
        return rlUnloadVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadVertexArray(unsigned int vaoId)
     * }
     */
    public static void rlUnloadVertexArray(int vaoId) {
        var mh$ = rlUnloadVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadVertexArray", vaoId);
            }
            mh$.invokeExact(vaoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadVertexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadVertexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static FunctionDescriptor rlUnloadVertexBuffer$descriptor() {
        return rlUnloadVertexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static MethodHandle rlUnloadVertexBuffer$handle() {
        return rlUnloadVertexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static MemorySegment rlUnloadVertexBuffer$address() {
        return rlUnloadVertexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadVertexBuffer(unsigned int vboId)
     * }
     */
    public static void rlUnloadVertexBuffer(int vboId) {
        var mh$ = rlUnloadVertexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadVertexBuffer", vboId);
            }
            mh$.invokeExact(vboId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttribute$descriptor() {
        return rlSetVertexAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static MethodHandle rlSetVertexAttribute$handle() {
        return rlSetVertexAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static MemorySegment rlSetVertexAttribute$address() {
        return rlSetVertexAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, int offset)
     * }
     */
    public static void rlSetVertexAttribute(int index, int compSize, int type, boolean normalized, int stride, int offset) {
        var mh$ = rlSetVertexAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttribute", index, compSize, type, normalized, stride, offset);
            }
            mh$.invokeExact(index, compSize, type, normalized, stride, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttributeDivisor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttributeDivisor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttributeDivisor$descriptor() {
        return rlSetVertexAttributeDivisor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static MethodHandle rlSetVertexAttributeDivisor$handle() {
        return rlSetVertexAttributeDivisor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static MemorySegment rlSetVertexAttributeDivisor$address() {
        return rlSetVertexAttributeDivisor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttributeDivisor(unsigned int index, int divisor)
     * }
     */
    public static void rlSetVertexAttributeDivisor(int index, int divisor) {
        var mh$ = rlSetVertexAttributeDivisor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttributeDivisor", index, divisor);
            }
            mh$.invokeExact(index, divisor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetVertexAttributeDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetVertexAttributeDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static FunctionDescriptor rlSetVertexAttributeDefault$descriptor() {
        return rlSetVertexAttributeDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static MethodHandle rlSetVertexAttributeDefault$handle() {
        return rlSetVertexAttributeDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static MemorySegment rlSetVertexAttributeDefault$address() {
        return rlSetVertexAttributeDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)
     * }
     */
    public static void rlSetVertexAttributeDefault(int locIndex, MemorySegment value, int attribType, int count) {
        var mh$ = rlSetVertexAttributeDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetVertexAttributeDefault", locIndex, value, attribType, count);
            }
            mh$.invokeExact(locIndex, value, attribType, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArray$descriptor() {
        return rlDrawVertexArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static MethodHandle rlDrawVertexArray$handle() {
        return rlDrawVertexArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static MemorySegment rlDrawVertexArray$address() {
        return rlDrawVertexArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArray(int offset, int count)
     * }
     */
    public static void rlDrawVertexArray(int offset, int count) {
        var mh$ = rlDrawVertexArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArray", offset, count);
            }
            mh$.invokeExact(offset, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayElements$descriptor() {
        return rlDrawVertexArrayElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static MethodHandle rlDrawVertexArrayElements$handle() {
        return rlDrawVertexArrayElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static MemorySegment rlDrawVertexArrayElements$address() {
        return rlDrawVertexArrayElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayElements(int offset, int count, const void *buffer)
     * }
     */
    public static void rlDrawVertexArrayElements(int offset, int count, MemorySegment buffer) {
        var mh$ = rlDrawVertexArrayElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayElements", offset, count, buffer);
            }
            mh$.invokeExact(offset, count, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayInstanced$descriptor() {
        return rlDrawVertexArrayInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static MethodHandle rlDrawVertexArrayInstanced$handle() {
        return rlDrawVertexArrayInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static MemorySegment rlDrawVertexArrayInstanced$address() {
        return rlDrawVertexArrayInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayInstanced(int offset, int count, int instances)
     * }
     */
    public static void rlDrawVertexArrayInstanced(int offset, int count, int instances) {
        var mh$ = rlDrawVertexArrayInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayInstanced", offset, count, instances);
            }
            mh$.invokeExact(offset, count, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlDrawVertexArrayElementsInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlDrawVertexArrayElementsInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static FunctionDescriptor rlDrawVertexArrayElementsInstanced$descriptor() {
        return rlDrawVertexArrayElementsInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static MethodHandle rlDrawVertexArrayElementsInstanced$handle() {
        return rlDrawVertexArrayElementsInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static MemorySegment rlDrawVertexArrayElementsInstanced$address() {
        return rlDrawVertexArrayElementsInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)
     * }
     */
    public static void rlDrawVertexArrayElementsInstanced(int offset, int count, MemorySegment buffer, int instances) {
        var mh$ = rlDrawVertexArrayElementsInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlDrawVertexArrayElementsInstanced", offset, count, buffer, instances);
            }
            mh$.invokeExact(offset, count, buffer, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static FunctionDescriptor rlLoadTexture$descriptor() {
        return rlLoadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static MethodHandle rlLoadTexture$handle() {
        return rlLoadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static MemorySegment rlLoadTexture$address() {
        return rlLoadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)
     * }
     */
    public static int rlLoadTexture(MemorySegment data, int width, int height, int format, int mipmapCount) {
        var mh$ = rlLoadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTexture", data, width, height, format, mipmapCount);
            }
            return (int)mh$.invokeExact(data, width, height, format, mipmapCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTextureDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTextureDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static FunctionDescriptor rlLoadTextureDepth$descriptor() {
        return rlLoadTextureDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static MethodHandle rlLoadTextureDepth$handle() {
        return rlLoadTextureDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static MemorySegment rlLoadTextureDepth$address() {
        return rlLoadTextureDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)
     * }
     */
    public static int rlLoadTextureDepth(int width, int height, boolean useRenderBuffer) {
        var mh$ = rlLoadTextureDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTextureDepth", width, height, useRenderBuffer);
            }
            return (int)mh$.invokeExact(width, height, useRenderBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static FunctionDescriptor rlLoadTextureCubemap$descriptor() {
        return rlLoadTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static MethodHandle rlLoadTextureCubemap$handle() {
        return rlLoadTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static MemorySegment rlLoadTextureCubemap$address() {
        return rlLoadTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadTextureCubemap(const void *data, int size, int format)
     * }
     */
    public static int rlLoadTextureCubemap(MemorySegment data, int size, int format) {
        var mh$ = rlLoadTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadTextureCubemap", data, size, format);
            }
            return (int)mh$.invokeExact(data, size, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static FunctionDescriptor rlUpdateTexture$descriptor() {
        return rlUpdateTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static MethodHandle rlUpdateTexture$handle() {
        return rlUpdateTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static MemorySegment rlUpdateTexture$address() {
        return rlUpdateTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)
     * }
     */
    public static void rlUpdateTexture(int id, int offsetX, int offsetY, int width, int height, int format, MemorySegment data) {
        var mh$ = rlUpdateTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateTexture", id, offsetX, offsetY, width, height, format, data);
            }
            mh$.invokeExact(id, offsetX, offsetY, width, height, format, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetGlTextureFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetGlTextureFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static FunctionDescriptor rlGetGlTextureFormats$descriptor() {
        return rlGetGlTextureFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static MethodHandle rlGetGlTextureFormats$handle() {
        return rlGetGlTextureFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static MemorySegment rlGetGlTextureFormats$address() {
        return rlGetGlTextureFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)
     * }
     */
    public static void rlGetGlTextureFormats(int format, MemorySegment glInternalFormat, MemorySegment glFormat, MemorySegment glType) {
        var mh$ = rlGetGlTextureFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetGlTextureFormats", format, glInternalFormat, glFormat, glType);
            }
            mh$.invokeExact(format, glInternalFormat, glFormat, glType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetPixelFormatName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetPixelFormatName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static FunctionDescriptor rlGetPixelFormatName$descriptor() {
        return rlGetPixelFormatName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MethodHandle rlGetPixelFormatName$handle() {
        return rlGetPixelFormatName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MemorySegment rlGetPixelFormatName$address() {
        return rlGetPixelFormatName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *rlGetPixelFormatName(unsigned int format)
     * }
     */
    public static MemorySegment rlGetPixelFormatName(int format) {
        var mh$ = rlGetPixelFormatName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetPixelFormatName", format);
            }
            return (MemorySegment)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadTexture$descriptor() {
        return rlUnloadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadTexture$handle() {
        return rlUnloadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadTexture$address() {
        return rlUnloadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadTexture(unsigned int id)
     * }
     */
    public static void rlUnloadTexture(int id) {
        var mh$ = rlUnloadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadTexture", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGenTextureMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGenTextureMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static FunctionDescriptor rlGenTextureMipmaps$descriptor() {
        return rlGenTextureMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static MethodHandle rlGenTextureMipmaps$handle() {
        return rlGenTextureMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static MemorySegment rlGenTextureMipmaps$address() {
        return rlGenTextureMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)
     * }
     */
    public static void rlGenTextureMipmaps(int id, int width, int height, int format, MemorySegment mipmaps) {
        var mh$ = rlGenTextureMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGenTextureMipmaps", id, width, height, format, mipmaps);
            }
            mh$.invokeExact(id, width, height, format, mipmaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadTexturePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadTexturePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static FunctionDescriptor rlReadTexturePixels$descriptor() {
        return rlReadTexturePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MethodHandle rlReadTexturePixels$handle() {
        return rlReadTexturePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MemorySegment rlReadTexturePixels$address() {
        return rlReadTexturePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *rlReadTexturePixels(unsigned int id, int width, int height, int format)
     * }
     */
    public static MemorySegment rlReadTexturePixels(int id, int width, int height, int format) {
        var mh$ = rlReadTexturePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadTexturePixels", id, width, height, format);
            }
            return (MemorySegment)mh$.invokeExact(id, width, height, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadScreenPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadScreenPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static FunctionDescriptor rlReadScreenPixels$descriptor() {
        return rlReadScreenPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MethodHandle rlReadScreenPixels$handle() {
        return rlReadScreenPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MemorySegment rlReadScreenPixels$address() {
        return rlReadScreenPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *rlReadScreenPixels(int width, int height)
     * }
     */
    public static MemorySegment rlReadScreenPixels(int width, int height) {
        var mh$ = rlReadScreenPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadScreenPixels", width, height);
            }
            return (MemorySegment)mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static FunctionDescriptor rlLoadFramebuffer$descriptor() {
        return rlLoadFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static MethodHandle rlLoadFramebuffer$handle() {
        return rlLoadFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static MemorySegment rlLoadFramebuffer$address() {
        return rlLoadFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadFramebuffer()
     * }
     */
    public static int rlLoadFramebuffer() {
        var mh$ = rlLoadFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadFramebuffer");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFramebufferAttach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFramebufferAttach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static FunctionDescriptor rlFramebufferAttach$descriptor() {
        return rlFramebufferAttach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static MethodHandle rlFramebufferAttach$handle() {
        return rlFramebufferAttach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static MemorySegment rlFramebufferAttach$address() {
        return rlFramebufferAttach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)
     * }
     */
    public static void rlFramebufferAttach(int fboId, int texId, int attachType, int texType, int mipLevel) {
        var mh$ = rlFramebufferAttach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFramebufferAttach", fboId, texId, attachType, texType, mipLevel);
            }
            mh$.invokeExact(fboId, texId, attachType, texType, mipLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlFramebufferComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlFramebufferComplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlFramebufferComplete$descriptor() {
        return rlFramebufferComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static MethodHandle rlFramebufferComplete$handle() {
        return rlFramebufferComplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static MemorySegment rlFramebufferComplete$address() {
        return rlFramebufferComplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool rlFramebufferComplete(unsigned int id)
     * }
     */
    public static boolean rlFramebufferComplete(int id) {
        var mh$ = rlFramebufferComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlFramebufferComplete", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadFramebuffer$descriptor() {
        return rlUnloadFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadFramebuffer$handle() {
        return rlUnloadFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadFramebuffer$address() {
        return rlUnloadFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadFramebuffer(unsigned int id)
     * }
     */
    public static void rlUnloadFramebuffer(int id) {
        var mh$ = rlUnloadFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadFramebuffer", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static FunctionDescriptor rlLoadShaderCode$descriptor() {
        return rlLoadShaderCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static MethodHandle rlLoadShaderCode$handle() {
        return rlLoadShaderCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static MemorySegment rlLoadShaderCode$address() {
        return rlLoadShaderCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)
     * }
     */
    public static int rlLoadShaderCode(MemorySegment vsCode, MemorySegment fsCode) {
        var mh$ = rlLoadShaderCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderCode", vsCode, fsCode);
            }
            return (int)mh$.invokeExact(vsCode, fsCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCompileShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCompileShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static FunctionDescriptor rlCompileShader$descriptor() {
        return rlCompileShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static MethodHandle rlCompileShader$handle() {
        return rlCompileShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static MemorySegment rlCompileShader$address() {
        return rlCompileShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlCompileShader(const char *shaderCode, int type)
     * }
     */
    public static int rlCompileShader(MemorySegment shaderCode, int type) {
        var mh$ = rlCompileShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCompileShader", shaderCode, type);
            }
            return (int)mh$.invokeExact(shaderCode, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static FunctionDescriptor rlLoadShaderProgram$descriptor() {
        return rlLoadShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static MethodHandle rlLoadShaderProgram$handle() {
        return rlLoadShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static MemorySegment rlLoadShaderProgram$address() {
        return rlLoadShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)
     * }
     */
    public static int rlLoadShaderProgram(int vShaderId, int fShaderId) {
        var mh$ = rlLoadShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderProgram", vShaderId, fShaderId);
            }
            return (int)mh$.invokeExact(vShaderId, fShaderId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlUnloadShaderProgram$descriptor() {
        return rlUnloadShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static MethodHandle rlUnloadShaderProgram$handle() {
        return rlUnloadShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static MemorySegment rlUnloadShaderProgram$address() {
        return rlUnloadShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadShaderProgram(unsigned int id)
     * }
     */
    public static void rlUnloadShaderProgram(int id) {
        var mh$ = rlUnloadShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadShaderProgram", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLocationUniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLocationUniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static FunctionDescriptor rlGetLocationUniform$descriptor() {
        return rlGetLocationUniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static MethodHandle rlGetLocationUniform$handle() {
        return rlGetLocationUniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static MemorySegment rlGetLocationUniform$address() {
        return rlGetLocationUniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)
     * }
     */
    public static int rlGetLocationUniform(int shaderId, MemorySegment uniformName) {
        var mh$ = rlGetLocationUniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLocationUniform", shaderId, uniformName);
            }
            return (int)mh$.invokeExact(shaderId, uniformName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetLocationAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetLocationAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static FunctionDescriptor rlGetLocationAttrib$descriptor() {
        return rlGetLocationAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static MethodHandle rlGetLocationAttrib$handle() {
        return rlGetLocationAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static MemorySegment rlGetLocationAttrib$address() {
        return rlGetLocationAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)
     * }
     */
    public static int rlGetLocationAttrib(int shaderId, MemorySegment attribName) {
        var mh$ = rlGetLocationAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetLocationAttrib", shaderId, attribName);
            }
            return (int)mh$.invokeExact(shaderId, attribName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static FunctionDescriptor rlSetUniform$descriptor() {
        return rlSetUniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MethodHandle rlSetUniform$handle() {
        return rlSetUniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MemorySegment rlSetUniform$address() {
        return rlSetUniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniform(int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static void rlSetUniform(int locIndex, MemorySegment value, int uniformType, int count) {
        var mh$ = rlSetUniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniform", locIndex, value, uniformType, count);
            }
            mh$.invokeExact(locIndex, value, uniformType, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniformMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniformMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static FunctionDescriptor rlSetUniformMatrix$descriptor() {
        return rlSetUniformMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static MethodHandle rlSetUniformMatrix$handle() {
        return rlSetUniformMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static MemorySegment rlSetUniformMatrix$address() {
        return rlSetUniformMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniformMatrix(int locIndex, Matrix mat)
     * }
     */
    public static void rlSetUniformMatrix(int locIndex, MemorySegment mat) {
        var mh$ = rlSetUniformMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniformMatrix", locIndex, mat);
            }
            mh$.invokeExact(locIndex, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetUniformSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetUniformSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static FunctionDescriptor rlSetUniformSampler$descriptor() {
        return rlSetUniformSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static MethodHandle rlSetUniformSampler$handle() {
        return rlSetUniformSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static MemorySegment rlSetUniformSampler$address() {
        return rlSetUniformSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetUniformSampler(int locIndex, unsigned int textureId)
     * }
     */
    public static void rlSetUniformSampler(int locIndex, int textureId) {
        var mh$ = rlSetUniformSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetUniformSampler", locIndex, textureId);
            }
            mh$.invokeExact(locIndex, textureId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static FunctionDescriptor rlSetShader$descriptor() {
        return rlSetShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static MethodHandle rlSetShader$handle() {
        return rlSetShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static MemorySegment rlSetShader$address() {
        return rlSetShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetShader(unsigned int id, int *locs)
     * }
     */
    public static void rlSetShader(int id, MemorySegment locs) {
        var mh$ = rlSetShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetShader", id, locs);
            }
            mh$.invokeExact(id, locs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadComputeShaderProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadComputeShaderProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static FunctionDescriptor rlLoadComputeShaderProgram$descriptor() {
        return rlLoadComputeShaderProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static MethodHandle rlLoadComputeShaderProgram$handle() {
        return rlLoadComputeShaderProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static MemorySegment rlLoadComputeShaderProgram$address() {
        return rlLoadComputeShaderProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)
     * }
     */
    public static int rlLoadComputeShaderProgram(int shaderId) {
        var mh$ = rlLoadComputeShaderProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadComputeShaderProgram", shaderId);
            }
            return (int)mh$.invokeExact(shaderId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlComputeShaderDispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlComputeShaderDispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static FunctionDescriptor rlComputeShaderDispatch$descriptor() {
        return rlComputeShaderDispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static MethodHandle rlComputeShaderDispatch$handle() {
        return rlComputeShaderDispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static MemorySegment rlComputeShaderDispatch$address() {
        return rlComputeShaderDispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)
     * }
     */
    public static void rlComputeShaderDispatch(int groupX, int groupY, int groupZ) {
        var mh$ = rlComputeShaderDispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlComputeShaderDispatch", groupX, groupY, groupZ);
            }
            mh$.invokeExact(groupX, groupY, groupZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static FunctionDescriptor rlLoadShaderBuffer$descriptor() {
        return rlLoadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static MethodHandle rlLoadShaderBuffer$handle() {
        return rlLoadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static MemorySegment rlLoadShaderBuffer$address() {
        return rlLoadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)
     * }
     */
    public static int rlLoadShaderBuffer(int size, MemorySegment data, int usageHint) {
        var mh$ = rlLoadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadShaderBuffer", size, data, usageHint);
            }
            return (int)mh$.invokeExact(size, data, usageHint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUnloadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUnloadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static FunctionDescriptor rlUnloadShaderBuffer$descriptor() {
        return rlUnloadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static MethodHandle rlUnloadShaderBuffer$handle() {
        return rlUnloadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static MemorySegment rlUnloadShaderBuffer$address() {
        return rlUnloadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUnloadShaderBuffer(unsigned int ssboId)
     * }
     */
    public static void rlUnloadShaderBuffer(int ssboId) {
        var mh$ = rlUnloadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUnloadShaderBuffer", ssboId);
            }
            mh$.invokeExact(ssboId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlUpdateShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlUpdateShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static FunctionDescriptor rlUpdateShaderBuffer$descriptor() {
        return rlUpdateShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static MethodHandle rlUpdateShaderBuffer$handle() {
        return rlUpdateShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static MemorySegment rlUpdateShaderBuffer$address() {
        return rlUpdateShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)
     * }
     */
    public static void rlUpdateShaderBuffer(int id, MemorySegment data, int dataSize, int offset) {
        var mh$ = rlUpdateShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlUpdateShaderBuffer", id, data, dataSize, offset);
            }
            mh$.invokeExact(id, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static FunctionDescriptor rlBindShaderBuffer$descriptor() {
        return rlBindShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static MethodHandle rlBindShaderBuffer$handle() {
        return rlBindShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static MemorySegment rlBindShaderBuffer$address() {
        return rlBindShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindShaderBuffer(unsigned int id, unsigned int index)
     * }
     */
    public static void rlBindShaderBuffer(int id, int index) {
        var mh$ = rlBindShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindShaderBuffer", id, index);
            }
            mh$.invokeExact(id, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlReadShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlReadShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static FunctionDescriptor rlReadShaderBuffer$descriptor() {
        return rlReadShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static MethodHandle rlReadShaderBuffer$handle() {
        return rlReadShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static MemorySegment rlReadShaderBuffer$address() {
        return rlReadShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)
     * }
     */
    public static void rlReadShaderBuffer(int id, MemorySegment dest, int count, int offset) {
        var mh$ = rlReadShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlReadShaderBuffer", id, dest, count, offset);
            }
            mh$.invokeExact(id, dest, count, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlCopyShaderBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlCopyShaderBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static FunctionDescriptor rlCopyShaderBuffer$descriptor() {
        return rlCopyShaderBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static MethodHandle rlCopyShaderBuffer$handle() {
        return rlCopyShaderBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static MemorySegment rlCopyShaderBuffer$address() {
        return rlCopyShaderBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)
     * }
     */
    public static void rlCopyShaderBuffer(int destId, int srcId, int destOffset, int srcOffset, int count) {
        var mh$ = rlCopyShaderBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlCopyShaderBuffer", destId, srcId, destOffset, srcOffset, count);
            }
            mh$.invokeExact(destId, srcId, destOffset, srcOffset, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetShaderBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetShaderBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static FunctionDescriptor rlGetShaderBufferSize$descriptor() {
        return rlGetShaderBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static MethodHandle rlGetShaderBufferSize$handle() {
        return rlGetShaderBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static MemorySegment rlGetShaderBufferSize$address() {
        return rlGetShaderBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int rlGetShaderBufferSize(unsigned int id)
     * }
     */
    public static int rlGetShaderBufferSize(int id) {
        var mh$ = rlGetShaderBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetShaderBufferSize", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlBindImageTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlBindImageTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static FunctionDescriptor rlBindImageTexture$descriptor() {
        return rlBindImageTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static MethodHandle rlBindImageTexture$handle() {
        return rlBindImageTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static MemorySegment rlBindImageTexture$address() {
        return rlBindImageTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)
     * }
     */
    public static void rlBindImageTexture(int id, int index, int format, boolean readonly) {
        var mh$ = rlBindImageTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlBindImageTexture", id, index, format, readonly);
            }
            mh$.invokeExact(id, index, format, readonly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixModelview {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixModelview");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static FunctionDescriptor rlGetMatrixModelview$descriptor() {
        return rlGetMatrixModelview.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MethodHandle rlGetMatrixModelview$handle() {
        return rlGetMatrixModelview.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MemorySegment rlGetMatrixModelview$address() {
        return rlGetMatrixModelview.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixModelview()
     * }
     */
    public static MemorySegment rlGetMatrixModelview(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixModelview.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixModelview", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixProjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixProjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static FunctionDescriptor rlGetMatrixProjection$descriptor() {
        return rlGetMatrixProjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MethodHandle rlGetMatrixProjection$handle() {
        return rlGetMatrixProjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MemorySegment rlGetMatrixProjection$address() {
        return rlGetMatrixProjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjection()
     * }
     */
    public static MemorySegment rlGetMatrixProjection(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixProjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixProjection", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static FunctionDescriptor rlGetMatrixTransform$descriptor() {
        return rlGetMatrixTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MethodHandle rlGetMatrixTransform$handle() {
        return rlGetMatrixTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MemorySegment rlGetMatrixTransform$address() {
        return rlGetMatrixTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixTransform()
     * }
     */
    public static MemorySegment rlGetMatrixTransform(SegmentAllocator allocator) {
        var mh$ = rlGetMatrixTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixTransform", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixProjectionStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixProjectionStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static FunctionDescriptor rlGetMatrixProjectionStereo$descriptor() {
        return rlGetMatrixProjectionStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MethodHandle rlGetMatrixProjectionStereo$handle() {
        return rlGetMatrixProjectionStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixProjectionStereo$address() {
        return rlGetMatrixProjectionStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixProjectionStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixProjectionStereo(SegmentAllocator allocator, int eye) {
        var mh$ = rlGetMatrixProjectionStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixProjectionStereo", allocator, eye);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlGetMatrixViewOffsetStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlGetMatrixViewOffsetStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static FunctionDescriptor rlGetMatrixViewOffsetStereo$descriptor() {
        return rlGetMatrixViewOffsetStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MethodHandle rlGetMatrixViewOffsetStereo$handle() {
        return rlGetMatrixViewOffsetStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixViewOffsetStereo$address() {
        return rlGetMatrixViewOffsetStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix rlGetMatrixViewOffsetStereo(int eye)
     * }
     */
    public static MemorySegment rlGetMatrixViewOffsetStereo(SegmentAllocator allocator, int eye) {
        var mh$ = rlGetMatrixViewOffsetStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlGetMatrixViewOffsetStereo", allocator, eye);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixProjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixProjection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static FunctionDescriptor rlSetMatrixProjection$descriptor() {
        return rlSetMatrixProjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static MethodHandle rlSetMatrixProjection$handle() {
        return rlSetMatrixProjection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static MemorySegment rlSetMatrixProjection$address() {
        return rlSetMatrixProjection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixProjection(Matrix proj)
     * }
     */
    public static void rlSetMatrixProjection(MemorySegment proj) {
        var mh$ = rlSetMatrixProjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixProjection", proj);
            }
            mh$.invokeExact(proj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixModelview {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixModelview");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static FunctionDescriptor rlSetMatrixModelview$descriptor() {
        return rlSetMatrixModelview.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static MethodHandle rlSetMatrixModelview$handle() {
        return rlSetMatrixModelview.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static MemorySegment rlSetMatrixModelview$address() {
        return rlSetMatrixModelview.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixModelview(Matrix view)
     * }
     */
    public static void rlSetMatrixModelview(MemorySegment view) {
        var mh$ = rlSetMatrixModelview.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixModelview", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixProjectionStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixProjectionStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static FunctionDescriptor rlSetMatrixProjectionStereo$descriptor() {
        return rlSetMatrixProjectionStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static MethodHandle rlSetMatrixProjectionStereo$handle() {
        return rlSetMatrixProjectionStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static MemorySegment rlSetMatrixProjectionStereo$address() {
        return rlSetMatrixProjectionStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixProjectionStereo(Matrix right, Matrix left)
     * }
     */
    public static void rlSetMatrixProjectionStereo(MemorySegment right, MemorySegment left) {
        var mh$ = rlSetMatrixProjectionStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixProjectionStereo", right, left);
            }
            mh$.invokeExact(right, left);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlSetMatrixViewOffsetStereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlSetMatrixViewOffsetStereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static FunctionDescriptor rlSetMatrixViewOffsetStereo$descriptor() {
        return rlSetMatrixViewOffsetStereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static MethodHandle rlSetMatrixViewOffsetStereo$handle() {
        return rlSetMatrixViewOffsetStereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static MemorySegment rlSetMatrixViewOffsetStereo$address() {
        return rlSetMatrixViewOffsetStereo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)
     * }
     */
    public static void rlSetMatrixViewOffsetStereo(MemorySegment right, MemorySegment left) {
        var mh$ = rlSetMatrixViewOffsetStereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlSetMatrixViewOffsetStereo", right, left);
            }
            mh$.invokeExact(right, left);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadDrawCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadDrawCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static FunctionDescriptor rlLoadDrawCube$descriptor() {
        return rlLoadDrawCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static MethodHandle rlLoadDrawCube$handle() {
        return rlLoadDrawCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static MemorySegment rlLoadDrawCube$address() {
        return rlLoadDrawCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadDrawCube()
     * }
     */
    public static void rlLoadDrawCube() {
        var mh$ = rlLoadDrawCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadDrawCube");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rlLoadDrawQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("rlLoadDrawQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static FunctionDescriptor rlLoadDrawQuad$descriptor() {
        return rlLoadDrawQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static MethodHandle rlLoadDrawQuad$handle() {
        return rlLoadDrawQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static MemorySegment rlLoadDrawQuad$address() {
        return rlLoadDrawQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rlLoadDrawQuad()
     * }
     */
    public static void rlLoadDrawQuad() {
        var mh$ = rlLoadDrawQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rlLoadDrawQuad");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = raylib.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = raylib.C_DOUBLE;

    private static class __math_errhandling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("__math_errhandling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static FunctionDescriptor __math_errhandling$descriptor() {
        return __math_errhandling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MethodHandle __math_errhandling$handle() {
        return __math_errhandling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MemorySegment __math_errhandling$address() {
        return __math_errhandling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static int __math_errhandling() {
        var mh$ = __math_errhandling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__math_errhandling");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static int __fpclassifyf(float x0) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__fpclassifyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static FunctionDescriptor __fpclassifyd$descriptor() {
        return __fpclassifyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MethodHandle __fpclassifyd$handle() {
        return __fpclassifyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MemorySegment __fpclassifyd$address() {
        return __fpclassifyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static int __fpclassifyd(double x0) {
        var mh$ = __fpclassifyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static float acosf(float x0) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static double acos(double x0) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static float asinf(float x0) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static double asin(double x0) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static float atanf(float x0) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static double atan(double x0) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static float atan2f(float x0, float x1) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static double atan2(double x0, double x1) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static float cosf(float x0) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static double cos(double x0) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static float sinf(float x0) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static double sin(double x0) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static float tanf(float x0) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static double tan(double x0) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static float acoshf(float x0) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static double acosh(double x0) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static float asinhf(float x0) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static double asinh(double x0) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static float atanhf(float x0) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static double atanh(double x0) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static float coshf(float x0) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static double cosh(double x0) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static float sinhf(float x0) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static double sinh(double x0) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static float tanhf(float x0) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static double tanh(double x0) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static float expf(float x0) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static double exp(double x0) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static float exp2f(float x0) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static double exp2(double x0) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static float expm1f(float x0) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static double expm1(double x0) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static float logf(float x0) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static double log(double x0) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static float log10f(float x0) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static double log10(double x0) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static float log2f(float x0) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static double log2(double x0) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static float log1pf(float x0) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static double log1p(double x0) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static float logbf(float x0) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static double logb(double x0) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static float modff(float x0, MemorySegment x1) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static double modf(double x0, MemorySegment x1) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static float ldexpf(float x0, int x1) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static double ldexp(double x0, int x1) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static float frexpf(float x0, MemorySegment x1) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static double frexp(double x0, MemorySegment x1) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static int ilogbf(float x0) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static int ilogb(double x0) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static float scalbnf(float x0, int x1) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static double scalbn(double x0, int x1) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_LONG
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static float scalblnf(float x0, long x1) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_LONG
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static double scalbln(double x0, long x1) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static float fabsf(float x0) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static double fabs(double x0) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static float cbrtf(float x0) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static double cbrt(double x0) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static float hypotf(float x0, float x1) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static double hypot(double x0, double x1) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static float powf(float x0, float x1) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static double pow(double x0, double x1) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static float sqrtf(float x0) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static double sqrt(double x0) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static float ceilf(float x0) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static double ceil(double x0) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static float floorf(float x0) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static double floor(double x0) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static float nearbyintf(float x0) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static double nearbyint(double x0) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static float rintf(float x0) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static double rint(double x0) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static long lrintf(float x0) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static long lrint(double x0) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static float roundf(float x0) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static double round(double x0) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static long lroundf(float x0) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static long lround(double x0) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG_LONG,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static long llrintf(float x0) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG_LONG,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static long llrint(double x0) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG_LONG,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static long llroundf(float x0) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG_LONG,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static long llround(double x0) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static float truncf(float x0) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static double trunc(double x0) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static float fmodf(float x0, float x1) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static double fmod(double x0, double x1) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static float remainderf(float x0, float x1) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static double remainder(double x0, double x1) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static float remquof(float x0, float x1, MemorySegment x2) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static double remquo(double x0, double x1, MemorySegment x2) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static float copysignf(float x0, float x1) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static double copysign(double x0, double x1) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static float nanf(MemorySegment x0) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static double nan(MemorySegment x0) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static float nextafterf(float x0, float x1) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static double nextafter(double x0, double x1) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static float fdimf(float x0, float x1) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static double fdim(double x0, double x1) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static float fmaxf(float x0, float x1) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static double fmax(double x0, double x1) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static float fminf(float x0, float x1) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static double fmin(double x0, double x1) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static float fmaf(float x0, float x1, float x2) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static double fma(double x0, double x1, double x2) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__exp10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static FunctionDescriptor __exp10f$descriptor() {
        return __exp10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MethodHandle __exp10f$handle() {
        return __exp10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MemorySegment __exp10f$address() {
        return __exp10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static float __exp10f(float x0) {
        var mh$ = __exp10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__exp10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static FunctionDescriptor __exp10$descriptor() {
        return __exp10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MethodHandle __exp10$handle() {
        return __exp10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MemorySegment __exp10$address() {
        return __exp10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static double __exp10(double x0) {
        var mh$ = __exp10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__cospif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static FunctionDescriptor __cospif$descriptor() {
        return __cospif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MethodHandle __cospif$handle() {
        return __cospif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MemorySegment __cospif$address() {
        return __cospif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static float __cospif(float x0) {
        var mh$ = __cospif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__cospi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static FunctionDescriptor __cospi$descriptor() {
        return __cospi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MethodHandle __cospi$handle() {
        return __cospi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MemorySegment __cospi$address() {
        return __cospi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static double __cospi(double x0) {
        var mh$ = __cospi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__sinpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static FunctionDescriptor __sinpif$descriptor() {
        return __sinpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MethodHandle __sinpif$handle() {
        return __sinpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MemorySegment __sinpif$address() {
        return __sinpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static float __sinpif(float x0) {
        var mh$ = __sinpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__sinpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static FunctionDescriptor __sinpi$descriptor() {
        return __sinpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MethodHandle __sinpi$handle() {
        return __sinpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MemorySegment __sinpi$address() {
        return __sinpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static double __sinpi(double x0) {
        var mh$ = __sinpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__tanpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static FunctionDescriptor __tanpif$descriptor() {
        return __tanpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MethodHandle __tanpif$handle() {
        return __tanpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MemorySegment __tanpif$address() {
        return __tanpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static float __tanpif(float x0) {
        var mh$ = __tanpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("__tanpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static FunctionDescriptor __tanpi$descriptor() {
        return __tanpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MethodHandle __tanpi$handle() {
        return __tanpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MemorySegment __tanpi$address() {
        return __tanpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static double __tanpi(double x0) {
        var mh$ = __tanpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_INT,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_INT,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static double scalb(double x0, double x1) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = raylib.C_INT;
        public static final MemorySegment SEGMENT = raylib.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }

    private static class Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static FunctionDescriptor Clamp$descriptor() {
        return Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static MethodHandle Clamp$handle() {
        return Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static MemorySegment Clamp$address() {
        return Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Clamp(float value, float min, float max)
     * }
     */
    public static float Clamp(float value, float min, float max) {
        var mh$ = Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Clamp", value, min, max);
            }
            return (float)mh$.invokeExact(value, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static FunctionDescriptor Lerp$descriptor() {
        return Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static MethodHandle Lerp$handle() {
        return Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static MemorySegment Lerp$address() {
        return Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Lerp(float start, float end, float amount)
     * }
     */
    public static float Lerp(float start, float end, float amount) {
        var mh$ = Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Lerp", start, end, amount);
            }
            return (float)mh$.invokeExact(start, end, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static FunctionDescriptor Normalize$descriptor() {
        return Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static MethodHandle Normalize$handle() {
        return Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static MemorySegment Normalize$address() {
        return Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Normalize(float value, float start, float end)
     * }
     */
    public static float Normalize(float value, float start, float end) {
        var mh$ = Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Normalize", value, start, end);
            }
            return (float)mh$.invokeExact(value, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Remap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Remap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static FunctionDescriptor Remap$descriptor() {
        return Remap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static MethodHandle Remap$handle() {
        return Remap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static MemorySegment Remap$address() {
        return Remap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)
     * }
     */
    public static float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd) {
        var mh$ = Remap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Remap", value, inputStart, inputEnd, outputStart, outputEnd);
            }
            return (float)mh$.invokeExact(value, inputStart, inputEnd, outputStart, outputEnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wrap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Wrap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static FunctionDescriptor Wrap$descriptor() {
        return Wrap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static MethodHandle Wrap$handle() {
        return Wrap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static MemorySegment Wrap$address() {
        return Wrap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Wrap(float value, float min, float max)
     * }
     */
    public static float Wrap(float value, float min, float max) {
        var mh$ = Wrap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wrap", value, min, max);
            }
            return (float)mh$.invokeExact(value, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloatEquals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("FloatEquals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static FunctionDescriptor FloatEquals$descriptor() {
        return FloatEquals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static MethodHandle FloatEquals$handle() {
        return FloatEquals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static MemorySegment FloatEquals$address() {
        return FloatEquals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FloatEquals(float x, float y)
     * }
     */
    public static int FloatEquals(float x, float y) {
        var mh$ = FloatEquals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloatEquals", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static FunctionDescriptor Vector2Zero$descriptor() {
        return Vector2Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MethodHandle Vector2Zero$handle() {
        return Vector2Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MemorySegment Vector2Zero$address() {
        return Vector2Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Zero()
     * }
     */
    public static MemorySegment Vector2Zero(SegmentAllocator allocator) {
        var mh$ = Vector2Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static FunctionDescriptor Vector2One$descriptor() {
        return Vector2One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MethodHandle Vector2One$handle() {
        return Vector2One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MemorySegment Vector2One$address() {
        return Vector2One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2One()
     * }
     */
    public static MemorySegment Vector2One(SegmentAllocator allocator) {
        var mh$ = Vector2One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Add$descriptor() {
        return Vector2Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Add$handle() {
        return Vector2Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Add$address() {
        return Vector2Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Add(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static FunctionDescriptor Vector2AddValue$descriptor() {
        return Vector2AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MethodHandle Vector2AddValue$handle() {
        return Vector2AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MemorySegment Vector2AddValue$address() {
        return Vector2AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2AddValue(Vector2 v, float add)
     * }
     */
    public static MemorySegment Vector2AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector2AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Subtract$descriptor() {
        return Vector2Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Subtract$handle() {
        return Vector2Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Subtract$address() {
        return Vector2Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static FunctionDescriptor Vector2SubtractValue$descriptor() {
        return Vector2SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MethodHandle Vector2SubtractValue$handle() {
        return Vector2SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MemorySegment Vector2SubtractValue$address() {
        return Vector2SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2SubtractValue(Vector2 v, float sub)
     * }
     */
    public static MemorySegment Vector2SubtractValue(SegmentAllocator allocator, MemorySegment v, float sub) {
        var mh$ = Vector2SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2SubtractValue", allocator, v, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Length$descriptor() {
        return Vector2Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Length$handle() {
        return Vector2Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Length$address() {
        return Vector2Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Length(Vector2 v)
     * }
     */
    public static float Vector2Length(MemorySegment v) {
        var mh$ = Vector2Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2LengthSqr$descriptor() {
        return Vector2LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static MethodHandle Vector2LengthSqr$handle() {
        return Vector2LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static MemorySegment Vector2LengthSqr$address() {
        return Vector2LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2LengthSqr(Vector2 v)
     * }
     */
    public static float Vector2LengthSqr(MemorySegment v) {
        var mh$ = Vector2LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2DotProduct$descriptor() {
        return Vector2DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2DotProduct$handle() {
        return Vector2DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2DotProduct$address() {
        return Vector2DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2DotProduct(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Distance$descriptor() {
        return Vector2Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Distance$handle() {
        return Vector2Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Distance$address() {
        return Vector2Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Distance(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2DistanceSqr$descriptor() {
        return Vector2DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2DistanceSqr$handle() {
        return Vector2DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2DistanceSqr$address() {
        return Vector2DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2DistanceSqr(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Angle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Angle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Angle$descriptor() {
        return Vector2Angle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Angle$handle() {
        return Vector2Angle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Angle$address() {
        return Vector2Angle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2Angle(Vector2 v1, Vector2 v2)
     * }
     */
    public static float Vector2Angle(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Angle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Angle", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2LineAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2LineAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static FunctionDescriptor Vector2LineAngle$descriptor() {
        return Vector2LineAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static MethodHandle Vector2LineAngle$handle() {
        return Vector2LineAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static MemorySegment Vector2LineAngle$address() {
        return Vector2LineAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector2LineAngle(Vector2 start, Vector2 end)
     * }
     */
    public static float Vector2LineAngle(MemorySegment start, MemorySegment end) {
        var mh$ = Vector2LineAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2LineAngle", start, end);
            }
            return (float)mh$.invokeExact(start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static FunctionDescriptor Vector2Scale$descriptor() {
        return Vector2Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MethodHandle Vector2Scale$handle() {
        return Vector2Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MemorySegment Vector2Scale$address() {
        return Vector2Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Scale(Vector2 v, float scale)
     * }
     */
    public static MemorySegment Vector2Scale(SegmentAllocator allocator, MemorySegment v, float scale) {
        var mh$ = Vector2Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Scale", allocator, v, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Multiply$descriptor() {
        return Vector2Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Multiply$handle() {
        return Vector2Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Multiply$address() {
        return Vector2Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Negate$descriptor() {
        return Vector2Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Negate$handle() {
        return Vector2Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Negate$address() {
        return Vector2Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Negate(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Divide$descriptor() {
        return Vector2Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Divide$handle() {
        return Vector2Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Divide$address() {
        return Vector2Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Divide(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Normalize$descriptor() {
        return Vector2Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Normalize$handle() {
        return Vector2Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Normalize$address() {
        return Vector2Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Normalize(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static FunctionDescriptor Vector2Transform$descriptor() {
        return Vector2Transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MethodHandle Vector2Transform$handle() {
        return Vector2Transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector2Transform$address() {
        return Vector2Transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Transform(Vector2 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector2Transform(SegmentAllocator allocator, MemorySegment v, MemorySegment mat) {
        var mh$ = Vector2Transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Transform", allocator, v, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector2Lerp$descriptor() {
        return Vector2Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MethodHandle Vector2Lerp$handle() {
        return Vector2Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MemorySegment Vector2Lerp$address() {
        return Vector2Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)
     * }
     */
    public static MemorySegment Vector2Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector2Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Reflect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Reflect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static FunctionDescriptor Vector2Reflect$descriptor() {
        return Vector2Reflect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MethodHandle Vector2Reflect$handle() {
        return Vector2Reflect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MemorySegment Vector2Reflect$address() {
        return Vector2Reflect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Reflect(Vector2 v, Vector2 normal)
     * }
     */
    public static MemorySegment Vector2Reflect(SegmentAllocator allocator, MemorySegment v, MemorySegment normal) {
        var mh$ = Vector2Reflect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Reflect", allocator, v, normal);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Min$descriptor() {
        return Vector2Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Min$handle() {
        return Vector2Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Min$address() {
        return Vector2Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Min(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static FunctionDescriptor Vector2Max$descriptor() {
        return Vector2Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MethodHandle Vector2Max$handle() {
        return Vector2Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Max$address() {
        return Vector2Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Max(Vector2 v1, Vector2 v2)
     * }
     */
    public static MemorySegment Vector2Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector2Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static FunctionDescriptor Vector2Rotate$descriptor() {
        return Vector2Rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MethodHandle Vector2Rotate$handle() {
        return Vector2Rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MemorySegment Vector2Rotate$address() {
        return Vector2Rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Rotate(Vector2 v, float angle)
     * }
     */
    public static MemorySegment Vector2Rotate(SegmentAllocator allocator, MemorySegment v, float angle) {
        var mh$ = Vector2Rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Rotate", allocator, v, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector2MoveTowards$descriptor() {
        return Vector2MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector2MoveTowards$handle() {
        return Vector2MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector2MoveTowards$address() {
        return Vector2MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector2MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector2MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static FunctionDescriptor Vector2Invert$descriptor() {
        return Vector2Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MethodHandle Vector2Invert$handle() {
        return Vector2Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Invert$address() {
        return Vector2Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Invert(Vector2 v)
     * }
     */
    public static MemorySegment Vector2Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector2Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static FunctionDescriptor Vector2Clamp$descriptor() {
        return Vector2Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MethodHandle Vector2Clamp$handle() {
        return Vector2Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MemorySegment Vector2Clamp$address() {
        return Vector2Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)
     * }
     */
    public static MemorySegment Vector2Clamp(SegmentAllocator allocator, MemorySegment v, MemorySegment min, MemorySegment max) {
        var mh$ = Vector2Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Clamp", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2ClampValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2ClampValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static FunctionDescriptor Vector2ClampValue$descriptor() {
        return Vector2ClampValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MethodHandle Vector2ClampValue$handle() {
        return Vector2ClampValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MemorySegment Vector2ClampValue$address() {
        return Vector2ClampValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2ClampValue(Vector2 v, float min, float max)
     * }
     */
    public static MemorySegment Vector2ClampValue(SegmentAllocator allocator, MemorySegment v, float min, float max) {
        var mh$ = Vector2ClampValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2ClampValue", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static FunctionDescriptor Vector2Equals$descriptor() {
        return Vector2Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static MethodHandle Vector2Equals$handle() {
        return Vector2Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static MemorySegment Vector2Equals$address() {
        return Vector2Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector2Equals(Vector2 p, Vector2 q)
     * }
     */
    public static int Vector2Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector2Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector2Refract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector2Refract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static FunctionDescriptor Vector2Refract$descriptor() {
        return Vector2Refract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MethodHandle Vector2Refract$handle() {
        return Vector2Refract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MemorySegment Vector2Refract$address() {
        return Vector2Refract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 Vector2Refract(Vector2 v, Vector2 n, float r)
     * }
     */
    public static MemorySegment Vector2Refract(SegmentAllocator allocator, MemorySegment v, MemorySegment n, float r) {
        var mh$ = Vector2Refract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector2Refract", allocator, v, n, r);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, n, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static FunctionDescriptor Vector3Zero$descriptor() {
        return Vector3Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MethodHandle Vector3Zero$handle() {
        return Vector3Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MemorySegment Vector3Zero$address() {
        return Vector3Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Zero()
     * }
     */
    public static MemorySegment Vector3Zero(SegmentAllocator allocator) {
        var mh$ = Vector3Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static FunctionDescriptor Vector3One$descriptor() {
        return Vector3One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MethodHandle Vector3One$handle() {
        return Vector3One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MemorySegment Vector3One$address() {
        return Vector3One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3One()
     * }
     */
    public static MemorySegment Vector3One(SegmentAllocator allocator) {
        var mh$ = Vector3One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Add$descriptor() {
        return Vector3Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Add$handle() {
        return Vector3Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Add$address() {
        return Vector3Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Add(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static FunctionDescriptor Vector3AddValue$descriptor() {
        return Vector3AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MethodHandle Vector3AddValue$handle() {
        return Vector3AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MemorySegment Vector3AddValue$address() {
        return Vector3AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3AddValue(Vector3 v, float add)
     * }
     */
    public static MemorySegment Vector3AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector3AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Subtract$descriptor() {
        return Vector3Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Subtract$handle() {
        return Vector3Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract$address() {
        return Vector3Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static FunctionDescriptor Vector3SubtractValue$descriptor() {
        return Vector3SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MethodHandle Vector3SubtractValue$handle() {
        return Vector3SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MemorySegment Vector3SubtractValue$address() {
        return Vector3SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3SubtractValue(Vector3 v, float sub)
     * }
     */
    public static MemorySegment Vector3SubtractValue(SegmentAllocator allocator, MemorySegment v, float sub) {
        var mh$ = Vector3SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3SubtractValue", allocator, v, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static FunctionDescriptor Vector3Scale$descriptor() {
        return Vector3Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MethodHandle Vector3Scale$handle() {
        return Vector3Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MemorySegment Vector3Scale$address() {
        return Vector3Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Scale(Vector3 v, float scalar)
     * }
     */
    public static MemorySegment Vector3Scale(SegmentAllocator allocator, MemorySegment v, float scalar) {
        var mh$ = Vector3Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Scale", allocator, v, scalar);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scalar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Multiply$descriptor() {
        return Vector3Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Multiply$handle() {
        return Vector3Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Multiply$address() {
        return Vector3Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3CrossProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3CrossProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3CrossProduct$descriptor() {
        return Vector3CrossProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3CrossProduct$handle() {
        return Vector3CrossProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3CrossProduct$address() {
        return Vector3CrossProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3CrossProduct(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3CrossProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3CrossProduct", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Perpendicular {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Perpendicular");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Perpendicular$descriptor() {
        return Vector3Perpendicular.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Perpendicular$handle() {
        return Vector3Perpendicular.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Perpendicular$address() {
        return Vector3Perpendicular.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Perpendicular(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Perpendicular(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Perpendicular.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Perpendicular", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Length$descriptor() {
        return Vector3Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static MethodHandle Vector3Length$handle() {
        return Vector3Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static MemorySegment Vector3Length$address() {
        return Vector3Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Length(const Vector3 v)
     * }
     */
    public static float Vector3Length(MemorySegment v) {
        var mh$ = Vector3Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3LengthSqr$descriptor() {
        return Vector3LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static MethodHandle Vector3LengthSqr$handle() {
        return Vector3LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static MemorySegment Vector3LengthSqr$address() {
        return Vector3LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3LengthSqr(const Vector3 v)
     * }
     */
    public static float Vector3LengthSqr(MemorySegment v) {
        var mh$ = Vector3LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3DotProduct$descriptor() {
        return Vector3DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3DotProduct$handle() {
        return Vector3DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3DotProduct$address() {
        return Vector3DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3DotProduct(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Distance$descriptor() {
        return Vector3Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Distance$handle() {
        return Vector3Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Distance$address() {
        return Vector3Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Distance(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3DistanceSqr$descriptor() {
        return Vector3DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3DistanceSqr$handle() {
        return Vector3DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3DistanceSqr$address() {
        return Vector3DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3DistanceSqr(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Angle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Angle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Angle$descriptor() {
        return Vector3Angle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Angle$handle() {
        return Vector3Angle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Angle$address() {
        return Vector3Angle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector3Angle(Vector3 v1, Vector3 v2)
     * }
     */
    public static float Vector3Angle(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Angle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Angle", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Negate$descriptor() {
        return Vector3Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Negate$handle() {
        return Vector3Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Negate$address() {
        return Vector3Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Negate(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Divide$descriptor() {
        return Vector3Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Divide$handle() {
        return Vector3Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Divide$address() {
        return Vector3Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Divide(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Normalize$descriptor() {
        return Vector3Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Normalize$handle() {
        return Vector3Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize$address() {
        return Vector3Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Project {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Project");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Project$descriptor() {
        return Vector3Project.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Project$handle() {
        return Vector3Project.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Project$address() {
        return Vector3Project.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Project(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Project(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Project.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Project", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Reject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Reject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Reject$descriptor() {
        return Vector3Reject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Reject$handle() {
        return Vector3Reject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Reject$address() {
        return Vector3Reject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Reject(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Reject(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Reject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Reject", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3OrthoNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3OrthoNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static FunctionDescriptor Vector3OrthoNormalize$descriptor() {
        return Vector3OrthoNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static MethodHandle Vector3OrthoNormalize$handle() {
        return Vector3OrthoNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static MemorySegment Vector3OrthoNormalize$address() {
        return Vector3OrthoNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)
     * }
     */
    public static void Vector3OrthoNormalize(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3OrthoNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3OrthoNormalize", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static FunctionDescriptor Vector3Transform$descriptor() {
        return Vector3Transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MethodHandle Vector3Transform$handle() {
        return Vector3Transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector3Transform$address() {
        return Vector3Transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Transform(Vector3 v, Matrix mat)
     * }
     */
    public static MemorySegment Vector3Transform(SegmentAllocator allocator, MemorySegment v, MemorySegment mat) {
        var mh$ = Vector3Transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Transform", allocator, v, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3RotateByQuaternion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3RotateByQuaternion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static FunctionDescriptor Vector3RotateByQuaternion$descriptor() {
        return Vector3RotateByQuaternion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MethodHandle Vector3RotateByQuaternion$handle() {
        return Vector3RotateByQuaternion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MemorySegment Vector3RotateByQuaternion$address() {
        return Vector3RotateByQuaternion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)
     * }
     */
    public static MemorySegment Vector3RotateByQuaternion(SegmentAllocator allocator, MemorySegment v, MemorySegment q) {
        var mh$ = Vector3RotateByQuaternion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3RotateByQuaternion", allocator, v, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3RotateByAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3RotateByAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor Vector3RotateByAxisAngle$descriptor() {
        return Vector3RotateByAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MethodHandle Vector3RotateByAxisAngle$handle() {
        return Vector3RotateByAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MemorySegment Vector3RotateByAxisAngle$address() {
        return Vector3RotateByAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)
     * }
     */
    public static MemorySegment Vector3RotateByAxisAngle(SegmentAllocator allocator, MemorySegment v, MemorySegment axis, float angle) {
        var mh$ = Vector3RotateByAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3RotateByAxisAngle", allocator, v, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector3MoveTowards$descriptor() {
        return Vector3MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector3MoveTowards$handle() {
        return Vector3MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector3MoveTowards$address() {
        return Vector3MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector3MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector3MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector3Lerp$descriptor() {
        return Vector3Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MethodHandle Vector3Lerp$handle() {
        return Vector3Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MemorySegment Vector3Lerp$address() {
        return Vector3Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)
     * }
     */
    public static MemorySegment Vector3Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector3Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3CubicHermite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3CubicHermite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static FunctionDescriptor Vector3CubicHermite$descriptor() {
        return Vector3CubicHermite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MethodHandle Vector3CubicHermite$handle() {
        return Vector3CubicHermite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MemorySegment Vector3CubicHermite$address() {
        return Vector3CubicHermite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount)
     * }
     */
    public static MemorySegment Vector3CubicHermite(SegmentAllocator allocator, MemorySegment v1, MemorySegment tangent1, MemorySegment v2, MemorySegment tangent2, float amount) {
        var mh$ = Vector3CubicHermite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3CubicHermite", allocator, v1, tangent1, v2, tangent2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, tangent1, v2, tangent2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Reflect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Reflect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static FunctionDescriptor Vector3Reflect$descriptor() {
        return Vector3Reflect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MethodHandle Vector3Reflect$handle() {
        return Vector3Reflect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MemorySegment Vector3Reflect$address() {
        return Vector3Reflect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Reflect(Vector3 v, Vector3 normal)
     * }
     */
    public static MemorySegment Vector3Reflect(SegmentAllocator allocator, MemorySegment v, MemorySegment normal) {
        var mh$ = Vector3Reflect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Reflect", allocator, v, normal);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Min$descriptor() {
        return Vector3Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Min$handle() {
        return Vector3Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Min$address() {
        return Vector3Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Min(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Max$descriptor() {
        return Vector3Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Max$handle() {
        return Vector3Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Max$address() {
        return Vector3Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Max(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Barycenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Barycenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static FunctionDescriptor Vector3Barycenter$descriptor() {
        return Vector3Barycenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MethodHandle Vector3Barycenter$handle() {
        return Vector3Barycenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MemorySegment Vector3Barycenter$address() {
        return Vector3Barycenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
     * }
     */
    public static MemorySegment Vector3Barycenter(SegmentAllocator allocator, MemorySegment p, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = Vector3Barycenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Barycenter", allocator, p, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Unproject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Unproject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static FunctionDescriptor Vector3Unproject$descriptor() {
        return Vector3Unproject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MethodHandle Vector3Unproject$handle() {
        return Vector3Unproject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject$address() {
        return Vector3Unproject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject(SegmentAllocator allocator, MemorySegment source, MemorySegment projection, MemorySegment view) {
        var mh$ = Vector3Unproject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Unproject", allocator, source, projection, view);
            }
            return (MemorySegment)mh$.invokeExact(allocator, source, projection, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3ToFloatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            float3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3ToFloatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3ToFloatV$descriptor() {
        return Vector3ToFloatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MethodHandle Vector3ToFloatV$handle() {
        return Vector3ToFloatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MemorySegment Vector3ToFloatV$address() {
        return Vector3ToFloatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float3 Vector3ToFloatV(Vector3 v)
     * }
     */
    public static MemorySegment Vector3ToFloatV(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3ToFloatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3ToFloatV", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Invert$descriptor() {
        return Vector3Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Invert$handle() {
        return Vector3Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Invert$address() {
        return Vector3Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Invert(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static FunctionDescriptor Vector3Clamp$descriptor() {
        return Vector3Clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MethodHandle Vector3Clamp$handle() {
        return Vector3Clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MemorySegment Vector3Clamp$address() {
        return Vector3Clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)
     * }
     */
    public static MemorySegment Vector3Clamp(SegmentAllocator allocator, MemorySegment v, MemorySegment min, MemorySegment max) {
        var mh$ = Vector3Clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Clamp", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3ClampValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3ClampValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static FunctionDescriptor Vector3ClampValue$descriptor() {
        return Vector3ClampValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MethodHandle Vector3ClampValue$handle() {
        return Vector3ClampValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MemorySegment Vector3ClampValue$address() {
        return Vector3ClampValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3ClampValue(Vector3 v, float min, float max)
     * }
     */
    public static MemorySegment Vector3ClampValue(SegmentAllocator allocator, MemorySegment v, float min, float max) {
        var mh$ = Vector3ClampValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3ClampValue", allocator, v, min, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static FunctionDescriptor Vector3Equals$descriptor() {
        return Vector3Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static MethodHandle Vector3Equals$handle() {
        return Vector3Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static MemorySegment Vector3Equals$address() {
        return Vector3Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector3Equals(Vector3 p, Vector3 q)
     * }
     */
    public static int Vector3Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector3Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Refract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector3Refract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static FunctionDescriptor Vector3Refract$descriptor() {
        return Vector3Refract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MethodHandle Vector3Refract$handle() {
        return Vector3Refract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MemorySegment Vector3Refract$address() {
        return Vector3Refract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)
     * }
     */
    public static MemorySegment Vector3Refract(SegmentAllocator allocator, MemorySegment v, MemorySegment n, float r) {
        var mh$ = Vector3Refract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Refract", allocator, v, n, r);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, n, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static FunctionDescriptor Vector4Zero$descriptor() {
        return Vector4Zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MethodHandle Vector4Zero$handle() {
        return Vector4Zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MemorySegment Vector4Zero$address() {
        return Vector4Zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Zero()
     * }
     */
    public static MemorySegment Vector4Zero(SegmentAllocator allocator) {
        var mh$ = Vector4Zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Zero", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4One {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4One");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static FunctionDescriptor Vector4One$descriptor() {
        return Vector4One.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MethodHandle Vector4One$handle() {
        return Vector4One.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MemorySegment Vector4One$address() {
        return Vector4One.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4One()
     * }
     */
    public static MemorySegment Vector4One(SegmentAllocator allocator) {
        var mh$ = Vector4One.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4One", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Add$descriptor() {
        return Vector4Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Add$handle() {
        return Vector4Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Add$address() {
        return Vector4Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Add(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Add(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Add", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4AddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4AddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static FunctionDescriptor Vector4AddValue$descriptor() {
        return Vector4AddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MethodHandle Vector4AddValue$handle() {
        return Vector4AddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4AddValue$address() {
        return Vector4AddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4AddValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4AddValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector4AddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4AddValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Subtract$descriptor() {
        return Vector4Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Subtract$handle() {
        return Vector4Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Subtract$address() {
        return Vector4Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Subtract(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4SubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4SubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static FunctionDescriptor Vector4SubtractValue$descriptor() {
        return Vector4SubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MethodHandle Vector4SubtractValue$handle() {
        return Vector4SubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4SubtractValue$address() {
        return Vector4SubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4SubtractValue(Vector4 v, float add)
     * }
     */
    public static MemorySegment Vector4SubtractValue(SegmentAllocator allocator, MemorySegment v, float add) {
        var mh$ = Vector4SubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4SubtractValue", allocator, v, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Length$descriptor() {
        return Vector4Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Length$handle() {
        return Vector4Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Length$address() {
        return Vector4Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4Length(Vector4 v)
     * }
     */
    public static float Vector4Length(MemorySegment v) {
        var mh$ = Vector4Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Length", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4LengthSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4LengthSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4LengthSqr$descriptor() {
        return Vector4LengthSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static MethodHandle Vector4LengthSqr$handle() {
        return Vector4LengthSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static MemorySegment Vector4LengthSqr$address() {
        return Vector4LengthSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4LengthSqr(Vector4 v)
     * }
     */
    public static float Vector4LengthSqr(MemorySegment v) {
        var mh$ = Vector4LengthSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4LengthSqr", v);
            }
            return (float)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4DotProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4DotProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4DotProduct$descriptor() {
        return Vector4DotProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4DotProduct$handle() {
        return Vector4DotProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4DotProduct$address() {
        return Vector4DotProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4DotProduct(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4DotProduct(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4DotProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4DotProduct", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Distance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Distance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Distance$descriptor() {
        return Vector4Distance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Distance$handle() {
        return Vector4Distance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Distance$address() {
        return Vector4Distance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4Distance(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4Distance(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Distance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Distance", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4DistanceSqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4DistanceSqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4DistanceSqr$descriptor() {
        return Vector4DistanceSqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4DistanceSqr$handle() {
        return Vector4DistanceSqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4DistanceSqr$address() {
        return Vector4DistanceSqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float Vector4DistanceSqr(Vector4 v1, Vector4 v2)
     * }
     */
    public static float Vector4DistanceSqr(MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4DistanceSqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4DistanceSqr", v1, v2);
            }
            return (float)mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static FunctionDescriptor Vector4Scale$descriptor() {
        return Vector4Scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MethodHandle Vector4Scale$handle() {
        return Vector4Scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MemorySegment Vector4Scale$address() {
        return Vector4Scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Scale(Vector4 v, float scale)
     * }
     */
    public static MemorySegment Vector4Scale(SegmentAllocator allocator, MemorySegment v, float scale) {
        var mh$ = Vector4Scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Scale", allocator, v, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Multiply$descriptor() {
        return Vector4Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Multiply$handle() {
        return Vector4Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Multiply$address() {
        return Vector4Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Multiply(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Multiply(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Multiply", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Negate$descriptor() {
        return Vector4Negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Negate$handle() {
        return Vector4Negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Negate$address() {
        return Vector4Negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Negate(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Negate(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Negate", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Divide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Divide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Divide$descriptor() {
        return Vector4Divide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Divide$handle() {
        return Vector4Divide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Divide$address() {
        return Vector4Divide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Divide(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Divide(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Divide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Divide", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Normalize$descriptor() {
        return Vector4Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Normalize$handle() {
        return Vector4Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Normalize$address() {
        return Vector4Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Normalize(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Min$descriptor() {
        return Vector4Min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Min$handle() {
        return Vector4Min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Min$address() {
        return Vector4Min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Min(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Min(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Min", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static FunctionDescriptor Vector4Max$descriptor() {
        return Vector4Max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MethodHandle Vector4Max$handle() {
        return Vector4Max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Max$address() {
        return Vector4Max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Max(Vector4 v1, Vector4 v2)
     * }
     */
    public static MemorySegment Vector4Max(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector4Max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Max", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Lerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Lerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static FunctionDescriptor Vector4Lerp$descriptor() {
        return Vector4Lerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MethodHandle Vector4Lerp$handle() {
        return Vector4Lerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MemorySegment Vector4Lerp$address() {
        return Vector4Lerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Lerp(Vector4 v1, Vector4 v2, float amount)
     * }
     */
    public static MemorySegment Vector4Lerp(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2, float amount) {
        var mh$ = Vector4Lerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Lerp", allocator, v1, v2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4MoveTowards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4MoveTowards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static FunctionDescriptor Vector4MoveTowards$descriptor() {
        return Vector4MoveTowards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MethodHandle Vector4MoveTowards$handle() {
        return Vector4MoveTowards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector4MoveTowards$address() {
        return Vector4MoveTowards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance)
     * }
     */
    public static MemorySegment Vector4MoveTowards(SegmentAllocator allocator, MemorySegment v, MemorySegment target, float maxDistance) {
        var mh$ = Vector4MoveTowards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4MoveTowards", allocator, v, target, maxDistance);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v, target, maxDistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static FunctionDescriptor Vector4Invert$descriptor() {
        return Vector4Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MethodHandle Vector4Invert$handle() {
        return Vector4Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Invert$address() {
        return Vector4Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 Vector4Invert(Vector4 v)
     * }
     */
    public static MemorySegment Vector4Invert(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector4Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Invert", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector4Equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Vector4Equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static FunctionDescriptor Vector4Equals$descriptor() {
        return Vector4Equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static MethodHandle Vector4Equals$handle() {
        return Vector4Equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static MemorySegment Vector4Equals$address() {
        return Vector4Equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Vector4Equals(Vector4 p, Vector4 q)
     * }
     */
    public static int Vector4Equals(MemorySegment p, MemorySegment q) {
        var mh$ = Vector4Equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector4Equals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixDeterminant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixDeterminant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixDeterminant$descriptor() {
        return MatrixDeterminant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static MethodHandle MatrixDeterminant$handle() {
        return MatrixDeterminant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static MemorySegment MatrixDeterminant$address() {
        return MatrixDeterminant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float MatrixDeterminant(Matrix mat)
     * }
     */
    public static float MatrixDeterminant(MemorySegment mat) {
        var mh$ = MatrixDeterminant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixDeterminant", mat);
            }
            return (float)mh$.invokeExact(mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixTrace$descriptor() {
        return MatrixTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static MethodHandle MatrixTrace$handle() {
        return MatrixTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTrace$address() {
        return MatrixTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float MatrixTrace(Matrix mat)
     * }
     */
    public static float MatrixTrace(MemorySegment mat) {
        var mh$ = MatrixTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTrace", mat);
            }
            return (float)mh$.invokeExact(mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTranspose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTranspose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixTranspose$descriptor() {
        return MatrixTranspose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MethodHandle MatrixTranspose$handle() {
        return MatrixTranspose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTranspose$address() {
        return MatrixTranspose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixTranspose(Matrix mat)
     * }
     */
    public static MemorySegment MatrixTranspose(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixTranspose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTranspose", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixInvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixInvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixInvert$descriptor() {
        return MatrixInvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MethodHandle MatrixInvert$handle() {
        return MatrixInvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MemorySegment MatrixInvert$address() {
        return MatrixInvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixInvert(Matrix mat)
     * }
     */
    public static MemorySegment MatrixInvert(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixInvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixInvert", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static FunctionDescriptor MatrixIdentity$descriptor() {
        return MatrixIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MethodHandle MatrixIdentity$handle() {
        return MatrixIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity$address() {
        return MatrixIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity(SegmentAllocator allocator) {
        var mh$ = MatrixIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixIdentity", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixAdd$descriptor() {
        return MatrixAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixAdd$handle() {
        return MatrixAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixAdd$address() {
        return MatrixAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixAdd(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixAdd(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixAdd", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixSubtract$descriptor() {
        return MatrixSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixSubtract$handle() {
        return MatrixSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixSubtract$address() {
        return MatrixSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixSubtract(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixSubtract(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixSubtract", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Matrix.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static FunctionDescriptor MatrixMultiply$descriptor() {
        return MatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MethodHandle MatrixMultiply$handle() {
        return MatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixMultiply$address() {
        return MatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixMultiply(Matrix left, Matrix right)
     * }
     */
    public static MemorySegment MatrixMultiply(SegmentAllocator allocator, MemorySegment left, MemorySegment right) {
        var mh$ = MatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixMultiply", allocator, left, right);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixTranslate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixTranslate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor MatrixTranslate$descriptor() {
        return MatrixTranslate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MethodHandle MatrixTranslate$handle() {
        return MatrixTranslate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixTranslate$address() {
        return MatrixTranslate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixTranslate(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixTranslate(SegmentAllocator allocator, float x, float y, float z) {
        var mh$ = MatrixTranslate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixTranslate", allocator, x, y, z);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotate$descriptor() {
        return MatrixRotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MethodHandle MatrixRotate$handle() {
        return MatrixRotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment MatrixRotate$address() {
        return MatrixRotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotate(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment MatrixRotate(SegmentAllocator allocator, MemorySegment axis, float angle) {
        var mh$ = MatrixRotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotate", allocator, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateX$descriptor() {
        return MatrixRotateX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MethodHandle MatrixRotateX$handle() {
        return MatrixRotateX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MemorySegment MatrixRotateX$address() {
        return MatrixRotateX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateX(float angle)
     * }
     */
    public static MemorySegment MatrixRotateX(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateX", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateY$descriptor() {
        return MatrixRotateY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MethodHandle MatrixRotateY$handle() {
        return MatrixRotateY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MemorySegment MatrixRotateY$address() {
        return MatrixRotateY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateY(float angle)
     * }
     */
    public static MemorySegment MatrixRotateY(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateY", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateZ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateZ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateZ$descriptor() {
        return MatrixRotateZ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MethodHandle MatrixRotateZ$handle() {
        return MatrixRotateZ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MemorySegment MatrixRotateZ$address() {
        return MatrixRotateZ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateZ(float angle)
     * }
     */
    public static MemorySegment MatrixRotateZ(SegmentAllocator allocator, float angle) {
        var mh$ = MatrixRotateZ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateZ", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateXYZ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateXYZ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateXYZ$descriptor() {
        return MatrixRotateXYZ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MethodHandle MatrixRotateXYZ$handle() {
        return MatrixRotateXYZ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateXYZ$address() {
        return MatrixRotateXYZ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateXYZ(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateXYZ(SegmentAllocator allocator, MemorySegment angle) {
        var mh$ = MatrixRotateXYZ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateXYZ", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixRotateZYX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixRotateZYX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static FunctionDescriptor MatrixRotateZYX$descriptor() {
        return MatrixRotateZYX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MethodHandle MatrixRotateZYX$handle() {
        return MatrixRotateZYX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateZYX$address() {
        return MatrixRotateZYX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixRotateZYX(Vector3 angle)
     * }
     */
    public static MemorySegment MatrixRotateZYX(SegmentAllocator allocator, MemorySegment angle) {
        var mh$ = MatrixRotateZYX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixRotateZYX", allocator, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor MatrixScale$descriptor() {
        return MatrixScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MethodHandle MatrixScale$handle() {
        return MatrixScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixScale$address() {
        return MatrixScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixScale(float x, float y, float z)
     * }
     */
    public static MemorySegment MatrixScale(SegmentAllocator allocator, float x, float y, float z) {
        var mh$ = MatrixScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixScale", allocator, x, y, z);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static FunctionDescriptor MatrixFrustum$descriptor() {
        return MatrixFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MethodHandle MatrixFrustum$handle() {
        return MatrixFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MemorySegment MatrixFrustum$address() {
        return MatrixFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
     * }
     */
    public static MemorySegment MatrixFrustum(SegmentAllocator allocator, double left, double right, double bottom, double top, double near, double far) {
        var mh$ = MatrixFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixFrustum", allocator, left, right, bottom, top, near, far);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right, bottom, top, near, far);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixPerspective$descriptor() {
        return MatrixPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixPerspective$handle() {
        return MatrixPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective$address() {
        return MatrixPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective(SegmentAllocator allocator, double fovY, double aspect, double nearPlane, double farPlane) {
        var mh$ = MatrixPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixPerspective", allocator, fovY, aspect, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fovY, aspect, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE,
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixOrtho$descriptor() {
        return MatrixOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixOrtho$handle() {
        return MatrixOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho$address() {
        return MatrixOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho(SegmentAllocator allocator, double left, double right, double bottom, double top, double nearPlane, double farPlane) {
        var mh$ = MatrixOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixOrtho", allocator, left, right, bottom, top, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right, bottom, top, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static FunctionDescriptor MatrixLookAt$descriptor() {
        return MatrixLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MethodHandle MatrixLookAt$handle() {
        return MatrixLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt$address() {
        return MatrixLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt(SegmentAllocator allocator, MemorySegment eye, MemorySegment target, MemorySegment up) {
        var mh$ = MatrixLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixLookAt", allocator, eye, target, up);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye, target, up);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixToFloatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            float16.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MatrixToFloatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static FunctionDescriptor MatrixToFloatV$descriptor() {
        return MatrixToFloatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MethodHandle MatrixToFloatV$handle() {
        return MatrixToFloatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MemorySegment MatrixToFloatV$address() {
        return MatrixToFloatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float16 MatrixToFloatV(Matrix mat)
     * }
     */
    public static MemorySegment MatrixToFloatV(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = MatrixToFloatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixToFloatV", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionAdd$descriptor() {
        return QuaternionAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionAdd$handle() {
        return QuaternionAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionAdd$address() {
        return QuaternionAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionAdd(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionAdd", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionAddValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionAddValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static FunctionDescriptor QuaternionAddValue$descriptor() {
        return QuaternionAddValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MethodHandle QuaternionAddValue$handle() {
        return QuaternionAddValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MemorySegment QuaternionAddValue$address() {
        return QuaternionAddValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionAddValue(Quaternion q, float add)
     * }
     */
    public static MemorySegment QuaternionAddValue(SegmentAllocator allocator, MemorySegment q, float add) {
        var mh$ = QuaternionAddValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionAddValue", allocator, q, add);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionSubtract$descriptor() {
        return QuaternionSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionSubtract$handle() {
        return QuaternionSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionSubtract$address() {
        return QuaternionSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionSubtract(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSubtract", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSubtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSubtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static FunctionDescriptor QuaternionSubtractValue$descriptor() {
        return QuaternionSubtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MethodHandle QuaternionSubtractValue$handle() {
        return QuaternionSubtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MemorySegment QuaternionSubtractValue$address() {
        return QuaternionSubtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSubtractValue(Quaternion q, float sub)
     * }
     */
    public static MemorySegment QuaternionSubtractValue(SegmentAllocator allocator, MemorySegment q, float sub) {
        var mh$ = QuaternionSubtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSubtractValue", allocator, q, sub);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static FunctionDescriptor QuaternionIdentity$descriptor() {
        return QuaternionIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MethodHandle QuaternionIdentity$handle() {
        return QuaternionIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MemorySegment QuaternionIdentity$address() {
        return QuaternionIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionIdentity()
     * }
     */
    public static MemorySegment QuaternionIdentity(SegmentAllocator allocator) {
        var mh$ = QuaternionIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionIdentity", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionLength$descriptor() {
        return QuaternionLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionLength$handle() {
        return QuaternionLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionLength$address() {
        return QuaternionLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float QuaternionLength(Quaternion q)
     * }
     */
    public static float QuaternionLength(MemorySegment q) {
        var mh$ = QuaternionLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionLength", q);
            }
            return (float)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionNormalize$descriptor() {
        return QuaternionNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionNormalize$handle() {
        return QuaternionNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionNormalize$address() {
        return QuaternionNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionNormalize(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionNormalize(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionNormalize", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionInvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionInvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionInvert$descriptor() {
        return QuaternionInvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionInvert$handle() {
        return QuaternionInvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionInvert$address() {
        return QuaternionInvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionInvert(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionInvert(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionInvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionInvert", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionMultiply$descriptor() {
        return QuaternionMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionMultiply$handle() {
        return QuaternionMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionMultiply$address() {
        return QuaternionMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionMultiply(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionMultiply", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static FunctionDescriptor QuaternionScale$descriptor() {
        return QuaternionScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MethodHandle QuaternionScale$handle() {
        return QuaternionScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MemorySegment QuaternionScale$address() {
        return QuaternionScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionScale(Quaternion q, float mul)
     * }
     */
    public static MemorySegment QuaternionScale(SegmentAllocator allocator, MemorySegment q, float mul) {
        var mh$ = QuaternionScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionScale", allocator, q, mul);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, mul);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static FunctionDescriptor QuaternionDivide$descriptor() {
        return QuaternionDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MethodHandle QuaternionDivide$handle() {
        return QuaternionDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionDivide$address() {
        return QuaternionDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)
     * }
     */
    public static MemorySegment QuaternionDivide(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2) {
        var mh$ = QuaternionDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionDivide", allocator, q1, q2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionLerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionLerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionLerp$descriptor() {
        return QuaternionLerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionLerp$handle() {
        return QuaternionLerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionLerp$address() {
        return QuaternionLerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionLerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionLerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionLerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionNlerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionNlerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionNlerp$descriptor() {
        return QuaternionNlerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionNlerp$handle() {
        return QuaternionNlerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionNlerp$address() {
        return QuaternionNlerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionNlerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionNlerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionNlerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionSlerp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionSlerp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static FunctionDescriptor QuaternionSlerp$descriptor() {
        return QuaternionSlerp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MethodHandle QuaternionSlerp$handle() {
        return QuaternionSlerp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionSlerp$address() {
        return QuaternionSlerp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)
     * }
     */
    public static MemorySegment QuaternionSlerp(SegmentAllocator allocator, MemorySegment q1, MemorySegment q2, float amount) {
        var mh$ = QuaternionSlerp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionSlerp", allocator, q1, q2, amount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, q2, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionCubicHermiteSpline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            Vector4.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionCubicHermiteSpline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static FunctionDescriptor QuaternionCubicHermiteSpline$descriptor() {
        return QuaternionCubicHermiteSpline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MethodHandle QuaternionCubicHermiteSpline$handle() {
        return QuaternionCubicHermiteSpline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MemorySegment QuaternionCubicHermiteSpline$address() {
        return QuaternionCubicHermiteSpline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t)
     * }
     */
    public static MemorySegment QuaternionCubicHermiteSpline(SegmentAllocator allocator, MemorySegment q1, MemorySegment outTangent1, MemorySegment q2, MemorySegment inTangent2, float t) {
        var mh$ = QuaternionCubicHermiteSpline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionCubicHermiteSpline", allocator, q1, outTangent1, q2, inTangent2, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q1, outTangent1, q2, inTangent2, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromVector3ToVector3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromVector3ToVector3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static FunctionDescriptor QuaternionFromVector3ToVector3$descriptor() {
        return QuaternionFromVector3ToVector3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MethodHandle QuaternionFromVector3ToVector3$handle() {
        return QuaternionFromVector3ToVector3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MemorySegment QuaternionFromVector3ToVector3$address() {
        return QuaternionFromVector3ToVector3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)
     * }
     */
    public static MemorySegment QuaternionFromVector3ToVector3(SegmentAllocator allocator, MemorySegment from, MemorySegment to) {
        var mh$ = QuaternionFromVector3ToVector3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromVector3ToVector3", allocator, from, to);
            }
            return (MemorySegment)mh$.invokeExact(allocator, from, to);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static FunctionDescriptor QuaternionFromMatrix$descriptor() {
        return QuaternionFromMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MethodHandle QuaternionFromMatrix$handle() {
        return QuaternionFromMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MemorySegment QuaternionFromMatrix$address() {
        return QuaternionFromMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromMatrix(Matrix mat)
     * }
     */
    public static MemorySegment QuaternionFromMatrix(SegmentAllocator allocator, MemorySegment mat) {
        var mh$ = QuaternionFromMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromMatrix", allocator, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionToMatrix$descriptor() {
        return QuaternionToMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionToMatrix$handle() {
        return QuaternionToMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToMatrix$address() {
        return QuaternionToMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix QuaternionToMatrix(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToMatrix(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionToMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToMatrix", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static FunctionDescriptor QuaternionFromAxisAngle$descriptor() {
        return QuaternionFromAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MethodHandle QuaternionFromAxisAngle$handle() {
        return QuaternionFromAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment QuaternionFromAxisAngle$address() {
        return QuaternionFromAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)
     * }
     */
    public static MemorySegment QuaternionFromAxisAngle(SegmentAllocator allocator, MemorySegment axis, float angle) {
        var mh$ = QuaternionFromAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromAxisAngle", allocator, axis, angle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, axis, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector4.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static FunctionDescriptor QuaternionToAxisAngle$descriptor() {
        return QuaternionToAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static MethodHandle QuaternionToAxisAngle$handle() {
        return QuaternionToAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static MemorySegment QuaternionToAxisAngle$address() {
        return QuaternionToAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)
     * }
     */
    public static void QuaternionToAxisAngle(MemorySegment q, MemorySegment outAxis, MemorySegment outAngle) {
        var mh$ = QuaternionToAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToAxisAngle", q, outAxis, outAngle);
            }
            mh$.invokeExact(q, outAxis, outAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionFromEuler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionFromEuler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static FunctionDescriptor QuaternionFromEuler$descriptor() {
        return QuaternionFromEuler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MethodHandle QuaternionFromEuler$handle() {
        return QuaternionFromEuler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MemorySegment QuaternionFromEuler$address() {
        return QuaternionFromEuler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)
     * }
     */
    public static MemorySegment QuaternionFromEuler(SegmentAllocator allocator, float pitch, float yaw, float roll) {
        var mh$ = QuaternionFromEuler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionFromEuler", allocator, pitch, yaw, roll);
            }
            return (MemorySegment)mh$.invokeExact(allocator, pitch, yaw, roll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionToEuler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionToEuler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionToEuler$descriptor() {
        return QuaternionToEuler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MethodHandle QuaternionToEuler$handle() {
        return QuaternionToEuler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToEuler$address() {
        return QuaternionToEuler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 QuaternionToEuler(Quaternion q)
     * }
     */
    public static MemorySegment QuaternionToEuler(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = QuaternionToEuler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionToEuler", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Vector4.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static FunctionDescriptor QuaternionTransform$descriptor() {
        return QuaternionTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MethodHandle QuaternionTransform$handle() {
        return QuaternionTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MemorySegment QuaternionTransform$address() {
        return QuaternionTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Quaternion QuaternionTransform(Quaternion q, Matrix mat)
     * }
     */
    public static MemorySegment QuaternionTransform(SegmentAllocator allocator, MemorySegment q, MemorySegment mat) {
        var mh$ = QuaternionTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionTransform", allocator, q, mat);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuaternionEquals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Vector4.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("QuaternionEquals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static FunctionDescriptor QuaternionEquals$descriptor() {
        return QuaternionEquals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static MethodHandle QuaternionEquals$handle() {
        return QuaternionEquals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static MemorySegment QuaternionEquals$address() {
        return QuaternionEquals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int QuaternionEquals(Quaternion p, Quaternion q)
     * }
     */
    public static int QuaternionEquals(MemorySegment p, MemorySegment q) {
        var mh$ = QuaternionEquals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuaternionEquals", p, q);
            }
            return (int)mh$.invokeExact(p, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define RAYLIB_VERSION "5.1-dev"
     * }
     */
    public static MemorySegment RAYLIB_VERSION() {
        class Holder {
            static final MemorySegment RAYLIB_VERSION
                = raylib.LIBRARY_ARENA.allocateFrom("5.1-dev");
        }
        return Holder.RAYLIB_VERSION;
    }
    private static final float PI = 3.1415927410125732f;
    /**
     * {@snippet lang=c :
     * #define PI 3.1415927410125732
     * }
     */
    public static float PI() {
        return PI;
    }
    private static final float DEG2RAD = 0.01745329238474369f;
    /**
     * {@snippet lang=c :
     * #define DEG2RAD 0.01745329238474369
     * }
     */
    public static float DEG2RAD() {
        return DEG2RAD;
    }
    private static final float RAD2DEG = 57.2957763671875f;
    /**
     * {@snippet lang=c :
     * #define RAD2DEG 57.2957763671875
     * }
     */
    public static float RAD2DEG() {
        return RAD2DEG;
    }
    private static final int MOUSE_LEFT_BUTTON = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_LEFT_BUTTON 0
     * }
     */
    public static int MOUSE_LEFT_BUTTON() {
        return MOUSE_LEFT_BUTTON;
    }
    private static final int MOUSE_RIGHT_BUTTON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_RIGHT_BUTTON 1
     * }
     */
    public static int MOUSE_RIGHT_BUTTON() {
        return MOUSE_RIGHT_BUTTON;
    }
    private static final int MOUSE_MIDDLE_BUTTON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MOUSE_MIDDLE_BUTTON 2
     * }
     */
    public static int MOUSE_MIDDLE_BUTTON() {
        return MOUSE_MIDDLE_BUTTON;
    }
    private static final int MATERIAL_MAP_DIFFUSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MATERIAL_MAP_DIFFUSE 0
     * }
     */
    public static int MATERIAL_MAP_DIFFUSE() {
        return MATERIAL_MAP_DIFFUSE;
    }
    private static final int MATERIAL_MAP_SPECULAR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATERIAL_MAP_SPECULAR 1
     * }
     */
    public static int MATERIAL_MAP_SPECULAR() {
        return MATERIAL_MAP_SPECULAR;
    }
    private static final int SHADER_LOC_MAP_DIFFUSE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SHADER_LOC_MAP_DIFFUSE 15
     * }
     */
    public static int SHADER_LOC_MAP_DIFFUSE() {
        return SHADER_LOC_MAP_DIFFUSE;
    }
    private static final int SHADER_LOC_MAP_SPECULAR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SHADER_LOC_MAP_SPECULAR 16
     * }
     */
    public static int SHADER_LOC_MAP_SPECULAR() {
        return SHADER_LOC_MAP_SPECULAR;
    }
    /**
     * {@snippet lang=c :
     * #define RLGL_VERSION "5.0"
     * }
     */
    public static MemorySegment RLGL_VERSION() {
        class Holder {
            static final MemorySegment RLGL_VERSION
                = raylib.LIBRARY_ARENA.allocateFrom("5.0");
        }
        return Holder.RLGL_VERSION;
    }
    private static final double RL_CULL_DISTANCE_NEAR = 0.01d;
    /**
     * {@snippet lang=c :
     * #define RL_CULL_DISTANCE_NEAR 0.01
     * }
     */
    public static double RL_CULL_DISTANCE_NEAR() {
        return RL_CULL_DISTANCE_NEAR;
    }
    private static final double RL_CULL_DISTANCE_FAR = 1000.0d;
    /**
     * {@snippet lang=c :
     * #define RL_CULL_DISTANCE_FAR 1000.0
     * }
     */
    public static double RL_CULL_DISTANCE_FAR() {
        return RL_CULL_DISTANCE_FAR;
    }
    private static final int RL_SHADER_LOC_MAP_DIFFUSE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define RL_SHADER_LOC_MAP_DIFFUSE 15
     * }
     */
    public static int RL_SHADER_LOC_MAP_DIFFUSE() {
        return RL_SHADER_LOC_MAP_DIFFUSE;
    }
    private static final int RL_SHADER_LOC_MAP_SPECULAR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RL_SHADER_LOC_MAP_SPECULAR 16
     * }
     */
    public static int RL_SHADER_LOC_MAP_SPECULAR() {
        return RL_SHADER_LOC_MAP_SPECULAR;
    }
    private static final float EPSILON = 9.999999974752427E-7f;
    /**
     * {@snippet lang=c :
     * #define EPSILON 9.999999974752427E-7
     * }
     */
    public static float EPSILON() {
        return EPSILON;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = raylib.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140200
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final double HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VAL Infinity
     * }
     */
    public static double HUGE_VAL() {
        return HUGE_VAL;
    }
    private static final float HUGE_VALF = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALF Infinity
     * }
     */
    public static float HUGE_VALF() {
        return HUGE_VALF;
    }
    private static final float NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define NAN NaN
     * }
     */
    public static float NAN() {
        return NAN;
    }
    private static final float INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define INFINITY Infinity
     * }
     */
    public static float INFINITY() {
        return INFINITY;
    }
    private static final int FP_ILOGB0 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGB0 -2147483648
     * }
     */
    public static int FP_ILOGB0() {
        return FP_ILOGB0;
    }
    private static final int FP_ILOGBNAN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGBNAN -2147483648
     * }
     */
    public static int FP_ILOGBNAN() {
        return FP_ILOGBNAN;
    }
    private static final double M_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define M_E 2.718281828459045
     * }
     */
    public static double M_E() {
        return M_E;
    }
    private static final double M_LOG2E = 1.4426950408889634d;
    /**
     * {@snippet lang=c :
     * #define M_LOG2E 1.4426950408889634
     * }
     */
    public static double M_LOG2E() {
        return M_LOG2E;
    }
    private static final double M_LOG10E = 0.4342944819032518d;
    /**
     * {@snippet lang=c :
     * #define M_LOG10E 0.4342944819032518
     * }
     */
    public static double M_LOG10E() {
        return M_LOG10E;
    }
    private static final double M_LN2 = 0.6931471805599453d;
    /**
     * {@snippet lang=c :
     * #define M_LN2 0.6931471805599453
     * }
     */
    public static double M_LN2() {
        return M_LN2;
    }
    private static final double M_LN10 = 2.302585092994046d;
    /**
     * {@snippet lang=c :
     * #define M_LN10 2.302585092994046
     * }
     */
    public static double M_LN10() {
        return M_LN10;
    }
    private static final double M_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define M_PI 3.141592653589793
     * }
     */
    public static double M_PI() {
        return M_PI;
    }
    private static final double M_PI_2 = 1.5707963267948966d;
    /**
     * {@snippet lang=c :
     * #define M_PI_2 1.5707963267948966
     * }
     */
    public static double M_PI_2() {
        return M_PI_2;
    }
    private static final double M_PI_4 = 0.7853981633974483d;
    /**
     * {@snippet lang=c :
     * #define M_PI_4 0.7853981633974483
     * }
     */
    public static double M_PI_4() {
        return M_PI_4;
    }
    private static final double M_1_PI = 0.3183098861837907d;
    /**
     * {@snippet lang=c :
     * #define M_1_PI 0.3183098861837907
     * }
     */
    public static double M_1_PI() {
        return M_1_PI;
    }
    private static final double M_2_PI = 0.6366197723675814d;
    /**
     * {@snippet lang=c :
     * #define M_2_PI 0.6366197723675814
     * }
     */
    public static double M_2_PI() {
        return M_2_PI;
    }
    private static final double M_2_SQRTPI = 1.1283791670955126d;
    /**
     * {@snippet lang=c :
     * #define M_2_SQRTPI 1.1283791670955126
     * }
     */
    public static double M_2_SQRTPI() {
        return M_2_SQRTPI;
    }
    private static final double M_SQRT2 = 1.4142135623730951d;
    /**
     * {@snippet lang=c :
     * #define M_SQRT2 1.4142135623730951
     * }
     */
    public static double M_SQRT2() {
        return M_SQRT2;
    }
    private static final double M_SQRT1_2 = 0.7071067811865476d;
    /**
     * {@snippet lang=c :
     * #define M_SQRT1_2 0.7071067811865476
     * }
     */
    public static double M_SQRT1_2() {
        return M_SQRT1_2;
    }
    private static final float MAXFLOAT = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define MAXFLOAT 3.4028234663852886E38
     * }
     */
    public static float MAXFLOAT() {
        return MAXFLOAT;
    }
    private static final int FP_SNAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_SNAN 1
     * }
     */
    public static int FP_SNAN() {
        return FP_SNAN;
    }
    private static final int FP_QNAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_QNAN 1
     * }
     */
    public static int FP_QNAN() {
        return FP_QNAN;
    }
    private static final float HUGE = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define HUGE 3.4028234663852886E38
     * }
     */
    public static float HUGE() {
        return HUGE;
    }
    private static final double X_TLOSS = 1.414847550405688E16d;
    /**
     * {@snippet lang=c :
     * #define X_TLOSS 1.414847550405688E16
     * }
     */
    public static double X_TLOSS() {
        return X_TLOSS;
    }
}

