// Generated by jextract

package org.vybe.raylib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class raylib_1 {

    raylib_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libraylib.dylib", LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libvybe_raylib.dylib", LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int RAYLIB_VERSION_MAJOR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RAYLIB_VERSION_MAJOR 5
     * }
     */
    public static int RAYLIB_VERSION_MAJOR() {
        return RAYLIB_VERSION_MAJOR;
    }
    private static final int RAYLIB_VERSION_MINOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RAYLIB_VERSION_MINOR 1
     * }
     */
    public static int RAYLIB_VERSION_MINOR() {
        return RAYLIB_VERSION_MINOR;
    }
    private static final int RAYLIB_VERSION_PATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RAYLIB_VERSION_PATCH 0
     * }
     */
    public static int RAYLIB_VERSION_PATCH() {
        return RAYLIB_VERSION_PATCH;
    }
    private static final int RL_DEFAULT_BATCH_BUFFER_ELEMENTS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_BATCH_BUFFER_ELEMENTS 8192
     * }
     */
    public static int RL_DEFAULT_BATCH_BUFFER_ELEMENTS() {
        return RL_DEFAULT_BATCH_BUFFER_ELEMENTS;
    }
    private static final int RL_DEFAULT_BATCH_BUFFERS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_BATCH_BUFFERS 1
     * }
     */
    public static int RL_DEFAULT_BATCH_BUFFERS() {
        return RL_DEFAULT_BATCH_BUFFERS;
    }
    private static final int RL_DEFAULT_BATCH_DRAWCALLS = (int)256L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_BATCH_DRAWCALLS 256
     * }
     */
    public static int RL_DEFAULT_BATCH_DRAWCALLS() {
        return RL_DEFAULT_BATCH_DRAWCALLS;
    }
    private static final int RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS 4
     * }
     */
    public static int RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS() {
        return RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS;
    }
    private static final int RL_MAX_MATRIX_STACK_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RL_MAX_MATRIX_STACK_SIZE 32
     * }
     */
    public static int RL_MAX_MATRIX_STACK_SIZE() {
        return RL_MAX_MATRIX_STACK_SIZE;
    }
    private static final int RL_MAX_SHADER_LOCATIONS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RL_MAX_SHADER_LOCATIONS 32
     * }
     */
    public static int RL_MAX_SHADER_LOCATIONS() {
        return RL_MAX_SHADER_LOCATIONS;
    }
    private static final int RL_TEXTURE_WRAP_S = (int)10242L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_S 10242
     * }
     */
    public static int RL_TEXTURE_WRAP_S() {
        return RL_TEXTURE_WRAP_S;
    }
    private static final int RL_TEXTURE_WRAP_T = (int)10243L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_T 10243
     * }
     */
    public static int RL_TEXTURE_WRAP_T() {
        return RL_TEXTURE_WRAP_T;
    }
    private static final int RL_TEXTURE_MAG_FILTER = (int)10240L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_MAG_FILTER 10240
     * }
     */
    public static int RL_TEXTURE_MAG_FILTER() {
        return RL_TEXTURE_MAG_FILTER;
    }
    private static final int RL_TEXTURE_MIN_FILTER = (int)10241L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_MIN_FILTER 10241
     * }
     */
    public static int RL_TEXTURE_MIN_FILTER() {
        return RL_TEXTURE_MIN_FILTER;
    }
    private static final int RL_TEXTURE_FILTER_NEAREST = (int)9728L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_NEAREST 9728
     * }
     */
    public static int RL_TEXTURE_FILTER_NEAREST() {
        return RL_TEXTURE_FILTER_NEAREST;
    }
    private static final int RL_TEXTURE_FILTER_LINEAR = (int)9729L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_LINEAR 9729
     * }
     */
    public static int RL_TEXTURE_FILTER_LINEAR() {
        return RL_TEXTURE_FILTER_LINEAR;
    }
    private static final int RL_TEXTURE_FILTER_MIP_NEAREST = (int)9984L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_MIP_NEAREST 9984
     * }
     */
    public static int RL_TEXTURE_FILTER_MIP_NEAREST() {
        return RL_TEXTURE_FILTER_MIP_NEAREST;
    }
    private static final int RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR = (int)9986L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR 9986
     * }
     */
    public static int RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR() {
        return RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR;
    }
    private static final int RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST = (int)9985L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST 9985
     * }
     */
    public static int RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST() {
        return RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST;
    }
    private static final int RL_TEXTURE_FILTER_MIP_LINEAR = (int)9987L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_MIP_LINEAR 9987
     * }
     */
    public static int RL_TEXTURE_FILTER_MIP_LINEAR() {
        return RL_TEXTURE_FILTER_MIP_LINEAR;
    }
    private static final int RL_TEXTURE_FILTER_ANISOTROPIC = (int)12288L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_FILTER_ANISOTROPIC 12288
     * }
     */
    public static int RL_TEXTURE_FILTER_ANISOTROPIC() {
        return RL_TEXTURE_FILTER_ANISOTROPIC;
    }
    private static final int RL_TEXTURE_MIPMAP_BIAS_RATIO = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_MIPMAP_BIAS_RATIO 16384
     * }
     */
    public static int RL_TEXTURE_MIPMAP_BIAS_RATIO() {
        return RL_TEXTURE_MIPMAP_BIAS_RATIO;
    }
    private static final int RL_TEXTURE_WRAP_REPEAT = (int)10497L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_REPEAT 10497
     * }
     */
    public static int RL_TEXTURE_WRAP_REPEAT() {
        return RL_TEXTURE_WRAP_REPEAT;
    }
    private static final int RL_TEXTURE_WRAP_CLAMP = (int)33071L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_CLAMP 33071
     * }
     */
    public static int RL_TEXTURE_WRAP_CLAMP() {
        return RL_TEXTURE_WRAP_CLAMP;
    }
    private static final int RL_TEXTURE_WRAP_MIRROR_REPEAT = (int)33648L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_MIRROR_REPEAT 33648
     * }
     */
    public static int RL_TEXTURE_WRAP_MIRROR_REPEAT() {
        return RL_TEXTURE_WRAP_MIRROR_REPEAT;
    }
    private static final int RL_TEXTURE_WRAP_MIRROR_CLAMP = (int)34626L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE_WRAP_MIRROR_CLAMP 34626
     * }
     */
    public static int RL_TEXTURE_WRAP_MIRROR_CLAMP() {
        return RL_TEXTURE_WRAP_MIRROR_CLAMP;
    }
    private static final int RL_MODELVIEW = (int)5888L;
    /**
     * {@snippet lang=c :
     * #define RL_MODELVIEW 5888
     * }
     */
    public static int RL_MODELVIEW() {
        return RL_MODELVIEW;
    }
    private static final int RL_PROJECTION = (int)5889L;
    /**
     * {@snippet lang=c :
     * #define RL_PROJECTION 5889
     * }
     */
    public static int RL_PROJECTION() {
        return RL_PROJECTION;
    }
    private static final int RL_TEXTURE = (int)5890L;
    /**
     * {@snippet lang=c :
     * #define RL_TEXTURE 5890
     * }
     */
    public static int RL_TEXTURE() {
        return RL_TEXTURE;
    }
    private static final int RL_LINES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RL_LINES 1
     * }
     */
    public static int RL_LINES() {
        return RL_LINES;
    }
    private static final int RL_TRIANGLES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RL_TRIANGLES 4
     * }
     */
    public static int RL_TRIANGLES() {
        return RL_TRIANGLES;
    }
    private static final int RL_QUADS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RL_QUADS 7
     * }
     */
    public static int RL_QUADS() {
        return RL_QUADS;
    }
    private static final int RL_UNSIGNED_BYTE = (int)5121L;
    /**
     * {@snippet lang=c :
     * #define RL_UNSIGNED_BYTE 5121
     * }
     */
    public static int RL_UNSIGNED_BYTE() {
        return RL_UNSIGNED_BYTE;
    }
    private static final int RL_FLOAT = (int)5126L;
    /**
     * {@snippet lang=c :
     * #define RL_FLOAT 5126
     * }
     */
    public static int RL_FLOAT() {
        return RL_FLOAT;
    }
    private static final int RL_STREAM_DRAW = (int)35040L;
    /**
     * {@snippet lang=c :
     * #define RL_STREAM_DRAW 35040
     * }
     */
    public static int RL_STREAM_DRAW() {
        return RL_STREAM_DRAW;
    }
    private static final int RL_STREAM_READ = (int)35041L;
    /**
     * {@snippet lang=c :
     * #define RL_STREAM_READ 35041
     * }
     */
    public static int RL_STREAM_READ() {
        return RL_STREAM_READ;
    }
    private static final int RL_STREAM_COPY = (int)35042L;
    /**
     * {@snippet lang=c :
     * #define RL_STREAM_COPY 35042
     * }
     */
    public static int RL_STREAM_COPY() {
        return RL_STREAM_COPY;
    }
    private static final int RL_STATIC_DRAW = (int)35044L;
    /**
     * {@snippet lang=c :
     * #define RL_STATIC_DRAW 35044
     * }
     */
    public static int RL_STATIC_DRAW() {
        return RL_STATIC_DRAW;
    }
    private static final int RL_STATIC_READ = (int)35045L;
    /**
     * {@snippet lang=c :
     * #define RL_STATIC_READ 35045
     * }
     */
    public static int RL_STATIC_READ() {
        return RL_STATIC_READ;
    }
    private static final int RL_STATIC_COPY = (int)35046L;
    /**
     * {@snippet lang=c :
     * #define RL_STATIC_COPY 35046
     * }
     */
    public static int RL_STATIC_COPY() {
        return RL_STATIC_COPY;
    }
    private static final int RL_DYNAMIC_DRAW = (int)35048L;
    /**
     * {@snippet lang=c :
     * #define RL_DYNAMIC_DRAW 35048
     * }
     */
    public static int RL_DYNAMIC_DRAW() {
        return RL_DYNAMIC_DRAW;
    }
    private static final int RL_DYNAMIC_READ = (int)35049L;
    /**
     * {@snippet lang=c :
     * #define RL_DYNAMIC_READ 35049
     * }
     */
    public static int RL_DYNAMIC_READ() {
        return RL_DYNAMIC_READ;
    }
    private static final int RL_DYNAMIC_COPY = (int)35050L;
    /**
     * {@snippet lang=c :
     * #define RL_DYNAMIC_COPY 35050
     * }
     */
    public static int RL_DYNAMIC_COPY() {
        return RL_DYNAMIC_COPY;
    }
    private static final int RL_FRAGMENT_SHADER = (int)35632L;
    /**
     * {@snippet lang=c :
     * #define RL_FRAGMENT_SHADER 35632
     * }
     */
    public static int RL_FRAGMENT_SHADER() {
        return RL_FRAGMENT_SHADER;
    }
    private static final int RL_VERTEX_SHADER = (int)35633L;
    /**
     * {@snippet lang=c :
     * #define RL_VERTEX_SHADER 35633
     * }
     */
    public static int RL_VERTEX_SHADER() {
        return RL_VERTEX_SHADER;
    }
    private static final int RL_COMPUTE_SHADER = (int)37305L;
    /**
     * {@snippet lang=c :
     * #define RL_COMPUTE_SHADER 37305
     * }
     */
    public static int RL_COMPUTE_SHADER() {
        return RL_COMPUTE_SHADER;
    }
    private static final int RL_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RL_ZERO 0
     * }
     */
    public static int RL_ZERO() {
        return RL_ZERO;
    }
    private static final int RL_ONE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE 1
     * }
     */
    public static int RL_ONE() {
        return RL_ONE;
    }
    private static final int RL_SRC_COLOR = (int)768L;
    /**
     * {@snippet lang=c :
     * #define RL_SRC_COLOR 768
     * }
     */
    public static int RL_SRC_COLOR() {
        return RL_SRC_COLOR;
    }
    private static final int RL_ONE_MINUS_SRC_COLOR = (int)769L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_SRC_COLOR 769
     * }
     */
    public static int RL_ONE_MINUS_SRC_COLOR() {
        return RL_ONE_MINUS_SRC_COLOR;
    }
    private static final int RL_SRC_ALPHA = (int)770L;
    /**
     * {@snippet lang=c :
     * #define RL_SRC_ALPHA 770
     * }
     */
    public static int RL_SRC_ALPHA() {
        return RL_SRC_ALPHA;
    }
    private static final int RL_ONE_MINUS_SRC_ALPHA = (int)771L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_SRC_ALPHA 771
     * }
     */
    public static int RL_ONE_MINUS_SRC_ALPHA() {
        return RL_ONE_MINUS_SRC_ALPHA;
    }
    private static final int RL_DST_ALPHA = (int)772L;
    /**
     * {@snippet lang=c :
     * #define RL_DST_ALPHA 772
     * }
     */
    public static int RL_DST_ALPHA() {
        return RL_DST_ALPHA;
    }
    private static final int RL_ONE_MINUS_DST_ALPHA = (int)773L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_DST_ALPHA 773
     * }
     */
    public static int RL_ONE_MINUS_DST_ALPHA() {
        return RL_ONE_MINUS_DST_ALPHA;
    }
    private static final int RL_DST_COLOR = (int)774L;
    /**
     * {@snippet lang=c :
     * #define RL_DST_COLOR 774
     * }
     */
    public static int RL_DST_COLOR() {
        return RL_DST_COLOR;
    }
    private static final int RL_ONE_MINUS_DST_COLOR = (int)775L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_DST_COLOR 775
     * }
     */
    public static int RL_ONE_MINUS_DST_COLOR() {
        return RL_ONE_MINUS_DST_COLOR;
    }
    private static final int RL_SRC_ALPHA_SATURATE = (int)776L;
    /**
     * {@snippet lang=c :
     * #define RL_SRC_ALPHA_SATURATE 776
     * }
     */
    public static int RL_SRC_ALPHA_SATURATE() {
        return RL_SRC_ALPHA_SATURATE;
    }
    private static final int RL_CONSTANT_COLOR = (int)32769L;
    /**
     * {@snippet lang=c :
     * #define RL_CONSTANT_COLOR 32769
     * }
     */
    public static int RL_CONSTANT_COLOR() {
        return RL_CONSTANT_COLOR;
    }
    private static final int RL_ONE_MINUS_CONSTANT_COLOR = (int)32770L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_CONSTANT_COLOR 32770
     * }
     */
    public static int RL_ONE_MINUS_CONSTANT_COLOR() {
        return RL_ONE_MINUS_CONSTANT_COLOR;
    }
    private static final int RL_CONSTANT_ALPHA = (int)32771L;
    /**
     * {@snippet lang=c :
     * #define RL_CONSTANT_ALPHA 32771
     * }
     */
    public static int RL_CONSTANT_ALPHA() {
        return RL_CONSTANT_ALPHA;
    }
    private static final int RL_ONE_MINUS_CONSTANT_ALPHA = (int)32772L;
    /**
     * {@snippet lang=c :
     * #define RL_ONE_MINUS_CONSTANT_ALPHA 32772
     * }
     */
    public static int RL_ONE_MINUS_CONSTANT_ALPHA() {
        return RL_ONE_MINUS_CONSTANT_ALPHA;
    }
    private static final int RL_FUNC_ADD = (int)32774L;
    /**
     * {@snippet lang=c :
     * #define RL_FUNC_ADD 32774
     * }
     */
    public static int RL_FUNC_ADD() {
        return RL_FUNC_ADD;
    }
    private static final int RL_MIN = (int)32775L;
    /**
     * {@snippet lang=c :
     * #define RL_MIN 32775
     * }
     */
    public static int RL_MIN() {
        return RL_MIN;
    }
    private static final int RL_MAX = (int)32776L;
    /**
     * {@snippet lang=c :
     * #define RL_MAX 32776
     * }
     */
    public static int RL_MAX() {
        return RL_MAX;
    }
    private static final int RL_FUNC_SUBTRACT = (int)32778L;
    /**
     * {@snippet lang=c :
     * #define RL_FUNC_SUBTRACT 32778
     * }
     */
    public static int RL_FUNC_SUBTRACT() {
        return RL_FUNC_SUBTRACT;
    }
    private static final int RL_FUNC_REVERSE_SUBTRACT = (int)32779L;
    /**
     * {@snippet lang=c :
     * #define RL_FUNC_REVERSE_SUBTRACT 32779
     * }
     */
    public static int RL_FUNC_REVERSE_SUBTRACT() {
        return RL_FUNC_REVERSE_SUBTRACT;
    }
    private static final int RL_BLEND_EQUATION = (int)32777L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_EQUATION 32777
     * }
     */
    public static int RL_BLEND_EQUATION() {
        return RL_BLEND_EQUATION;
    }
    private static final int RL_BLEND_EQUATION_RGB = (int)32777L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_EQUATION_RGB 32777
     * }
     */
    public static int RL_BLEND_EQUATION_RGB() {
        return RL_BLEND_EQUATION_RGB;
    }
    private static final int RL_BLEND_EQUATION_ALPHA = (int)34877L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_EQUATION_ALPHA 34877
     * }
     */
    public static int RL_BLEND_EQUATION_ALPHA() {
        return RL_BLEND_EQUATION_ALPHA;
    }
    private static final int RL_BLEND_DST_RGB = (int)32968L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_DST_RGB 32968
     * }
     */
    public static int RL_BLEND_DST_RGB() {
        return RL_BLEND_DST_RGB;
    }
    private static final int RL_BLEND_SRC_RGB = (int)32969L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_SRC_RGB 32969
     * }
     */
    public static int RL_BLEND_SRC_RGB() {
        return RL_BLEND_SRC_RGB;
    }
    private static final int RL_BLEND_DST_ALPHA = (int)32970L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_DST_ALPHA 32970
     * }
     */
    public static int RL_BLEND_DST_ALPHA() {
        return RL_BLEND_DST_ALPHA;
    }
    private static final int RL_BLEND_SRC_ALPHA = (int)32971L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_SRC_ALPHA 32971
     * }
     */
    public static int RL_BLEND_SRC_ALPHA() {
        return RL_BLEND_SRC_ALPHA;
    }
    private static final int RL_BLEND_COLOR = (int)32773L;
    /**
     * {@snippet lang=c :
     * #define RL_BLEND_COLOR 32773
     * }
     */
    public static int RL_BLEND_COLOR() {
        return RL_BLEND_COLOR;
    }
    private static final int RL_READ_FRAMEBUFFER = (int)36008L;
    /**
     * {@snippet lang=c :
     * #define RL_READ_FRAMEBUFFER 36008
     * }
     */
    public static int RL_READ_FRAMEBUFFER() {
        return RL_READ_FRAMEBUFFER;
    }
    private static final int RL_DRAW_FRAMEBUFFER = (int)36009L;
    /**
     * {@snippet lang=c :
     * #define RL_DRAW_FRAMEBUFFER 36009
     * }
     */
    public static int RL_DRAW_FRAMEBUFFER() {
        return RL_DRAW_FRAMEBUFFER;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_POSITION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_POSITION 0
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_POSITION() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_POSITION;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD 1
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_NORMAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_NORMAL 2
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_NORMAL() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_NORMAL;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_COLOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_COLOR 3
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_COLOR() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_COLOR;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TANGENT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_TANGENT 4
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TANGENT() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_TANGENT;
    }
    private static final int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD2 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD2 5
     * }
     */
    public static int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD2() {
        return RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD2;
    }
    private static final int RAYGUI_VERSION_MAJOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_VERSION_MAJOR 4
     * }
     */
    public static int RAYGUI_VERSION_MAJOR() {
        return RAYGUI_VERSION_MAJOR;
    }
    private static final int RAYGUI_VERSION_MINOR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_VERSION_MINOR 5
     * }
     */
    public static int RAYGUI_VERSION_MINOR() {
        return RAYGUI_VERSION_MINOR;
    }
    private static final int RAYGUI_VERSION_PATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_VERSION_PATCH 0
     * }
     */
    public static int RAYGUI_VERSION_PATCH() {
        return RAYGUI_VERSION_PATCH;
    }
    private static final int SCROLLBAR_LEFT_SIDE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCROLLBAR_LEFT_SIDE 0
     * }
     */
    public static int SCROLLBAR_LEFT_SIDE() {
        return SCROLLBAR_LEFT_SIDE;
    }
    private static final int SCROLLBAR_RIGHT_SIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCROLLBAR_RIGHT_SIDE 1
     * }
     */
    public static int SCROLLBAR_RIGHT_SIDE() {
        return SCROLLBAR_RIGHT_SIDE;
    }
    private static final int RAYGUI_ICON_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_ICON_SIZE 16
     * }
     */
    public static int RAYGUI_ICON_SIZE() {
        return RAYGUI_ICON_SIZE;
    }
    private static final int RAYGUI_ICON_MAX_ICONS = (int)256L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_ICON_MAX_ICONS 256
     * }
     */
    public static int RAYGUI_ICON_MAX_ICONS() {
        return RAYGUI_ICON_MAX_ICONS;
    }
    private static final int RAYGUI_ICON_MAX_NAME_LENGTH = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_ICON_MAX_NAME_LENGTH 32
     * }
     */
    public static int RAYGUI_ICON_MAX_NAME_LENGTH() {
        return RAYGUI_ICON_MAX_NAME_LENGTH;
    }
    private static final int RAYGUI_MAX_CONTROLS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MAX_CONTROLS 16
     * }
     */
    public static int RAYGUI_MAX_CONTROLS() {
        return RAYGUI_MAX_CONTROLS;
    }
    private static final int RAYGUI_MAX_PROPS_BASE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MAX_PROPS_BASE 16
     * }
     */
    public static int RAYGUI_MAX_PROPS_BASE() {
        return RAYGUI_MAX_PROPS_BASE;
    }
    private static final int RAYGUI_MAX_PROPS_EXTENDED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MAX_PROPS_EXTENDED 8
     * }
     */
    public static int RAYGUI_MAX_PROPS_EXTENDED() {
        return RAYGUI_MAX_PROPS_EXTENDED;
    }
    private static final int RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT 24
     * }
     */
    public static int RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT() {
        return RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT;
    }
    private static final int RAYGUI_GROUPBOX_LINE_THICK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_GROUPBOX_LINE_THICK 1
     * }
     */
    public static int RAYGUI_GROUPBOX_LINE_THICK() {
        return RAYGUI_GROUPBOX_LINE_THICK;
    }
    private static final int RAYGUI_LINE_MARGIN_TEXT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_LINE_MARGIN_TEXT 12
     * }
     */
    public static int RAYGUI_LINE_MARGIN_TEXT() {
        return RAYGUI_LINE_MARGIN_TEXT;
    }
    private static final int RAYGUI_LINE_TEXT_PADDING = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_LINE_TEXT_PADDING 4
     * }
     */
    public static int RAYGUI_LINE_TEXT_PADDING() {
        return RAYGUI_LINE_TEXT_PADDING;
    }
    private static final int RAYGUI_PANEL_BORDER_WIDTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_PANEL_BORDER_WIDTH 1
     * }
     */
    public static int RAYGUI_PANEL_BORDER_WIDTH() {
        return RAYGUI_PANEL_BORDER_WIDTH;
    }
    private static final int RAYGUI_TABBAR_ITEM_WIDTH = (int)160L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TABBAR_ITEM_WIDTH 160
     * }
     */
    public static int RAYGUI_TABBAR_ITEM_WIDTH() {
        return RAYGUI_TABBAR_ITEM_WIDTH;
    }
    private static final int RAYGUI_MIN_SCROLLBAR_WIDTH = (int)40L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MIN_SCROLLBAR_WIDTH 40
     * }
     */
    public static int RAYGUI_MIN_SCROLLBAR_WIDTH() {
        return RAYGUI_MIN_SCROLLBAR_WIDTH;
    }
    private static final int RAYGUI_MIN_SCROLLBAR_HEIGHT = (int)40L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MIN_SCROLLBAR_HEIGHT 40
     * }
     */
    public static int RAYGUI_MIN_SCROLLBAR_HEIGHT() {
        return RAYGUI_MIN_SCROLLBAR_HEIGHT;
    }
    private static final int RAYGUI_MIN_MOUSE_WHEEL_SPEED = (int)20L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MIN_MOUSE_WHEEL_SPEED 20
     * }
     */
    public static int RAYGUI_MIN_MOUSE_WHEEL_SPEED() {
        return RAYGUI_MIN_MOUSE_WHEEL_SPEED;
    }
    private static final int RAYGUI_TOGGLEGROUP_MAX_ITEMS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TOGGLEGROUP_MAX_ITEMS 32
     * }
     */
    public static int RAYGUI_TOGGLEGROUP_MAX_ITEMS() {
        return RAYGUI_TOGGLEGROUP_MAX_ITEMS;
    }
    private static final int RAYGUI_TEXTBOX_AUTO_CURSOR_COOLDOWN = (int)40L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTBOX_AUTO_CURSOR_COOLDOWN 40
     * }
     */
    public static int RAYGUI_TEXTBOX_AUTO_CURSOR_COOLDOWN() {
        return RAYGUI_TEXTBOX_AUTO_CURSOR_COOLDOWN;
    }
    private static final int RAYGUI_TEXTBOX_AUTO_CURSOR_DELAY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTBOX_AUTO_CURSOR_DELAY 1
     * }
     */
    public static int RAYGUI_TEXTBOX_AUTO_CURSOR_DELAY() {
        return RAYGUI_TEXTBOX_AUTO_CURSOR_DELAY;
    }
    private static final int RAYGUI_VALUEBOX_MAX_CHARS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_VALUEBOX_MAX_CHARS 32
     * }
     */
    public static int RAYGUI_VALUEBOX_MAX_CHARS() {
        return RAYGUI_VALUEBOX_MAX_CHARS;
    }
    private static final int RAYGUI_COLORBARALPHA_CHECKED_SIZE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_COLORBARALPHA_CHECKED_SIZE 10
     * }
     */
    public static int RAYGUI_COLORBARALPHA_CHECKED_SIZE() {
        return RAYGUI_COLORBARALPHA_CHECKED_SIZE;
    }
    private static final int RAYGUI_MESSAGEBOX_BUTTON_HEIGHT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MESSAGEBOX_BUTTON_HEIGHT 24
     * }
     */
    public static int RAYGUI_MESSAGEBOX_BUTTON_HEIGHT() {
        return RAYGUI_MESSAGEBOX_BUTTON_HEIGHT;
    }
    private static final int RAYGUI_MESSAGEBOX_BUTTON_PADDING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MESSAGEBOX_BUTTON_PADDING 12
     * }
     */
    public static int RAYGUI_MESSAGEBOX_BUTTON_PADDING() {
        return RAYGUI_MESSAGEBOX_BUTTON_PADDING;
    }
    private static final int RAYGUI_TEXTINPUTBOX_BUTTON_HEIGHT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTINPUTBOX_BUTTON_HEIGHT 24
     * }
     */
    public static int RAYGUI_TEXTINPUTBOX_BUTTON_HEIGHT() {
        return RAYGUI_TEXTINPUTBOX_BUTTON_HEIGHT;
    }
    private static final int RAYGUI_TEXTINPUTBOX_BUTTON_PADDING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTINPUTBOX_BUTTON_PADDING 12
     * }
     */
    public static int RAYGUI_TEXTINPUTBOX_BUTTON_PADDING() {
        return RAYGUI_TEXTINPUTBOX_BUTTON_PADDING;
    }
    private static final int RAYGUI_TEXTINPUTBOX_HEIGHT = (int)26L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTINPUTBOX_HEIGHT 26
     * }
     */
    public static int RAYGUI_TEXTINPUTBOX_HEIGHT() {
        return RAYGUI_TEXTINPUTBOX_HEIGHT;
    }
    private static final int MAX_LINE_BUFFER_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define MAX_LINE_BUFFER_SIZE 256
     * }
     */
    public static int MAX_LINE_BUFFER_SIZE() {
        return MAX_LINE_BUFFER_SIZE;
    }
    private static final int ICON_TEXT_PADDING = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ICON_TEXT_PADDING 4
     * }
     */
    public static int ICON_TEXT_PADDING() {
        return ICON_TEXT_PADDING;
    }
    private static final int RAYGUI_MAX_TEXT_LINES = (int)128L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_MAX_TEXT_LINES 128
     * }
     */
    public static int RAYGUI_MAX_TEXT_LINES() {
        return RAYGUI_MAX_TEXT_LINES;
    }
    private static final int RAYGUI_TEXTSPLIT_MAX_ITEMS = (int)128L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTSPLIT_MAX_ITEMS 128
     * }
     */
    public static int RAYGUI_TEXTSPLIT_MAX_ITEMS() {
        return RAYGUI_TEXTSPLIT_MAX_ITEMS;
    }
    private static final int RAYGUI_TEXTSPLIT_MAX_TEXT_SIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define RAYGUI_TEXTSPLIT_MAX_TEXT_SIZE 1024
     * }
     */
    public static int RAYGUI_TEXTSPLIT_MAX_TEXT_SIZE() {
        return RAYGUI_TEXTSPLIT_MAX_TEXT_SIZE;
    }
    private static final int FLAG_VSYNC_HINT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_VSYNC_HINT = 64
     * }
     */
    public static int FLAG_VSYNC_HINT() {
        return FLAG_VSYNC_HINT;
    }
    private static final int FLAG_FULLSCREEN_MODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_FULLSCREEN_MODE = 2
     * }
     */
    public static int FLAG_FULLSCREEN_MODE() {
        return FLAG_FULLSCREEN_MODE;
    }
    private static final int FLAG_WINDOW_RESIZABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_RESIZABLE = 4
     * }
     */
    public static int FLAG_WINDOW_RESIZABLE() {
        return FLAG_WINDOW_RESIZABLE;
    }
    private static final int FLAG_WINDOW_UNDECORATED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_UNDECORATED = 8
     * }
     */
    public static int FLAG_WINDOW_UNDECORATED() {
        return FLAG_WINDOW_UNDECORATED;
    }
    private static final int FLAG_WINDOW_HIDDEN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_HIDDEN = 128
     * }
     */
    public static int FLAG_WINDOW_HIDDEN() {
        return FLAG_WINDOW_HIDDEN;
    }
    private static final int FLAG_WINDOW_MINIMIZED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MINIMIZED = 512
     * }
     */
    public static int FLAG_WINDOW_MINIMIZED() {
        return FLAG_WINDOW_MINIMIZED;
    }
    private static final int FLAG_WINDOW_MAXIMIZED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MAXIMIZED = 1024
     * }
     */
    public static int FLAG_WINDOW_MAXIMIZED() {
        return FLAG_WINDOW_MAXIMIZED;
    }
    private static final int FLAG_WINDOW_UNFOCUSED = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_UNFOCUSED = 2048
     * }
     */
    public static int FLAG_WINDOW_UNFOCUSED() {
        return FLAG_WINDOW_UNFOCUSED;
    }
    private static final int FLAG_WINDOW_TOPMOST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_TOPMOST = 4096
     * }
     */
    public static int FLAG_WINDOW_TOPMOST() {
        return FLAG_WINDOW_TOPMOST;
    }
    private static final int FLAG_WINDOW_ALWAYS_RUN = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_ALWAYS_RUN = 256
     * }
     */
    public static int FLAG_WINDOW_ALWAYS_RUN() {
        return FLAG_WINDOW_ALWAYS_RUN;
    }
    private static final int FLAG_WINDOW_TRANSPARENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_TRANSPARENT = 16
     * }
     */
    public static int FLAG_WINDOW_TRANSPARENT() {
        return FLAG_WINDOW_TRANSPARENT;
    }
    private static final int FLAG_WINDOW_HIGHDPI = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_HIGHDPI = 8192
     * }
     */
    public static int FLAG_WINDOW_HIGHDPI() {
        return FLAG_WINDOW_HIGHDPI;
    }
    private static final int FLAG_WINDOW_MOUSE_PASSTHROUGH = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
     * }
     */
    public static int FLAG_WINDOW_MOUSE_PASSTHROUGH() {
        return FLAG_WINDOW_MOUSE_PASSTHROUGH;
    }
    private static final int FLAG_BORDERLESS_WINDOWED_MODE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_BORDERLESS_WINDOWED_MODE = 32768
     * }
     */
    public static int FLAG_BORDERLESS_WINDOWED_MODE() {
        return FLAG_BORDERLESS_WINDOWED_MODE;
    }
    private static final int FLAG_MSAA_4X_HINT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_MSAA_4X_HINT = 32
     * }
     */
    public static int FLAG_MSAA_4X_HINT() {
        return FLAG_MSAA_4X_HINT;
    }
    private static final int FLAG_INTERLACED_HINT = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_INTERLACED_HINT = 65536
     * }
     */
    public static int FLAG_INTERLACED_HINT() {
        return FLAG_INTERLACED_HINT;
    }
    private static final int LOG_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_ALL = 0
     * }
     */
    public static int LOG_ALL() {
        return LOG_ALL;
    }
    private static final int LOG_TRACE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_TRACE = 1
     * }
     */
    public static int LOG_TRACE() {
        return LOG_TRACE;
    }
    private static final int LOG_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_DEBUG = 2
     * }
     */
    public static int LOG_DEBUG() {
        return LOG_DEBUG;
    }
    private static final int LOG_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_INFO = 3
     * }
     */
    public static int LOG_INFO() {
        return LOG_INFO;
    }
    private static final int LOG_WARNING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_WARNING = 4
     * }
     */
    public static int LOG_WARNING() {
        return LOG_WARNING;
    }
    private static final int LOG_ERROR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_ERROR = 5
     * }
     */
    public static int LOG_ERROR() {
        return LOG_ERROR;
    }
    private static final int LOG_FATAL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_FATAL = 6
     * }
     */
    public static int LOG_FATAL() {
        return LOG_FATAL;
    }
    private static final int LOG_NONE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LOG_NONE = 7
     * }
     */
    public static int LOG_NONE() {
        return LOG_NONE;
    }
    private static final int KEY_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_NULL = 0
     * }
     */
    public static int KEY_NULL() {
        return KEY_NULL;
    }
    private static final int KEY_APOSTROPHE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_APOSTROPHE = 39
     * }
     */
    public static int KEY_APOSTROPHE() {
        return KEY_APOSTROPHE;
    }
    private static final int KEY_COMMA = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_COMMA = 44
     * }
     */
    public static int KEY_COMMA() {
        return KEY_COMMA;
    }
    private static final int KEY_MINUS = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_MINUS = 45
     * }
     */
    public static int KEY_MINUS() {
        return KEY_MINUS;
    }
    private static final int KEY_PERIOD = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_PERIOD = 46
     * }
     */
    public static int KEY_PERIOD() {
        return KEY_PERIOD;
    }
    private static final int KEY_SLASH = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SLASH = 47
     * }
     */
    public static int KEY_SLASH() {
        return KEY_SLASH;
    }
    private static final int KEY_ZERO = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_ZERO = 48
     * }
     */
    public static int KEY_ZERO() {
        return KEY_ZERO;
    }
    private static final int KEY_ONE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_ONE = 49
     * }
     */
    public static int KEY_ONE() {
        return KEY_ONE;
    }
    private static final int KEY_TWO = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_TWO = 50
     * }
     */
    public static int KEY_TWO() {
        return KEY_TWO;
    }
    private static final int KEY_THREE = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_THREE = 51
     * }
     */
    public static int KEY_THREE() {
        return KEY_THREE;
    }
    private static final int KEY_FOUR = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_FOUR = 52
     * }
     */
    public static int KEY_FOUR() {
        return KEY_FOUR;
    }
    private static final int KEY_FIVE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_FIVE = 53
     * }
     */
    public static int KEY_FIVE() {
        return KEY_FIVE;
    }
    private static final int KEY_SIX = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SIX = 54
     * }
     */
    public static int KEY_SIX() {
        return KEY_SIX;
    }
    private static final int KEY_SEVEN = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SEVEN = 55
     * }
     */
    public static int KEY_SEVEN() {
        return KEY_SEVEN;
    }
    private static final int KEY_EIGHT = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_EIGHT = 56
     * }
     */
    public static int KEY_EIGHT() {
        return KEY_EIGHT;
    }
    private static final int KEY_NINE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_NINE = 57
     * }
     */
    public static int KEY_NINE() {
        return KEY_NINE;
    }
    private static final int KEY_SEMICOLON = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SEMICOLON = 59
     * }
     */
    public static int KEY_SEMICOLON() {
        return KEY_SEMICOLON;
    }
    private static final int KEY_EQUAL = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_EQUAL = 61
     * }
     */
    public static int KEY_EQUAL() {
        return KEY_EQUAL;
    }
    private static final int KEY_A = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_A = 65
     * }
     */
    public static int KEY_A() {
        return KEY_A;
    }
    private static final int KEY_B = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_B = 66
     * }
     */
    public static int KEY_B() {
        return KEY_B;
    }
    private static final int KEY_C = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_C = 67
     * }
     */
    public static int KEY_C() {
        return KEY_C;
    }
    private static final int KEY_D = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_D = 68
     * }
     */
    public static int KEY_D() {
        return KEY_D;
    }
    private static final int KEY_E = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_E = 69
     * }
     */
    public static int KEY_E() {
        return KEY_E;
    }
    private static final int KEY_F = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F = 70
     * }
     */
    public static int KEY_F() {
        return KEY_F;
    }
    private static final int KEY_G = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_G = 71
     * }
     */
    public static int KEY_G() {
        return KEY_G;
    }
    private static final int KEY_H = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_H = 72
     * }
     */
    public static int KEY_H() {
        return KEY_H;
    }
    private static final int KEY_I = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_I = 73
     * }
     */
    public static int KEY_I() {
        return KEY_I;
    }
    private static final int KEY_J = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_J = 74
     * }
     */
    public static int KEY_J() {
        return KEY_J;
    }
    private static final int KEY_K = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_K = 75
     * }
     */
    public static int KEY_K() {
        return KEY_K;
    }
    private static final int KEY_L = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_L = 76
     * }
     */
    public static int KEY_L() {
        return KEY_L;
    }
    private static final int KEY_M = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_M = 77
     * }
     */
    public static int KEY_M() {
        return KEY_M;
    }
    private static final int KEY_N = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_N = 78
     * }
     */
    public static int KEY_N() {
        return KEY_N;
    }
    private static final int KEY_O = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_O = 79
     * }
     */
    public static int KEY_O() {
        return KEY_O;
    }
    private static final int KEY_P = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_P = 80
     * }
     */
    public static int KEY_P() {
        return KEY_P;
    }
    private static final int KEY_Q = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_Q = 81
     * }
     */
    public static int KEY_Q() {
        return KEY_Q;
    }
    private static final int KEY_R = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_R = 82
     * }
     */
    public static int KEY_R() {
        return KEY_R;
    }
    private static final int KEY_S = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_S = 83
     * }
     */
    public static int KEY_S() {
        return KEY_S;
    }
    private static final int KEY_T = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_T = 84
     * }
     */
    public static int KEY_T() {
        return KEY_T;
    }
    private static final int KEY_U = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_U = 85
     * }
     */
    public static int KEY_U() {
        return KEY_U;
    }
    private static final int KEY_V = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_V = 86
     * }
     */
    public static int KEY_V() {
        return KEY_V;
    }
    private static final int KEY_W = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_W = 87
     * }
     */
    public static int KEY_W() {
        return KEY_W;
    }
    private static final int KEY_X = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_X = 88
     * }
     */
    public static int KEY_X() {
        return KEY_X;
    }
    private static final int KEY_Y = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_Y = 89
     * }
     */
    public static int KEY_Y() {
        return KEY_Y;
    }
    private static final int KEY_Z = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_Z = 90
     * }
     */
    public static int KEY_Z() {
        return KEY_Z;
    }
    private static final int KEY_LEFT_BRACKET = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT_BRACKET = 91
     * }
     */
    public static int KEY_LEFT_BRACKET() {
        return KEY_LEFT_BRACKET;
    }
    private static final int KEY_BACKSLASH = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_BACKSLASH = 92
     * }
     */
    public static int KEY_BACKSLASH() {
        return KEY_BACKSLASH;
    }
    private static final int KEY_RIGHT_BRACKET = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT_BRACKET = 93
     * }
     */
    public static int KEY_RIGHT_BRACKET() {
        return KEY_RIGHT_BRACKET;
    }
    private static final int KEY_GRAVE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_GRAVE = 96
     * }
     */
    public static int KEY_GRAVE() {
        return KEY_GRAVE;
    }
    private static final int KEY_SPACE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SPACE = 32
     * }
     */
    public static int KEY_SPACE() {
        return KEY_SPACE;
    }
    private static final int KEY_ESCAPE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_ESCAPE = 256
     * }
     */
    public static int KEY_ESCAPE() {
        return KEY_ESCAPE;
    }
    private static final int KEY_ENTER = (int)257L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_ENTER = 257
     * }
     */
    public static int KEY_ENTER() {
        return KEY_ENTER;
    }
    private static final int KEY_TAB = (int)258L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_TAB = 258
     * }
     */
    public static int KEY_TAB() {
        return KEY_TAB;
    }
    private static final int KEY_BACKSPACE = (int)259L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_BACKSPACE = 259
     * }
     */
    public static int KEY_BACKSPACE() {
        return KEY_BACKSPACE;
    }
    private static final int KEY_INSERT = (int)260L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_INSERT = 260
     * }
     */
    public static int KEY_INSERT() {
        return KEY_INSERT;
    }
    private static final int KEY_DELETE = (int)261L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_DELETE = 261
     * }
     */
    public static int KEY_DELETE() {
        return KEY_DELETE;
    }
    private static final int KEY_RIGHT = (int)262L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT = 262
     * }
     */
    public static int KEY_RIGHT() {
        return KEY_RIGHT;
    }
    private static final int KEY_LEFT = (int)263L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT = 263
     * }
     */
    public static int KEY_LEFT() {
        return KEY_LEFT;
    }
    private static final int KEY_DOWN = (int)264L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_DOWN = 264
     * }
     */
    public static int KEY_DOWN() {
        return KEY_DOWN;
    }
    private static final int KEY_UP = (int)265L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_UP = 265
     * }
     */
    public static int KEY_UP() {
        return KEY_UP;
    }
    private static final int KEY_PAGE_UP = (int)266L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_PAGE_UP = 266
     * }
     */
    public static int KEY_PAGE_UP() {
        return KEY_PAGE_UP;
    }
    private static final int KEY_PAGE_DOWN = (int)267L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_PAGE_DOWN = 267
     * }
     */
    public static int KEY_PAGE_DOWN() {
        return KEY_PAGE_DOWN;
    }
    private static final int KEY_HOME = (int)268L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_HOME = 268
     * }
     */
    public static int KEY_HOME() {
        return KEY_HOME;
    }
    private static final int KEY_END = (int)269L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_END = 269
     * }
     */
    public static int KEY_END() {
        return KEY_END;
    }
    private static final int KEY_CAPS_LOCK = (int)280L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_CAPS_LOCK = 280
     * }
     */
    public static int KEY_CAPS_LOCK() {
        return KEY_CAPS_LOCK;
    }
    private static final int KEY_SCROLL_LOCK = (int)281L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_SCROLL_LOCK = 281
     * }
     */
    public static int KEY_SCROLL_LOCK() {
        return KEY_SCROLL_LOCK;
    }
    private static final int KEY_NUM_LOCK = (int)282L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_NUM_LOCK = 282
     * }
     */
    public static int KEY_NUM_LOCK() {
        return KEY_NUM_LOCK;
    }
    private static final int KEY_PRINT_SCREEN = (int)283L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_PRINT_SCREEN = 283
     * }
     */
    public static int KEY_PRINT_SCREEN() {
        return KEY_PRINT_SCREEN;
    }
    private static final int KEY_PAUSE = (int)284L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_PAUSE = 284
     * }
     */
    public static int KEY_PAUSE() {
        return KEY_PAUSE;
    }
    private static final int KEY_F1 = (int)290L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F1 = 290
     * }
     */
    public static int KEY_F1() {
        return KEY_F1;
    }
    private static final int KEY_F2 = (int)291L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F2 = 291
     * }
     */
    public static int KEY_F2() {
        return KEY_F2;
    }
    private static final int KEY_F3 = (int)292L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F3 = 292
     * }
     */
    public static int KEY_F3() {
        return KEY_F3;
    }
    private static final int KEY_F4 = (int)293L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F4 = 293
     * }
     */
    public static int KEY_F4() {
        return KEY_F4;
    }
    private static final int KEY_F5 = (int)294L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F5 = 294
     * }
     */
    public static int KEY_F5() {
        return KEY_F5;
    }
    private static final int KEY_F6 = (int)295L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F6 = 295
     * }
     */
    public static int KEY_F6() {
        return KEY_F6;
    }
    private static final int KEY_F7 = (int)296L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F7 = 296
     * }
     */
    public static int KEY_F7() {
        return KEY_F7;
    }
    private static final int KEY_F8 = (int)297L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F8 = 297
     * }
     */
    public static int KEY_F8() {
        return KEY_F8;
    }
    private static final int KEY_F9 = (int)298L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F9 = 298
     * }
     */
    public static int KEY_F9() {
        return KEY_F9;
    }
    private static final int KEY_F10 = (int)299L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F10 = 299
     * }
     */
    public static int KEY_F10() {
        return KEY_F10;
    }
    private static final int KEY_F11 = (int)300L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F11 = 300
     * }
     */
    public static int KEY_F11() {
        return KEY_F11;
    }
    private static final int KEY_F12 = (int)301L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_F12 = 301
     * }
     */
    public static int KEY_F12() {
        return KEY_F12;
    }
    private static final int KEY_LEFT_SHIFT = (int)340L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT_SHIFT = 340
     * }
     */
    public static int KEY_LEFT_SHIFT() {
        return KEY_LEFT_SHIFT;
    }
    private static final int KEY_LEFT_CONTROL = (int)341L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT_CONTROL = 341
     * }
     */
    public static int KEY_LEFT_CONTROL() {
        return KEY_LEFT_CONTROL;
    }
    private static final int KEY_LEFT_ALT = (int)342L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT_ALT = 342
     * }
     */
    public static int KEY_LEFT_ALT() {
        return KEY_LEFT_ALT;
    }
    private static final int KEY_LEFT_SUPER = (int)343L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_LEFT_SUPER = 343
     * }
     */
    public static int KEY_LEFT_SUPER() {
        return KEY_LEFT_SUPER;
    }
    private static final int KEY_RIGHT_SHIFT = (int)344L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT_SHIFT = 344
     * }
     */
    public static int KEY_RIGHT_SHIFT() {
        return KEY_RIGHT_SHIFT;
    }
    private static final int KEY_RIGHT_CONTROL = (int)345L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT_CONTROL = 345
     * }
     */
    public static int KEY_RIGHT_CONTROL() {
        return KEY_RIGHT_CONTROL;
    }
    private static final int KEY_RIGHT_ALT = (int)346L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT_ALT = 346
     * }
     */
    public static int KEY_RIGHT_ALT() {
        return KEY_RIGHT_ALT;
    }
    private static final int KEY_RIGHT_SUPER = (int)347L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_RIGHT_SUPER = 347
     * }
     */
    public static int KEY_RIGHT_SUPER() {
        return KEY_RIGHT_SUPER;
    }
    private static final int KEY_KB_MENU = (int)348L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KB_MENU = 348
     * }
     */
    public static int KEY_KB_MENU() {
        return KEY_KB_MENU;
    }
    private static final int KEY_KP_0 = (int)320L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_0 = 320
     * }
     */
    public static int KEY_KP_0() {
        return KEY_KP_0;
    }
    private static final int KEY_KP_1 = (int)321L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_1 = 321
     * }
     */
    public static int KEY_KP_1() {
        return KEY_KP_1;
    }
    private static final int KEY_KP_2 = (int)322L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_2 = 322
     * }
     */
    public static int KEY_KP_2() {
        return KEY_KP_2;
    }
    private static final int KEY_KP_3 = (int)323L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_3 = 323
     * }
     */
    public static int KEY_KP_3() {
        return KEY_KP_3;
    }
    private static final int KEY_KP_4 = (int)324L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_4 = 324
     * }
     */
    public static int KEY_KP_4() {
        return KEY_KP_4;
    }
    private static final int KEY_KP_5 = (int)325L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_5 = 325
     * }
     */
    public static int KEY_KP_5() {
        return KEY_KP_5;
    }
    private static final int KEY_KP_6 = (int)326L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_6 = 326
     * }
     */
    public static int KEY_KP_6() {
        return KEY_KP_6;
    }
    private static final int KEY_KP_7 = (int)327L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_7 = 327
     * }
     */
    public static int KEY_KP_7() {
        return KEY_KP_7;
    }
    private static final int KEY_KP_8 = (int)328L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_8 = 328
     * }
     */
    public static int KEY_KP_8() {
        return KEY_KP_8;
    }
    private static final int KEY_KP_9 = (int)329L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_9 = 329
     * }
     */
    public static int KEY_KP_9() {
        return KEY_KP_9;
    }
    private static final int KEY_KP_DECIMAL = (int)330L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_DECIMAL = 330
     * }
     */
    public static int KEY_KP_DECIMAL() {
        return KEY_KP_DECIMAL;
    }
    private static final int KEY_KP_DIVIDE = (int)331L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_DIVIDE = 331
     * }
     */
    public static int KEY_KP_DIVIDE() {
        return KEY_KP_DIVIDE;
    }
    private static final int KEY_KP_MULTIPLY = (int)332L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_MULTIPLY = 332
     * }
     */
    public static int KEY_KP_MULTIPLY() {
        return KEY_KP_MULTIPLY;
    }
    private static final int KEY_KP_SUBTRACT = (int)333L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_SUBTRACT = 333
     * }
     */
    public static int KEY_KP_SUBTRACT() {
        return KEY_KP_SUBTRACT;
    }
    private static final int KEY_KP_ADD = (int)334L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_ADD = 334
     * }
     */
    public static int KEY_KP_ADD() {
        return KEY_KP_ADD;
    }
    private static final int KEY_KP_ENTER = (int)335L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_ENTER = 335
     * }
     */
    public static int KEY_KP_ENTER() {
        return KEY_KP_ENTER;
    }
    private static final int KEY_KP_EQUAL = (int)336L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_KP_EQUAL = 336
     * }
     */
    public static int KEY_KP_EQUAL() {
        return KEY_KP_EQUAL;
    }
    private static final int KEY_BACK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_BACK = 4
     * }
     */
    public static int KEY_BACK() {
        return KEY_BACK;
    }
    private static final int KEY_MENU = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_MENU = 5
     * }
     */
    public static int KEY_MENU() {
        return KEY_MENU;
    }
    private static final int KEY_VOLUME_UP = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_VOLUME_UP = 24
     * }
     */
    public static int KEY_VOLUME_UP() {
        return KEY_VOLUME_UP;
    }
    private static final int KEY_VOLUME_DOWN = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KEY_VOLUME_DOWN = 25
     * }
     */
    public static int KEY_VOLUME_DOWN() {
        return KEY_VOLUME_DOWN;
    }
    private static final int MOUSE_BUTTON_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_LEFT = 0
     * }
     */
    public static int MOUSE_BUTTON_LEFT() {
        return MOUSE_BUTTON_LEFT;
    }
    private static final int MOUSE_BUTTON_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_RIGHT = 1
     * }
     */
    public static int MOUSE_BUTTON_RIGHT() {
        return MOUSE_BUTTON_RIGHT;
    }
    private static final int MOUSE_BUTTON_MIDDLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_MIDDLE = 2
     * }
     */
    public static int MOUSE_BUTTON_MIDDLE() {
        return MOUSE_BUTTON_MIDDLE;
    }
    private static final int MOUSE_BUTTON_SIDE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_SIDE = 3
     * }
     */
    public static int MOUSE_BUTTON_SIDE() {
        return MOUSE_BUTTON_SIDE;
    }
    private static final int MOUSE_BUTTON_EXTRA = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_EXTRA = 4
     * }
     */
    public static int MOUSE_BUTTON_EXTRA() {
        return MOUSE_BUTTON_EXTRA;
    }
    private static final int MOUSE_BUTTON_FORWARD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_FORWARD = 5
     * }
     */
    public static int MOUSE_BUTTON_FORWARD() {
        return MOUSE_BUTTON_FORWARD;
    }
    private static final int MOUSE_BUTTON_BACK = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_BUTTON_BACK = 6
     * }
     */
    public static int MOUSE_BUTTON_BACK() {
        return MOUSE_BUTTON_BACK;
    }
    private static final int MOUSE_CURSOR_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_DEFAULT = 0
     * }
     */
    public static int MOUSE_CURSOR_DEFAULT() {
        return MOUSE_CURSOR_DEFAULT;
    }
    private static final int MOUSE_CURSOR_ARROW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_ARROW = 1
     * }
     */
    public static int MOUSE_CURSOR_ARROW() {
        return MOUSE_CURSOR_ARROW;
    }
    private static final int MOUSE_CURSOR_IBEAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_IBEAM = 2
     * }
     */
    public static int MOUSE_CURSOR_IBEAM() {
        return MOUSE_CURSOR_IBEAM;
    }
    private static final int MOUSE_CURSOR_CROSSHAIR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_CROSSHAIR = 3
     * }
     */
    public static int MOUSE_CURSOR_CROSSHAIR() {
        return MOUSE_CURSOR_CROSSHAIR;
    }
    private static final int MOUSE_CURSOR_POINTING_HAND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_POINTING_HAND = 4
     * }
     */
    public static int MOUSE_CURSOR_POINTING_HAND() {
        return MOUSE_CURSOR_POINTING_HAND;
    }
    private static final int MOUSE_CURSOR_RESIZE_EW = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_RESIZE_EW = 5
     * }
     */
    public static int MOUSE_CURSOR_RESIZE_EW() {
        return MOUSE_CURSOR_RESIZE_EW;
    }
    private static final int MOUSE_CURSOR_RESIZE_NS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_RESIZE_NS = 6
     * }
     */
    public static int MOUSE_CURSOR_RESIZE_NS() {
        return MOUSE_CURSOR_RESIZE_NS;
    }
    private static final int MOUSE_CURSOR_RESIZE_NWSE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_RESIZE_NWSE = 7
     * }
     */
    public static int MOUSE_CURSOR_RESIZE_NWSE() {
        return MOUSE_CURSOR_RESIZE_NWSE;
    }
    private static final int MOUSE_CURSOR_RESIZE_NESW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_RESIZE_NESW = 8
     * }
     */
    public static int MOUSE_CURSOR_RESIZE_NESW() {
        return MOUSE_CURSOR_RESIZE_NESW;
    }
    private static final int MOUSE_CURSOR_RESIZE_ALL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_RESIZE_ALL = 9
     * }
     */
    public static int MOUSE_CURSOR_RESIZE_ALL() {
        return MOUSE_CURSOR_RESIZE_ALL;
    }
    private static final int MOUSE_CURSOR_NOT_ALLOWED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MOUSE_CURSOR_NOT_ALLOWED = 10
     * }
     */
    public static int MOUSE_CURSOR_NOT_ALLOWED() {
        return MOUSE_CURSOR_NOT_ALLOWED;
    }
    private static final int GAMEPAD_BUTTON_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_UNKNOWN = 0
     * }
     */
    public static int GAMEPAD_BUTTON_UNKNOWN() {
        return GAMEPAD_BUTTON_UNKNOWN;
    }
    private static final int GAMEPAD_BUTTON_LEFT_FACE_UP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_FACE_UP = 1
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_FACE_UP() {
        return GAMEPAD_BUTTON_LEFT_FACE_UP;
    }
    private static final int GAMEPAD_BUTTON_LEFT_FACE_RIGHT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_FACE_RIGHT() {
        return GAMEPAD_BUTTON_LEFT_FACE_RIGHT;
    }
    private static final int GAMEPAD_BUTTON_LEFT_FACE_DOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_FACE_DOWN() {
        return GAMEPAD_BUTTON_LEFT_FACE_DOWN;
    }
    private static final int GAMEPAD_BUTTON_LEFT_FACE_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_FACE_LEFT() {
        return GAMEPAD_BUTTON_LEFT_FACE_LEFT;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_FACE_UP = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_FACE_UP = 5
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_FACE_UP() {
        return GAMEPAD_BUTTON_RIGHT_FACE_UP;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_FACE_RIGHT() {
        return GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_FACE_DOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_FACE_DOWN() {
        return GAMEPAD_BUTTON_RIGHT_FACE_DOWN;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_FACE_LEFT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_FACE_LEFT() {
        return GAMEPAD_BUTTON_RIGHT_FACE_LEFT;
    }
    private static final int GAMEPAD_BUTTON_LEFT_TRIGGER_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_TRIGGER_1() {
        return GAMEPAD_BUTTON_LEFT_TRIGGER_1;
    }
    private static final int GAMEPAD_BUTTON_LEFT_TRIGGER_2 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_TRIGGER_2() {
        return GAMEPAD_BUTTON_LEFT_TRIGGER_2;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_TRIGGER_1() {
        return GAMEPAD_BUTTON_RIGHT_TRIGGER_1;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_TRIGGER_2() {
        return GAMEPAD_BUTTON_RIGHT_TRIGGER_2;
    }
    private static final int GAMEPAD_BUTTON_MIDDLE_LEFT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_MIDDLE_LEFT = 13
     * }
     */
    public static int GAMEPAD_BUTTON_MIDDLE_LEFT() {
        return GAMEPAD_BUTTON_MIDDLE_LEFT;
    }
    private static final int GAMEPAD_BUTTON_MIDDLE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_MIDDLE = 14
     * }
     */
    public static int GAMEPAD_BUTTON_MIDDLE() {
        return GAMEPAD_BUTTON_MIDDLE;
    }
    private static final int GAMEPAD_BUTTON_MIDDLE_RIGHT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_MIDDLE_RIGHT = 15
     * }
     */
    public static int GAMEPAD_BUTTON_MIDDLE_RIGHT() {
        return GAMEPAD_BUTTON_MIDDLE_RIGHT;
    }
    private static final int GAMEPAD_BUTTON_LEFT_THUMB = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_LEFT_THUMB = 16
     * }
     */
    public static int GAMEPAD_BUTTON_LEFT_THUMB() {
        return GAMEPAD_BUTTON_LEFT_THUMB;
    }
    private static final int GAMEPAD_BUTTON_RIGHT_THUMB = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_BUTTON_RIGHT_THUMB = 17
     * }
     */
    public static int GAMEPAD_BUTTON_RIGHT_THUMB() {
        return GAMEPAD_BUTTON_RIGHT_THUMB;
    }
    private static final int GAMEPAD_AXIS_LEFT_X = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_LEFT_X = 0
     * }
     */
    public static int GAMEPAD_AXIS_LEFT_X() {
        return GAMEPAD_AXIS_LEFT_X;
    }
    private static final int GAMEPAD_AXIS_LEFT_Y = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_LEFT_Y = 1
     * }
     */
    public static int GAMEPAD_AXIS_LEFT_Y() {
        return GAMEPAD_AXIS_LEFT_Y;
    }
    private static final int GAMEPAD_AXIS_RIGHT_X = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_RIGHT_X = 2
     * }
     */
    public static int GAMEPAD_AXIS_RIGHT_X() {
        return GAMEPAD_AXIS_RIGHT_X;
    }
    private static final int GAMEPAD_AXIS_RIGHT_Y = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_RIGHT_Y = 3
     * }
     */
    public static int GAMEPAD_AXIS_RIGHT_Y() {
        return GAMEPAD_AXIS_RIGHT_Y;
    }
    private static final int GAMEPAD_AXIS_LEFT_TRIGGER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_LEFT_TRIGGER = 4
     * }
     */
    public static int GAMEPAD_AXIS_LEFT_TRIGGER() {
        return GAMEPAD_AXIS_LEFT_TRIGGER;
    }
    private static final int GAMEPAD_AXIS_RIGHT_TRIGGER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GAMEPAD_AXIS_RIGHT_TRIGGER = 5
     * }
     */
    public static int GAMEPAD_AXIS_RIGHT_TRIGGER() {
        return GAMEPAD_AXIS_RIGHT_TRIGGER;
    }
    private static final int MATERIAL_MAP_ALBEDO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_ALBEDO = 0
     * }
     */
    public static int MATERIAL_MAP_ALBEDO() {
        return MATERIAL_MAP_ALBEDO;
    }
    private static final int MATERIAL_MAP_METALNESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_METALNESS = 1
     * }
     */
    public static int MATERIAL_MAP_METALNESS() {
        return MATERIAL_MAP_METALNESS;
    }
    private static final int MATERIAL_MAP_NORMAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_NORMAL = 2
     * }
     */
    public static int MATERIAL_MAP_NORMAL() {
        return MATERIAL_MAP_NORMAL;
    }
    private static final int MATERIAL_MAP_ROUGHNESS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_ROUGHNESS = 3
     * }
     */
    public static int MATERIAL_MAP_ROUGHNESS() {
        return MATERIAL_MAP_ROUGHNESS;
    }
    private static final int MATERIAL_MAP_OCCLUSION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_OCCLUSION = 4
     * }
     */
    public static int MATERIAL_MAP_OCCLUSION() {
        return MATERIAL_MAP_OCCLUSION;
    }
    private static final int MATERIAL_MAP_EMISSION = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_EMISSION = 5
     * }
     */
    public static int MATERIAL_MAP_EMISSION() {
        return MATERIAL_MAP_EMISSION;
    }
    private static final int MATERIAL_MAP_HEIGHT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_HEIGHT = 6
     * }
     */
    public static int MATERIAL_MAP_HEIGHT() {
        return MATERIAL_MAP_HEIGHT;
    }
    private static final int MATERIAL_MAP_CUBEMAP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_CUBEMAP = 7
     * }
     */
    public static int MATERIAL_MAP_CUBEMAP() {
        return MATERIAL_MAP_CUBEMAP;
    }
    private static final int MATERIAL_MAP_IRRADIANCE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_IRRADIANCE = 8
     * }
     */
    public static int MATERIAL_MAP_IRRADIANCE() {
        return MATERIAL_MAP_IRRADIANCE;
    }
    private static final int MATERIAL_MAP_PREFILTER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_PREFILTER = 9
     * }
     */
    public static int MATERIAL_MAP_PREFILTER() {
        return MATERIAL_MAP_PREFILTER;
    }
    private static final int MATERIAL_MAP_BRDF = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MATERIAL_MAP_BRDF = 10
     * }
     */
    public static int MATERIAL_MAP_BRDF() {
        return MATERIAL_MAP_BRDF;
    }
    private static final int SHADER_LOC_VERTEX_POSITION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_POSITION = 0
     * }
     */
    public static int SHADER_LOC_VERTEX_POSITION() {
        return SHADER_LOC_VERTEX_POSITION;
    }
    private static final int SHADER_LOC_VERTEX_TEXCOORD01 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_TEXCOORD01 = 1
     * }
     */
    public static int SHADER_LOC_VERTEX_TEXCOORD01() {
        return SHADER_LOC_VERTEX_TEXCOORD01;
    }
    private static final int SHADER_LOC_VERTEX_TEXCOORD02 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_TEXCOORD02 = 2
     * }
     */
    public static int SHADER_LOC_VERTEX_TEXCOORD02() {
        return SHADER_LOC_VERTEX_TEXCOORD02;
    }
    private static final int SHADER_LOC_VERTEX_NORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_NORMAL = 3
     * }
     */
    public static int SHADER_LOC_VERTEX_NORMAL() {
        return SHADER_LOC_VERTEX_NORMAL;
    }
    private static final int SHADER_LOC_VERTEX_TANGENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_TANGENT = 4
     * }
     */
    public static int SHADER_LOC_VERTEX_TANGENT() {
        return SHADER_LOC_VERTEX_TANGENT;
    }
    private static final int SHADER_LOC_VERTEX_COLOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VERTEX_COLOR = 5
     * }
     */
    public static int SHADER_LOC_VERTEX_COLOR() {
        return SHADER_LOC_VERTEX_COLOR;
    }
    private static final int SHADER_LOC_MATRIX_MVP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MATRIX_MVP = 6
     * }
     */
    public static int SHADER_LOC_MATRIX_MVP() {
        return SHADER_LOC_MATRIX_MVP;
    }
    private static final int SHADER_LOC_MATRIX_VIEW = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MATRIX_VIEW = 7
     * }
     */
    public static int SHADER_LOC_MATRIX_VIEW() {
        return SHADER_LOC_MATRIX_VIEW;
    }
    private static final int SHADER_LOC_MATRIX_PROJECTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MATRIX_PROJECTION = 8
     * }
     */
    public static int SHADER_LOC_MATRIX_PROJECTION() {
        return SHADER_LOC_MATRIX_PROJECTION;
    }
    private static final int SHADER_LOC_MATRIX_MODEL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MATRIX_MODEL = 9
     * }
     */
    public static int SHADER_LOC_MATRIX_MODEL() {
        return SHADER_LOC_MATRIX_MODEL;
    }
    private static final int SHADER_LOC_MATRIX_NORMAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MATRIX_NORMAL = 10
     * }
     */
    public static int SHADER_LOC_MATRIX_NORMAL() {
        return SHADER_LOC_MATRIX_NORMAL;
    }
    private static final int SHADER_LOC_VECTOR_VIEW = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_VECTOR_VIEW = 11
     * }
     */
    public static int SHADER_LOC_VECTOR_VIEW() {
        return SHADER_LOC_VECTOR_VIEW;
    }
    private static final int SHADER_LOC_COLOR_DIFFUSE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_COLOR_DIFFUSE = 12
     * }
     */
    public static int SHADER_LOC_COLOR_DIFFUSE() {
        return SHADER_LOC_COLOR_DIFFUSE;
    }
    private static final int SHADER_LOC_COLOR_SPECULAR = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_COLOR_SPECULAR = 13
     * }
     */
    public static int SHADER_LOC_COLOR_SPECULAR() {
        return SHADER_LOC_COLOR_SPECULAR;
    }
    private static final int SHADER_LOC_COLOR_AMBIENT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_COLOR_AMBIENT = 14
     * }
     */
    public static int SHADER_LOC_COLOR_AMBIENT() {
        return SHADER_LOC_COLOR_AMBIENT;
    }
    private static final int SHADER_LOC_MAP_ALBEDO = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_ALBEDO = 15
     * }
     */
    public static int SHADER_LOC_MAP_ALBEDO() {
        return SHADER_LOC_MAP_ALBEDO;
    }
    private static final int SHADER_LOC_MAP_METALNESS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_METALNESS = 16
     * }
     */
    public static int SHADER_LOC_MAP_METALNESS() {
        return SHADER_LOC_MAP_METALNESS;
    }
    private static final int SHADER_LOC_MAP_NORMAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_NORMAL = 17
     * }
     */
    public static int SHADER_LOC_MAP_NORMAL() {
        return SHADER_LOC_MAP_NORMAL;
    }
    private static final int SHADER_LOC_MAP_ROUGHNESS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_ROUGHNESS = 18
     * }
     */
    public static int SHADER_LOC_MAP_ROUGHNESS() {
        return SHADER_LOC_MAP_ROUGHNESS;
    }
    private static final int SHADER_LOC_MAP_OCCLUSION = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_OCCLUSION = 19
     * }
     */
    public static int SHADER_LOC_MAP_OCCLUSION() {
        return SHADER_LOC_MAP_OCCLUSION;
    }
    private static final int SHADER_LOC_MAP_EMISSION = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_EMISSION = 20
     * }
     */
    public static int SHADER_LOC_MAP_EMISSION() {
        return SHADER_LOC_MAP_EMISSION;
    }
    private static final int SHADER_LOC_MAP_HEIGHT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_HEIGHT = 21
     * }
     */
    public static int SHADER_LOC_MAP_HEIGHT() {
        return SHADER_LOC_MAP_HEIGHT;
    }
    private static final int SHADER_LOC_MAP_CUBEMAP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_CUBEMAP = 22
     * }
     */
    public static int SHADER_LOC_MAP_CUBEMAP() {
        return SHADER_LOC_MAP_CUBEMAP;
    }
    private static final int SHADER_LOC_MAP_IRRADIANCE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_IRRADIANCE = 23
     * }
     */
    public static int SHADER_LOC_MAP_IRRADIANCE() {
        return SHADER_LOC_MAP_IRRADIANCE;
    }
    private static final int SHADER_LOC_MAP_PREFILTER = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_PREFILTER = 24
     * }
     */
    public static int SHADER_LOC_MAP_PREFILTER() {
        return SHADER_LOC_MAP_PREFILTER;
    }
    private static final int SHADER_LOC_MAP_BRDF = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_LOC_MAP_BRDF = 25
     * }
     */
    public static int SHADER_LOC_MAP_BRDF() {
        return SHADER_LOC_MAP_BRDF;
    }
    private static final int SHADER_UNIFORM_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_FLOAT = 0
     * }
     */
    public static int SHADER_UNIFORM_FLOAT() {
        return SHADER_UNIFORM_FLOAT;
    }
    private static final int SHADER_UNIFORM_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_VEC2 = 1
     * }
     */
    public static int SHADER_UNIFORM_VEC2() {
        return SHADER_UNIFORM_VEC2;
    }
    private static final int SHADER_UNIFORM_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_VEC3 = 2
     * }
     */
    public static int SHADER_UNIFORM_VEC3() {
        return SHADER_UNIFORM_VEC3;
    }
    private static final int SHADER_UNIFORM_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_VEC4 = 3
     * }
     */
    public static int SHADER_UNIFORM_VEC4() {
        return SHADER_UNIFORM_VEC4;
    }
    private static final int SHADER_UNIFORM_INT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_INT = 4
     * }
     */
    public static int SHADER_UNIFORM_INT() {
        return SHADER_UNIFORM_INT;
    }
    private static final int SHADER_UNIFORM_IVEC2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_IVEC2 = 5
     * }
     */
    public static int SHADER_UNIFORM_IVEC2() {
        return SHADER_UNIFORM_IVEC2;
    }
    private static final int SHADER_UNIFORM_IVEC3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_IVEC3 = 6
     * }
     */
    public static int SHADER_UNIFORM_IVEC3() {
        return SHADER_UNIFORM_IVEC3;
    }
    private static final int SHADER_UNIFORM_IVEC4 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_IVEC4 = 7
     * }
     */
    public static int SHADER_UNIFORM_IVEC4() {
        return SHADER_UNIFORM_IVEC4;
    }
    private static final int SHADER_UNIFORM_SAMPLER2D = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_UNIFORM_SAMPLER2D = 8
     * }
     */
    public static int SHADER_UNIFORM_SAMPLER2D() {
        return SHADER_UNIFORM_SAMPLER2D;
    }
    private static final int SHADER_ATTRIB_FLOAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_ATTRIB_FLOAT = 0
     * }
     */
    public static int SHADER_ATTRIB_FLOAT() {
        return SHADER_ATTRIB_FLOAT;
    }
    private static final int SHADER_ATTRIB_VEC2 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_ATTRIB_VEC2 = 1
     * }
     */
    public static int SHADER_ATTRIB_VEC2() {
        return SHADER_ATTRIB_VEC2;
    }
    private static final int SHADER_ATTRIB_VEC3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_ATTRIB_VEC3 = 2
     * }
     */
    public static int SHADER_ATTRIB_VEC3() {
        return SHADER_ATTRIB_VEC3;
    }
    private static final int SHADER_ATTRIB_VEC4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHADER_ATTRIB_VEC4 = 3
     * }
     */
    public static int SHADER_ATTRIB_VEC4() {
        return SHADER_ATTRIB_VEC4;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_GRAYSCALE() {
        return PIXELFORMAT_UNCOMPRESSED_GRAYSCALE;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA() {
        return PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R5G6B5 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R5G6B5() {
        return PIXELFORMAT_UNCOMPRESSED_R5G6B5;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R8G8B8 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R8G8B8() {
        return PIXELFORMAT_UNCOMPRESSED_R8G8B8;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R5G5B5A1() {
        return PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R4G4B4A4() {
        return PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R8G8B8A8() {
        return PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R32 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R32 = 8
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R32() {
        return PIXELFORMAT_UNCOMPRESSED_R32;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R32G32B32 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R32G32B32() {
        return PIXELFORMAT_UNCOMPRESSED_R32G32B32;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R32G32B32A32() {
        return PIXELFORMAT_UNCOMPRESSED_R32G32B32A32;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R16 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R16 = 11
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R16() {
        return PIXELFORMAT_UNCOMPRESSED_R16;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R16G16B16 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R16G16B16() {
        return PIXELFORMAT_UNCOMPRESSED_R16G16B16;
    }
    private static final int PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13
     * }
     */
    public static int PIXELFORMAT_UNCOMPRESSED_R16G16B16A16() {
        return PIXELFORMAT_UNCOMPRESSED_R16G16B16A16;
    }
    private static final int PIXELFORMAT_COMPRESSED_DXT1_RGB = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_DXT1_RGB = 14
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_DXT1_RGB() {
        return PIXELFORMAT_COMPRESSED_DXT1_RGB;
    }
    private static final int PIXELFORMAT_COMPRESSED_DXT1_RGBA = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_DXT1_RGBA() {
        return PIXELFORMAT_COMPRESSED_DXT1_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_DXT3_RGBA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_DXT3_RGBA() {
        return PIXELFORMAT_COMPRESSED_DXT3_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_DXT5_RGBA = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_DXT5_RGBA() {
        return PIXELFORMAT_COMPRESSED_DXT5_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_ETC1_RGB = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_ETC1_RGB = 18
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_ETC1_RGB() {
        return PIXELFORMAT_COMPRESSED_ETC1_RGB;
    }
    private static final int PIXELFORMAT_COMPRESSED_ETC2_RGB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_ETC2_RGB = 19
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_ETC2_RGB() {
        return PIXELFORMAT_COMPRESSED_ETC2_RGB;
    }
    private static final int PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA() {
        return PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_PVRT_RGB = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_PVRT_RGB = 21
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_PVRT_RGB() {
        return PIXELFORMAT_COMPRESSED_PVRT_RGB;
    }
    private static final int PIXELFORMAT_COMPRESSED_PVRT_RGBA = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_PVRT_RGBA() {
        return PIXELFORMAT_COMPRESSED_PVRT_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA() {
        return PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA;
    }
    private static final int PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24
     * }
     */
    public static int PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA() {
        return PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA;
    }
    private static final int TEXTURE_FILTER_POINT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_POINT = 0
     * }
     */
    public static int TEXTURE_FILTER_POINT() {
        return TEXTURE_FILTER_POINT;
    }
    private static final int TEXTURE_FILTER_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_BILINEAR = 1
     * }
     */
    public static int TEXTURE_FILTER_BILINEAR() {
        return TEXTURE_FILTER_BILINEAR;
    }
    private static final int TEXTURE_FILTER_TRILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_TRILINEAR = 2
     * }
     */
    public static int TEXTURE_FILTER_TRILINEAR() {
        return TEXTURE_FILTER_TRILINEAR;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_4X = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_4X = 3
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_4X() {
        return TEXTURE_FILTER_ANISOTROPIC_4X;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_8X = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_8X = 4
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_8X() {
        return TEXTURE_FILTER_ANISOTROPIC_8X;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_16X = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_16X = 5
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_16X() {
        return TEXTURE_FILTER_ANISOTROPIC_16X;
    }
    private static final int TEXTURE_WRAP_REPEAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_WRAP_REPEAT = 0
     * }
     */
    public static int TEXTURE_WRAP_REPEAT() {
        return TEXTURE_WRAP_REPEAT;
    }
    private static final int TEXTURE_WRAP_CLAMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_WRAP_CLAMP = 1
     * }
     */
    public static int TEXTURE_WRAP_CLAMP() {
        return TEXTURE_WRAP_CLAMP;
    }
    private static final int TEXTURE_WRAP_MIRROR_REPEAT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_WRAP_MIRROR_REPEAT = 2
     * }
     */
    public static int TEXTURE_WRAP_MIRROR_REPEAT() {
        return TEXTURE_WRAP_MIRROR_REPEAT;
    }
    private static final int TEXTURE_WRAP_MIRROR_CLAMP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_WRAP_MIRROR_CLAMP = 3
     * }
     */
    public static int TEXTURE_WRAP_MIRROR_CLAMP() {
        return TEXTURE_WRAP_MIRROR_CLAMP;
    }
    private static final int CUBEMAP_LAYOUT_AUTO_DETECT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_AUTO_DETECT = 0
     * }
     */
    public static int CUBEMAP_LAYOUT_AUTO_DETECT() {
        return CUBEMAP_LAYOUT_AUTO_DETECT;
    }
    private static final int CUBEMAP_LAYOUT_LINE_VERTICAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_LINE_VERTICAL = 1
     * }
     */
    public static int CUBEMAP_LAYOUT_LINE_VERTICAL() {
        return CUBEMAP_LAYOUT_LINE_VERTICAL;
    }
    private static final int CUBEMAP_LAYOUT_LINE_HORIZONTAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2
     * }
     */
    public static int CUBEMAP_LAYOUT_LINE_HORIZONTAL() {
        return CUBEMAP_LAYOUT_LINE_HORIZONTAL;
    }
    private static final int CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3
     * }
     */
    public static int CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR() {
        return CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR;
    }
    private static final int CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4
     * }
     */
    public static int CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE() {
        return CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE;
    }
    private static final int CUBEMAP_LAYOUT_PANORAMA = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CUBEMAP_LAYOUT_PANORAMA = 5
     * }
     */
    public static int CUBEMAP_LAYOUT_PANORAMA() {
        return CUBEMAP_LAYOUT_PANORAMA;
    }
    private static final int FONT_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FONT_DEFAULT = 0
     * }
     */
    public static int FONT_DEFAULT() {
        return FONT_DEFAULT;
    }
    private static final int FONT_BITMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FONT_BITMAP = 1
     * }
     */
    public static int FONT_BITMAP() {
        return FONT_BITMAP;
    }
    private static final int FONT_SDF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FONT_SDF = 2
     * }
     */
    public static int FONT_SDF() {
        return FONT_SDF;
    }
    private static final int BLEND_ALPHA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_ALPHA = 0
     * }
     */
    public static int BLEND_ALPHA() {
        return BLEND_ALPHA;
    }
    private static final int BLEND_ADDITIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_ADDITIVE = 1
     * }
     */
    public static int BLEND_ADDITIVE() {
        return BLEND_ADDITIVE;
    }
    private static final int BLEND_MULTIPLIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_MULTIPLIED = 2
     * }
     */
    public static int BLEND_MULTIPLIED() {
        return BLEND_MULTIPLIED;
    }
    private static final int BLEND_ADD_COLORS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_ADD_COLORS = 3
     * }
     */
    public static int BLEND_ADD_COLORS() {
        return BLEND_ADD_COLORS;
    }
    private static final int BLEND_SUBTRACT_COLORS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_SUBTRACT_COLORS = 4
     * }
     */
    public static int BLEND_SUBTRACT_COLORS() {
        return BLEND_SUBTRACT_COLORS;
    }
    private static final int BLEND_ALPHA_PREMULTIPLY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_ALPHA_PREMULTIPLY = 5
     * }
     */
    public static int BLEND_ALPHA_PREMULTIPLY() {
        return BLEND_ALPHA_PREMULTIPLY;
    }
    private static final int BLEND_CUSTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_CUSTOM = 6
     * }
     */
    public static int BLEND_CUSTOM() {
        return BLEND_CUSTOM;
    }
    private static final int BLEND_CUSTOM_SEPARATE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BLEND_CUSTOM_SEPARATE = 7
     * }
     */
    public static int BLEND_CUSTOM_SEPARATE() {
        return BLEND_CUSTOM_SEPARATE;
    }
    private static final int GESTURE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_NONE = 0
     * }
     */
    public static int GESTURE_NONE() {
        return GESTURE_NONE;
    }
    private static final int GESTURE_TAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_TAP = 1
     * }
     */
    public static int GESTURE_TAP() {
        return GESTURE_TAP;
    }
    private static final int GESTURE_DOUBLETAP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_DOUBLETAP = 2
     * }
     */
    public static int GESTURE_DOUBLETAP() {
        return GESTURE_DOUBLETAP;
    }
    private static final int GESTURE_HOLD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_HOLD = 4
     * }
     */
    public static int GESTURE_HOLD() {
        return GESTURE_HOLD;
    }
    private static final int GESTURE_DRAG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_DRAG = 8
     * }
     */
    public static int GESTURE_DRAG() {
        return GESTURE_DRAG;
    }
    private static final int GESTURE_SWIPE_RIGHT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_SWIPE_RIGHT = 16
     * }
     */
    public static int GESTURE_SWIPE_RIGHT() {
        return GESTURE_SWIPE_RIGHT;
    }
    private static final int GESTURE_SWIPE_LEFT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_SWIPE_LEFT = 32
     * }
     */
    public static int GESTURE_SWIPE_LEFT() {
        return GESTURE_SWIPE_LEFT;
    }
    private static final int GESTURE_SWIPE_UP = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_SWIPE_UP = 64
     * }
     */
    public static int GESTURE_SWIPE_UP() {
        return GESTURE_SWIPE_UP;
    }
    private static final int GESTURE_SWIPE_DOWN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_SWIPE_DOWN = 128
     * }
     */
    public static int GESTURE_SWIPE_DOWN() {
        return GESTURE_SWIPE_DOWN;
    }
    private static final int GESTURE_PINCH_IN = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_PINCH_IN = 256
     * }
     */
    public static int GESTURE_PINCH_IN() {
        return GESTURE_PINCH_IN;
    }
    private static final int GESTURE_PINCH_OUT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GESTURE_PINCH_OUT = 512
     * }
     */
    public static int GESTURE_PINCH_OUT() {
        return GESTURE_PINCH_OUT;
    }
    private static final int CAMERA_CUSTOM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_CUSTOM = 0
     * }
     */
    public static int CAMERA_CUSTOM() {
        return CAMERA_CUSTOM;
    }
    private static final int CAMERA_FREE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_FREE = 1
     * }
     */
    public static int CAMERA_FREE() {
        return CAMERA_FREE;
    }
    private static final int CAMERA_ORBITAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_ORBITAL = 2
     * }
     */
    public static int CAMERA_ORBITAL() {
        return CAMERA_ORBITAL;
    }
    private static final int CAMERA_FIRST_PERSON = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_FIRST_PERSON = 3
     * }
     */
    public static int CAMERA_FIRST_PERSON() {
        return CAMERA_FIRST_PERSON;
    }
    private static final int CAMERA_THIRD_PERSON = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_THIRD_PERSON = 4
     * }
     */
    public static int CAMERA_THIRD_PERSON() {
        return CAMERA_THIRD_PERSON;
    }
    private static final int CAMERA_PERSPECTIVE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_PERSPECTIVE = 0
     * }
     */
    public static int CAMERA_PERSPECTIVE() {
        return CAMERA_PERSPECTIVE;
    }
    private static final int CAMERA_ORTHOGRAPHIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_ORTHOGRAPHIC = 1
     * }
     */
    public static int CAMERA_ORTHOGRAPHIC() {
        return CAMERA_ORTHOGRAPHIC;
    }
    private static final int NPATCH_NINE_PATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NPATCH_NINE_PATCH = 0
     * }
     */
    public static int NPATCH_NINE_PATCH() {
        return NPATCH_NINE_PATCH;
    }
    private static final int NPATCH_THREE_PATCH_VERTICAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NPATCH_THREE_PATCH_VERTICAL = 1
     * }
     */
    public static int NPATCH_THREE_PATCH_VERTICAL() {
        return NPATCH_THREE_PATCH_VERTICAL;
    }
    private static final int NPATCH_THREE_PATCH_HORIZONTAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NPATCH_THREE_PATCH_HORIZONTAL = 2
     * }
     */
    public static int NPATCH_THREE_PATCH_HORIZONTAL() {
        return NPATCH_THREE_PATCH_HORIZONTAL;
    }

    private static class InitWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("InitWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static FunctionDescriptor InitWindow$descriptor() {
        return InitWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static MethodHandle InitWindow$handle() {
        return InitWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static MemorySegment InitWindow$address() {
        return InitWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static void InitWindow(int width, int height, MemorySegment title) {
        var mh$ = InitWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitWindow", width, height, title);
            }
            mh$.invokeExact(width, height, title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("CloseWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static FunctionDescriptor CloseWindow$descriptor() {
        return CloseWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static MethodHandle CloseWindow$handle() {
        return CloseWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static MemorySegment CloseWindow$address() {
        return CloseWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static void CloseWindow() {
        var mh$ = CloseWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowShouldClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("WindowShouldClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool WindowShouldClose()
     * }
     */
    public static FunctionDescriptor WindowShouldClose$descriptor() {
        return WindowShouldClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool WindowShouldClose()
     * }
     */
    public static MethodHandle WindowShouldClose$handle() {
        return WindowShouldClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool WindowShouldClose()
     * }
     */
    public static MemorySegment WindowShouldClose$address() {
        return WindowShouldClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool WindowShouldClose()
     * }
     */
    public static boolean WindowShouldClose() {
        var mh$ = WindowShouldClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowShouldClose");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowReady()
     * }
     */
    public static FunctionDescriptor IsWindowReady$descriptor() {
        return IsWindowReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowReady()
     * }
     */
    public static MethodHandle IsWindowReady$handle() {
        return IsWindowReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowReady()
     * }
     */
    public static MemorySegment IsWindowReady$address() {
        return IsWindowReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowReady()
     * }
     */
    public static boolean IsWindowReady() {
        var mh$ = IsWindowReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowReady");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowFullscreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowFullscreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowFullscreen()
     * }
     */
    public static FunctionDescriptor IsWindowFullscreen$descriptor() {
        return IsWindowFullscreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowFullscreen()
     * }
     */
    public static MethodHandle IsWindowFullscreen$handle() {
        return IsWindowFullscreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowFullscreen()
     * }
     */
    public static MemorySegment IsWindowFullscreen$address() {
        return IsWindowFullscreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowFullscreen()
     * }
     */
    public static boolean IsWindowFullscreen() {
        var mh$ = IsWindowFullscreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowFullscreen");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowHidden {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowHidden");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowHidden()
     * }
     */
    public static FunctionDescriptor IsWindowHidden$descriptor() {
        return IsWindowHidden.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowHidden()
     * }
     */
    public static MethodHandle IsWindowHidden$handle() {
        return IsWindowHidden.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowHidden()
     * }
     */
    public static MemorySegment IsWindowHidden$address() {
        return IsWindowHidden.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowHidden()
     * }
     */
    public static boolean IsWindowHidden() {
        var mh$ = IsWindowHidden.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowHidden");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowMinimized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowMinimized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowMinimized()
     * }
     */
    public static FunctionDescriptor IsWindowMinimized$descriptor() {
        return IsWindowMinimized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowMinimized()
     * }
     */
    public static MethodHandle IsWindowMinimized$handle() {
        return IsWindowMinimized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowMinimized()
     * }
     */
    public static MemorySegment IsWindowMinimized$address() {
        return IsWindowMinimized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowMinimized()
     * }
     */
    public static boolean IsWindowMinimized() {
        var mh$ = IsWindowMinimized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowMinimized");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowMaximized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowMaximized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowMaximized()
     * }
     */
    public static FunctionDescriptor IsWindowMaximized$descriptor() {
        return IsWindowMaximized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowMaximized()
     * }
     */
    public static MethodHandle IsWindowMaximized$handle() {
        return IsWindowMaximized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowMaximized()
     * }
     */
    public static MemorySegment IsWindowMaximized$address() {
        return IsWindowMaximized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowMaximized()
     * }
     */
    public static boolean IsWindowMaximized() {
        var mh$ = IsWindowMaximized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowMaximized");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowFocused {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowFocused");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowFocused()
     * }
     */
    public static FunctionDescriptor IsWindowFocused$descriptor() {
        return IsWindowFocused.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowFocused()
     * }
     */
    public static MethodHandle IsWindowFocused$handle() {
        return IsWindowFocused.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowFocused()
     * }
     */
    public static MemorySegment IsWindowFocused$address() {
        return IsWindowFocused.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowFocused()
     * }
     */
    public static boolean IsWindowFocused() {
        var mh$ = IsWindowFocused.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowFocused");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowResized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowResized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowResized()
     * }
     */
    public static FunctionDescriptor IsWindowResized$descriptor() {
        return IsWindowResized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowResized()
     * }
     */
    public static MethodHandle IsWindowResized$handle() {
        return IsWindowResized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowResized()
     * }
     */
    public static MemorySegment IsWindowResized$address() {
        return IsWindowResized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowResized()
     * }
     */
    public static boolean IsWindowResized() {
        var mh$ = IsWindowResized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowResized");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWindowState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWindowState(unsigned int flag)
     * }
     */
    public static FunctionDescriptor IsWindowState$descriptor() {
        return IsWindowState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWindowState(unsigned int flag)
     * }
     */
    public static MethodHandle IsWindowState$handle() {
        return IsWindowState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWindowState(unsigned int flag)
     * }
     */
    public static MemorySegment IsWindowState$address() {
        return IsWindowState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWindowState(unsigned int flag)
     * }
     */
    public static boolean IsWindowState(int flag) {
        var mh$ = IsWindowState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowState", flag);
            }
            return (boolean)mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowState(unsigned int flags)
     * }
     */
    public static FunctionDescriptor SetWindowState$descriptor() {
        return SetWindowState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowState(unsigned int flags)
     * }
     */
    public static MethodHandle SetWindowState$handle() {
        return SetWindowState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowState(unsigned int flags)
     * }
     */
    public static MemorySegment SetWindowState$address() {
        return SetWindowState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowState(unsigned int flags)
     * }
     */
    public static void SetWindowState(int flags) {
        var mh$ = SetWindowState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowState", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearWindowState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ClearWindowState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClearWindowState(unsigned int flags)
     * }
     */
    public static FunctionDescriptor ClearWindowState$descriptor() {
        return ClearWindowState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClearWindowState(unsigned int flags)
     * }
     */
    public static MethodHandle ClearWindowState$handle() {
        return ClearWindowState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ClearWindowState(unsigned int flags)
     * }
     */
    public static MemorySegment ClearWindowState$address() {
        return ClearWindowState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ClearWindowState(unsigned int flags)
     * }
     */
    public static void ClearWindowState(int flags) {
        var mh$ = ClearWindowState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearWindowState", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToggleFullscreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("ToggleFullscreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ToggleFullscreen()
     * }
     */
    public static FunctionDescriptor ToggleFullscreen$descriptor() {
        return ToggleFullscreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ToggleFullscreen()
     * }
     */
    public static MethodHandle ToggleFullscreen$handle() {
        return ToggleFullscreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ToggleFullscreen()
     * }
     */
    public static MemorySegment ToggleFullscreen$address() {
        return ToggleFullscreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ToggleFullscreen()
     * }
     */
    public static void ToggleFullscreen() {
        var mh$ = ToggleFullscreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToggleFullscreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToggleBorderlessWindowed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("ToggleBorderlessWindowed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ToggleBorderlessWindowed()
     * }
     */
    public static FunctionDescriptor ToggleBorderlessWindowed$descriptor() {
        return ToggleBorderlessWindowed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ToggleBorderlessWindowed()
     * }
     */
    public static MethodHandle ToggleBorderlessWindowed$handle() {
        return ToggleBorderlessWindowed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ToggleBorderlessWindowed()
     * }
     */
    public static MemorySegment ToggleBorderlessWindowed$address() {
        return ToggleBorderlessWindowed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ToggleBorderlessWindowed()
     * }
     */
    public static void ToggleBorderlessWindowed() {
        var mh$ = ToggleBorderlessWindowed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToggleBorderlessWindowed");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MaximizeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("MaximizeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MaximizeWindow()
     * }
     */
    public static FunctionDescriptor MaximizeWindow$descriptor() {
        return MaximizeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MaximizeWindow()
     * }
     */
    public static MethodHandle MaximizeWindow$handle() {
        return MaximizeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MaximizeWindow()
     * }
     */
    public static MemorySegment MaximizeWindow$address() {
        return MaximizeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MaximizeWindow()
     * }
     */
    public static void MaximizeWindow() {
        var mh$ = MaximizeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MaximizeWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MinimizeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("MinimizeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MinimizeWindow()
     * }
     */
    public static FunctionDescriptor MinimizeWindow$descriptor() {
        return MinimizeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MinimizeWindow()
     * }
     */
    public static MethodHandle MinimizeWindow$handle() {
        return MinimizeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MinimizeWindow()
     * }
     */
    public static MemorySegment MinimizeWindow$address() {
        return MinimizeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MinimizeWindow()
     * }
     */
    public static void MinimizeWindow() {
        var mh$ = MinimizeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MinimizeWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("RestoreWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RestoreWindow()
     * }
     */
    public static FunctionDescriptor RestoreWindow$descriptor() {
        return RestoreWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RestoreWindow()
     * }
     */
    public static MethodHandle RestoreWindow$handle() {
        return RestoreWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RestoreWindow()
     * }
     */
    public static MemorySegment RestoreWindow$address() {
        return RestoreWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RestoreWindow()
     * }
     */
    public static void RestoreWindow() {
        var mh$ = RestoreWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowIcon(Image image)
     * }
     */
    public static FunctionDescriptor SetWindowIcon$descriptor() {
        return SetWindowIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowIcon(Image image)
     * }
     */
    public static MethodHandle SetWindowIcon$handle() {
        return SetWindowIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowIcon(Image image)
     * }
     */
    public static MemorySegment SetWindowIcon$address() {
        return SetWindowIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowIcon(Image image)
     * }
     */
    public static void SetWindowIcon(MemorySegment image) {
        var mh$ = SetWindowIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowIcon", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowIcons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowIcons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowIcons(Image *images, int count)
     * }
     */
    public static FunctionDescriptor SetWindowIcons$descriptor() {
        return SetWindowIcons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowIcons(Image *images, int count)
     * }
     */
    public static MethodHandle SetWindowIcons$handle() {
        return SetWindowIcons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowIcons(Image *images, int count)
     * }
     */
    public static MemorySegment SetWindowIcons$address() {
        return SetWindowIcons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowIcons(Image *images, int count)
     * }
     */
    public static void SetWindowIcons(MemorySegment images, int count) {
        var mh$ = SetWindowIcons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowIcons", images, count);
            }
            mh$.invokeExact(images, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowTitle(const char *title)
     * }
     */
    public static FunctionDescriptor SetWindowTitle$descriptor() {
        return SetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowTitle(const char *title)
     * }
     */
    public static MethodHandle SetWindowTitle$handle() {
        return SetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowTitle(const char *title)
     * }
     */
    public static MemorySegment SetWindowTitle$address() {
        return SetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowTitle(const char *title)
     * }
     */
    public static void SetWindowTitle(MemorySegment title) {
        var mh$ = SetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowPosition(int x, int y)
     * }
     */
    public static FunctionDescriptor SetWindowPosition$descriptor() {
        return SetWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowPosition(int x, int y)
     * }
     */
    public static MethodHandle SetWindowPosition$handle() {
        return SetWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowPosition(int x, int y)
     * }
     */
    public static MemorySegment SetWindowPosition$address() {
        return SetWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowPosition(int x, int y)
     * }
     */
    public static void SetWindowPosition(int x, int y) {
        var mh$ = SetWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPosition", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowMonitor(int monitor)
     * }
     */
    public static FunctionDescriptor SetWindowMonitor$descriptor() {
        return SetWindowMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowMonitor(int monitor)
     * }
     */
    public static MethodHandle SetWindowMonitor$handle() {
        return SetWindowMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowMonitor(int monitor)
     * }
     */
    public static MemorySegment SetWindowMonitor$address() {
        return SetWindowMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowMonitor(int monitor)
     * }
     */
    public static void SetWindowMonitor(int monitor) {
        var mh$ = SetWindowMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowMonitor", monitor);
            }
            mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowMinSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowMinSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowMinSize(int width, int height)
     * }
     */
    public static FunctionDescriptor SetWindowMinSize$descriptor() {
        return SetWindowMinSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowMinSize(int width, int height)
     * }
     */
    public static MethodHandle SetWindowMinSize$handle() {
        return SetWindowMinSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowMinSize(int width, int height)
     * }
     */
    public static MemorySegment SetWindowMinSize$address() {
        return SetWindowMinSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowMinSize(int width, int height)
     * }
     */
    public static void SetWindowMinSize(int width, int height) {
        var mh$ = SetWindowMinSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowMinSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowMaxSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowMaxSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowMaxSize(int width, int height)
     * }
     */
    public static FunctionDescriptor SetWindowMaxSize$descriptor() {
        return SetWindowMaxSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowMaxSize(int width, int height)
     * }
     */
    public static MethodHandle SetWindowMaxSize$handle() {
        return SetWindowMaxSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowMaxSize(int width, int height)
     * }
     */
    public static MemorySegment SetWindowMaxSize$address() {
        return SetWindowMaxSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowMaxSize(int width, int height)
     * }
     */
    public static void SetWindowMaxSize(int width, int height) {
        var mh$ = SetWindowMaxSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowMaxSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowSize(int width, int height)
     * }
     */
    public static FunctionDescriptor SetWindowSize$descriptor() {
        return SetWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowSize(int width, int height)
     * }
     */
    public static MethodHandle SetWindowSize$handle() {
        return SetWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowSize(int width, int height)
     * }
     */
    public static MemorySegment SetWindowSize$address() {
        return SetWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowSize(int width, int height)
     * }
     */
    public static void SetWindowSize(int width, int height) {
        var mh$ = SetWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowOpacity(float opacity)
     * }
     */
    public static FunctionDescriptor SetWindowOpacity$descriptor() {
        return SetWindowOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowOpacity(float opacity)
     * }
     */
    public static MethodHandle SetWindowOpacity$handle() {
        return SetWindowOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowOpacity(float opacity)
     * }
     */
    public static MemorySegment SetWindowOpacity$address() {
        return SetWindowOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowOpacity(float opacity)
     * }
     */
    public static void SetWindowOpacity(float opacity) {
        var mh$ = SetWindowOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowOpacity", opacity);
            }
            mh$.invokeExact(opacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowFocused {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetWindowFocused");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetWindowFocused()
     * }
     */
    public static FunctionDescriptor SetWindowFocused$descriptor() {
        return SetWindowFocused.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetWindowFocused()
     * }
     */
    public static MethodHandle SetWindowFocused$handle() {
        return SetWindowFocused.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetWindowFocused()
     * }
     */
    public static MemorySegment SetWindowFocused$address() {
        return SetWindowFocused.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetWindowFocused()
     * }
     */
    public static void SetWindowFocused() {
        var mh$ = SetWindowFocused.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowFocused");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWindowHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *GetWindowHandle()
     * }
     */
    public static FunctionDescriptor GetWindowHandle$descriptor() {
        return GetWindowHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *GetWindowHandle()
     * }
     */
    public static MethodHandle GetWindowHandle$handle() {
        return GetWindowHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *GetWindowHandle()
     * }
     */
    public static MemorySegment GetWindowHandle$address() {
        return GetWindowHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *GetWindowHandle()
     * }
     */
    public static MemorySegment GetWindowHandle() {
        var mh$ = GetWindowHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowHandle");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetScreenWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static FunctionDescriptor GetScreenWidth$descriptor() {
        return GetScreenWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static MethodHandle GetScreenWidth$handle() {
        return GetScreenWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static MemorySegment GetScreenWidth$address() {
        return GetScreenWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static int GetScreenWidth() {
        var mh$ = GetScreenWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenWidth");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetScreenHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static FunctionDescriptor GetScreenHeight$descriptor() {
        return GetScreenHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static MethodHandle GetScreenHeight$handle() {
        return GetScreenHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static MemorySegment GetScreenHeight$address() {
        return GetScreenHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static int GetScreenHeight() {
        var mh$ = GetScreenHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenHeight");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRenderWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRenderWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRenderWidth()
     * }
     */
    public static FunctionDescriptor GetRenderWidth$descriptor() {
        return GetRenderWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRenderWidth()
     * }
     */
    public static MethodHandle GetRenderWidth$handle() {
        return GetRenderWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRenderWidth()
     * }
     */
    public static MemorySegment GetRenderWidth$address() {
        return GetRenderWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRenderWidth()
     * }
     */
    public static int GetRenderWidth() {
        var mh$ = GetRenderWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRenderWidth");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRenderHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRenderHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRenderHeight()
     * }
     */
    public static FunctionDescriptor GetRenderHeight$descriptor() {
        return GetRenderHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRenderHeight()
     * }
     */
    public static MethodHandle GetRenderHeight$handle() {
        return GetRenderHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRenderHeight()
     * }
     */
    public static MemorySegment GetRenderHeight$address() {
        return GetRenderHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRenderHeight()
     * }
     */
    public static int GetRenderHeight() {
        var mh$ = GetRenderHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRenderHeight");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * float GetCurrentAspect()
     * }
     */
    public static class GetCurrentAspect {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                raylib.C_FLOAT        );
        private static final MemorySegment ADDR = raylib.findOrThrow("GetCurrentAspect");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private GetCurrentAspect(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * float GetCurrentAspect()
         * }
         */
        public static GetCurrentAspect makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new GetCurrentAspect(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public float apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("GetCurrentAspect", x0);
                }
                return (float)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class GetMonitorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorCount()
     * }
     */
    public static FunctionDescriptor GetMonitorCount$descriptor() {
        return GetMonitorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorCount()
     * }
     */
    public static MethodHandle GetMonitorCount$handle() {
        return GetMonitorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorCount()
     * }
     */
    public static MemorySegment GetMonitorCount$address() {
        return GetMonitorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorCount()
     * }
     */
    public static int GetMonitorCount() {
        var mh$ = GetMonitorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorCount");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCurrentMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrentMonitor()
     * }
     */
    public static FunctionDescriptor GetCurrentMonitor$descriptor() {
        return GetCurrentMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrentMonitor()
     * }
     */
    public static MethodHandle GetCurrentMonitor$handle() {
        return GetCurrentMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrentMonitor()
     * }
     */
    public static MemorySegment GetCurrentMonitor$address() {
        return GetCurrentMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrentMonitor()
     * }
     */
    public static int GetCurrentMonitor() {
        var mh$ = GetCurrentMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentMonitor");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMonitorPosition(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorPosition$descriptor() {
        return GetMonitorPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMonitorPosition(int monitor)
     * }
     */
    public static MethodHandle GetMonitorPosition$handle() {
        return GetMonitorPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMonitorPosition(int monitor)
     * }
     */
    public static MemorySegment GetMonitorPosition$address() {
        return GetMonitorPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMonitorPosition(int monitor)
     * }
     */
    public static MemorySegment GetMonitorPosition(SegmentAllocator allocator, int monitor) {
        var mh$ = GetMonitorPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorPosition", allocator, monitor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorWidth(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorWidth$descriptor() {
        return GetMonitorWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorWidth(int monitor)
     * }
     */
    public static MethodHandle GetMonitorWidth$handle() {
        return GetMonitorWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorWidth(int monitor)
     * }
     */
    public static MemorySegment GetMonitorWidth$address() {
        return GetMonitorWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorWidth(int monitor)
     * }
     */
    public static int GetMonitorWidth(int monitor) {
        var mh$ = GetMonitorWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorWidth", monitor);
            }
            return (int)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorHeight(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorHeight$descriptor() {
        return GetMonitorHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorHeight(int monitor)
     * }
     */
    public static MethodHandle GetMonitorHeight$handle() {
        return GetMonitorHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorHeight(int monitor)
     * }
     */
    public static MemorySegment GetMonitorHeight$address() {
        return GetMonitorHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorHeight(int monitor)
     * }
     */
    public static int GetMonitorHeight(int monitor) {
        var mh$ = GetMonitorHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorHeight", monitor);
            }
            return (int)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorPhysicalWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorPhysicalWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalWidth(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorPhysicalWidth$descriptor() {
        return GetMonitorPhysicalWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalWidth(int monitor)
     * }
     */
    public static MethodHandle GetMonitorPhysicalWidth$handle() {
        return GetMonitorPhysicalWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalWidth(int monitor)
     * }
     */
    public static MemorySegment GetMonitorPhysicalWidth$address() {
        return GetMonitorPhysicalWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorPhysicalWidth(int monitor)
     * }
     */
    public static int GetMonitorPhysicalWidth(int monitor) {
        var mh$ = GetMonitorPhysicalWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorPhysicalWidth", monitor);
            }
            return (int)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorPhysicalHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorPhysicalHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalHeight(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorPhysicalHeight$descriptor() {
        return GetMonitorPhysicalHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalHeight(int monitor)
     * }
     */
    public static MethodHandle GetMonitorPhysicalHeight$handle() {
        return GetMonitorPhysicalHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorPhysicalHeight(int monitor)
     * }
     */
    public static MemorySegment GetMonitorPhysicalHeight$address() {
        return GetMonitorPhysicalHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorPhysicalHeight(int monitor)
     * }
     */
    public static int GetMonitorPhysicalHeight(int monitor) {
        var mh$ = GetMonitorPhysicalHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorPhysicalHeight", monitor);
            }
            return (int)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorRefreshRate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorRefreshRate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMonitorRefreshRate(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorRefreshRate$descriptor() {
        return GetMonitorRefreshRate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMonitorRefreshRate(int monitor)
     * }
     */
    public static MethodHandle GetMonitorRefreshRate$handle() {
        return GetMonitorRefreshRate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMonitorRefreshRate(int monitor)
     * }
     */
    public static MemorySegment GetMonitorRefreshRate$address() {
        return GetMonitorRefreshRate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMonitorRefreshRate(int monitor)
     * }
     */
    public static int GetMonitorRefreshRate(int monitor) {
        var mh$ = GetMonitorRefreshRate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorRefreshRate", monitor);
            }
            return (int)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetWindowPosition()
     * }
     */
    public static FunctionDescriptor GetWindowPosition$descriptor() {
        return GetWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetWindowPosition()
     * }
     */
    public static MethodHandle GetWindowPosition$handle() {
        return GetWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetWindowPosition()
     * }
     */
    public static MemorySegment GetWindowPosition$address() {
        return GetWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetWindowPosition()
     * }
     */
    public static MemorySegment GetWindowPosition(SegmentAllocator allocator) {
        var mh$ = GetWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowPosition", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowScaleDPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWindowScaleDPI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetWindowScaleDPI()
     * }
     */
    public static FunctionDescriptor GetWindowScaleDPI$descriptor() {
        return GetWindowScaleDPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetWindowScaleDPI()
     * }
     */
    public static MethodHandle GetWindowScaleDPI$handle() {
        return GetWindowScaleDPI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetWindowScaleDPI()
     * }
     */
    public static MemorySegment GetWindowScaleDPI$address() {
        return GetWindowScaleDPI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetWindowScaleDPI()
     * }
     */
    public static MemorySegment GetWindowScaleDPI(SegmentAllocator allocator) {
        var mh$ = GetWindowScaleDPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowScaleDPI", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMonitorName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetMonitorName(int monitor)
     * }
     */
    public static FunctionDescriptor GetMonitorName$descriptor() {
        return GetMonitorName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetMonitorName(int monitor)
     * }
     */
    public static MethodHandle GetMonitorName$handle() {
        return GetMonitorName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetMonitorName(int monitor)
     * }
     */
    public static MemorySegment GetMonitorName$address() {
        return GetMonitorName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetMonitorName(int monitor)
     * }
     */
    public static MemorySegment GetMonitorName(int monitor) {
        var mh$ = GetMonitorName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorName", monitor);
            }
            return (MemorySegment)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetClipboardText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetClipboardText(const char *text)
     * }
     */
    public static FunctionDescriptor SetClipboardText$descriptor() {
        return SetClipboardText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetClipboardText(const char *text)
     * }
     */
    public static MethodHandle SetClipboardText$handle() {
        return SetClipboardText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetClipboardText(const char *text)
     * }
     */
    public static MemorySegment SetClipboardText$address() {
        return SetClipboardText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetClipboardText(const char *text)
     * }
     */
    public static void SetClipboardText(MemorySegment text) {
        var mh$ = SetClipboardText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardText", text);
            }
            mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetClipboardText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetClipboardText()
     * }
     */
    public static FunctionDescriptor GetClipboardText$descriptor() {
        return GetClipboardText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetClipboardText()
     * }
     */
    public static MethodHandle GetClipboardText$handle() {
        return GetClipboardText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetClipboardText()
     * }
     */
    public static MemorySegment GetClipboardText$address() {
        return GetClipboardText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetClipboardText()
     * }
     */
    public static MemorySegment GetClipboardText() {
        var mh$ = GetClipboardText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardText");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableEventWaiting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EnableEventWaiting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnableEventWaiting()
     * }
     */
    public static FunctionDescriptor EnableEventWaiting$descriptor() {
        return EnableEventWaiting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnableEventWaiting()
     * }
     */
    public static MethodHandle EnableEventWaiting$handle() {
        return EnableEventWaiting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EnableEventWaiting()
     * }
     */
    public static MemorySegment EnableEventWaiting$address() {
        return EnableEventWaiting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EnableEventWaiting()
     * }
     */
    public static void EnableEventWaiting() {
        var mh$ = EnableEventWaiting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableEventWaiting");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableEventWaiting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("DisableEventWaiting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisableEventWaiting()
     * }
     */
    public static FunctionDescriptor DisableEventWaiting$descriptor() {
        return DisableEventWaiting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisableEventWaiting()
     * }
     */
    public static MethodHandle DisableEventWaiting$handle() {
        return DisableEventWaiting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisableEventWaiting()
     * }
     */
    public static MemorySegment DisableEventWaiting$address() {
        return DisableEventWaiting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisableEventWaiting()
     * }
     */
    public static void DisableEventWaiting() {
        var mh$ = DisableEventWaiting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableEventWaiting");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("ShowCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ShowCursor()
     * }
     */
    public static FunctionDescriptor ShowCursor$descriptor() {
        return ShowCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ShowCursor()
     * }
     */
    public static MethodHandle ShowCursor$handle() {
        return ShowCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ShowCursor()
     * }
     */
    public static MemorySegment ShowCursor$address() {
        return ShowCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ShowCursor()
     * }
     */
    public static void ShowCursor() {
        var mh$ = ShowCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowCursor");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HideCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("HideCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void HideCursor()
     * }
     */
    public static FunctionDescriptor HideCursor$descriptor() {
        return HideCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void HideCursor()
     * }
     */
    public static MethodHandle HideCursor$handle() {
        return HideCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void HideCursor()
     * }
     */
    public static MemorySegment HideCursor$address() {
        return HideCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void HideCursor()
     * }
     */
    public static void HideCursor() {
        var mh$ = HideCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HideCursor");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCursorHidden {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsCursorHidden");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsCursorHidden()
     * }
     */
    public static FunctionDescriptor IsCursorHidden$descriptor() {
        return IsCursorHidden.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsCursorHidden()
     * }
     */
    public static MethodHandle IsCursorHidden$handle() {
        return IsCursorHidden.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsCursorHidden()
     * }
     */
    public static MemorySegment IsCursorHidden$address() {
        return IsCursorHidden.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsCursorHidden()
     * }
     */
    public static boolean IsCursorHidden() {
        var mh$ = IsCursorHidden.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCursorHidden");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EnableCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnableCursor()
     * }
     */
    public static FunctionDescriptor EnableCursor$descriptor() {
        return EnableCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnableCursor()
     * }
     */
    public static MethodHandle EnableCursor$handle() {
        return EnableCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EnableCursor()
     * }
     */
    public static MemorySegment EnableCursor$address() {
        return EnableCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EnableCursor()
     * }
     */
    public static void EnableCursor() {
        var mh$ = EnableCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableCursor");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("DisableCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisableCursor()
     * }
     */
    public static FunctionDescriptor DisableCursor$descriptor() {
        return DisableCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisableCursor()
     * }
     */
    public static MethodHandle DisableCursor$handle() {
        return DisableCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisableCursor()
     * }
     */
    public static MemorySegment DisableCursor$address() {
        return DisableCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisableCursor()
     * }
     */
    public static void DisableCursor() {
        var mh$ = DisableCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableCursor");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCursorOnScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsCursorOnScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsCursorOnScreen()
     * }
     */
    public static FunctionDescriptor IsCursorOnScreen$descriptor() {
        return IsCursorOnScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsCursorOnScreen()
     * }
     */
    public static MethodHandle IsCursorOnScreen$handle() {
        return IsCursorOnScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsCursorOnScreen()
     * }
     */
    public static MemorySegment IsCursorOnScreen$address() {
        return IsCursorOnScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsCursorOnScreen()
     * }
     */
    public static boolean IsCursorOnScreen() {
        var mh$ = IsCursorOnScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCursorOnScreen");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearBackground {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ClearBackground");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static FunctionDescriptor ClearBackground$descriptor() {
        return ClearBackground.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static MethodHandle ClearBackground$handle() {
        return ClearBackground.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static MemorySegment ClearBackground$address() {
        return ClearBackground.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static void ClearBackground(MemorySegment color) {
        var mh$ = ClearBackground.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearBackground", color);
            }
            mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginDrawing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginDrawing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static FunctionDescriptor BeginDrawing$descriptor() {
        return BeginDrawing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static MethodHandle BeginDrawing$handle() {
        return BeginDrawing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static MemorySegment BeginDrawing$address() {
        return BeginDrawing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static void BeginDrawing() {
        var mh$ = BeginDrawing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginDrawing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDrawing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndDrawing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static FunctionDescriptor EndDrawing$descriptor() {
        return EndDrawing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static MethodHandle EndDrawing$handle() {
        return EndDrawing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static MemorySegment EndDrawing$address() {
        return EndDrawing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static void EndDrawing() {
        var mh$ = EndDrawing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDrawing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginMode2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera2D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginMode2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginMode2D(Camera2D camera)
     * }
     */
    public static FunctionDescriptor BeginMode2D$descriptor() {
        return BeginMode2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginMode2D(Camera2D camera)
     * }
     */
    public static MethodHandle BeginMode2D$handle() {
        return BeginMode2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginMode2D(Camera2D camera)
     * }
     */
    public static MemorySegment BeginMode2D$address() {
        return BeginMode2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginMode2D(Camera2D camera)
     * }
     */
    public static void BeginMode2D(MemorySegment camera) {
        var mh$ = BeginMode2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginMode2D", camera);
            }
            mh$.invokeExact(camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndMode2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndMode2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndMode2D()
     * }
     */
    public static FunctionDescriptor EndMode2D$descriptor() {
        return EndMode2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndMode2D()
     * }
     */
    public static MethodHandle EndMode2D$handle() {
        return EndMode2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndMode2D()
     * }
     */
    public static MemorySegment EndMode2D$address() {
        return EndMode2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndMode2D()
     * }
     */
    public static void EndMode2D() {
        var mh$ = EndMode2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndMode2D");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginMode3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginMode3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginMode3D(Camera3D camera)
     * }
     */
    public static FunctionDescriptor BeginMode3D$descriptor() {
        return BeginMode3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginMode3D(Camera3D camera)
     * }
     */
    public static MethodHandle BeginMode3D$handle() {
        return BeginMode3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginMode3D(Camera3D camera)
     * }
     */
    public static MemorySegment BeginMode3D$address() {
        return BeginMode3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginMode3D(Camera3D camera)
     * }
     */
    public static void BeginMode3D(MemorySegment camera) {
        var mh$ = BeginMode3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginMode3D", camera);
            }
            mh$.invokeExact(camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndMode3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndMode3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndMode3D()
     * }
     */
    public static FunctionDescriptor EndMode3D$descriptor() {
        return EndMode3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndMode3D()
     * }
     */
    public static MethodHandle EndMode3D$handle() {
        return EndMode3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndMode3D()
     * }
     */
    public static MemorySegment EndMode3D$address() {
        return EndMode3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndMode3D()
     * }
     */
    public static void EndMode3D() {
        var mh$ = EndMode3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndMode3D");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginTextureMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RenderTexture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginTextureMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginTextureMode(RenderTexture2D target)
     * }
     */
    public static FunctionDescriptor BeginTextureMode$descriptor() {
        return BeginTextureMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginTextureMode(RenderTexture2D target)
     * }
     */
    public static MethodHandle BeginTextureMode$handle() {
        return BeginTextureMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginTextureMode(RenderTexture2D target)
     * }
     */
    public static MemorySegment BeginTextureMode$address() {
        return BeginTextureMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginTextureMode(RenderTexture2D target)
     * }
     */
    public static void BeginTextureMode(MemorySegment target) {
        var mh$ = BeginTextureMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginTextureMode", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndTextureMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndTextureMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndTextureMode()
     * }
     */
    public static FunctionDescriptor EndTextureMode$descriptor() {
        return EndTextureMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndTextureMode()
     * }
     */
    public static MethodHandle EndTextureMode$handle() {
        return EndTextureMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndTextureMode()
     * }
     */
    public static MemorySegment EndTextureMode$address() {
        return EndTextureMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndTextureMode()
     * }
     */
    public static void EndTextureMode() {
        var mh$ = EndTextureMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndTextureMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginShaderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginShaderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginShaderMode(Shader shader)
     * }
     */
    public static FunctionDescriptor BeginShaderMode$descriptor() {
        return BeginShaderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginShaderMode(Shader shader)
     * }
     */
    public static MethodHandle BeginShaderMode$handle() {
        return BeginShaderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginShaderMode(Shader shader)
     * }
     */
    public static MemorySegment BeginShaderMode$address() {
        return BeginShaderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginShaderMode(Shader shader)
     * }
     */
    public static void BeginShaderMode(MemorySegment shader) {
        var mh$ = BeginShaderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginShaderMode", shader);
            }
            mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndShaderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndShaderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndShaderMode()
     * }
     */
    public static FunctionDescriptor EndShaderMode$descriptor() {
        return EndShaderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndShaderMode()
     * }
     */
    public static MethodHandle EndShaderMode$handle() {
        return EndShaderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndShaderMode()
     * }
     */
    public static MemorySegment EndShaderMode$address() {
        return EndShaderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndShaderMode()
     * }
     */
    public static void EndShaderMode() {
        var mh$ = EndShaderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndShaderMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginBlendMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginBlendMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginBlendMode(int mode)
     * }
     */
    public static FunctionDescriptor BeginBlendMode$descriptor() {
        return BeginBlendMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginBlendMode(int mode)
     * }
     */
    public static MethodHandle BeginBlendMode$handle() {
        return BeginBlendMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginBlendMode(int mode)
     * }
     */
    public static MemorySegment BeginBlendMode$address() {
        return BeginBlendMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginBlendMode(int mode)
     * }
     */
    public static void BeginBlendMode(int mode) {
        var mh$ = BeginBlendMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginBlendMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndBlendMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndBlendMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndBlendMode()
     * }
     */
    public static FunctionDescriptor EndBlendMode$descriptor() {
        return EndBlendMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndBlendMode()
     * }
     */
    public static MethodHandle EndBlendMode$handle() {
        return EndBlendMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndBlendMode()
     * }
     */
    public static MemorySegment EndBlendMode$address() {
        return EndBlendMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndBlendMode()
     * }
     */
    public static void EndBlendMode() {
        var mh$ = EndBlendMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndBlendMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginScissorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginScissorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor BeginScissorMode$descriptor() {
        return BeginScissorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle BeginScissorMode$handle() {
        return BeginScissorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment BeginScissorMode$address() {
        return BeginScissorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static void BeginScissorMode(int x, int y, int width, int height) {
        var mh$ = BeginScissorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginScissorMode", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndScissorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndScissorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static FunctionDescriptor EndScissorMode$descriptor() {
        return EndScissorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static MethodHandle EndScissorMode$handle() {
        return EndScissorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static MemorySegment EndScissorMode$address() {
        return EndScissorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static void EndScissorMode() {
        var mh$ = EndScissorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndScissorMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginVrStereoMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VrStereoConfig.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("BeginVrStereoMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginVrStereoMode(VrStereoConfig config)
     * }
     */
    public static FunctionDescriptor BeginVrStereoMode$descriptor() {
        return BeginVrStereoMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginVrStereoMode(VrStereoConfig config)
     * }
     */
    public static MethodHandle BeginVrStereoMode$handle() {
        return BeginVrStereoMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginVrStereoMode(VrStereoConfig config)
     * }
     */
    public static MemorySegment BeginVrStereoMode$address() {
        return BeginVrStereoMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginVrStereoMode(VrStereoConfig config)
     * }
     */
    public static void BeginVrStereoMode(MemorySegment config) {
        var mh$ = BeginVrStereoMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginVrStereoMode", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndVrStereoMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("EndVrStereoMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndVrStereoMode()
     * }
     */
    public static FunctionDescriptor EndVrStereoMode$descriptor() {
        return EndVrStereoMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndVrStereoMode()
     * }
     */
    public static MethodHandle EndVrStereoMode$handle() {
        return EndVrStereoMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndVrStereoMode()
     * }
     */
    public static MemorySegment EndVrStereoMode$address() {
        return EndVrStereoMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndVrStereoMode()
     * }
     */
    public static void EndVrStereoMode() {
        var mh$ = EndVrStereoMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndVrStereoMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadVrStereoConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            VrStereoConfig.layout(),
            VrDeviceInfo.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadVrStereoConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)
     * }
     */
    public static FunctionDescriptor LoadVrStereoConfig$descriptor() {
        return LoadVrStereoConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)
     * }
     */
    public static MethodHandle LoadVrStereoConfig$handle() {
        return LoadVrStereoConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)
     * }
     */
    public static MemorySegment LoadVrStereoConfig$address() {
        return LoadVrStereoConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)
     * }
     */
    public static MemorySegment LoadVrStereoConfig(SegmentAllocator allocator, MemorySegment device) {
        var mh$ = LoadVrStereoConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadVrStereoConfig", allocator, device);
            }
            return (MemorySegment)mh$.invokeExact(allocator, device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadVrStereoConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VrStereoConfig.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadVrStereoConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadVrStereoConfig(VrStereoConfig config)
     * }
     */
    public static FunctionDescriptor UnloadVrStereoConfig$descriptor() {
        return UnloadVrStereoConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadVrStereoConfig(VrStereoConfig config)
     * }
     */
    public static MethodHandle UnloadVrStereoConfig$handle() {
        return UnloadVrStereoConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadVrStereoConfig(VrStereoConfig config)
     * }
     */
    public static MemorySegment UnloadVrStereoConfig$address() {
        return UnloadVrStereoConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadVrStereoConfig(VrStereoConfig config)
     * }
     */
    public static void UnloadVrStereoConfig(MemorySegment config) {
        var mh$ = UnloadVrStereoConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadVrStereoConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Shader.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Shader LoadShader(const char *vsFileName, const char *fsFileName)
     * }
     */
    public static FunctionDescriptor LoadShader$descriptor() {
        return LoadShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Shader LoadShader(const char *vsFileName, const char *fsFileName)
     * }
     */
    public static MethodHandle LoadShader$handle() {
        return LoadShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Shader LoadShader(const char *vsFileName, const char *fsFileName)
     * }
     */
    public static MemorySegment LoadShader$address() {
        return LoadShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Shader LoadShader(const char *vsFileName, const char *fsFileName)
     * }
     */
    public static MemorySegment LoadShader(SegmentAllocator allocator, MemorySegment vsFileName, MemorySegment fsFileName) {
        var mh$ = LoadShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadShader", allocator, vsFileName, fsFileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vsFileName, fsFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadShaderFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Shader.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadShaderFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)
     * }
     */
    public static FunctionDescriptor LoadShaderFromMemory$descriptor() {
        return LoadShaderFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)
     * }
     */
    public static MethodHandle LoadShaderFromMemory$handle() {
        return LoadShaderFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)
     * }
     */
    public static MemorySegment LoadShaderFromMemory$address() {
        return LoadShaderFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)
     * }
     */
    public static MemorySegment LoadShaderFromMemory(SegmentAllocator allocator, MemorySegment vsCode, MemorySegment fsCode) {
        var mh$ = LoadShaderFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadShaderFromMemory", allocator, vsCode, fsCode);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vsCode, fsCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsShaderReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Shader.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsShaderReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsShaderReady(Shader shader)
     * }
     */
    public static FunctionDescriptor IsShaderReady$descriptor() {
        return IsShaderReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsShaderReady(Shader shader)
     * }
     */
    public static MethodHandle IsShaderReady$handle() {
        return IsShaderReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsShaderReady(Shader shader)
     * }
     */
    public static MemorySegment IsShaderReady$address() {
        return IsShaderReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsShaderReady(Shader shader)
     * }
     */
    public static boolean IsShaderReady(MemorySegment shader) {
        var mh$ = IsShaderReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsShaderReady", shader);
            }
            return (boolean)mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShaderLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Shader.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetShaderLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetShaderLocation(Shader shader, const char *uniformName)
     * }
     */
    public static FunctionDescriptor GetShaderLocation$descriptor() {
        return GetShaderLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetShaderLocation(Shader shader, const char *uniformName)
     * }
     */
    public static MethodHandle GetShaderLocation$handle() {
        return GetShaderLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetShaderLocation(Shader shader, const char *uniformName)
     * }
     */
    public static MemorySegment GetShaderLocation$address() {
        return GetShaderLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetShaderLocation(Shader shader, const char *uniformName)
     * }
     */
    public static int GetShaderLocation(MemorySegment shader, MemorySegment uniformName) {
        var mh$ = GetShaderLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShaderLocation", shader, uniformName);
            }
            return (int)mh$.invokeExact(shader, uniformName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShaderLocationAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Shader.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetShaderLocationAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetShaderLocationAttrib(Shader shader, const char *attribName)
     * }
     */
    public static FunctionDescriptor GetShaderLocationAttrib$descriptor() {
        return GetShaderLocationAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetShaderLocationAttrib(Shader shader, const char *attribName)
     * }
     */
    public static MethodHandle GetShaderLocationAttrib$handle() {
        return GetShaderLocationAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetShaderLocationAttrib(Shader shader, const char *attribName)
     * }
     */
    public static MemorySegment GetShaderLocationAttrib$address() {
        return GetShaderLocationAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetShaderLocationAttrib(Shader shader, const char *attribName)
     * }
     */
    public static int GetShaderLocationAttrib(MemorySegment shader, MemorySegment attribName) {
        var mh$ = GetShaderLocationAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShaderLocationAttrib", shader, attribName);
            }
            return (int)mh$.invokeExact(shader, attribName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetShaderValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout(),
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetShaderValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)
     * }
     */
    public static FunctionDescriptor SetShaderValue$descriptor() {
        return SetShaderValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)
     * }
     */
    public static MethodHandle SetShaderValue$handle() {
        return SetShaderValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)
     * }
     */
    public static MemorySegment SetShaderValue$address() {
        return SetShaderValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)
     * }
     */
    public static void SetShaderValue(MemorySegment shader, int locIndex, MemorySegment value, int uniformType) {
        var mh$ = SetShaderValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetShaderValue", shader, locIndex, value, uniformType);
            }
            mh$.invokeExact(shader, locIndex, value, uniformType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetShaderValueV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout(),
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetShaderValueV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static FunctionDescriptor SetShaderValueV$descriptor() {
        return SetShaderValueV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MethodHandle SetShaderValueV$handle() {
        return SetShaderValueV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static MemorySegment SetShaderValueV$address() {
        return SetShaderValueV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)
     * }
     */
    public static void SetShaderValueV(MemorySegment shader, int locIndex, MemorySegment value, int uniformType, int count) {
        var mh$ = SetShaderValueV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetShaderValueV", shader, locIndex, value, uniformType, count);
            }
            mh$.invokeExact(shader, locIndex, value, uniformType, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetShaderValueMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout(),
            raylib.C_INT,
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetShaderValueMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)
     * }
     */
    public static FunctionDescriptor SetShaderValueMatrix$descriptor() {
        return SetShaderValueMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)
     * }
     */
    public static MethodHandle SetShaderValueMatrix$handle() {
        return SetShaderValueMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)
     * }
     */
    public static MemorySegment SetShaderValueMatrix$address() {
        return SetShaderValueMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)
     * }
     */
    public static void SetShaderValueMatrix(MemorySegment shader, int locIndex, MemorySegment mat) {
        var mh$ = SetShaderValueMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetShaderValueMatrix", shader, locIndex, mat);
            }
            mh$.invokeExact(shader, locIndex, mat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetShaderValueTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout(),
            raylib.C_INT,
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetShaderValueTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)
     * }
     */
    public static FunctionDescriptor SetShaderValueTexture$descriptor() {
        return SetShaderValueTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)
     * }
     */
    public static MethodHandle SetShaderValueTexture$handle() {
        return SetShaderValueTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)
     * }
     */
    public static MemorySegment SetShaderValueTexture$address() {
        return SetShaderValueTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)
     * }
     */
    public static void SetShaderValueTexture(MemorySegment shader, int locIndex, MemorySegment texture) {
        var mh$ = SetShaderValueTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetShaderValueTexture", shader, locIndex, texture);
            }
            mh$.invokeExact(shader, locIndex, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Shader.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadShader(Shader shader)
     * }
     */
    public static FunctionDescriptor UnloadShader$descriptor() {
        return UnloadShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadShader(Shader shader)
     * }
     */
    public static MethodHandle UnloadShader$handle() {
        return UnloadShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadShader(Shader shader)
     * }
     */
    public static MemorySegment UnloadShader$address() {
        return UnloadShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadShader(Shader shader)
     * }
     */
    public static void UnloadShader(MemorySegment shader) {
        var mh$ = UnloadShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadShader", shader);
            }
            mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenToWorldRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            Camera3D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetScreenToWorldRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRay(Vector2 position, Camera camera)
     * }
     */
    public static FunctionDescriptor GetScreenToWorldRay$descriptor() {
        return GetScreenToWorldRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRay(Vector2 position, Camera camera)
     * }
     */
    public static MethodHandle GetScreenToWorldRay$handle() {
        return GetScreenToWorldRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRay(Vector2 position, Camera camera)
     * }
     */
    public static MemorySegment GetScreenToWorldRay$address() {
        return GetScreenToWorldRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray GetScreenToWorldRay(Vector2 position, Camera camera)
     * }
     */
    public static MemorySegment GetScreenToWorldRay(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = GetScreenToWorldRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenToWorldRay", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenToWorldRayEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            Camera3D.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetScreenToWorldRayEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height)
     * }
     */
    public static FunctionDescriptor GetScreenToWorldRayEx$descriptor() {
        return GetScreenToWorldRayEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height)
     * }
     */
    public static MethodHandle GetScreenToWorldRayEx$handle() {
        return GetScreenToWorldRayEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height)
     * }
     */
    public static MemorySegment GetScreenToWorldRayEx$address() {
        return GetScreenToWorldRayEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height)
     * }
     */
    public static MemorySegment GetScreenToWorldRayEx(SegmentAllocator allocator, MemorySegment position, MemorySegment camera, int width, int height) {
        var mh$ = GetScreenToWorldRayEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenToWorldRayEx", allocator, position, camera, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldToScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector3.layout(),
            Camera3D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWorldToScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen(Vector3 position, Camera camera)
     * }
     */
    public static FunctionDescriptor GetWorldToScreen$descriptor() {
        return GetWorldToScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen(Vector3 position, Camera camera)
     * }
     */
    public static MethodHandle GetWorldToScreen$handle() {
        return GetWorldToScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen(Vector3 position, Camera camera)
     * }
     */
    public static MemorySegment GetWorldToScreen$address() {
        return GetWorldToScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen(Vector3 position, Camera camera)
     * }
     */
    public static MemorySegment GetWorldToScreen(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = GetWorldToScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldToScreen", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldToScreenEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector3.layout(),
            Camera3D.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWorldToScreenEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)
     * }
     */
    public static FunctionDescriptor GetWorldToScreenEx$descriptor() {
        return GetWorldToScreenEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)
     * }
     */
    public static MethodHandle GetWorldToScreenEx$handle() {
        return GetWorldToScreenEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)
     * }
     */
    public static MemorySegment GetWorldToScreenEx$address() {
        return GetWorldToScreenEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)
     * }
     */
    public static MemorySegment GetWorldToScreenEx(SegmentAllocator allocator, MemorySegment position, MemorySegment camera, int width, int height) {
        var mh$ = GetWorldToScreenEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldToScreenEx", allocator, position, camera, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldToScreen2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Camera2D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWorldToScreen2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)
     * }
     */
    public static FunctionDescriptor GetWorldToScreen2D$descriptor() {
        return GetWorldToScreen2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MethodHandle GetWorldToScreen2D$handle() {
        return GetWorldToScreen2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MemorySegment GetWorldToScreen2D$address() {
        return GetWorldToScreen2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MemorySegment GetWorldToScreen2D(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = GetWorldToScreen2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldToScreen2D", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenToWorld2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Camera2D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetScreenToWorld2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)
     * }
     */
    public static FunctionDescriptor GetScreenToWorld2D$descriptor() {
        return GetScreenToWorld2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MethodHandle GetScreenToWorld2D$handle() {
        return GetScreenToWorld2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MemorySegment GetScreenToWorld2D$address() {
        return GetScreenToWorld2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)
     * }
     */
    public static MemorySegment GetScreenToWorld2D(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = GetScreenToWorld2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenToWorld2D", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCameraMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Camera3D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCameraMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix(Camera camera)
     * }
     */
    public static FunctionDescriptor GetCameraMatrix$descriptor() {
        return GetCameraMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix(Camera camera)
     * }
     */
    public static MethodHandle GetCameraMatrix$handle() {
        return GetCameraMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix(Camera camera)
     * }
     */
    public static MemorySegment GetCameraMatrix$address() {
        return GetCameraMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix GetCameraMatrix(Camera camera)
     * }
     */
    public static MemorySegment GetCameraMatrix(SegmentAllocator allocator, MemorySegment camera) {
        var mh$ = GetCameraMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCameraMatrix", allocator, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCameraMatrix2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            Camera2D.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCameraMatrix2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix2D(Camera2D camera)
     * }
     */
    public static FunctionDescriptor GetCameraMatrix2D$descriptor() {
        return GetCameraMatrix2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix2D(Camera2D camera)
     * }
     */
    public static MethodHandle GetCameraMatrix2D$handle() {
        return GetCameraMatrix2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix GetCameraMatrix2D(Camera2D camera)
     * }
     */
    public static MemorySegment GetCameraMatrix2D$address() {
        return GetCameraMatrix2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix GetCameraMatrix2D(Camera2D camera)
     * }
     */
    public static MemorySegment GetCameraMatrix2D(SegmentAllocator allocator, MemorySegment camera) {
        var mh$ = GetCameraMatrix2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCameraMatrix2D", allocator, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTargetFPS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTargetFPS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static FunctionDescriptor SetTargetFPS$descriptor() {
        return SetTargetFPS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static MethodHandle SetTargetFPS$handle() {
        return SetTargetFPS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static MemorySegment SetTargetFPS$address() {
        return SetTargetFPS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static void SetTargetFPS(int fps) {
        var mh$ = SetTargetFPS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTargetFPS", fps);
            }
            mh$.invokeExact(fps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFrameTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFrameTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static FunctionDescriptor GetFrameTime$descriptor() {
        return GetFrameTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static MethodHandle GetFrameTime$handle() {
        return GetFrameTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static MemorySegment GetFrameTime$address() {
        return GetFrameTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static float GetFrameTime() {
        var mh$ = GetFrameTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFrameTime");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_DOUBLE    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double GetTime()
     * }
     */
    public static FunctionDescriptor GetTime$descriptor() {
        return GetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double GetTime()
     * }
     */
    public static MethodHandle GetTime$handle() {
        return GetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double GetTime()
     * }
     */
    public static MemorySegment GetTime$address() {
        return GetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double GetTime()
     * }
     */
    public static double GetTime() {
        var mh$ = GetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTime");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFPS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFPS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetFPS()
     * }
     */
    public static FunctionDescriptor GetFPS$descriptor() {
        return GetFPS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetFPS()
     * }
     */
    public static MethodHandle GetFPS$handle() {
        return GetFPS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetFPS()
     * }
     */
    public static MemorySegment GetFPS$address() {
        return GetFPS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetFPS()
     * }
     */
    public static int GetFPS() {
        var mh$ = GetFPS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFPS");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("SwapScreenBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwapScreenBuffer()
     * }
     */
    public static FunctionDescriptor SwapScreenBuffer$descriptor() {
        return SwapScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwapScreenBuffer()
     * }
     */
    public static MethodHandle SwapScreenBuffer$handle() {
        return SwapScreenBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SwapScreenBuffer()
     * }
     */
    public static MemorySegment SwapScreenBuffer$address() {
        return SwapScreenBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SwapScreenBuffer()
     * }
     */
    public static void SwapScreenBuffer() {
        var mh$ = SwapScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapScreenBuffer");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PollInputEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("PollInputEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PollInputEvents()
     * }
     */
    public static FunctionDescriptor PollInputEvents$descriptor() {
        return PollInputEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PollInputEvents()
     * }
     */
    public static MethodHandle PollInputEvents$handle() {
        return PollInputEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PollInputEvents()
     * }
     */
    public static MemorySegment PollInputEvents$address() {
        return PollInputEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PollInputEvents()
     * }
     */
    public static void PollInputEvents() {
        var mh$ = PollInputEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PollInputEvents");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_DOUBLE
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaitTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitTime(double seconds)
     * }
     */
    public static FunctionDescriptor WaitTime$descriptor() {
        return WaitTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitTime(double seconds)
     * }
     */
    public static MethodHandle WaitTime$handle() {
        return WaitTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitTime(double seconds)
     * }
     */
    public static MemorySegment WaitTime$address() {
        return WaitTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitTime(double seconds)
     * }
     */
    public static void WaitTime(double seconds) {
        var mh$ = WaitTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitTime", seconds);
            }
            mh$.invokeExact(seconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRandomSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetRandomSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetRandomSeed(unsigned int seed)
     * }
     */
    public static FunctionDescriptor SetRandomSeed$descriptor() {
        return SetRandomSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetRandomSeed(unsigned int seed)
     * }
     */
    public static MethodHandle SetRandomSeed$handle() {
        return SetRandomSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetRandomSeed(unsigned int seed)
     * }
     */
    public static MemorySegment SetRandomSeed$address() {
        return SetRandomSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetRandomSeed(unsigned int seed)
     * }
     */
    public static void SetRandomSeed(int seed) {
        var mh$ = SetRandomSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRandomSeed", seed);
            }
            mh$.invokeExact(seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRandomValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRandomValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRandomValue(int min, int max)
     * }
     */
    public static FunctionDescriptor GetRandomValue$descriptor() {
        return GetRandomValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRandomValue(int min, int max)
     * }
     */
    public static MethodHandle GetRandomValue$handle() {
        return GetRandomValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRandomValue(int min, int max)
     * }
     */
    public static MemorySegment GetRandomValue$address() {
        return GetRandomValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRandomValue(int min, int max)
     * }
     */
    public static int GetRandomValue(int min, int max) {
        var mh$ = GetRandomValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRandomValue", min, max);
            }
            return (int)mh$.invokeExact(min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadRandomSequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadRandomSequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *LoadRandomSequence(unsigned int count, int min, int max)
     * }
     */
    public static FunctionDescriptor LoadRandomSequence$descriptor() {
        return LoadRandomSequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *LoadRandomSequence(unsigned int count, int min, int max)
     * }
     */
    public static MethodHandle LoadRandomSequence$handle() {
        return LoadRandomSequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *LoadRandomSequence(unsigned int count, int min, int max)
     * }
     */
    public static MemorySegment LoadRandomSequence$address() {
        return LoadRandomSequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *LoadRandomSequence(unsigned int count, int min, int max)
     * }
     */
    public static MemorySegment LoadRandomSequence(int count, int min, int max) {
        var mh$ = LoadRandomSequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadRandomSequence", count, min, max);
            }
            return (MemorySegment)mh$.invokeExact(count, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadRandomSequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadRandomSequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadRandomSequence(int *sequence)
     * }
     */
    public static FunctionDescriptor UnloadRandomSequence$descriptor() {
        return UnloadRandomSequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadRandomSequence(int *sequence)
     * }
     */
    public static MethodHandle UnloadRandomSequence$handle() {
        return UnloadRandomSequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadRandomSequence(int *sequence)
     * }
     */
    public static MemorySegment UnloadRandomSequence$address() {
        return UnloadRandomSequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadRandomSequence(int *sequence)
     * }
     */
    public static void UnloadRandomSequence(MemorySegment sequence) {
        var mh$ = UnloadRandomSequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadRandomSequence", sequence);
            }
            mh$.invokeExact(sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TakeScreenshot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TakeScreenshot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TakeScreenshot(const char *fileName)
     * }
     */
    public static FunctionDescriptor TakeScreenshot$descriptor() {
        return TakeScreenshot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TakeScreenshot(const char *fileName)
     * }
     */
    public static MethodHandle TakeScreenshot$handle() {
        return TakeScreenshot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TakeScreenshot(const char *fileName)
     * }
     */
    public static MemorySegment TakeScreenshot$address() {
        return TakeScreenshot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TakeScreenshot(const char *fileName)
     * }
     */
    public static void TakeScreenshot(MemorySegment fileName) {
        var mh$ = TakeScreenshot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TakeScreenshot", fileName);
            }
            mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConfigFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetConfigFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static FunctionDescriptor SetConfigFlags$descriptor() {
        return SetConfigFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static MethodHandle SetConfigFlags$handle() {
        return SetConfigFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static MemorySegment SetConfigFlags$address() {
        return SetConfigFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static void SetConfigFlags(int flags) {
        var mh$ = SetConfigFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConfigFlags", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("OpenURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OpenURL(const char *url)
     * }
     */
    public static FunctionDescriptor OpenURL$descriptor() {
        return OpenURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OpenURL(const char *url)
     * }
     */
    public static MethodHandle OpenURL$handle() {
        return OpenURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OpenURL(const char *url)
     * }
     */
    public static MemorySegment OpenURL$address() {
        return OpenURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OpenURL(const char *url)
     * }
     */
    public static void OpenURL(MemorySegment url) {
        var mh$ = OpenURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenURL", url);
            }
            mh$.invokeExact(url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void TraceLog(int logLevel, const char *text, ...)
     * }
     */
    public static class TraceLog {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                raylib.C_INT,
                raylib.C_POINTER
            );
        private static final MemorySegment ADDR = raylib.findOrThrow("TraceLog");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private TraceLog(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void TraceLog(int logLevel, const char *text, ...)
         * }
         */
        public static TraceLog makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new TraceLog(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int logLevel, MemorySegment text, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("TraceLog", logLevel, text, x2);
                }
                spreader.invokeExact(logLevel, text, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class SetTraceLogLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTraceLogLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTraceLogLevel(int logLevel)
     * }
     */
    public static FunctionDescriptor SetTraceLogLevel$descriptor() {
        return SetTraceLogLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTraceLogLevel(int logLevel)
     * }
     */
    public static MethodHandle SetTraceLogLevel$handle() {
        return SetTraceLogLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTraceLogLevel(int logLevel)
     * }
     */
    public static MemorySegment SetTraceLogLevel$address() {
        return SetTraceLogLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTraceLogLevel(int logLevel)
     * }
     */
    public static void SetTraceLogLevel(int logLevel) {
        var mh$ = SetTraceLogLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTraceLogLevel", logLevel);
            }
            mh$.invokeExact(logLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MemAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MemAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *MemAlloc(unsigned int size)
     * }
     */
    public static FunctionDescriptor MemAlloc$descriptor() {
        return MemAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *MemAlloc(unsigned int size)
     * }
     */
    public static MethodHandle MemAlloc$handle() {
        return MemAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *MemAlloc(unsigned int size)
     * }
     */
    public static MemorySegment MemAlloc$address() {
        return MemAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *MemAlloc(unsigned int size)
     * }
     */
    public static MemorySegment MemAlloc(int size) {
        var mh$ = MemAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MemAlloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MemRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MemRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *MemRealloc(void *ptr, unsigned int size)
     * }
     */
    public static FunctionDescriptor MemRealloc$descriptor() {
        return MemRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *MemRealloc(void *ptr, unsigned int size)
     * }
     */
    public static MethodHandle MemRealloc$handle() {
        return MemRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *MemRealloc(void *ptr, unsigned int size)
     * }
     */
    public static MemorySegment MemRealloc$address() {
        return MemRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *MemRealloc(void *ptr, unsigned int size)
     * }
     */
    public static MemorySegment MemRealloc(MemorySegment ptr, int size) {
        var mh$ = MemRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MemRealloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MemFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MemFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MemFree(void *ptr)
     * }
     */
    public static FunctionDescriptor MemFree$descriptor() {
        return MemFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MemFree(void *ptr)
     * }
     */
    public static MethodHandle MemFree$handle() {
        return MemFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MemFree(void *ptr)
     * }
     */
    public static MemorySegment MemFree$address() {
        return MemFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MemFree(void *ptr)
     * }
     */
    public static void MemFree(MemorySegment ptr) {
        var mh$ = MemFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MemFree", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTraceLogCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTraceLogCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTraceLogCallback(TraceLogCallback callback)
     * }
     */
    public static FunctionDescriptor SetTraceLogCallback$descriptor() {
        return SetTraceLogCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTraceLogCallback(TraceLogCallback callback)
     * }
     */
    public static MethodHandle SetTraceLogCallback$handle() {
        return SetTraceLogCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTraceLogCallback(TraceLogCallback callback)
     * }
     */
    public static MemorySegment SetTraceLogCallback$address() {
        return SetTraceLogCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTraceLogCallback(TraceLogCallback callback)
     * }
     */
    public static void SetTraceLogCallback(MemorySegment callback) {
        var mh$ = SetTraceLogCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTraceLogCallback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLoadFileDataCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetLoadFileDataCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLoadFileDataCallback(LoadFileDataCallback callback)
     * }
     */
    public static FunctionDescriptor SetLoadFileDataCallback$descriptor() {
        return SetLoadFileDataCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLoadFileDataCallback(LoadFileDataCallback callback)
     * }
     */
    public static MethodHandle SetLoadFileDataCallback$handle() {
        return SetLoadFileDataCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLoadFileDataCallback(LoadFileDataCallback callback)
     * }
     */
    public static MemorySegment SetLoadFileDataCallback$address() {
        return SetLoadFileDataCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLoadFileDataCallback(LoadFileDataCallback callback)
     * }
     */
    public static void SetLoadFileDataCallback(MemorySegment callback) {
        var mh$ = SetLoadFileDataCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLoadFileDataCallback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSaveFileDataCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSaveFileDataCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSaveFileDataCallback(SaveFileDataCallback callback)
     * }
     */
    public static FunctionDescriptor SetSaveFileDataCallback$descriptor() {
        return SetSaveFileDataCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSaveFileDataCallback(SaveFileDataCallback callback)
     * }
     */
    public static MethodHandle SetSaveFileDataCallback$handle() {
        return SetSaveFileDataCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSaveFileDataCallback(SaveFileDataCallback callback)
     * }
     */
    public static MemorySegment SetSaveFileDataCallback$address() {
        return SetSaveFileDataCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSaveFileDataCallback(SaveFileDataCallback callback)
     * }
     */
    public static void SetSaveFileDataCallback(MemorySegment callback) {
        var mh$ = SetSaveFileDataCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSaveFileDataCallback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLoadFileTextCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetLoadFileTextCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLoadFileTextCallback(LoadFileTextCallback callback)
     * }
     */
    public static FunctionDescriptor SetLoadFileTextCallback$descriptor() {
        return SetLoadFileTextCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLoadFileTextCallback(LoadFileTextCallback callback)
     * }
     */
    public static MethodHandle SetLoadFileTextCallback$handle() {
        return SetLoadFileTextCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLoadFileTextCallback(LoadFileTextCallback callback)
     * }
     */
    public static MemorySegment SetLoadFileTextCallback$address() {
        return SetLoadFileTextCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLoadFileTextCallback(LoadFileTextCallback callback)
     * }
     */
    public static void SetLoadFileTextCallback(MemorySegment callback) {
        var mh$ = SetLoadFileTextCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLoadFileTextCallback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSaveFileTextCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSaveFileTextCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSaveFileTextCallback(SaveFileTextCallback callback)
     * }
     */
    public static FunctionDescriptor SetSaveFileTextCallback$descriptor() {
        return SetSaveFileTextCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSaveFileTextCallback(SaveFileTextCallback callback)
     * }
     */
    public static MethodHandle SetSaveFileTextCallback$handle() {
        return SetSaveFileTextCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSaveFileTextCallback(SaveFileTextCallback callback)
     * }
     */
    public static MemorySegment SetSaveFileTextCallback$address() {
        return SetSaveFileTextCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSaveFileTextCallback(SaveFileTextCallback callback)
     * }
     */
    public static void SetSaveFileTextCallback(MemorySegment callback) {
        var mh$ = SetSaveFileTextCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSaveFileTextCallback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFileData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFileData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *LoadFileData(const char *fileName, int *dataSize)
     * }
     */
    public static FunctionDescriptor LoadFileData$descriptor() {
        return LoadFileData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *LoadFileData(const char *fileName, int *dataSize)
     * }
     */
    public static MethodHandle LoadFileData$handle() {
        return LoadFileData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *LoadFileData(const char *fileName, int *dataSize)
     * }
     */
    public static MemorySegment LoadFileData$address() {
        return LoadFileData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *LoadFileData(const char *fileName, int *dataSize)
     * }
     */
    public static MemorySegment LoadFileData(MemorySegment fileName, MemorySegment dataSize) {
        var mh$ = LoadFileData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFileData", fileName, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(fileName, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFileData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFileData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFileData(unsigned char *data)
     * }
     */
    public static FunctionDescriptor UnloadFileData$descriptor() {
        return UnloadFileData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFileData(unsigned char *data)
     * }
     */
    public static MethodHandle UnloadFileData$handle() {
        return UnloadFileData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFileData(unsigned char *data)
     * }
     */
    public static MemorySegment UnloadFileData$address() {
        return UnloadFileData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFileData(unsigned char *data)
     * }
     */
    public static void UnloadFileData(MemorySegment data) {
        var mh$ = UnloadFileData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFileData", data);
            }
            mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveFileData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SaveFileData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool SaveFileData(const char *fileName, void *data, int dataSize)
     * }
     */
    public static FunctionDescriptor SaveFileData$descriptor() {
        return SaveFileData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool SaveFileData(const char *fileName, void *data, int dataSize)
     * }
     */
    public static MethodHandle SaveFileData$handle() {
        return SaveFileData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool SaveFileData(const char *fileName, void *data, int dataSize)
     * }
     */
    public static MemorySegment SaveFileData$address() {
        return SaveFileData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool SaveFileData(const char *fileName, void *data, int dataSize)
     * }
     */
    public static boolean SaveFileData(MemorySegment fileName, MemorySegment data, int dataSize) {
        var mh$ = SaveFileData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveFileData", fileName, data, dataSize);
            }
            return (boolean)mh$.invokeExact(fileName, data, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportDataAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportDataAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportDataAsCode$descriptor() {
        return ExportDataAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName)
     * }
     */
    public static MethodHandle ExportDataAsCode$handle() {
        return ExportDataAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName)
     * }
     */
    public static MemorySegment ExportDataAsCode$address() {
        return ExportDataAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName)
     * }
     */
    public static boolean ExportDataAsCode(MemorySegment data, int dataSize, MemorySegment fileName) {
        var mh$ = ExportDataAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportDataAsCode", data, dataSize, fileName);
            }
            return (boolean)mh$.invokeExact(data, dataSize, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFileText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFileText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LoadFileText(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadFileText$descriptor() {
        return LoadFileText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LoadFileText(const char *fileName)
     * }
     */
    public static MethodHandle LoadFileText$handle() {
        return LoadFileText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LoadFileText(const char *fileName)
     * }
     */
    public static MemorySegment LoadFileText$address() {
        return LoadFileText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LoadFileText(const char *fileName)
     * }
     */
    public static MemorySegment LoadFileText(MemorySegment fileName) {
        var mh$ = LoadFileText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFileText", fileName);
            }
            return (MemorySegment)mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFileText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFileText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFileText(char *text)
     * }
     */
    public static FunctionDescriptor UnloadFileText$descriptor() {
        return UnloadFileText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFileText(char *text)
     * }
     */
    public static MethodHandle UnloadFileText$handle() {
        return UnloadFileText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFileText(char *text)
     * }
     */
    public static MemorySegment UnloadFileText$address() {
        return UnloadFileText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFileText(char *text)
     * }
     */
    public static void UnloadFileText(MemorySegment text) {
        var mh$ = UnloadFileText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFileText", text);
            }
            mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveFileText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SaveFileText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool SaveFileText(const char *fileName, char *text)
     * }
     */
    public static FunctionDescriptor SaveFileText$descriptor() {
        return SaveFileText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool SaveFileText(const char *fileName, char *text)
     * }
     */
    public static MethodHandle SaveFileText$handle() {
        return SaveFileText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool SaveFileText(const char *fileName, char *text)
     * }
     */
    public static MemorySegment SaveFileText$address() {
        return SaveFileText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool SaveFileText(const char *fileName, char *text)
     * }
     */
    public static boolean SaveFileText(MemorySegment fileName, MemorySegment text) {
        var mh$ = SaveFileText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveFileText", fileName, text);
            }
            return (boolean)mh$.invokeExact(fileName, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileExists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("FileExists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool FileExists(const char *fileName)
     * }
     */
    public static FunctionDescriptor FileExists$descriptor() {
        return FileExists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool FileExists(const char *fileName)
     * }
     */
    public static MethodHandle FileExists$handle() {
        return FileExists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool FileExists(const char *fileName)
     * }
     */
    public static MemorySegment FileExists$address() {
        return FileExists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool FileExists(const char *fileName)
     * }
     */
    public static boolean FileExists(MemorySegment fileName) {
        var mh$ = FileExists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileExists", fileName);
            }
            return (boolean)mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DirectoryExists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DirectoryExists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool DirectoryExists(const char *dirPath)
     * }
     */
    public static FunctionDescriptor DirectoryExists$descriptor() {
        return DirectoryExists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool DirectoryExists(const char *dirPath)
     * }
     */
    public static MethodHandle DirectoryExists$handle() {
        return DirectoryExists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool DirectoryExists(const char *dirPath)
     * }
     */
    public static MemorySegment DirectoryExists$address() {
        return DirectoryExists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool DirectoryExists(const char *dirPath)
     * }
     */
    public static boolean DirectoryExists(MemorySegment dirPath) {
        var mh$ = DirectoryExists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DirectoryExists", dirPath);
            }
            return (boolean)mh$.invokeExact(dirPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsFileExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsFileExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsFileExtension(const char *fileName, const char *ext)
     * }
     */
    public static FunctionDescriptor IsFileExtension$descriptor() {
        return IsFileExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsFileExtension(const char *fileName, const char *ext)
     * }
     */
    public static MethodHandle IsFileExtension$handle() {
        return IsFileExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsFileExtension(const char *fileName, const char *ext)
     * }
     */
    public static MemorySegment IsFileExtension$address() {
        return IsFileExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsFileExtension(const char *fileName, const char *ext)
     * }
     */
    public static boolean IsFileExtension(MemorySegment fileName, MemorySegment ext) {
        var mh$ = IsFileExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsFileExtension", fileName, ext);
            }
            return (boolean)mh$.invokeExact(fileName, ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFileLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetFileLength(const char *fileName)
     * }
     */
    public static FunctionDescriptor GetFileLength$descriptor() {
        return GetFileLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetFileLength(const char *fileName)
     * }
     */
    public static MethodHandle GetFileLength$handle() {
        return GetFileLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetFileLength(const char *fileName)
     * }
     */
    public static MemorySegment GetFileLength$address() {
        return GetFileLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetFileLength(const char *fileName)
     * }
     */
    public static int GetFileLength(MemorySegment fileName) {
        var mh$ = GetFileLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileLength", fileName);
            }
            return (int)mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFileExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetFileExtension(const char *fileName)
     * }
     */
    public static FunctionDescriptor GetFileExtension$descriptor() {
        return GetFileExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetFileExtension(const char *fileName)
     * }
     */
    public static MethodHandle GetFileExtension$handle() {
        return GetFileExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetFileExtension(const char *fileName)
     * }
     */
    public static MemorySegment GetFileExtension$address() {
        return GetFileExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetFileExtension(const char *fileName)
     * }
     */
    public static MemorySegment GetFileExtension(MemorySegment fileName) {
        var mh$ = GetFileExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileExtension", fileName);
            }
            return (MemorySegment)mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFileName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetFileName(const char *filePath)
     * }
     */
    public static FunctionDescriptor GetFileName$descriptor() {
        return GetFileName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetFileName(const char *filePath)
     * }
     */
    public static MethodHandle GetFileName$handle() {
        return GetFileName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetFileName(const char *filePath)
     * }
     */
    public static MemorySegment GetFileName$address() {
        return GetFileName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetFileName(const char *filePath)
     * }
     */
    public static MemorySegment GetFileName(MemorySegment filePath) {
        var mh$ = GetFileName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileName", filePath);
            }
            return (MemorySegment)mh$.invokeExact(filePath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileNameWithoutExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFileNameWithoutExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetFileNameWithoutExt(const char *filePath)
     * }
     */
    public static FunctionDescriptor GetFileNameWithoutExt$descriptor() {
        return GetFileNameWithoutExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetFileNameWithoutExt(const char *filePath)
     * }
     */
    public static MethodHandle GetFileNameWithoutExt$handle() {
        return GetFileNameWithoutExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetFileNameWithoutExt(const char *filePath)
     * }
     */
    public static MemorySegment GetFileNameWithoutExt$address() {
        return GetFileNameWithoutExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetFileNameWithoutExt(const char *filePath)
     * }
     */
    public static MemorySegment GetFileNameWithoutExt(MemorySegment filePath) {
        var mh$ = GetFileNameWithoutExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileNameWithoutExt", filePath);
            }
            return (MemorySegment)mh$.invokeExact(filePath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDirectoryPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetDirectoryPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetDirectoryPath(const char *filePath)
     * }
     */
    public static FunctionDescriptor GetDirectoryPath$descriptor() {
        return GetDirectoryPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetDirectoryPath(const char *filePath)
     * }
     */
    public static MethodHandle GetDirectoryPath$handle() {
        return GetDirectoryPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetDirectoryPath(const char *filePath)
     * }
     */
    public static MemorySegment GetDirectoryPath$address() {
        return GetDirectoryPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetDirectoryPath(const char *filePath)
     * }
     */
    public static MemorySegment GetDirectoryPath(MemorySegment filePath) {
        var mh$ = GetDirectoryPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDirectoryPath", filePath);
            }
            return (MemorySegment)mh$.invokeExact(filePath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrevDirectoryPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetPrevDirectoryPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetPrevDirectoryPath(const char *dirPath)
     * }
     */
    public static FunctionDescriptor GetPrevDirectoryPath$descriptor() {
        return GetPrevDirectoryPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetPrevDirectoryPath(const char *dirPath)
     * }
     */
    public static MethodHandle GetPrevDirectoryPath$handle() {
        return GetPrevDirectoryPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetPrevDirectoryPath(const char *dirPath)
     * }
     */
    public static MemorySegment GetPrevDirectoryPath$address() {
        return GetPrevDirectoryPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetPrevDirectoryPath(const char *dirPath)
     * }
     */
    public static MemorySegment GetPrevDirectoryPath(MemorySegment dirPath) {
        var mh$ = GetPrevDirectoryPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrevDirectoryPath", dirPath);
            }
            return (MemorySegment)mh$.invokeExact(dirPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorkingDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetWorkingDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetWorkingDirectory()
     * }
     */
    public static FunctionDescriptor GetWorkingDirectory$descriptor() {
        return GetWorkingDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetWorkingDirectory()
     * }
     */
    public static MethodHandle GetWorkingDirectory$handle() {
        return GetWorkingDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetWorkingDirectory()
     * }
     */
    public static MemorySegment GetWorkingDirectory$address() {
        return GetWorkingDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetWorkingDirectory()
     * }
     */
    public static MemorySegment GetWorkingDirectory() {
        var mh$ = GetWorkingDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorkingDirectory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetApplicationDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetApplicationDirectory()
     * }
     */
    public static FunctionDescriptor GetApplicationDirectory$descriptor() {
        return GetApplicationDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetApplicationDirectory()
     * }
     */
    public static MethodHandle GetApplicationDirectory$handle() {
        return GetApplicationDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetApplicationDirectory()
     * }
     */
    public static MemorySegment GetApplicationDirectory$address() {
        return GetApplicationDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetApplicationDirectory()
     * }
     */
    public static MemorySegment GetApplicationDirectory() {
        var mh$ = GetApplicationDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationDirectory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ChangeDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ChangeDirectory(const char *dir)
     * }
     */
    public static FunctionDescriptor ChangeDirectory$descriptor() {
        return ChangeDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ChangeDirectory(const char *dir)
     * }
     */
    public static MethodHandle ChangeDirectory$handle() {
        return ChangeDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ChangeDirectory(const char *dir)
     * }
     */
    public static MemorySegment ChangeDirectory$address() {
        return ChangeDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ChangeDirectory(const char *dir)
     * }
     */
    public static boolean ChangeDirectory(MemorySegment dir) {
        var mh$ = ChangeDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDirectory", dir);
            }
            return (boolean)mh$.invokeExact(dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsPathFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsPathFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsPathFile(const char *path)
     * }
     */
    public static FunctionDescriptor IsPathFile$descriptor() {
        return IsPathFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsPathFile(const char *path)
     * }
     */
    public static MethodHandle IsPathFile$handle() {
        return IsPathFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsPathFile(const char *path)
     * }
     */
    public static MemorySegment IsPathFile$address() {
        return IsPathFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsPathFile(const char *path)
     * }
     */
    public static boolean IsPathFile(MemorySegment path) {
        var mh$ = IsPathFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsPathFile", path);
            }
            return (boolean)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadDirectoryFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FilePathList.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadDirectoryFiles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFiles(const char *dirPath)
     * }
     */
    public static FunctionDescriptor LoadDirectoryFiles$descriptor() {
        return LoadDirectoryFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFiles(const char *dirPath)
     * }
     */
    public static MethodHandle LoadDirectoryFiles$handle() {
        return LoadDirectoryFiles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFiles(const char *dirPath)
     * }
     */
    public static MemorySegment LoadDirectoryFiles$address() {
        return LoadDirectoryFiles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFiles(const char *dirPath)
     * }
     */
    public static MemorySegment LoadDirectoryFiles(SegmentAllocator allocator, MemorySegment dirPath) {
        var mh$ = LoadDirectoryFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadDirectoryFiles", allocator, dirPath);
            }
            return (MemorySegment)mh$.invokeExact(allocator, dirPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadDirectoryFilesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FilePathList.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadDirectoryFilesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)
     * }
     */
    public static FunctionDescriptor LoadDirectoryFilesEx$descriptor() {
        return LoadDirectoryFilesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)
     * }
     */
    public static MethodHandle LoadDirectoryFilesEx$handle() {
        return LoadDirectoryFilesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)
     * }
     */
    public static MemorySegment LoadDirectoryFilesEx$address() {
        return LoadDirectoryFilesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)
     * }
     */
    public static MemorySegment LoadDirectoryFilesEx(SegmentAllocator allocator, MemorySegment basePath, MemorySegment filter, boolean scanSubdirs) {
        var mh$ = LoadDirectoryFilesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadDirectoryFilesEx", allocator, basePath, filter, scanSubdirs);
            }
            return (MemorySegment)mh$.invokeExact(allocator, basePath, filter, scanSubdirs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadDirectoryFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FilePathList.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadDirectoryFiles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadDirectoryFiles(FilePathList files)
     * }
     */
    public static FunctionDescriptor UnloadDirectoryFiles$descriptor() {
        return UnloadDirectoryFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadDirectoryFiles(FilePathList files)
     * }
     */
    public static MethodHandle UnloadDirectoryFiles$handle() {
        return UnloadDirectoryFiles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadDirectoryFiles(FilePathList files)
     * }
     */
    public static MemorySegment UnloadDirectoryFiles$address() {
        return UnloadDirectoryFiles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadDirectoryFiles(FilePathList files)
     * }
     */
    public static void UnloadDirectoryFiles(MemorySegment files) {
        var mh$ = UnloadDirectoryFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadDirectoryFiles", files);
            }
            mh$.invokeExact(files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsFileDropped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsFileDropped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsFileDropped()
     * }
     */
    public static FunctionDescriptor IsFileDropped$descriptor() {
        return IsFileDropped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsFileDropped()
     * }
     */
    public static MethodHandle IsFileDropped$handle() {
        return IsFileDropped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsFileDropped()
     * }
     */
    public static MemorySegment IsFileDropped$address() {
        return IsFileDropped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsFileDropped()
     * }
     */
    public static boolean IsFileDropped() {
        var mh$ = IsFileDropped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsFileDropped");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadDroppedFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FilePathList.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadDroppedFiles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FilePathList LoadDroppedFiles()
     * }
     */
    public static FunctionDescriptor LoadDroppedFiles$descriptor() {
        return LoadDroppedFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FilePathList LoadDroppedFiles()
     * }
     */
    public static MethodHandle LoadDroppedFiles$handle() {
        return LoadDroppedFiles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FilePathList LoadDroppedFiles()
     * }
     */
    public static MemorySegment LoadDroppedFiles$address() {
        return LoadDroppedFiles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FilePathList LoadDroppedFiles()
     * }
     */
    public static MemorySegment LoadDroppedFiles(SegmentAllocator allocator) {
        var mh$ = LoadDroppedFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadDroppedFiles", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadDroppedFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FilePathList.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadDroppedFiles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadDroppedFiles(FilePathList files)
     * }
     */
    public static FunctionDescriptor UnloadDroppedFiles$descriptor() {
        return UnloadDroppedFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadDroppedFiles(FilePathList files)
     * }
     */
    public static MethodHandle UnloadDroppedFiles$handle() {
        return UnloadDroppedFiles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadDroppedFiles(FilePathList files)
     * }
     */
    public static MemorySegment UnloadDroppedFiles$address() {
        return UnloadDroppedFiles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadDroppedFiles(FilePathList files)
     * }
     */
    public static void UnloadDroppedFiles(MemorySegment files) {
        var mh$ = UnloadDroppedFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadDroppedFiles", files);
            }
            mh$.invokeExact(files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileModTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_LONG,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFileModTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long GetFileModTime(const char *fileName)
     * }
     */
    public static FunctionDescriptor GetFileModTime$descriptor() {
        return GetFileModTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long GetFileModTime(const char *fileName)
     * }
     */
    public static MethodHandle GetFileModTime$handle() {
        return GetFileModTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long GetFileModTime(const char *fileName)
     * }
     */
    public static MemorySegment GetFileModTime$address() {
        return GetFileModTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long GetFileModTime(const char *fileName)
     * }
     */
    public static long GetFileModTime(MemorySegment fileName) {
        var mh$ = GetFileModTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileModTime", fileName);
            }
            return (long)mh$.invokeExact(fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompressData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CompressData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)
     * }
     */
    public static FunctionDescriptor CompressData$descriptor() {
        return CompressData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)
     * }
     */
    public static MethodHandle CompressData$handle() {
        return CompressData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)
     * }
     */
    public static MemorySegment CompressData$address() {
        return CompressData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)
     * }
     */
    public static MemorySegment CompressData(MemorySegment data, int dataSize, MemorySegment compDataSize) {
        var mh$ = CompressData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompressData", data, dataSize, compDataSize);
            }
            return (MemorySegment)mh$.invokeExact(data, dataSize, compDataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecompressData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DecompressData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)
     * }
     */
    public static FunctionDescriptor DecompressData$descriptor() {
        return DecompressData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)
     * }
     */
    public static MethodHandle DecompressData$handle() {
        return DecompressData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)
     * }
     */
    public static MemorySegment DecompressData$address() {
        return DecompressData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)
     * }
     */
    public static MemorySegment DecompressData(MemorySegment compData, int compDataSize, MemorySegment dataSize) {
        var mh$ = DecompressData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecompressData", compData, compDataSize, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(compData, compDataSize, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeDataBase64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("EncodeDataBase64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)
     * }
     */
    public static FunctionDescriptor EncodeDataBase64$descriptor() {
        return EncodeDataBase64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)
     * }
     */
    public static MethodHandle EncodeDataBase64$handle() {
        return EncodeDataBase64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)
     * }
     */
    public static MemorySegment EncodeDataBase64$address() {
        return EncodeDataBase64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)
     * }
     */
    public static MemorySegment EncodeDataBase64(MemorySegment data, int dataSize, MemorySegment outputSize) {
        var mh$ = EncodeDataBase64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeDataBase64", data, dataSize, outputSize);
            }
            return (MemorySegment)mh$.invokeExact(data, dataSize, outputSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeDataBase64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DecodeDataBase64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)
     * }
     */
    public static FunctionDescriptor DecodeDataBase64$descriptor() {
        return DecodeDataBase64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)
     * }
     */
    public static MethodHandle DecodeDataBase64$handle() {
        return DecodeDataBase64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)
     * }
     */
    public static MemorySegment DecodeDataBase64$address() {
        return DecodeDataBase64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)
     * }
     */
    public static MemorySegment DecodeDataBase64(MemorySegment data, MemorySegment outputSize) {
        var mh$ = DecodeDataBase64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeDataBase64", data, outputSize);
            }
            return (MemorySegment)mh$.invokeExact(data, outputSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAutomationEventList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AutomationEventList.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadAutomationEventList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AutomationEventList LoadAutomationEventList(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadAutomationEventList$descriptor() {
        return LoadAutomationEventList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AutomationEventList LoadAutomationEventList(const char *fileName)
     * }
     */
    public static MethodHandle LoadAutomationEventList$handle() {
        return LoadAutomationEventList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AutomationEventList LoadAutomationEventList(const char *fileName)
     * }
     */
    public static MemorySegment LoadAutomationEventList$address() {
        return LoadAutomationEventList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AutomationEventList LoadAutomationEventList(const char *fileName)
     * }
     */
    public static MemorySegment LoadAutomationEventList(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadAutomationEventList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAutomationEventList", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadAutomationEventList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AutomationEventList.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadAutomationEventList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadAutomationEventList(AutomationEventList list)
     * }
     */
    public static FunctionDescriptor UnloadAutomationEventList$descriptor() {
        return UnloadAutomationEventList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadAutomationEventList(AutomationEventList list)
     * }
     */
    public static MethodHandle UnloadAutomationEventList$handle() {
        return UnloadAutomationEventList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadAutomationEventList(AutomationEventList list)
     * }
     */
    public static MemorySegment UnloadAutomationEventList$address() {
        return UnloadAutomationEventList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadAutomationEventList(AutomationEventList list)
     * }
     */
    public static void UnloadAutomationEventList(MemorySegment list) {
        var mh$ = UnloadAutomationEventList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadAutomationEventList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportAutomationEventList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AutomationEventList.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportAutomationEventList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportAutomationEventList(AutomationEventList list, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportAutomationEventList$descriptor() {
        return ExportAutomationEventList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportAutomationEventList(AutomationEventList list, const char *fileName)
     * }
     */
    public static MethodHandle ExportAutomationEventList$handle() {
        return ExportAutomationEventList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportAutomationEventList(AutomationEventList list, const char *fileName)
     * }
     */
    public static MemorySegment ExportAutomationEventList$address() {
        return ExportAutomationEventList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportAutomationEventList(AutomationEventList list, const char *fileName)
     * }
     */
    public static boolean ExportAutomationEventList(MemorySegment list, MemorySegment fileName) {
        var mh$ = ExportAutomationEventList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportAutomationEventList", list, fileName);
            }
            return (boolean)mh$.invokeExact(list, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAutomationEventList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAutomationEventList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAutomationEventList(AutomationEventList *list)
     * }
     */
    public static FunctionDescriptor SetAutomationEventList$descriptor() {
        return SetAutomationEventList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAutomationEventList(AutomationEventList *list)
     * }
     */
    public static MethodHandle SetAutomationEventList$handle() {
        return SetAutomationEventList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAutomationEventList(AutomationEventList *list)
     * }
     */
    public static MemorySegment SetAutomationEventList$address() {
        return SetAutomationEventList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAutomationEventList(AutomationEventList *list)
     * }
     */
    public static void SetAutomationEventList(MemorySegment list) {
        var mh$ = SetAutomationEventList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAutomationEventList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAutomationEventBaseFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAutomationEventBaseFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAutomationEventBaseFrame(int frame)
     * }
     */
    public static FunctionDescriptor SetAutomationEventBaseFrame$descriptor() {
        return SetAutomationEventBaseFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAutomationEventBaseFrame(int frame)
     * }
     */
    public static MethodHandle SetAutomationEventBaseFrame$handle() {
        return SetAutomationEventBaseFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAutomationEventBaseFrame(int frame)
     * }
     */
    public static MemorySegment SetAutomationEventBaseFrame$address() {
        return SetAutomationEventBaseFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAutomationEventBaseFrame(int frame)
     * }
     */
    public static void SetAutomationEventBaseFrame(int frame) {
        var mh$ = SetAutomationEventBaseFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAutomationEventBaseFrame", frame);
            }
            mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartAutomationEventRecording {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("StartAutomationEventRecording");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StartAutomationEventRecording()
     * }
     */
    public static FunctionDescriptor StartAutomationEventRecording$descriptor() {
        return StartAutomationEventRecording.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StartAutomationEventRecording()
     * }
     */
    public static MethodHandle StartAutomationEventRecording$handle() {
        return StartAutomationEventRecording.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StartAutomationEventRecording()
     * }
     */
    public static MemorySegment StartAutomationEventRecording$address() {
        return StartAutomationEventRecording.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StartAutomationEventRecording()
     * }
     */
    public static void StartAutomationEventRecording() {
        var mh$ = StartAutomationEventRecording.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartAutomationEventRecording");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopAutomationEventRecording {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopAutomationEventRecording");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopAutomationEventRecording()
     * }
     */
    public static FunctionDescriptor StopAutomationEventRecording$descriptor() {
        return StopAutomationEventRecording.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopAutomationEventRecording()
     * }
     */
    public static MethodHandle StopAutomationEventRecording$handle() {
        return StopAutomationEventRecording.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopAutomationEventRecording()
     * }
     */
    public static MemorySegment StopAutomationEventRecording$address() {
        return StopAutomationEventRecording.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopAutomationEventRecording()
     * }
     */
    public static void StopAutomationEventRecording() {
        var mh$ = StopAutomationEventRecording.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopAutomationEventRecording");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayAutomationEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AutomationEvent.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlayAutomationEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlayAutomationEvent(AutomationEvent event)
     * }
     */
    public static FunctionDescriptor PlayAutomationEvent$descriptor() {
        return PlayAutomationEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlayAutomationEvent(AutomationEvent event)
     * }
     */
    public static MethodHandle PlayAutomationEvent$handle() {
        return PlayAutomationEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlayAutomationEvent(AutomationEvent event)
     * }
     */
    public static MemorySegment PlayAutomationEvent$address() {
        return PlayAutomationEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlayAutomationEvent(AutomationEvent event)
     * }
     */
    public static void PlayAutomationEvent(MemorySegment event) {
        var mh$ = PlayAutomationEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayAutomationEvent", event);
            }
            mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsKeyPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsKeyPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsKeyPressed(int key)
     * }
     */
    public static FunctionDescriptor IsKeyPressed$descriptor() {
        return IsKeyPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsKeyPressed(int key)
     * }
     */
    public static MethodHandle IsKeyPressed$handle() {
        return IsKeyPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsKeyPressed(int key)
     * }
     */
    public static MemorySegment IsKeyPressed$address() {
        return IsKeyPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsKeyPressed(int key)
     * }
     */
    public static boolean IsKeyPressed(int key) {
        var mh$ = IsKeyPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsKeyPressed", key);
            }
            return (boolean)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsKeyPressedRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsKeyPressedRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsKeyPressedRepeat(int key)
     * }
     */
    public static FunctionDescriptor IsKeyPressedRepeat$descriptor() {
        return IsKeyPressedRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsKeyPressedRepeat(int key)
     * }
     */
    public static MethodHandle IsKeyPressedRepeat$handle() {
        return IsKeyPressedRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsKeyPressedRepeat(int key)
     * }
     */
    public static MemorySegment IsKeyPressedRepeat$address() {
        return IsKeyPressedRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsKeyPressedRepeat(int key)
     * }
     */
    public static boolean IsKeyPressedRepeat(int key) {
        var mh$ = IsKeyPressedRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsKeyPressedRepeat", key);
            }
            return (boolean)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsKeyDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsKeyDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsKeyDown(int key)
     * }
     */
    public static FunctionDescriptor IsKeyDown$descriptor() {
        return IsKeyDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsKeyDown(int key)
     * }
     */
    public static MethodHandle IsKeyDown$handle() {
        return IsKeyDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsKeyDown(int key)
     * }
     */
    public static MemorySegment IsKeyDown$address() {
        return IsKeyDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsKeyDown(int key)
     * }
     */
    public static boolean IsKeyDown(int key) {
        var mh$ = IsKeyDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsKeyDown", key);
            }
            return (boolean)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsKeyReleased {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsKeyReleased");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsKeyReleased(int key)
     * }
     */
    public static FunctionDescriptor IsKeyReleased$descriptor() {
        return IsKeyReleased.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsKeyReleased(int key)
     * }
     */
    public static MethodHandle IsKeyReleased$handle() {
        return IsKeyReleased.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsKeyReleased(int key)
     * }
     */
    public static MemorySegment IsKeyReleased$address() {
        return IsKeyReleased.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsKeyReleased(int key)
     * }
     */
    public static boolean IsKeyReleased(int key) {
        var mh$ = IsKeyReleased.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsKeyReleased", key);
            }
            return (boolean)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsKeyUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsKeyUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsKeyUp(int key)
     * }
     */
    public static FunctionDescriptor IsKeyUp$descriptor() {
        return IsKeyUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsKeyUp(int key)
     * }
     */
    public static MethodHandle IsKeyUp$handle() {
        return IsKeyUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsKeyUp(int key)
     * }
     */
    public static MemorySegment IsKeyUp$address() {
        return IsKeyUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsKeyUp(int key)
     * }
     */
    public static boolean IsKeyUp(int key) {
        var mh$ = IsKeyUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsKeyUp", key);
            }
            return (boolean)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetKeyPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyPressed()
     * }
     */
    public static FunctionDescriptor GetKeyPressed$descriptor() {
        return GetKeyPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyPressed()
     * }
     */
    public static MethodHandle GetKeyPressed$handle() {
        return GetKeyPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyPressed()
     * }
     */
    public static MemorySegment GetKeyPressed$address() {
        return GetKeyPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyPressed()
     * }
     */
    public static int GetKeyPressed() {
        var mh$ = GetKeyPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyPressed");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCharPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCharPressed()
     * }
     */
    public static FunctionDescriptor GetCharPressed$descriptor() {
        return GetCharPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCharPressed()
     * }
     */
    public static MethodHandle GetCharPressed$handle() {
        return GetCharPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCharPressed()
     * }
     */
    public static MemorySegment GetCharPressed$address() {
        return GetCharPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCharPressed()
     * }
     */
    public static int GetCharPressed() {
        var mh$ = GetCharPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharPressed");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetExitKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetExitKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetExitKey(int key)
     * }
     */
    public static FunctionDescriptor SetExitKey$descriptor() {
        return SetExitKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetExitKey(int key)
     * }
     */
    public static MethodHandle SetExitKey$handle() {
        return SetExitKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetExitKey(int key)
     * }
     */
    public static MemorySegment SetExitKey$address() {
        return SetExitKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetExitKey(int key)
     * }
     */
    public static void SetExitKey(int key) {
        var mh$ = SetExitKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetExitKey", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGamepadAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGamepadAvailable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGamepadAvailable(int gamepad)
     * }
     */
    public static FunctionDescriptor IsGamepadAvailable$descriptor() {
        return IsGamepadAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGamepadAvailable(int gamepad)
     * }
     */
    public static MethodHandle IsGamepadAvailable$handle() {
        return IsGamepadAvailable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGamepadAvailable(int gamepad)
     * }
     */
    public static MemorySegment IsGamepadAvailable$address() {
        return IsGamepadAvailable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGamepadAvailable(int gamepad)
     * }
     */
    public static boolean IsGamepadAvailable(int gamepad) {
        var mh$ = IsGamepadAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGamepadAvailable", gamepad);
            }
            return (boolean)mh$.invokeExact(gamepad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGamepadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGamepadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *GetGamepadName(int gamepad)
     * }
     */
    public static FunctionDescriptor GetGamepadName$descriptor() {
        return GetGamepadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *GetGamepadName(int gamepad)
     * }
     */
    public static MethodHandle GetGamepadName$handle() {
        return GetGamepadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *GetGamepadName(int gamepad)
     * }
     */
    public static MemorySegment GetGamepadName$address() {
        return GetGamepadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *GetGamepadName(int gamepad)
     * }
     */
    public static MemorySegment GetGamepadName(int gamepad) {
        var mh$ = GetGamepadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGamepadName", gamepad);
            }
            return (MemorySegment)mh$.invokeExact(gamepad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGamepadButtonPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGamepadButtonPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGamepadButtonPressed(int gamepad, int button)
     * }
     */
    public static FunctionDescriptor IsGamepadButtonPressed$descriptor() {
        return IsGamepadButtonPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGamepadButtonPressed(int gamepad, int button)
     * }
     */
    public static MethodHandle IsGamepadButtonPressed$handle() {
        return IsGamepadButtonPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGamepadButtonPressed(int gamepad, int button)
     * }
     */
    public static MemorySegment IsGamepadButtonPressed$address() {
        return IsGamepadButtonPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGamepadButtonPressed(int gamepad, int button)
     * }
     */
    public static boolean IsGamepadButtonPressed(int gamepad, int button) {
        var mh$ = IsGamepadButtonPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGamepadButtonPressed", gamepad, button);
            }
            return (boolean)mh$.invokeExact(gamepad, button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGamepadButtonDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGamepadButtonDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGamepadButtonDown(int gamepad, int button)
     * }
     */
    public static FunctionDescriptor IsGamepadButtonDown$descriptor() {
        return IsGamepadButtonDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGamepadButtonDown(int gamepad, int button)
     * }
     */
    public static MethodHandle IsGamepadButtonDown$handle() {
        return IsGamepadButtonDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGamepadButtonDown(int gamepad, int button)
     * }
     */
    public static MemorySegment IsGamepadButtonDown$address() {
        return IsGamepadButtonDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGamepadButtonDown(int gamepad, int button)
     * }
     */
    public static boolean IsGamepadButtonDown(int gamepad, int button) {
        var mh$ = IsGamepadButtonDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGamepadButtonDown", gamepad, button);
            }
            return (boolean)mh$.invokeExact(gamepad, button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGamepadButtonReleased {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGamepadButtonReleased");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGamepadButtonReleased(int gamepad, int button)
     * }
     */
    public static FunctionDescriptor IsGamepadButtonReleased$descriptor() {
        return IsGamepadButtonReleased.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGamepadButtonReleased(int gamepad, int button)
     * }
     */
    public static MethodHandle IsGamepadButtonReleased$handle() {
        return IsGamepadButtonReleased.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGamepadButtonReleased(int gamepad, int button)
     * }
     */
    public static MemorySegment IsGamepadButtonReleased$address() {
        return IsGamepadButtonReleased.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGamepadButtonReleased(int gamepad, int button)
     * }
     */
    public static boolean IsGamepadButtonReleased(int gamepad, int button) {
        var mh$ = IsGamepadButtonReleased.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGamepadButtonReleased", gamepad, button);
            }
            return (boolean)mh$.invokeExact(gamepad, button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGamepadButtonUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGamepadButtonUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGamepadButtonUp(int gamepad, int button)
     * }
     */
    public static FunctionDescriptor IsGamepadButtonUp$descriptor() {
        return IsGamepadButtonUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGamepadButtonUp(int gamepad, int button)
     * }
     */
    public static MethodHandle IsGamepadButtonUp$handle() {
        return IsGamepadButtonUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGamepadButtonUp(int gamepad, int button)
     * }
     */
    public static MemorySegment IsGamepadButtonUp$address() {
        return IsGamepadButtonUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGamepadButtonUp(int gamepad, int button)
     * }
     */
    public static boolean IsGamepadButtonUp(int gamepad, int button) {
        var mh$ = IsGamepadButtonUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGamepadButtonUp", gamepad, button);
            }
            return (boolean)mh$.invokeExact(gamepad, button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGamepadButtonPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGamepadButtonPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGamepadButtonPressed()
     * }
     */
    public static FunctionDescriptor GetGamepadButtonPressed$descriptor() {
        return GetGamepadButtonPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGamepadButtonPressed()
     * }
     */
    public static MethodHandle GetGamepadButtonPressed$handle() {
        return GetGamepadButtonPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGamepadButtonPressed()
     * }
     */
    public static MemorySegment GetGamepadButtonPressed$address() {
        return GetGamepadButtonPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGamepadButtonPressed()
     * }
     */
    public static int GetGamepadButtonPressed() {
        var mh$ = GetGamepadButtonPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGamepadButtonPressed");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGamepadAxisCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGamepadAxisCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGamepadAxisCount(int gamepad)
     * }
     */
    public static FunctionDescriptor GetGamepadAxisCount$descriptor() {
        return GetGamepadAxisCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGamepadAxisCount(int gamepad)
     * }
     */
    public static MethodHandle GetGamepadAxisCount$handle() {
        return GetGamepadAxisCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGamepadAxisCount(int gamepad)
     * }
     */
    public static MemorySegment GetGamepadAxisCount$address() {
        return GetGamepadAxisCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGamepadAxisCount(int gamepad)
     * }
     */
    public static int GetGamepadAxisCount(int gamepad) {
        var mh$ = GetGamepadAxisCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGamepadAxisCount", gamepad);
            }
            return (int)mh$.invokeExact(gamepad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGamepadAxisMovement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGamepadAxisMovement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetGamepadAxisMovement(int gamepad, int axis)
     * }
     */
    public static FunctionDescriptor GetGamepadAxisMovement$descriptor() {
        return GetGamepadAxisMovement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetGamepadAxisMovement(int gamepad, int axis)
     * }
     */
    public static MethodHandle GetGamepadAxisMovement$handle() {
        return GetGamepadAxisMovement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetGamepadAxisMovement(int gamepad, int axis)
     * }
     */
    public static MemorySegment GetGamepadAxisMovement$address() {
        return GetGamepadAxisMovement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetGamepadAxisMovement(int gamepad, int axis)
     * }
     */
    public static float GetGamepadAxisMovement(int gamepad, int axis) {
        var mh$ = GetGamepadAxisMovement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGamepadAxisMovement", gamepad, axis);
            }
            return (float)mh$.invokeExact(gamepad, axis);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGamepadMappings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetGamepadMappings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetGamepadMappings(const char *mappings)
     * }
     */
    public static FunctionDescriptor SetGamepadMappings$descriptor() {
        return SetGamepadMappings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetGamepadMappings(const char *mappings)
     * }
     */
    public static MethodHandle SetGamepadMappings$handle() {
        return SetGamepadMappings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetGamepadMappings(const char *mappings)
     * }
     */
    public static MemorySegment SetGamepadMappings$address() {
        return SetGamepadMappings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetGamepadMappings(const char *mappings)
     * }
     */
    public static int SetGamepadMappings(MemorySegment mappings) {
        var mh$ = SetGamepadMappings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGamepadMappings", mappings);
            }
            return (int)mh$.invokeExact(mappings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGamepadVibration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetGamepadVibration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor)
     * }
     */
    public static FunctionDescriptor SetGamepadVibration$descriptor() {
        return SetGamepadVibration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor)
     * }
     */
    public static MethodHandle SetGamepadVibration$handle() {
        return SetGamepadVibration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor)
     * }
     */
    public static MemorySegment SetGamepadVibration$address() {
        return SetGamepadVibration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor)
     * }
     */
    public static void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor) {
        var mh$ = SetGamepadVibration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGamepadVibration", gamepad, leftMotor, rightMotor);
            }
            mh$.invokeExact(gamepad, leftMotor, rightMotor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseButtonPressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMouseButtonPressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMouseButtonPressed(int button)
     * }
     */
    public static FunctionDescriptor IsMouseButtonPressed$descriptor() {
        return IsMouseButtonPressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMouseButtonPressed(int button)
     * }
     */
    public static MethodHandle IsMouseButtonPressed$handle() {
        return IsMouseButtonPressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMouseButtonPressed(int button)
     * }
     */
    public static MemorySegment IsMouseButtonPressed$address() {
        return IsMouseButtonPressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMouseButtonPressed(int button)
     * }
     */
    public static boolean IsMouseButtonPressed(int button) {
        var mh$ = IsMouseButtonPressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseButtonPressed", button);
            }
            return (boolean)mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseButtonDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMouseButtonDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMouseButtonDown(int button)
     * }
     */
    public static FunctionDescriptor IsMouseButtonDown$descriptor() {
        return IsMouseButtonDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMouseButtonDown(int button)
     * }
     */
    public static MethodHandle IsMouseButtonDown$handle() {
        return IsMouseButtonDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMouseButtonDown(int button)
     * }
     */
    public static MemorySegment IsMouseButtonDown$address() {
        return IsMouseButtonDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMouseButtonDown(int button)
     * }
     */
    public static boolean IsMouseButtonDown(int button) {
        var mh$ = IsMouseButtonDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseButtonDown", button);
            }
            return (boolean)mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseButtonReleased {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMouseButtonReleased");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMouseButtonReleased(int button)
     * }
     */
    public static FunctionDescriptor IsMouseButtonReleased$descriptor() {
        return IsMouseButtonReleased.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMouseButtonReleased(int button)
     * }
     */
    public static MethodHandle IsMouseButtonReleased$handle() {
        return IsMouseButtonReleased.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMouseButtonReleased(int button)
     * }
     */
    public static MemorySegment IsMouseButtonReleased$address() {
        return IsMouseButtonReleased.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMouseButtonReleased(int button)
     * }
     */
    public static boolean IsMouseButtonReleased(int button) {
        var mh$ = IsMouseButtonReleased.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseButtonReleased", button);
            }
            return (boolean)mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseButtonUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMouseButtonUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMouseButtonUp(int button)
     * }
     */
    public static FunctionDescriptor IsMouseButtonUp$descriptor() {
        return IsMouseButtonUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMouseButtonUp(int button)
     * }
     */
    public static MethodHandle IsMouseButtonUp$handle() {
        return IsMouseButtonUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMouseButtonUp(int button)
     * }
     */
    public static MemorySegment IsMouseButtonUp$address() {
        return IsMouseButtonUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMouseButtonUp(int button)
     * }
     */
    public static boolean IsMouseButtonUp(int button) {
        var mh$ = IsMouseButtonUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseButtonUp", button);
            }
            return (boolean)mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMouseX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseX()
     * }
     */
    public static FunctionDescriptor GetMouseX$descriptor() {
        return GetMouseX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseX()
     * }
     */
    public static MethodHandle GetMouseX$handle() {
        return GetMouseX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMouseX()
     * }
     */
    public static MemorySegment GetMouseX$address() {
        return GetMouseX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMouseX()
     * }
     */
    public static int GetMouseX() {
        var mh$ = GetMouseX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseX");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMouseY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseY()
     * }
     */
    public static FunctionDescriptor GetMouseY$descriptor() {
        return GetMouseY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseY()
     * }
     */
    public static MethodHandle GetMouseY$handle() {
        return GetMouseY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMouseY()
     * }
     */
    public static MemorySegment GetMouseY$address() {
        return GetMouseY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMouseY()
     * }
     */
    public static int GetMouseY() {
        var mh$ = GetMouseY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseY");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMousePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMousePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static FunctionDescriptor GetMousePosition$descriptor() {
        return GetMousePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MethodHandle GetMousePosition$handle() {
        return GetMousePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MemorySegment GetMousePosition$address() {
        return GetMousePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MemorySegment GetMousePosition(SegmentAllocator allocator) {
        var mh$ = GetMousePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMousePosition", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseDelta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMouseDelta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMouseDelta()
     * }
     */
    public static FunctionDescriptor GetMouseDelta$descriptor() {
        return GetMouseDelta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMouseDelta()
     * }
     */
    public static MethodHandle GetMouseDelta$handle() {
        return GetMouseDelta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMouseDelta()
     * }
     */
    public static MemorySegment GetMouseDelta$address() {
        return GetMouseDelta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMouseDelta()
     * }
     */
    public static MemorySegment GetMouseDelta(SegmentAllocator allocator) {
        var mh$ = GetMouseDelta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseDelta", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMousePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMousePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMousePosition(int x, int y)
     * }
     */
    public static FunctionDescriptor SetMousePosition$descriptor() {
        return SetMousePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMousePosition(int x, int y)
     * }
     */
    public static MethodHandle SetMousePosition$handle() {
        return SetMousePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMousePosition(int x, int y)
     * }
     */
    public static MemorySegment SetMousePosition$address() {
        return SetMousePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMousePosition(int x, int y)
     * }
     */
    public static void SetMousePosition(int x, int y) {
        var mh$ = SetMousePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMousePosition", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMouseOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMouseOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMouseOffset(int offsetX, int offsetY)
     * }
     */
    public static FunctionDescriptor SetMouseOffset$descriptor() {
        return SetMouseOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMouseOffset(int offsetX, int offsetY)
     * }
     */
    public static MethodHandle SetMouseOffset$handle() {
        return SetMouseOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMouseOffset(int offsetX, int offsetY)
     * }
     */
    public static MemorySegment SetMouseOffset$address() {
        return SetMouseOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMouseOffset(int offsetX, int offsetY)
     * }
     */
    public static void SetMouseOffset(int offsetX, int offsetY) {
        var mh$ = SetMouseOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMouseOffset", offsetX, offsetY);
            }
            mh$.invokeExact(offsetX, offsetY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMouseScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMouseScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMouseScale(float scaleX, float scaleY)
     * }
     */
    public static FunctionDescriptor SetMouseScale$descriptor() {
        return SetMouseScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMouseScale(float scaleX, float scaleY)
     * }
     */
    public static MethodHandle SetMouseScale$handle() {
        return SetMouseScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMouseScale(float scaleX, float scaleY)
     * }
     */
    public static MemorySegment SetMouseScale$address() {
        return SetMouseScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMouseScale(float scaleX, float scaleY)
     * }
     */
    public static void SetMouseScale(float scaleX, float scaleY) {
        var mh$ = SetMouseScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMouseScale", scaleX, scaleY);
            }
            mh$.invokeExact(scaleX, scaleY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseWheelMove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMouseWheelMove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMouseWheelMove()
     * }
     */
    public static FunctionDescriptor GetMouseWheelMove$descriptor() {
        return GetMouseWheelMove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMouseWheelMove()
     * }
     */
    public static MethodHandle GetMouseWheelMove$handle() {
        return GetMouseWheelMove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMouseWheelMove()
     * }
     */
    public static MemorySegment GetMouseWheelMove$address() {
        return GetMouseWheelMove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMouseWheelMove()
     * }
     */
    public static float GetMouseWheelMove() {
        var mh$ = GetMouseWheelMove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseWheelMove");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseWheelMoveV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMouseWheelMoveV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static FunctionDescriptor GetMouseWheelMoveV$descriptor() {
        return GetMouseWheelMoveV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MethodHandle GetMouseWheelMoveV$handle() {
        return GetMouseWheelMoveV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MemorySegment GetMouseWheelMoveV$address() {
        return GetMouseWheelMoveV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MemorySegment GetMouseWheelMoveV(SegmentAllocator allocator) {
        var mh$ = GetMouseWheelMoveV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseWheelMoveV", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMouseCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMouseCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMouseCursor(int cursor)
     * }
     */
    public static FunctionDescriptor SetMouseCursor$descriptor() {
        return SetMouseCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMouseCursor(int cursor)
     * }
     */
    public static MethodHandle SetMouseCursor$handle() {
        return SetMouseCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMouseCursor(int cursor)
     * }
     */
    public static MemorySegment SetMouseCursor$address() {
        return SetMouseCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMouseCursor(int cursor)
     * }
     */
    public static void SetMouseCursor(int cursor) {
        var mh$ = SetMouseCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMouseCursor", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTouchX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTouchX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTouchX()
     * }
     */
    public static FunctionDescriptor GetTouchX$descriptor() {
        return GetTouchX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTouchX()
     * }
     */
    public static MethodHandle GetTouchX$handle() {
        return GetTouchX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTouchX()
     * }
     */
    public static MemorySegment GetTouchX$address() {
        return GetTouchX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTouchX()
     * }
     */
    public static int GetTouchX() {
        var mh$ = GetTouchX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchX");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTouchY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTouchY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTouchY()
     * }
     */
    public static FunctionDescriptor GetTouchY$descriptor() {
        return GetTouchY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTouchY()
     * }
     */
    public static MethodHandle GetTouchY$handle() {
        return GetTouchY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTouchY()
     * }
     */
    public static MemorySegment GetTouchY$address() {
        return GetTouchY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTouchY()
     * }
     */
    public static int GetTouchY() {
        var mh$ = GetTouchY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchY");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTouchPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTouchPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetTouchPosition(int index)
     * }
     */
    public static FunctionDescriptor GetTouchPosition$descriptor() {
        return GetTouchPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetTouchPosition(int index)
     * }
     */
    public static MethodHandle GetTouchPosition$handle() {
        return GetTouchPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetTouchPosition(int index)
     * }
     */
    public static MemorySegment GetTouchPosition$address() {
        return GetTouchPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetTouchPosition(int index)
     * }
     */
    public static MemorySegment GetTouchPosition(SegmentAllocator allocator, int index) {
        var mh$ = GetTouchPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchPosition", allocator, index);
            }
            return (MemorySegment)mh$.invokeExact(allocator, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTouchPointId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTouchPointId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTouchPointId(int index)
     * }
     */
    public static FunctionDescriptor GetTouchPointId$descriptor() {
        return GetTouchPointId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTouchPointId(int index)
     * }
     */
    public static MethodHandle GetTouchPointId$handle() {
        return GetTouchPointId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTouchPointId(int index)
     * }
     */
    public static MemorySegment GetTouchPointId$address() {
        return GetTouchPointId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTouchPointId(int index)
     * }
     */
    public static int GetTouchPointId(int index) {
        var mh$ = GetTouchPointId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchPointId", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTouchPointCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetTouchPointCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTouchPointCount()
     * }
     */
    public static FunctionDescriptor GetTouchPointCount$descriptor() {
        return GetTouchPointCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTouchPointCount()
     * }
     */
    public static MethodHandle GetTouchPointCount$handle() {
        return GetTouchPointCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTouchPointCount()
     * }
     */
    public static MemorySegment GetTouchPointCount$address() {
        return GetTouchPointCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTouchPointCount()
     * }
     */
    public static int GetTouchPointCount() {
        var mh$ = GetTouchPointCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchPointCount");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGesturesEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetGesturesEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetGesturesEnabled(unsigned int flags)
     * }
     */
    public static FunctionDescriptor SetGesturesEnabled$descriptor() {
        return SetGesturesEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetGesturesEnabled(unsigned int flags)
     * }
     */
    public static MethodHandle SetGesturesEnabled$handle() {
        return SetGesturesEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetGesturesEnabled(unsigned int flags)
     * }
     */
    public static MemorySegment SetGesturesEnabled$address() {
        return SetGesturesEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetGesturesEnabled(unsigned int flags)
     * }
     */
    public static void SetGesturesEnabled(int flags) {
        var mh$ = SetGesturesEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGesturesEnabled", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGestureDetected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsGestureDetected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsGestureDetected(unsigned int gesture)
     * }
     */
    public static FunctionDescriptor IsGestureDetected$descriptor() {
        return IsGestureDetected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsGestureDetected(unsigned int gesture)
     * }
     */
    public static MethodHandle IsGestureDetected$handle() {
        return IsGestureDetected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsGestureDetected(unsigned int gesture)
     * }
     */
    public static MemorySegment IsGestureDetected$address() {
        return IsGestureDetected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsGestureDetected(unsigned int gesture)
     * }
     */
    public static boolean IsGestureDetected(int gesture) {
        var mh$ = IsGestureDetected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGestureDetected", gesture);
            }
            return (boolean)mh$.invokeExact(gesture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureDetected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGestureDetected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGestureDetected()
     * }
     */
    public static FunctionDescriptor GetGestureDetected$descriptor() {
        return GetGestureDetected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGestureDetected()
     * }
     */
    public static MethodHandle GetGestureDetected$handle() {
        return GetGestureDetected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGestureDetected()
     * }
     */
    public static MemorySegment GetGestureDetected$address() {
        return GetGestureDetected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGestureDetected()
     * }
     */
    public static int GetGestureDetected() {
        var mh$ = GetGestureDetected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureDetected");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureHoldDuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGestureHoldDuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetGestureHoldDuration()
     * }
     */
    public static FunctionDescriptor GetGestureHoldDuration$descriptor() {
        return GetGestureHoldDuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetGestureHoldDuration()
     * }
     */
    public static MethodHandle GetGestureHoldDuration$handle() {
        return GetGestureHoldDuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetGestureHoldDuration()
     * }
     */
    public static MemorySegment GetGestureHoldDuration$address() {
        return GetGestureHoldDuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetGestureHoldDuration()
     * }
     */
    public static float GetGestureHoldDuration() {
        var mh$ = GetGestureHoldDuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureHoldDuration");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureDragVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGestureDragVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetGestureDragVector()
     * }
     */
    public static FunctionDescriptor GetGestureDragVector$descriptor() {
        return GetGestureDragVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetGestureDragVector()
     * }
     */
    public static MethodHandle GetGestureDragVector$handle() {
        return GetGestureDragVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetGestureDragVector()
     * }
     */
    public static MemorySegment GetGestureDragVector$address() {
        return GetGestureDragVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetGestureDragVector()
     * }
     */
    public static MemorySegment GetGestureDragVector(SegmentAllocator allocator) {
        var mh$ = GetGestureDragVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureDragVector", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureDragAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGestureDragAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetGestureDragAngle()
     * }
     */
    public static FunctionDescriptor GetGestureDragAngle$descriptor() {
        return GetGestureDragAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetGestureDragAngle()
     * }
     */
    public static MethodHandle GetGestureDragAngle$handle() {
        return GetGestureDragAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetGestureDragAngle()
     * }
     */
    public static MemorySegment GetGestureDragAngle$address() {
        return GetGestureDragAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetGestureDragAngle()
     * }
     */
    public static float GetGestureDragAngle() {
        var mh$ = GetGestureDragAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureDragAngle");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGesturePinchVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGesturePinchVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetGesturePinchVector()
     * }
     */
    public static FunctionDescriptor GetGesturePinchVector$descriptor() {
        return GetGesturePinchVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetGesturePinchVector()
     * }
     */
    public static MethodHandle GetGesturePinchVector$handle() {
        return GetGesturePinchVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetGesturePinchVector()
     * }
     */
    public static MemorySegment GetGesturePinchVector$address() {
        return GetGesturePinchVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetGesturePinchVector()
     * }
     */
    public static MemorySegment GetGesturePinchVector(SegmentAllocator allocator) {
        var mh$ = GetGesturePinchVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGesturePinchVector", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGesturePinchAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGesturePinchAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetGesturePinchAngle()
     * }
     */
    public static FunctionDescriptor GetGesturePinchAngle$descriptor() {
        return GetGesturePinchAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetGesturePinchAngle()
     * }
     */
    public static MethodHandle GetGesturePinchAngle$handle() {
        return GetGesturePinchAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetGesturePinchAngle()
     * }
     */
    public static MemorySegment GetGesturePinchAngle$address() {
        return GetGesturePinchAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetGesturePinchAngle()
     * }
     */
    public static float GetGesturePinchAngle() {
        var mh$ = GetGesturePinchAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGesturePinchAngle");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateCamera {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateCamera");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateCamera(Camera *camera, int mode)
     * }
     */
    public static FunctionDescriptor UpdateCamera$descriptor() {
        return UpdateCamera.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateCamera(Camera *camera, int mode)
     * }
     */
    public static MethodHandle UpdateCamera$handle() {
        return UpdateCamera.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateCamera(Camera *camera, int mode)
     * }
     */
    public static MemorySegment UpdateCamera$address() {
        return UpdateCamera.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateCamera(Camera *camera, int mode)
     * }
     */
    public static void UpdateCamera(MemorySegment camera, int mode) {
        var mh$ = UpdateCamera.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateCamera", camera, mode);
            }
            mh$.invokeExact(camera, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateCameraPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateCameraPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom)
     * }
     */
    public static FunctionDescriptor UpdateCameraPro$descriptor() {
        return UpdateCameraPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom)
     * }
     */
    public static MethodHandle UpdateCameraPro$handle() {
        return UpdateCameraPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom)
     * }
     */
    public static MemorySegment UpdateCameraPro$address() {
        return UpdateCameraPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom)
     * }
     */
    public static void UpdateCameraPro(MemorySegment camera, MemorySegment movement, MemorySegment rotation, float zoom) {
        var mh$ = UpdateCameraPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateCameraPro", camera, movement, rotation, zoom);
            }
            mh$.invokeExact(camera, movement, rotation, zoom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetShapesTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetShapesTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetShapesTexture(Texture2D texture, Rectangle source)
     * }
     */
    public static FunctionDescriptor SetShapesTexture$descriptor() {
        return SetShapesTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetShapesTexture(Texture2D texture, Rectangle source)
     * }
     */
    public static MethodHandle SetShapesTexture$handle() {
        return SetShapesTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetShapesTexture(Texture2D texture, Rectangle source)
     * }
     */
    public static MemorySegment SetShapesTexture$address() {
        return SetShapesTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetShapesTexture(Texture2D texture, Rectangle source)
     * }
     */
    public static void SetShapesTexture(MemorySegment texture, MemorySegment source) {
        var mh$ = SetShapesTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetShapesTexture", texture, source);
            }
            mh$.invokeExact(texture, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShapesTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetShapesTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Texture2D GetShapesTexture()
     * }
     */
    public static FunctionDescriptor GetShapesTexture$descriptor() {
        return GetShapesTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Texture2D GetShapesTexture()
     * }
     */
    public static MethodHandle GetShapesTexture$handle() {
        return GetShapesTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Texture2D GetShapesTexture()
     * }
     */
    public static MemorySegment GetShapesTexture$address() {
        return GetShapesTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Texture2D GetShapesTexture()
     * }
     */
    public static MemorySegment GetShapesTexture(SegmentAllocator allocator) {
        var mh$ = GetShapesTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShapesTexture", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShapesTextureRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetShapesTextureRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetShapesTextureRectangle()
     * }
     */
    public static FunctionDescriptor GetShapesTextureRectangle$descriptor() {
        return GetShapesTextureRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetShapesTextureRectangle()
     * }
     */
    public static MethodHandle GetShapesTextureRectangle$handle() {
        return GetShapesTextureRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetShapesTextureRectangle()
     * }
     */
    public static MemorySegment GetShapesTextureRectangle$address() {
        return GetShapesTextureRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetShapesTextureRectangle()
     * }
     */
    public static MemorySegment GetShapesTextureRectangle(SegmentAllocator allocator) {
        var mh$ = GetShapesTextureRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShapesTextureRectangle", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPixel(int posX, int posY, Color color)
     * }
     */
    public static FunctionDescriptor DrawPixel$descriptor() {
        return DrawPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPixel(int posX, int posY, Color color)
     * }
     */
    public static MethodHandle DrawPixel$handle() {
        return DrawPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPixel(int posX, int posY, Color color)
     * }
     */
    public static MemorySegment DrawPixel$address() {
        return DrawPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPixel(int posX, int posY, Color color)
     * }
     */
    public static void DrawPixel(int posX, int posY, MemorySegment color) {
        var mh$ = DrawPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPixel", posX, posY, color);
            }
            mh$.invokeExact(posX, posY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPixelV(Vector2 position, Color color)
     * }
     */
    public static FunctionDescriptor DrawPixelV$descriptor() {
        return DrawPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPixelV(Vector2 position, Color color)
     * }
     */
    public static MethodHandle DrawPixelV$handle() {
        return DrawPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPixelV(Vector2 position, Color color)
     * }
     */
    public static MemorySegment DrawPixelV$address() {
        return DrawPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPixelV(Vector2 position, Color color)
     * }
     */
    public static void DrawPixelV(MemorySegment position, MemorySegment color) {
        var mh$ = DrawPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPixelV", position, color);
            }
            mh$.invokeExact(position, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static FunctionDescriptor DrawLine$descriptor() {
        return DrawLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MethodHandle DrawLine$handle() {
        return DrawLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MemorySegment DrawLine$address() {
        return DrawLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, MemorySegment color) {
        var mh$ = DrawLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLine", startPosX, startPosY, endPosX, endPosY, color);
            }
            mh$.invokeExact(startPosX, startPosY, endPosX, endPosY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLineV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLineV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLineV(Vector2 startPos, Vector2 endPos, Color color)
     * }
     */
    public static FunctionDescriptor DrawLineV$descriptor() {
        return DrawLineV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLineV(Vector2 startPos, Vector2 endPos, Color color)
     * }
     */
    public static MethodHandle DrawLineV$handle() {
        return DrawLineV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLineV(Vector2 startPos, Vector2 endPos, Color color)
     * }
     */
    public static MemorySegment DrawLineV$address() {
        return DrawLineV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLineV(Vector2 startPos, Vector2 endPos, Color color)
     * }
     */
    public static void DrawLineV(MemorySegment startPos, MemorySegment endPos, MemorySegment color) {
        var mh$ = DrawLineV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLineV", startPos, endPos, color);
            }
            mh$.invokeExact(startPos, endPos, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLineEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLineEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawLineEx$descriptor() {
        return DrawLineEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static MethodHandle DrawLineEx$handle() {
        return DrawLineEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static MemorySegment DrawLineEx$address() {
        return DrawLineEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static void DrawLineEx(MemorySegment startPos, MemorySegment endPos, float thick, MemorySegment color) {
        var mh$ = DrawLineEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLineEx", startPos, endPos, thick, color);
            }
            mh$.invokeExact(startPos, endPos, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLineStrip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLineStrip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLineStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static FunctionDescriptor DrawLineStrip$descriptor() {
        return DrawLineStrip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLineStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MethodHandle DrawLineStrip$handle() {
        return DrawLineStrip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLineStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MemorySegment DrawLineStrip$address() {
        return DrawLineStrip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLineStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static void DrawLineStrip(MemorySegment points, int pointCount, MemorySegment color) {
        var mh$ = DrawLineStrip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLineStrip", points, pointCount, color);
            }
            mh$.invokeExact(points, pointCount, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLineBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLineBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawLineBezier$descriptor() {
        return DrawLineBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static MethodHandle DrawLineBezier$handle() {
        return DrawLineBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static MemorySegment DrawLineBezier$address() {
        return DrawLineBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color)
     * }
     */
    public static void DrawLineBezier(MemorySegment startPos, MemorySegment endPos, float thick, MemorySegment color) {
        var mh$ = DrawLineBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLineBezier", startPos, endPos, thick, color);
            }
            mh$.invokeExact(startPos, endPos, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircle(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircle$descriptor() {
        return DrawCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircle(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static MethodHandle DrawCircle$handle() {
        return DrawCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircle(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static MemorySegment DrawCircle$address() {
        return DrawCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircle(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static void DrawCircle(int centerX, int centerY, float radius, MemorySegment color) {
        var mh$ = DrawCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircle", centerX, centerY, radius, color);
            }
            mh$.invokeExact(centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleSector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleSector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircleSector$descriptor() {
        return DrawCircleSector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MethodHandle DrawCircleSector$handle() {
        return DrawCircleSector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MemorySegment DrawCircleSector$address() {
        return DrawCircleSector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static void DrawCircleSector(MemorySegment center, float radius, float startAngle, float endAngle, int segments, MemorySegment color) {
        var mh$ = DrawCircleSector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleSector", center, radius, startAngle, endAngle, segments, color);
            }
            mh$.invokeExact(center, radius, startAngle, endAngle, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleSectorLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleSectorLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircleSectorLines$descriptor() {
        return DrawCircleSectorLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MethodHandle DrawCircleSectorLines$handle() {
        return DrawCircleSectorLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MemorySegment DrawCircleSectorLines$address() {
        return DrawCircleSectorLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static void DrawCircleSectorLines(MemorySegment center, float radius, float startAngle, float endAngle, int segments, MemorySegment color) {
        var mh$ = DrawCircleSectorLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleSectorLines", center, radius, startAngle, endAngle, segments, color);
            }
            mh$.invokeExact(center, radius, startAngle, endAngle, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleGradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleGradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2)
     * }
     */
    public static FunctionDescriptor DrawCircleGradient$descriptor() {
        return DrawCircleGradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2)
     * }
     */
    public static MethodHandle DrawCircleGradient$handle() {
        return DrawCircleGradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2)
     * }
     */
    public static MemorySegment DrawCircleGradient$address() {
        return DrawCircleGradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2)
     * }
     */
    public static void DrawCircleGradient(int centerX, int centerY, float radius, MemorySegment color1, MemorySegment color2) {
        var mh$ = DrawCircleGradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleGradient", centerX, centerY, radius, color1, color2);
            }
            mh$.invokeExact(centerX, centerY, radius, color1, color2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleV(Vector2 center, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircleV$descriptor() {
        return DrawCircleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleV(Vector2 center, float radius, Color color)
     * }
     */
    public static MethodHandle DrawCircleV$handle() {
        return DrawCircleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleV(Vector2 center, float radius, Color color)
     * }
     */
    public static MemorySegment DrawCircleV$address() {
        return DrawCircleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleV(Vector2 center, float radius, Color color)
     * }
     */
    public static void DrawCircleV(MemorySegment center, float radius, MemorySegment color) {
        var mh$ = DrawCircleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleV", center, radius, color);
            }
            mh$.invokeExact(center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleLines(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircleLines$descriptor() {
        return DrawCircleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleLines(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static MethodHandle DrawCircleLines$handle() {
        return DrawCircleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleLines(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static MemorySegment DrawCircleLines$address() {
        return DrawCircleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleLines(int centerX, int centerY, float radius, Color color)
     * }
     */
    public static void DrawCircleLines(int centerX, int centerY, float radius, MemorySegment color) {
        var mh$ = DrawCircleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleLines", centerX, centerY, radius, color);
            }
            mh$.invokeExact(centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircleLinesV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircleLinesV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircleLinesV(Vector2 center, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircleLinesV$descriptor() {
        return DrawCircleLinesV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircleLinesV(Vector2 center, float radius, Color color)
     * }
     */
    public static MethodHandle DrawCircleLinesV$handle() {
        return DrawCircleLinesV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircleLinesV(Vector2 center, float radius, Color color)
     * }
     */
    public static MemorySegment DrawCircleLinesV$address() {
        return DrawCircleLinesV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircleLinesV(Vector2 center, float radius, Color color)
     * }
     */
    public static void DrawCircleLinesV(MemorySegment center, float radius, MemorySegment color) {
        var mh$ = DrawCircleLinesV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircleLinesV", center, radius, color);
            }
            mh$.invokeExact(center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEllipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawEllipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static FunctionDescriptor DrawEllipse$descriptor() {
        return DrawEllipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static MethodHandle DrawEllipse$handle() {
        return DrawEllipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static MemorySegment DrawEllipse$address() {
        return DrawEllipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, MemorySegment color) {
        var mh$ = DrawEllipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEllipse", centerX, centerY, radiusH, radiusV, color);
            }
            mh$.invokeExact(centerX, centerY, radiusH, radiusV, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEllipseLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawEllipseLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static FunctionDescriptor DrawEllipseLines$descriptor() {
        return DrawEllipseLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static MethodHandle DrawEllipseLines$handle() {
        return DrawEllipseLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static MemorySegment DrawEllipseLines$address() {
        return DrawEllipseLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color)
     * }
     */
    public static void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, MemorySegment color) {
        var mh$ = DrawEllipseLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEllipseLines", centerX, centerY, radiusH, radiusV, color);
            }
            mh$.invokeExact(centerX, centerY, radiusH, radiusV, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRing$descriptor() {
        return DrawRing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRing$handle() {
        return DrawRing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRing$address() {
        return DrawRing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static void DrawRing(MemorySegment center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, MemorySegment color) {
        var mh$ = DrawRing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRing", center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
            }
            mh$.invokeExact(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRingLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRingLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRingLines$descriptor() {
        return DrawRingLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRingLines$handle() {
        return DrawRingLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRingLines$address() {
        return DrawRingLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static void DrawRingLines(MemorySegment center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, MemorySegment color) {
        var mh$ = DrawRingLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRingLines", center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
            }
            mh$.invokeExact(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangle$descriptor() {
        return DrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MethodHandle DrawRectangle$handle() {
        return DrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MemorySegment DrawRectangle$address() {
        return DrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static void DrawRectangle(int posX, int posY, int width, int height, MemorySegment color) {
        var mh$ = DrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangle", posX, posY, width, height, color);
            }
            mh$.invokeExact(posX, posY, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleV(Vector2 position, Vector2 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleV$descriptor() {
        return DrawRectangleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleV(Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MethodHandle DrawRectangleV$handle() {
        return DrawRectangleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleV(Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MemorySegment DrawRectangleV$address() {
        return DrawRectangleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleV(Vector2 position, Vector2 size, Color color)
     * }
     */
    public static void DrawRectangleV(MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = DrawRectangleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleV", position, size, color);
            }
            mh$.invokeExact(position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleRec(Rectangle rec, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleRec$descriptor() {
        return DrawRectangleRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleRec(Rectangle rec, Color color)
     * }
     */
    public static MethodHandle DrawRectangleRec$handle() {
        return DrawRectangleRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleRec(Rectangle rec, Color color)
     * }
     */
    public static MemorySegment DrawRectangleRec$address() {
        return DrawRectangleRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleRec(Rectangle rec, Color color)
     * }
     */
    public static void DrawRectangleRec(MemorySegment rec, MemorySegment color) {
        var mh$ = DrawRectangleRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleRec", rec, color);
            }
            mh$.invokeExact(rec, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectanglePro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectanglePro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectanglePro$descriptor() {
        return DrawRectanglePro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color)
     * }
     */
    public static MethodHandle DrawRectanglePro$handle() {
        return DrawRectanglePro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color)
     * }
     */
    public static MemorySegment DrawRectanglePro$address() {
        return DrawRectanglePro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color)
     * }
     */
    public static void DrawRectanglePro(MemorySegment rec, MemorySegment origin, float rotation, MemorySegment color) {
        var mh$ = DrawRectanglePro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectanglePro", rec, origin, rotation, color);
            }
            mh$.invokeExact(rec, origin, rotation, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleGradientV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleGradientV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static FunctionDescriptor DrawRectangleGradientV$descriptor() {
        return DrawRectangleGradientV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static MethodHandle DrawRectangleGradientV$handle() {
        return DrawRectangleGradientV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static MemorySegment DrawRectangleGradientV$address() {
        return DrawRectangleGradientV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static void DrawRectangleGradientV(int posX, int posY, int width, int height, MemorySegment color1, MemorySegment color2) {
        var mh$ = DrawRectangleGradientV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleGradientV", posX, posY, width, height, color1, color2);
            }
            mh$.invokeExact(posX, posY, width, height, color1, color2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleGradientH {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleGradientH");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static FunctionDescriptor DrawRectangleGradientH$descriptor() {
        return DrawRectangleGradientH.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static MethodHandle DrawRectangleGradientH$handle() {
        return DrawRectangleGradientH.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static MemorySegment DrawRectangleGradientH$address() {
        return DrawRectangleGradientH.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2)
     * }
     */
    public static void DrawRectangleGradientH(int posX, int posY, int width, int height, MemorySegment color1, MemorySegment color2) {
        var mh$ = DrawRectangleGradientH.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleGradientH", posX, posY, width, height, color1, color2);
            }
            mh$.invokeExact(posX, posY, width, height, color1, color2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleGradientEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            Color.layout(),
            Color.layout(),
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleGradientEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4)
     * }
     */
    public static FunctionDescriptor DrawRectangleGradientEx$descriptor() {
        return DrawRectangleGradientEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4)
     * }
     */
    public static MethodHandle DrawRectangleGradientEx$handle() {
        return DrawRectangleGradientEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4)
     * }
     */
    public static MemorySegment DrawRectangleGradientEx$address() {
        return DrawRectangleGradientEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4)
     * }
     */
    public static void DrawRectangleGradientEx(MemorySegment rec, MemorySegment col1, MemorySegment col2, MemorySegment col3, MemorySegment col4) {
        var mh$ = DrawRectangleGradientEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleGradientEx", rec, col1, col2, col3, col4);
            }
            mh$.invokeExact(rec, col1, col2, col3, col4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleLines(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleLines$descriptor() {
        return DrawRectangleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleLines(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MethodHandle DrawRectangleLines$handle() {
        return DrawRectangleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleLines(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MemorySegment DrawRectangleLines$address() {
        return DrawRectangleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleLines(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static void DrawRectangleLines(int posX, int posY, int width, int height, MemorySegment color) {
        var mh$ = DrawRectangleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleLines", posX, posY, width, height, color);
            }
            mh$.invokeExact(posX, posY, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleLinesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleLinesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleLinesEx$descriptor() {
        return DrawRectangleLinesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)
     * }
     */
    public static MethodHandle DrawRectangleLinesEx$handle() {
        return DrawRectangleLinesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)
     * }
     */
    public static MemorySegment DrawRectangleLinesEx$address() {
        return DrawRectangleLinesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)
     * }
     */
    public static void DrawRectangleLinesEx(MemorySegment rec, float lineThick, MemorySegment color) {
        var mh$ = DrawRectangleLinesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleLinesEx", rec, lineThick, color);
            }
            mh$.invokeExact(rec, lineThick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleRounded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleRounded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleRounded$descriptor() {
        return DrawRectangleRounded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRectangleRounded$handle() {
        return DrawRectangleRounded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRectangleRounded$address() {
        return DrawRectangleRounded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static void DrawRectangleRounded(MemorySegment rec, float roundness, int segments, MemorySegment color) {
        var mh$ = DrawRectangleRounded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleRounded", rec, roundness, segments, color);
            }
            mh$.invokeExact(rec, roundness, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleRoundedLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleRoundedLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleRoundedLines$descriptor() {
        return DrawRectangleRoundedLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRectangleRoundedLines$handle() {
        return DrawRectangleRoundedLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRectangleRoundedLines$address() {
        return DrawRectangleRoundedLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static void DrawRectangleRoundedLines(MemorySegment rec, float roundness, int segments, MemorySegment color) {
        var mh$ = DrawRectangleRoundedLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleRoundedLines", rec, roundness, segments, color);
            }
            mh$.invokeExact(rec, roundness, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleRoundedLinesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rectangle.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRectangleRoundedLinesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLinesEx(Rectangle rec, float roundness, int segments, float lineThick, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleRoundedLinesEx$descriptor() {
        return DrawRectangleRoundedLinesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLinesEx(Rectangle rec, float roundness, int segments, float lineThick, Color color)
     * }
     */
    public static MethodHandle DrawRectangleRoundedLinesEx$handle() {
        return DrawRectangleRoundedLinesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleRoundedLinesEx(Rectangle rec, float roundness, int segments, float lineThick, Color color)
     * }
     */
    public static MemorySegment DrawRectangleRoundedLinesEx$address() {
        return DrawRectangleRoundedLinesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleRoundedLinesEx(Rectangle rec, float roundness, int segments, float lineThick, Color color)
     * }
     */
    public static void DrawRectangleRoundedLinesEx(MemorySegment rec, float roundness, int segments, float lineThick, MemorySegment color) {
        var mh$ = DrawRectangleRoundedLinesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleRoundedLinesEx", rec, roundness, segments, lineThick, color);
            }
            mh$.invokeExact(rec, roundness, segments, lineThick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangle$descriptor() {
        return DrawTriangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static MethodHandle DrawTriangle$handle() {
        return DrawTriangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static MemorySegment DrawTriangle$address() {
        return DrawTriangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static void DrawTriangle(MemorySegment v1, MemorySegment v2, MemorySegment v3, MemorySegment color) {
        var mh$ = DrawTriangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangle", v1, v2, v3, color);
            }
            mh$.invokeExact(v1, v2, v3, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangleLines$descriptor() {
        return DrawTriangleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static MethodHandle DrawTriangleLines$handle() {
        return DrawTriangleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static MemorySegment DrawTriangleLines$address() {
        return DrawTriangleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color)
     * }
     */
    public static void DrawTriangleLines(MemorySegment v1, MemorySegment v2, MemorySegment v3, MemorySegment color) {
        var mh$ = DrawTriangleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangleLines", v1, v2, v3, color);
            }
            mh$.invokeExact(v1, v2, v3, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangleFan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangleFan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangleFan(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangleFan$descriptor() {
        return DrawTriangleFan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangleFan(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MethodHandle DrawTriangleFan$handle() {
        return DrawTriangleFan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangleFan(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MemorySegment DrawTriangleFan$address() {
        return DrawTriangleFan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangleFan(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static void DrawTriangleFan(MemorySegment points, int pointCount, MemorySegment color) {
        var mh$ = DrawTriangleFan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangleFan", points, pointCount, color);
            }
            mh$.invokeExact(points, pointCount, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangleStrip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangleStrip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangleStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangleStrip$descriptor() {
        return DrawTriangleStrip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangleStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MethodHandle DrawTriangleStrip$handle() {
        return DrawTriangleStrip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangleStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static MemorySegment DrawTriangleStrip$address() {
        return DrawTriangleStrip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangleStrip(Vector2 *points, int pointCount, Color color)
     * }
     */
    public static void DrawTriangleStrip(MemorySegment points, int pointCount, MemorySegment color) {
        var mh$ = DrawTriangleStrip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangleStrip", points, pointCount, color);
            }
            mh$.invokeExact(points, pointCount, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static FunctionDescriptor DrawPoly$descriptor() {
        return DrawPoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static MethodHandle DrawPoly$handle() {
        return DrawPoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static MemorySegment DrawPoly$address() {
        return DrawPoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static void DrawPoly(MemorySegment center, int sides, float radius, float rotation, MemorySegment color) {
        var mh$ = DrawPoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPoly", center, sides, radius, rotation, color);
            }
            mh$.invokeExact(center, sides, radius, rotation, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPolyLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPolyLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static FunctionDescriptor DrawPolyLines$descriptor() {
        return DrawPolyLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static MethodHandle DrawPolyLines$handle() {
        return DrawPolyLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static MemorySegment DrawPolyLines$address() {
        return DrawPolyLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color)
     * }
     */
    public static void DrawPolyLines(MemorySegment center, int sides, float radius, float rotation, MemorySegment color) {
        var mh$ = DrawPolyLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPolyLines", center, sides, radius, rotation, color);
            }
            mh$.invokeExact(center, sides, radius, rotation, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPolyLinesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            raylib.C_INT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPolyLinesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color)
     * }
     */
    public static FunctionDescriptor DrawPolyLinesEx$descriptor() {
        return DrawPolyLinesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color)
     * }
     */
    public static MethodHandle DrawPolyLinesEx$handle() {
        return DrawPolyLinesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color)
     * }
     */
    public static MemorySegment DrawPolyLinesEx$address() {
        return DrawPolyLinesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color)
     * }
     */
    public static void DrawPolyLinesEx(MemorySegment center, int sides, float radius, float rotation, float lineThick, MemorySegment color) {
        var mh$ = DrawPolyLinesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPolyLinesEx", center, sides, radius, rotation, lineThick, color);
            }
            mh$.invokeExact(center, sides, radius, rotation, lineThick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineLinear$descriptor() {
        return DrawSplineLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineLinear$handle() {
        return DrawSplineLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineLinear$address() {
        return DrawSplineLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static void DrawSplineLinear(MemorySegment points, int pointCount, float thick, MemorySegment color) {
        var mh$ = DrawSplineLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineLinear", points, pointCount, thick, color);
            }
            mh$.invokeExact(points, pointCount, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineBasis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineBasis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineBasis$descriptor() {
        return DrawSplineBasis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineBasis$handle() {
        return DrawSplineBasis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineBasis$address() {
        return DrawSplineBasis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static void DrawSplineBasis(MemorySegment points, int pointCount, float thick, MemorySegment color) {
        var mh$ = DrawSplineBasis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineBasis", points, pointCount, thick, color);
            }
            mh$.invokeExact(points, pointCount, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineCatmullRom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineCatmullRom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineCatmullRom$descriptor() {
        return DrawSplineCatmullRom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineCatmullRom$handle() {
        return DrawSplineCatmullRom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineCatmullRom$address() {
        return DrawSplineCatmullRom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static void DrawSplineCatmullRom(MemorySegment points, int pointCount, float thick, MemorySegment color) {
        var mh$ = DrawSplineCatmullRom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineCatmullRom", points, pointCount, thick, color);
            }
            mh$.invokeExact(points, pointCount, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineBezierQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineBezierQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineBezierQuadratic$descriptor() {
        return DrawSplineBezierQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineBezierQuadratic$handle() {
        return DrawSplineBezierQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineBezierQuadratic$address() {
        return DrawSplineBezierQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static void DrawSplineBezierQuadratic(MemorySegment points, int pointCount, float thick, MemorySegment color) {
        var mh$ = DrawSplineBezierQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineBezierQuadratic", points, pointCount, thick, color);
            }
            mh$.invokeExact(points, pointCount, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineBezierCubic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineBezierCubic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineBezierCubic$descriptor() {
        return DrawSplineBezierCubic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineBezierCubic$handle() {
        return DrawSplineBezierCubic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineBezierCubic$address() {
        return DrawSplineBezierCubic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color)
     * }
     */
    public static void DrawSplineBezierCubic(MemorySegment points, int pointCount, float thick, MemorySegment color) {
        var mh$ = DrawSplineBezierCubic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineBezierCubic", points, pointCount, thick, color);
            }
            mh$.invokeExact(points, pointCount, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineSegmentLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineSegmentLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineSegmentLinear$descriptor() {
        return DrawSplineSegmentLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineSegmentLinear$handle() {
        return DrawSplineSegmentLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineSegmentLinear$address() {
        return DrawSplineSegmentLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color)
     * }
     */
    public static void DrawSplineSegmentLinear(MemorySegment p1, MemorySegment p2, float thick, MemorySegment color) {
        var mh$ = DrawSplineSegmentLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineSegmentLinear", p1, p2, thick, color);
            }
            mh$.invokeExact(p1, p2, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineSegmentBasis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineSegmentBasis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineSegmentBasis$descriptor() {
        return DrawSplineSegmentBasis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineSegmentBasis$handle() {
        return DrawSplineSegmentBasis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineSegmentBasis$address() {
        return DrawSplineSegmentBasis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static void DrawSplineSegmentBasis(MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4, float thick, MemorySegment color) {
        var mh$ = DrawSplineSegmentBasis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineSegmentBasis", p1, p2, p3, p4, thick, color);
            }
            mh$.invokeExact(p1, p2, p3, p4, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineSegmentCatmullRom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineSegmentCatmullRom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineSegmentCatmullRom$descriptor() {
        return DrawSplineSegmentCatmullRom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineSegmentCatmullRom$handle() {
        return DrawSplineSegmentCatmullRom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineSegmentCatmullRom$address() {
        return DrawSplineSegmentCatmullRom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color)
     * }
     */
    public static void DrawSplineSegmentCatmullRom(MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4, float thick, MemorySegment color) {
        var mh$ = DrawSplineSegmentCatmullRom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineSegmentCatmullRom", p1, p2, p3, p4, thick, color);
            }
            mh$.invokeExact(p1, p2, p3, p4, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineSegmentBezierQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineSegmentBezierQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineSegmentBezierQuadratic$descriptor() {
        return DrawSplineSegmentBezierQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineSegmentBezierQuadratic$handle() {
        return DrawSplineSegmentBezierQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineSegmentBezierQuadratic$address() {
        return DrawSplineSegmentBezierQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color)
     * }
     */
    public static void DrawSplineSegmentBezierQuadratic(MemorySegment p1, MemorySegment c2, MemorySegment p3, float thick, MemorySegment color) {
        var mh$ = DrawSplineSegmentBezierQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineSegmentBezierQuadratic", p1, c2, p3, thick, color);
            }
            mh$.invokeExact(p1, c2, p3, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSplineSegmentBezierCubic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSplineSegmentBezierCubic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color)
     * }
     */
    public static FunctionDescriptor DrawSplineSegmentBezierCubic$descriptor() {
        return DrawSplineSegmentBezierCubic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MethodHandle DrawSplineSegmentBezierCubic$handle() {
        return DrawSplineSegmentBezierCubic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color)
     * }
     */
    public static MemorySegment DrawSplineSegmentBezierCubic$address() {
        return DrawSplineSegmentBezierCubic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color)
     * }
     */
    public static void DrawSplineSegmentBezierCubic(MemorySegment p1, MemorySegment c2, MemorySegment c3, MemorySegment p4, float thick, MemorySegment color) {
        var mh$ = DrawSplineSegmentBezierCubic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSplineSegmentBezierCubic", p1, c2, c3, p4, thick, color);
            }
            mh$.invokeExact(p1, c2, c3, p4, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSplinePointLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetSplinePointLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t)
     * }
     */
    public static FunctionDescriptor GetSplinePointLinear$descriptor() {
        return GetSplinePointLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t)
     * }
     */
    public static MethodHandle GetSplinePointLinear$handle() {
        return GetSplinePointLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t)
     * }
     */
    public static MemorySegment GetSplinePointLinear$address() {
        return GetSplinePointLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t)
     * }
     */
    public static MemorySegment GetSplinePointLinear(SegmentAllocator allocator, MemorySegment startPos, MemorySegment endPos, float t) {
        var mh$ = GetSplinePointLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSplinePointLinear", allocator, startPos, endPos, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, startPos, endPos, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSplinePointBasis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetSplinePointBasis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static FunctionDescriptor GetSplinePointBasis$descriptor() {
        return GetSplinePointBasis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MethodHandle GetSplinePointBasis$handle() {
        return GetSplinePointBasis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointBasis$address() {
        return GetSplinePointBasis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointBasis(SegmentAllocator allocator, MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4, float t) {
        var mh$ = GetSplinePointBasis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSplinePointBasis", allocator, p1, p2, p3, p4, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p1, p2, p3, p4, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSplinePointCatmullRom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetSplinePointCatmullRom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static FunctionDescriptor GetSplinePointCatmullRom$descriptor() {
        return GetSplinePointCatmullRom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MethodHandle GetSplinePointCatmullRom$handle() {
        return GetSplinePointCatmullRom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointCatmullRom$address() {
        return GetSplinePointCatmullRom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointCatmullRom(SegmentAllocator allocator, MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4, float t) {
        var mh$ = GetSplinePointCatmullRom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSplinePointCatmullRom", allocator, p1, p2, p3, p4, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p1, p2, p3, p4, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSplinePointBezierQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetSplinePointBezierQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t)
     * }
     */
    public static FunctionDescriptor GetSplinePointBezierQuad$descriptor() {
        return GetSplinePointBezierQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t)
     * }
     */
    public static MethodHandle GetSplinePointBezierQuad$handle() {
        return GetSplinePointBezierQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t)
     * }
     */
    public static MemorySegment GetSplinePointBezierQuad$address() {
        return GetSplinePointBezierQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t)
     * }
     */
    public static MemorySegment GetSplinePointBezierQuad(SegmentAllocator allocator, MemorySegment p1, MemorySegment c2, MemorySegment p3, float t) {
        var mh$ = GetSplinePointBezierQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSplinePointBezierQuad", allocator, p1, c2, p3, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p1, c2, p3, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSplinePointBezierCubic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetSplinePointBezierCubic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t)
     * }
     */
    public static FunctionDescriptor GetSplinePointBezierCubic$descriptor() {
        return GetSplinePointBezierCubic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t)
     * }
     */
    public static MethodHandle GetSplinePointBezierCubic$handle() {
        return GetSplinePointBezierCubic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointBezierCubic$address() {
        return GetSplinePointBezierCubic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t)
     * }
     */
    public static MemorySegment GetSplinePointBezierCubic(SegmentAllocator allocator, MemorySegment p1, MemorySegment c2, MemorySegment c3, MemorySegment p4, float t) {
        var mh$ = GetSplinePointBezierCubic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSplinePointBezierCubic", allocator, p1, c2, c3, p4, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p1, c2, c3, p4, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionRecs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Rectangle.layout(),
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionRecs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static FunctionDescriptor CheckCollisionRecs$descriptor() {
        return CheckCollisionRecs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static MethodHandle CheckCollisionRecs$handle() {
        return CheckCollisionRecs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static MemorySegment CheckCollisionRecs$address() {
        return CheckCollisionRecs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static boolean CheckCollisionRecs(MemorySegment rec1, MemorySegment rec2) {
        var mh$ = CheckCollisionRecs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionRecs", rec1, rec2);
            }
            return (boolean)mh$.invokeExact(rec1, rec2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionCircles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            raylib.C_FLOAT,
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionCircles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2)
     * }
     */
    public static FunctionDescriptor CheckCollisionCircles$descriptor() {
        return CheckCollisionCircles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2)
     * }
     */
    public static MethodHandle CheckCollisionCircles$handle() {
        return CheckCollisionCircles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2)
     * }
     */
    public static MemorySegment CheckCollisionCircles$address() {
        return CheckCollisionCircles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2)
     * }
     */
    public static boolean CheckCollisionCircles(MemorySegment center1, float radius1, MemorySegment center2, float radius2) {
        var mh$ = CheckCollisionCircles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionCircles", center1, radius1, center2, radius2);
            }
            return (boolean)mh$.invokeExact(center1, radius1, center2, radius2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionCircleRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            raylib.C_FLOAT,
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionCircleRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec)
     * }
     */
    public static FunctionDescriptor CheckCollisionCircleRec$descriptor() {
        return CheckCollisionCircleRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec)
     * }
     */
    public static MethodHandle CheckCollisionCircleRec$handle() {
        return CheckCollisionCircleRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec)
     * }
     */
    public static MemorySegment CheckCollisionCircleRec$address() {
        return CheckCollisionCircleRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec)
     * }
     */
    public static boolean CheckCollisionCircleRec(MemorySegment center, float radius, MemorySegment rec) {
        var mh$ = CheckCollisionCircleRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionCircleRec", center, radius, rec);
            }
            return (boolean)mh$.invokeExact(center, radius, rec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionPointRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionPointRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionPointRec(Vector2 point, Rectangle rec)
     * }
     */
    public static FunctionDescriptor CheckCollisionPointRec$descriptor() {
        return CheckCollisionPointRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionPointRec(Vector2 point, Rectangle rec)
     * }
     */
    public static MethodHandle CheckCollisionPointRec$handle() {
        return CheckCollisionPointRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionPointRec(Vector2 point, Rectangle rec)
     * }
     */
    public static MemorySegment CheckCollisionPointRec$address() {
        return CheckCollisionPointRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionPointRec(Vector2 point, Rectangle rec)
     * }
     */
    public static boolean CheckCollisionPointRec(MemorySegment point, MemorySegment rec) {
        var mh$ = CheckCollisionPointRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionPointRec", point, rec);
            }
            return (boolean)mh$.invokeExact(point, rec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionPointCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionPointCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius)
     * }
     */
    public static FunctionDescriptor CheckCollisionPointCircle$descriptor() {
        return CheckCollisionPointCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius)
     * }
     */
    public static MethodHandle CheckCollisionPointCircle$handle() {
        return CheckCollisionPointCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius)
     * }
     */
    public static MemorySegment CheckCollisionPointCircle$address() {
        return CheckCollisionPointCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius)
     * }
     */
    public static boolean CheckCollisionPointCircle(MemorySegment point, MemorySegment center, float radius) {
        var mh$ = CheckCollisionPointCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionPointCircle", point, center, radius);
            }
            return (boolean)mh$.invokeExact(point, center, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionPointTriangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionPointTriangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3)
     * }
     */
    public static FunctionDescriptor CheckCollisionPointTriangle$descriptor() {
        return CheckCollisionPointTriangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3)
     * }
     */
    public static MethodHandle CheckCollisionPointTriangle$handle() {
        return CheckCollisionPointTriangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3)
     * }
     */
    public static MemorySegment CheckCollisionPointTriangle$address() {
        return CheckCollisionPointTriangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3)
     * }
     */
    public static boolean CheckCollisionPointTriangle(MemorySegment point, MemorySegment p1, MemorySegment p2, MemorySegment p3) {
        var mh$ = CheckCollisionPointTriangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionPointTriangle", point, p1, p2, p3);
            }
            return (boolean)mh$.invokeExact(point, p1, p2, p3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionPointPoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionPointPoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount)
     * }
     */
    public static FunctionDescriptor CheckCollisionPointPoly$descriptor() {
        return CheckCollisionPointPoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount)
     * }
     */
    public static MethodHandle CheckCollisionPointPoly$handle() {
        return CheckCollisionPointPoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount)
     * }
     */
    public static MemorySegment CheckCollisionPointPoly$address() {
        return CheckCollisionPointPoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount)
     * }
     */
    public static boolean CheckCollisionPointPoly(MemorySegment point, MemorySegment points, int pointCount) {
        var mh$ = CheckCollisionPointPoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionPointPoly", point, points, pointCount);
            }
            return (boolean)mh$.invokeExact(point, points, pointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint)
     * }
     */
    public static FunctionDescriptor CheckCollisionLines$descriptor() {
        return CheckCollisionLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint)
     * }
     */
    public static MethodHandle CheckCollisionLines$handle() {
        return CheckCollisionLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint)
     * }
     */
    public static MemorySegment CheckCollisionLines$address() {
        return CheckCollisionLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint)
     * }
     */
    public static boolean CheckCollisionLines(MemorySegment startPos1, MemorySegment endPos1, MemorySegment startPos2, MemorySegment endPos2, MemorySegment collisionPoint) {
        var mh$ = CheckCollisionLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionLines", startPos1, endPos1, startPos2, endPos2, collisionPoint);
            }
            return (boolean)mh$.invokeExact(startPos1, endPos1, startPos2, endPos2, collisionPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionPointLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector2.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionPointLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold)
     * }
     */
    public static FunctionDescriptor CheckCollisionPointLine$descriptor() {
        return CheckCollisionPointLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold)
     * }
     */
    public static MethodHandle CheckCollisionPointLine$handle() {
        return CheckCollisionPointLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold)
     * }
     */
    public static MemorySegment CheckCollisionPointLine$address() {
        return CheckCollisionPointLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold)
     * }
     */
    public static boolean CheckCollisionPointLine(MemorySegment point, MemorySegment p1, MemorySegment p2, int threshold) {
        var mh$ = CheckCollisionPointLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionPointLine", point, p1, p2, threshold);
            }
            return (boolean)mh$.invokeExact(point, p1, p2, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCollisionRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout(),
            Rectangle.layout(),
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCollisionRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static FunctionDescriptor GetCollisionRec$descriptor() {
        return GetCollisionRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static MethodHandle GetCollisionRec$handle() {
        return GetCollisionRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static MemorySegment GetCollisionRec$address() {
        return GetCollisionRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2)
     * }
     */
    public static MemorySegment GetCollisionRec(SegmentAllocator allocator, MemorySegment rec1, MemorySegment rec2) {
        var mh$ = GetCollisionRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCollisionRec", allocator, rec1, rec2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, rec1, rec2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadImage$descriptor() {
        return LoadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MethodHandle LoadImage$handle() {
        return LoadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MemorySegment LoadImage$address() {
        return LoadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MemorySegment LoadImage(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImage", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize)
     * }
     */
    public static FunctionDescriptor LoadImageRaw$descriptor() {
        return LoadImageRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize)
     * }
     */
    public static MethodHandle LoadImageRaw$handle() {
        return LoadImageRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize)
     * }
     */
    public static MemorySegment LoadImageRaw$address() {
        return LoadImageRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize)
     * }
     */
    public static MemorySegment LoadImageRaw(SegmentAllocator allocator, MemorySegment fileName, int width, int height, int format, int headerSize) {
        var mh$ = LoadImageRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageRaw", allocator, fileName, width, height, format, headerSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName, width, height, format, headerSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageSvg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageSvg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageSvg(const char *fileNameOrString, int width, int height)
     * }
     */
    public static FunctionDescriptor LoadImageSvg$descriptor() {
        return LoadImageSvg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageSvg(const char *fileNameOrString, int width, int height)
     * }
     */
    public static MethodHandle LoadImageSvg$handle() {
        return LoadImageSvg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageSvg(const char *fileNameOrString, int width, int height)
     * }
     */
    public static MemorySegment LoadImageSvg$address() {
        return LoadImageSvg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageSvg(const char *fileNameOrString, int width, int height)
     * }
     */
    public static MemorySegment LoadImageSvg(SegmentAllocator allocator, MemorySegment fileNameOrString, int width, int height) {
        var mh$ = LoadImageSvg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageSvg", allocator, fileNameOrString, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileNameOrString, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageAnim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageAnim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageAnim(const char *fileName, int *frames)
     * }
     */
    public static FunctionDescriptor LoadImageAnim$descriptor() {
        return LoadImageAnim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageAnim(const char *fileName, int *frames)
     * }
     */
    public static MethodHandle LoadImageAnim$handle() {
        return LoadImageAnim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageAnim(const char *fileName, int *frames)
     * }
     */
    public static MemorySegment LoadImageAnim$address() {
        return LoadImageAnim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageAnim(const char *fileName, int *frames)
     * }
     */
    public static MemorySegment LoadImageAnim(SegmentAllocator allocator, MemorySegment fileName, MemorySegment frames) {
        var mh$ = LoadImageAnim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageAnim", allocator, fileName, frames);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName, frames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageAnimFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageAnimFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames)
     * }
     */
    public static FunctionDescriptor LoadImageAnimFromMemory$descriptor() {
        return LoadImageAnimFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames)
     * }
     */
    public static MethodHandle LoadImageAnimFromMemory$handle() {
        return LoadImageAnimFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames)
     * }
     */
    public static MemorySegment LoadImageAnimFromMemory$address() {
        return LoadImageAnimFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames)
     * }
     */
    public static MemorySegment LoadImageAnimFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize, MemorySegment frames) {
        var mh$ = LoadImageAnimFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageAnimFromMemory", allocator, fileType, fileData, dataSize, frames);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize, frames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static FunctionDescriptor LoadImageFromMemory$descriptor() {
        return LoadImageFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MethodHandle LoadImageFromMemory$handle() {
        return LoadImageFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadImageFromMemory$address() {
        return LoadImageFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadImageFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize) {
        var mh$ = LoadImageFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageFromMemory", allocator, fileType, fileData, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageFromTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageFromTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageFromTexture(Texture2D texture)
     * }
     */
    public static FunctionDescriptor LoadImageFromTexture$descriptor() {
        return LoadImageFromTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageFromTexture(Texture2D texture)
     * }
     */
    public static MethodHandle LoadImageFromTexture$handle() {
        return LoadImageFromTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageFromTexture(Texture2D texture)
     * }
     */
    public static MemorySegment LoadImageFromTexture$address() {
        return LoadImageFromTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageFromTexture(Texture2D texture)
     * }
     */
    public static MemorySegment LoadImageFromTexture(SegmentAllocator allocator, MemorySegment texture) {
        var mh$ = LoadImageFromTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageFromTexture", allocator, texture);
            }
            return (MemorySegment)mh$.invokeExact(allocator, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageFromScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageFromScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImageFromScreen()
     * }
     */
    public static FunctionDescriptor LoadImageFromScreen$descriptor() {
        return LoadImageFromScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImageFromScreen()
     * }
     */
    public static MethodHandle LoadImageFromScreen$handle() {
        return LoadImageFromScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImageFromScreen()
     * }
     */
    public static MemorySegment LoadImageFromScreen$address() {
        return LoadImageFromScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImageFromScreen()
     * }
     */
    public static MemorySegment LoadImageFromScreen(SegmentAllocator allocator) {
        var mh$ = LoadImageFromScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageFromScreen", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsImageReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsImageReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsImageReady(Image image)
     * }
     */
    public static FunctionDescriptor IsImageReady$descriptor() {
        return IsImageReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsImageReady(Image image)
     * }
     */
    public static MethodHandle IsImageReady$handle() {
        return IsImageReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsImageReady(Image image)
     * }
     */
    public static MemorySegment IsImageReady$address() {
        return IsImageReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsImageReady(Image image)
     * }
     */
    public static boolean IsImageReady(MemorySegment image) {
        var mh$ = IsImageReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsImageReady", image);
            }
            return (boolean)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadImage(Image image)
     * }
     */
    public static FunctionDescriptor UnloadImage$descriptor() {
        return UnloadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadImage(Image image)
     * }
     */
    public static MethodHandle UnloadImage$handle() {
        return UnloadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadImage(Image image)
     * }
     */
    public static MemorySegment UnloadImage$address() {
        return UnloadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadImage(Image image)
     * }
     */
    public static void UnloadImage(MemorySegment image) {
        var mh$ = UnloadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadImage", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Image.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportImage(Image image, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportImage$descriptor() {
        return ExportImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportImage(Image image, const char *fileName)
     * }
     */
    public static MethodHandle ExportImage$handle() {
        return ExportImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportImage(Image image, const char *fileName)
     * }
     */
    public static MemorySegment ExportImage$address() {
        return ExportImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportImage(Image image, const char *fileName)
     * }
     */
    public static boolean ExportImage(MemorySegment image, MemorySegment fileName) {
        var mh$ = ExportImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportImage", image, fileName);
            }
            return (boolean)mh$.invokeExact(image, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportImageToMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportImageToMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize)
     * }
     */
    public static FunctionDescriptor ExportImageToMemory$descriptor() {
        return ExportImageToMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize)
     * }
     */
    public static MethodHandle ExportImageToMemory$handle() {
        return ExportImageToMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize)
     * }
     */
    public static MemorySegment ExportImageToMemory$address() {
        return ExportImageToMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize)
     * }
     */
    public static MemorySegment ExportImageToMemory(MemorySegment image, MemorySegment fileType, MemorySegment fileSize) {
        var mh$ = ExportImageToMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportImageToMemory", image, fileType, fileSize);
            }
            return (MemorySegment)mh$.invokeExact(image, fileType, fileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportImageAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Image.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportImageAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportImageAsCode(Image image, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportImageAsCode$descriptor() {
        return ExportImageAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportImageAsCode(Image image, const char *fileName)
     * }
     */
    public static MethodHandle ExportImageAsCode$handle() {
        return ExportImageAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportImageAsCode(Image image, const char *fileName)
     * }
     */
    public static MemorySegment ExportImageAsCode$address() {
        return ExportImageAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportImageAsCode(Image image, const char *fileName)
     * }
     */
    public static boolean ExportImageAsCode(MemorySegment image, MemorySegment fileName) {
        var mh$ = ExportImageAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportImageAsCode", image, fileName);
            }
            return (boolean)mh$.invokeExact(image, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageColor(int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor GenImageColor$descriptor() {
        return GenImageColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageColor(int width, int height, Color color)
     * }
     */
    public static MethodHandle GenImageColor$handle() {
        return GenImageColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageColor(int width, int height, Color color)
     * }
     */
    public static MemorySegment GenImageColor$address() {
        return GenImageColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageColor(int width, int height, Color color)
     * }
     */
    public static MemorySegment GenImageColor(SegmentAllocator allocator, int width, int height, MemorySegment color) {
        var mh$ = GenImageColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageColor", allocator, width, height, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageGradientLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageGradientLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end)
     * }
     */
    public static FunctionDescriptor GenImageGradientLinear$descriptor() {
        return GenImageGradientLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end)
     * }
     */
    public static MethodHandle GenImageGradientLinear$handle() {
        return GenImageGradientLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end)
     * }
     */
    public static MemorySegment GenImageGradientLinear$address() {
        return GenImageGradientLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end)
     * }
     */
    public static MemorySegment GenImageGradientLinear(SegmentAllocator allocator, int width, int height, int direction, MemorySegment start, MemorySegment end) {
        var mh$ = GenImageGradientLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageGradientLinear", allocator, width, height, direction, start, end);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, direction, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageGradientRadial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageGradientRadial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static FunctionDescriptor GenImageGradientRadial$descriptor() {
        return GenImageGradientRadial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MethodHandle GenImageGradientRadial$handle() {
        return GenImageGradientRadial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MemorySegment GenImageGradientRadial$address() {
        return GenImageGradientRadial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MemorySegment GenImageGradientRadial(SegmentAllocator allocator, int width, int height, float density, MemorySegment inner, MemorySegment outer) {
        var mh$ = GenImageGradientRadial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageGradientRadial", allocator, width, height, density, inner, outer);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, density, inner, outer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageGradientSquare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageGradientSquare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static FunctionDescriptor GenImageGradientSquare$descriptor() {
        return GenImageGradientSquare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MethodHandle GenImageGradientSquare$handle() {
        return GenImageGradientSquare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MemorySegment GenImageGradientSquare$address() {
        return GenImageGradientSquare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer)
     * }
     */
    public static MemorySegment GenImageGradientSquare(SegmentAllocator allocator, int width, int height, float density, MemorySegment inner, MemorySegment outer) {
        var mh$ = GenImageGradientSquare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageGradientSquare", allocator, width, height, density, inner, outer);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, density, inner, outer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageChecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2)
     * }
     */
    public static FunctionDescriptor GenImageChecked$descriptor() {
        return GenImageChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2)
     * }
     */
    public static MethodHandle GenImageChecked$handle() {
        return GenImageChecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2)
     * }
     */
    public static MemorySegment GenImageChecked$address() {
        return GenImageChecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2)
     * }
     */
    public static MemorySegment GenImageChecked(SegmentAllocator allocator, int width, int height, int checksX, int checksY, MemorySegment col1, MemorySegment col2) {
        var mh$ = GenImageChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageChecked", allocator, width, height, checksX, checksY, col1, col2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, checksX, checksY, col1, col2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageWhiteNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageWhiteNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageWhiteNoise(int width, int height, float factor)
     * }
     */
    public static FunctionDescriptor GenImageWhiteNoise$descriptor() {
        return GenImageWhiteNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageWhiteNoise(int width, int height, float factor)
     * }
     */
    public static MethodHandle GenImageWhiteNoise$handle() {
        return GenImageWhiteNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageWhiteNoise(int width, int height, float factor)
     * }
     */
    public static MemorySegment GenImageWhiteNoise$address() {
        return GenImageWhiteNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageWhiteNoise(int width, int height, float factor)
     * }
     */
    public static MemorySegment GenImageWhiteNoise(SegmentAllocator allocator, int width, int height, float factor) {
        var mh$ = GenImageWhiteNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageWhiteNoise", allocator, width, height, factor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, factor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImagePerlinNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImagePerlinNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
     * }
     */
    public static FunctionDescriptor GenImagePerlinNoise$descriptor() {
        return GenImagePerlinNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
     * }
     */
    public static MethodHandle GenImagePerlinNoise$handle() {
        return GenImagePerlinNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
     * }
     */
    public static MemorySegment GenImagePerlinNoise$address() {
        return GenImagePerlinNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
     * }
     */
    public static MemorySegment GenImagePerlinNoise(SegmentAllocator allocator, int width, int height, int offsetX, int offsetY, float scale) {
        var mh$ = GenImagePerlinNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImagePerlinNoise", allocator, width, height, offsetX, offsetY, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, offsetX, offsetY, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageCellular {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageCellular");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageCellular(int width, int height, int tileSize)
     * }
     */
    public static FunctionDescriptor GenImageCellular$descriptor() {
        return GenImageCellular.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageCellular(int width, int height, int tileSize)
     * }
     */
    public static MethodHandle GenImageCellular$handle() {
        return GenImageCellular.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageCellular(int width, int height, int tileSize)
     * }
     */
    public static MemorySegment GenImageCellular$address() {
        return GenImageCellular.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageCellular(int width, int height, int tileSize)
     * }
     */
    public static MemorySegment GenImageCellular(SegmentAllocator allocator, int width, int height, int tileSize) {
        var mh$ = GenImageCellular.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageCellular", allocator, width, height, tileSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, tileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageText(int width, int height, const char *text)
     * }
     */
    public static FunctionDescriptor GenImageText$descriptor() {
        return GenImageText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageText(int width, int height, const char *text)
     * }
     */
    public static MethodHandle GenImageText$handle() {
        return GenImageText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageText(int width, int height, const char *text)
     * }
     */
    public static MemorySegment GenImageText$address() {
        return GenImageText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageText(int width, int height, const char *text)
     * }
     */
    public static MemorySegment GenImageText(SegmentAllocator allocator, int width, int height, MemorySegment text) {
        var mh$ = GenImageText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageText", allocator, width, height, text);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image ImageCopy(Image image)
     * }
     */
    public static FunctionDescriptor ImageCopy$descriptor() {
        return ImageCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image ImageCopy(Image image)
     * }
     */
    public static MethodHandle ImageCopy$handle() {
        return ImageCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image ImageCopy(Image image)
     * }
     */
    public static MemorySegment ImageCopy$address() {
        return ImageCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image ImageCopy(Image image)
     * }
     */
    public static MemorySegment ImageCopy(SegmentAllocator allocator, MemorySegment image) {
        var mh$ = ImageCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageCopy", allocator, image);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageFromImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            Image.layout(),
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageFromImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image ImageFromImage(Image image, Rectangle rec)
     * }
     */
    public static FunctionDescriptor ImageFromImage$descriptor() {
        return ImageFromImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image ImageFromImage(Image image, Rectangle rec)
     * }
     */
    public static MethodHandle ImageFromImage$handle() {
        return ImageFromImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image ImageFromImage(Image image, Rectangle rec)
     * }
     */
    public static MemorySegment ImageFromImage$address() {
        return ImageFromImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image ImageFromImage(Image image, Rectangle rec)
     * }
     */
    public static MemorySegment ImageFromImage(SegmentAllocator allocator, MemorySegment image, MemorySegment rec) {
        var mh$ = ImageFromImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageFromImage", allocator, image, rec);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, rec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image ImageText(const char *text, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor ImageText$descriptor() {
        return ImageText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image ImageText(const char *text, int fontSize, Color color)
     * }
     */
    public static MethodHandle ImageText$handle() {
        return ImageText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image ImageText(const char *text, int fontSize, Color color)
     * }
     */
    public static MemorySegment ImageText$address() {
        return ImageText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image ImageText(const char *text, int fontSize, Color color)
     * }
     */
    public static MemorySegment ImageText(SegmentAllocator allocator, MemorySegment text, int fontSize, MemorySegment color) {
        var mh$ = ImageText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageText", allocator, text, fontSize, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, text, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor ImageTextEx$descriptor() {
        return ImageTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle ImageTextEx$handle() {
        return ImageTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment ImageTextEx$address() {
        return ImageTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment ImageTextEx(SegmentAllocator allocator, MemorySegment font, MemorySegment text, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = ImageTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageTextEx", allocator, font, text, fontSize, spacing, tint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, text, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageFormat(Image *image, int newFormat)
     * }
     */
    public static FunctionDescriptor ImageFormat$descriptor() {
        return ImageFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageFormat(Image *image, int newFormat)
     * }
     */
    public static MethodHandle ImageFormat$handle() {
        return ImageFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageFormat(Image *image, int newFormat)
     * }
     */
    public static MemorySegment ImageFormat$address() {
        return ImageFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageFormat(Image *image, int newFormat)
     * }
     */
    public static void ImageFormat(MemorySegment image, int newFormat) {
        var mh$ = ImageFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageFormat", image, newFormat);
            }
            mh$.invokeExact(image, newFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageToPOT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageToPOT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageToPOT(Image *image, Color fill)
     * }
     */
    public static FunctionDescriptor ImageToPOT$descriptor() {
        return ImageToPOT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageToPOT(Image *image, Color fill)
     * }
     */
    public static MethodHandle ImageToPOT$handle() {
        return ImageToPOT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageToPOT(Image *image, Color fill)
     * }
     */
    public static MemorySegment ImageToPOT$address() {
        return ImageToPOT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageToPOT(Image *image, Color fill)
     * }
     */
    public static void ImageToPOT(MemorySegment image, MemorySegment fill) {
        var mh$ = ImageToPOT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageToPOT", image, fill);
            }
            mh$.invokeExact(image, fill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageCrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Rectangle.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageCrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageCrop(Image *image, Rectangle crop)
     * }
     */
    public static FunctionDescriptor ImageCrop$descriptor() {
        return ImageCrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageCrop(Image *image, Rectangle crop)
     * }
     */
    public static MethodHandle ImageCrop$handle() {
        return ImageCrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageCrop(Image *image, Rectangle crop)
     * }
     */
    public static MemorySegment ImageCrop$address() {
        return ImageCrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageCrop(Image *image, Rectangle crop)
     * }
     */
    public static void ImageCrop(MemorySegment image, MemorySegment crop) {
        var mh$ = ImageCrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageCrop", image, crop);
            }
            mh$.invokeExact(image, crop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageAlphaCrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageAlphaCrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageAlphaCrop(Image *image, float threshold)
     * }
     */
    public static FunctionDescriptor ImageAlphaCrop$descriptor() {
        return ImageAlphaCrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageAlphaCrop(Image *image, float threshold)
     * }
     */
    public static MethodHandle ImageAlphaCrop$handle() {
        return ImageAlphaCrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageAlphaCrop(Image *image, float threshold)
     * }
     */
    public static MemorySegment ImageAlphaCrop$address() {
        return ImageAlphaCrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageAlphaCrop(Image *image, float threshold)
     * }
     */
    public static void ImageAlphaCrop(MemorySegment image, float threshold) {
        var mh$ = ImageAlphaCrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageAlphaCrop", image, threshold);
            }
            mh$.invokeExact(image, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageAlphaClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageAlphaClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageAlphaClear(Image *image, Color color, float threshold)
     * }
     */
    public static FunctionDescriptor ImageAlphaClear$descriptor() {
        return ImageAlphaClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageAlphaClear(Image *image, Color color, float threshold)
     * }
     */
    public static MethodHandle ImageAlphaClear$handle() {
        return ImageAlphaClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageAlphaClear(Image *image, Color color, float threshold)
     * }
     */
    public static MemorySegment ImageAlphaClear$address() {
        return ImageAlphaClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageAlphaClear(Image *image, Color color, float threshold)
     * }
     */
    public static void ImageAlphaClear(MemorySegment image, MemorySegment color, float threshold) {
        var mh$ = ImageAlphaClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageAlphaClear", image, color, threshold);
            }
            mh$.invokeExact(image, color, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageAlphaMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageAlphaMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageAlphaMask(Image *image, Image alphaMask)
     * }
     */
    public static FunctionDescriptor ImageAlphaMask$descriptor() {
        return ImageAlphaMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageAlphaMask(Image *image, Image alphaMask)
     * }
     */
    public static MethodHandle ImageAlphaMask$handle() {
        return ImageAlphaMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageAlphaMask(Image *image, Image alphaMask)
     * }
     */
    public static MemorySegment ImageAlphaMask$address() {
        return ImageAlphaMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageAlphaMask(Image *image, Image alphaMask)
     * }
     */
    public static void ImageAlphaMask(MemorySegment image, MemorySegment alphaMask) {
        var mh$ = ImageAlphaMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageAlphaMask", image, alphaMask);
            }
            mh$.invokeExact(image, alphaMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageAlphaPremultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageAlphaPremultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageAlphaPremultiply(Image *image)
     * }
     */
    public static FunctionDescriptor ImageAlphaPremultiply$descriptor() {
        return ImageAlphaPremultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageAlphaPremultiply(Image *image)
     * }
     */
    public static MethodHandle ImageAlphaPremultiply$handle() {
        return ImageAlphaPremultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageAlphaPremultiply(Image *image)
     * }
     */
    public static MemorySegment ImageAlphaPremultiply$address() {
        return ImageAlphaPremultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageAlphaPremultiply(Image *image)
     * }
     */
    public static void ImageAlphaPremultiply(MemorySegment image) {
        var mh$ = ImageAlphaPremultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageAlphaPremultiply", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageBlurGaussian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageBlurGaussian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageBlurGaussian(Image *image, int blurSize)
     * }
     */
    public static FunctionDescriptor ImageBlurGaussian$descriptor() {
        return ImageBlurGaussian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageBlurGaussian(Image *image, int blurSize)
     * }
     */
    public static MethodHandle ImageBlurGaussian$handle() {
        return ImageBlurGaussian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageBlurGaussian(Image *image, int blurSize)
     * }
     */
    public static MemorySegment ImageBlurGaussian$address() {
        return ImageBlurGaussian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageBlurGaussian(Image *image, int blurSize)
     * }
     */
    public static void ImageBlurGaussian(MemorySegment image, int blurSize) {
        var mh$ = ImageBlurGaussian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageBlurGaussian", image, blurSize);
            }
            mh$.invokeExact(image, blurSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageKernelConvolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageKernelConvolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageKernelConvolution(Image *image, float *kernel, int kernelSize)
     * }
     */
    public static FunctionDescriptor ImageKernelConvolution$descriptor() {
        return ImageKernelConvolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageKernelConvolution(Image *image, float *kernel, int kernelSize)
     * }
     */
    public static MethodHandle ImageKernelConvolution$handle() {
        return ImageKernelConvolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageKernelConvolution(Image *image, float *kernel, int kernelSize)
     * }
     */
    public static MemorySegment ImageKernelConvolution$address() {
        return ImageKernelConvolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageKernelConvolution(Image *image, float *kernel, int kernelSize)
     * }
     */
    public static void ImageKernelConvolution(MemorySegment image, MemorySegment kernel, int kernelSize) {
        var mh$ = ImageKernelConvolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageKernelConvolution", image, kernel, kernelSize);
            }
            mh$.invokeExact(image, kernel, kernelSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageResize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageResize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageResize(Image *image, int newWidth, int newHeight)
     * }
     */
    public static FunctionDescriptor ImageResize$descriptor() {
        return ImageResize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageResize(Image *image, int newWidth, int newHeight)
     * }
     */
    public static MethodHandle ImageResize$handle() {
        return ImageResize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageResize(Image *image, int newWidth, int newHeight)
     * }
     */
    public static MemorySegment ImageResize$address() {
        return ImageResize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageResize(Image *image, int newWidth, int newHeight)
     * }
     */
    public static void ImageResize(MemorySegment image, int newWidth, int newHeight) {
        var mh$ = ImageResize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageResize", image, newWidth, newHeight);
            }
            mh$.invokeExact(image, newWidth, newHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageResizeNN {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageResizeNN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageResizeNN(Image *image, int newWidth, int newHeight)
     * }
     */
    public static FunctionDescriptor ImageResizeNN$descriptor() {
        return ImageResizeNN.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageResizeNN(Image *image, int newWidth, int newHeight)
     * }
     */
    public static MethodHandle ImageResizeNN$handle() {
        return ImageResizeNN.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageResizeNN(Image *image, int newWidth, int newHeight)
     * }
     */
    public static MemorySegment ImageResizeNN$address() {
        return ImageResizeNN.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageResizeNN(Image *image, int newWidth, int newHeight)
     * }
     */
    public static void ImageResizeNN(MemorySegment image, int newWidth, int newHeight) {
        var mh$ = ImageResizeNN.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageResizeNN", image, newWidth, newHeight);
            }
            mh$.invokeExact(image, newWidth, newHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageResizeCanvas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageResizeCanvas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill)
     * }
     */
    public static FunctionDescriptor ImageResizeCanvas$descriptor() {
        return ImageResizeCanvas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill)
     * }
     */
    public static MethodHandle ImageResizeCanvas$handle() {
        return ImageResizeCanvas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill)
     * }
     */
    public static MemorySegment ImageResizeCanvas$address() {
        return ImageResizeCanvas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill)
     * }
     */
    public static void ImageResizeCanvas(MemorySegment image, int newWidth, int newHeight, int offsetX, int offsetY, MemorySegment fill) {
        var mh$ = ImageResizeCanvas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageResizeCanvas", image, newWidth, newHeight, offsetX, offsetY, fill);
            }
            mh$.invokeExact(image, newWidth, newHeight, offsetX, offsetY, fill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageMipmaps(Image *image)
     * }
     */
    public static FunctionDescriptor ImageMipmaps$descriptor() {
        return ImageMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageMipmaps(Image *image)
     * }
     */
    public static MethodHandle ImageMipmaps$handle() {
        return ImageMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageMipmaps(Image *image)
     * }
     */
    public static MemorySegment ImageMipmaps$address() {
        return ImageMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageMipmaps(Image *image)
     * }
     */
    public static void ImageMipmaps(MemorySegment image) {
        var mh$ = ImageMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageMipmaps", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDither {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDither");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp)
     * }
     */
    public static FunctionDescriptor ImageDither$descriptor() {
        return ImageDither.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp)
     * }
     */
    public static MethodHandle ImageDither$handle() {
        return ImageDither.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp)
     * }
     */
    public static MemorySegment ImageDither$address() {
        return ImageDither.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp)
     * }
     */
    public static void ImageDither(MemorySegment image, int rBpp, int gBpp, int bBpp, int aBpp) {
        var mh$ = ImageDither.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDither", image, rBpp, gBpp, bBpp, aBpp);
            }
            mh$.invokeExact(image, rBpp, gBpp, bBpp, aBpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageFlipVertical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageFlipVertical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageFlipVertical(Image *image)
     * }
     */
    public static FunctionDescriptor ImageFlipVertical$descriptor() {
        return ImageFlipVertical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageFlipVertical(Image *image)
     * }
     */
    public static MethodHandle ImageFlipVertical$handle() {
        return ImageFlipVertical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageFlipVertical(Image *image)
     * }
     */
    public static MemorySegment ImageFlipVertical$address() {
        return ImageFlipVertical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageFlipVertical(Image *image)
     * }
     */
    public static void ImageFlipVertical(MemorySegment image) {
        var mh$ = ImageFlipVertical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageFlipVertical", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageFlipHorizontal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageFlipHorizontal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageFlipHorizontal(Image *image)
     * }
     */
    public static FunctionDescriptor ImageFlipHorizontal$descriptor() {
        return ImageFlipHorizontal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageFlipHorizontal(Image *image)
     * }
     */
    public static MethodHandle ImageFlipHorizontal$handle() {
        return ImageFlipHorizontal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageFlipHorizontal(Image *image)
     * }
     */
    public static MemorySegment ImageFlipHorizontal$address() {
        return ImageFlipHorizontal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageFlipHorizontal(Image *image)
     * }
     */
    public static void ImageFlipHorizontal(MemorySegment image) {
        var mh$ = ImageFlipHorizontal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageFlipHorizontal", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageRotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageRotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageRotate(Image *image, int degrees)
     * }
     */
    public static FunctionDescriptor ImageRotate$descriptor() {
        return ImageRotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageRotate(Image *image, int degrees)
     * }
     */
    public static MethodHandle ImageRotate$handle() {
        return ImageRotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageRotate(Image *image, int degrees)
     * }
     */
    public static MemorySegment ImageRotate$address() {
        return ImageRotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageRotate(Image *image, int degrees)
     * }
     */
    public static void ImageRotate(MemorySegment image, int degrees) {
        var mh$ = ImageRotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageRotate", image, degrees);
            }
            mh$.invokeExact(image, degrees);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageRotateCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageRotateCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageRotateCW(Image *image)
     * }
     */
    public static FunctionDescriptor ImageRotateCW$descriptor() {
        return ImageRotateCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageRotateCW(Image *image)
     * }
     */
    public static MethodHandle ImageRotateCW$handle() {
        return ImageRotateCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageRotateCW(Image *image)
     * }
     */
    public static MemorySegment ImageRotateCW$address() {
        return ImageRotateCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageRotateCW(Image *image)
     * }
     */
    public static void ImageRotateCW(MemorySegment image) {
        var mh$ = ImageRotateCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageRotateCW", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageRotateCCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageRotateCCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageRotateCCW(Image *image)
     * }
     */
    public static FunctionDescriptor ImageRotateCCW$descriptor() {
        return ImageRotateCCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageRotateCCW(Image *image)
     * }
     */
    public static MethodHandle ImageRotateCCW$handle() {
        return ImageRotateCCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageRotateCCW(Image *image)
     * }
     */
    public static MemorySegment ImageRotateCCW$address() {
        return ImageRotateCCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageRotateCCW(Image *image)
     * }
     */
    public static void ImageRotateCCW(MemorySegment image) {
        var mh$ = ImageRotateCCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageRotateCCW", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorTint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorTint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorTint(Image *image, Color color)
     * }
     */
    public static FunctionDescriptor ImageColorTint$descriptor() {
        return ImageColorTint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorTint(Image *image, Color color)
     * }
     */
    public static MethodHandle ImageColorTint$handle() {
        return ImageColorTint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorTint(Image *image, Color color)
     * }
     */
    public static MemorySegment ImageColorTint$address() {
        return ImageColorTint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorTint(Image *image, Color color)
     * }
     */
    public static void ImageColorTint(MemorySegment image, MemorySegment color) {
        var mh$ = ImageColorTint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorTint", image, color);
            }
            mh$.invokeExact(image, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorInvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorInvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorInvert(Image *image)
     * }
     */
    public static FunctionDescriptor ImageColorInvert$descriptor() {
        return ImageColorInvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorInvert(Image *image)
     * }
     */
    public static MethodHandle ImageColorInvert$handle() {
        return ImageColorInvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorInvert(Image *image)
     * }
     */
    public static MemorySegment ImageColorInvert$address() {
        return ImageColorInvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorInvert(Image *image)
     * }
     */
    public static void ImageColorInvert(MemorySegment image) {
        var mh$ = ImageColorInvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorInvert", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorGrayscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorGrayscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorGrayscale(Image *image)
     * }
     */
    public static FunctionDescriptor ImageColorGrayscale$descriptor() {
        return ImageColorGrayscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorGrayscale(Image *image)
     * }
     */
    public static MethodHandle ImageColorGrayscale$handle() {
        return ImageColorGrayscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorGrayscale(Image *image)
     * }
     */
    public static MemorySegment ImageColorGrayscale$address() {
        return ImageColorGrayscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorGrayscale(Image *image)
     * }
     */
    public static void ImageColorGrayscale(MemorySegment image) {
        var mh$ = ImageColorGrayscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorGrayscale", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorContrast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorContrast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorContrast(Image *image, float contrast)
     * }
     */
    public static FunctionDescriptor ImageColorContrast$descriptor() {
        return ImageColorContrast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorContrast(Image *image, float contrast)
     * }
     */
    public static MethodHandle ImageColorContrast$handle() {
        return ImageColorContrast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorContrast(Image *image, float contrast)
     * }
     */
    public static MemorySegment ImageColorContrast$address() {
        return ImageColorContrast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorContrast(Image *image, float contrast)
     * }
     */
    public static void ImageColorContrast(MemorySegment image, float contrast) {
        var mh$ = ImageColorContrast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorContrast", image, contrast);
            }
            mh$.invokeExact(image, contrast);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorBrightness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorBrightness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorBrightness(Image *image, int brightness)
     * }
     */
    public static FunctionDescriptor ImageColorBrightness$descriptor() {
        return ImageColorBrightness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorBrightness(Image *image, int brightness)
     * }
     */
    public static MethodHandle ImageColorBrightness$handle() {
        return ImageColorBrightness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorBrightness(Image *image, int brightness)
     * }
     */
    public static MemorySegment ImageColorBrightness$address() {
        return ImageColorBrightness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorBrightness(Image *image, int brightness)
     * }
     */
    public static void ImageColorBrightness(MemorySegment image, int brightness) {
        var mh$ = ImageColorBrightness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorBrightness", image, brightness);
            }
            mh$.invokeExact(image, brightness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageColorReplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageColorReplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageColorReplace(Image *image, Color color, Color replace)
     * }
     */
    public static FunctionDescriptor ImageColorReplace$descriptor() {
        return ImageColorReplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageColorReplace(Image *image, Color color, Color replace)
     * }
     */
    public static MethodHandle ImageColorReplace$handle() {
        return ImageColorReplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageColorReplace(Image *image, Color color, Color replace)
     * }
     */
    public static MemorySegment ImageColorReplace$address() {
        return ImageColorReplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageColorReplace(Image *image, Color color, Color replace)
     * }
     */
    public static void ImageColorReplace(MemorySegment image, MemorySegment color, MemorySegment replace) {
        var mh$ = ImageColorReplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageColorReplace", image, color, replace);
            }
            mh$.invokeExact(image, color, replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImageColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color *LoadImageColors(Image image)
     * }
     */
    public static FunctionDescriptor LoadImageColors$descriptor() {
        return LoadImageColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color *LoadImageColors(Image image)
     * }
     */
    public static MethodHandle LoadImageColors$handle() {
        return LoadImageColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color *LoadImageColors(Image image)
     * }
     */
    public static MemorySegment LoadImageColors$address() {
        return LoadImageColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color *LoadImageColors(Image image)
     * }
     */
    public static MemorySegment LoadImageColors(MemorySegment image) {
        var mh$ = LoadImageColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageColors", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImagePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Image.layout(),
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadImagePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static FunctionDescriptor LoadImagePalette$descriptor() {
        return LoadImagePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MethodHandle LoadImagePalette$handle() {
        return LoadImagePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MemorySegment LoadImagePalette$address() {
        return LoadImagePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount)
     * }
     */
    public static MemorySegment LoadImagePalette(MemorySegment image, int maxPaletteSize, MemorySegment colorCount) {
        var mh$ = LoadImagePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImagePalette", image, maxPaletteSize, colorCount);
            }
            return (MemorySegment)mh$.invokeExact(image, maxPaletteSize, colorCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadImageColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadImageColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static FunctionDescriptor UnloadImageColors$descriptor() {
        return UnloadImageColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static MethodHandle UnloadImageColors$handle() {
        return UnloadImageColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static MemorySegment UnloadImageColors$address() {
        return UnloadImageColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadImageColors(Color *colors)
     * }
     */
    public static void UnloadImageColors(MemorySegment colors) {
        var mh$ = UnloadImageColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadImageColors", colors);
            }
            mh$.invokeExact(colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadImagePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadImagePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static FunctionDescriptor UnloadImagePalette$descriptor() {
        return UnloadImagePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static MethodHandle UnloadImagePalette$handle() {
        return UnloadImagePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static MemorySegment UnloadImagePalette$address() {
        return UnloadImagePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadImagePalette(Color *colors)
     * }
     */
    public static void UnloadImagePalette(MemorySegment colors) {
        var mh$ = UnloadImagePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadImagePalette", colors);
            }
            mh$.invokeExact(colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageAlphaBorder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout(),
            Image.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetImageAlphaBorder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static FunctionDescriptor GetImageAlphaBorder$descriptor() {
        return GetImageAlphaBorder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MethodHandle GetImageAlphaBorder$handle() {
        return GetImageAlphaBorder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MemorySegment GetImageAlphaBorder$address() {
        return GetImageAlphaBorder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetImageAlphaBorder(Image image, float threshold)
     * }
     */
    public static MemorySegment GetImageAlphaBorder(SegmentAllocator allocator, MemorySegment image, float threshold) {
        var mh$ = GetImageAlphaBorder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageAlphaBorder", allocator, image, threshold);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Image.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetImageColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static FunctionDescriptor GetImageColor$descriptor() {
        return GetImageColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MethodHandle GetImageColor$handle() {
        return GetImageColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MemorySegment GetImageColor$address() {
        return GetImageColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetImageColor(Image image, int x, int y)
     * }
     */
    public static MemorySegment GetImageColor(SegmentAllocator allocator, MemorySegment image, int x, int y) {
        var mh$ = GetImageColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageColor", allocator, image, x, y);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageClearBackground {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageClearBackground");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static FunctionDescriptor ImageClearBackground$descriptor() {
        return ImageClearBackground.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static MethodHandle ImageClearBackground$handle() {
        return ImageClearBackground.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static MemorySegment ImageClearBackground$address() {
        return ImageClearBackground.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageClearBackground(Image *dst, Color color)
     * }
     */
    public static void ImageClearBackground(MemorySegment dst, MemorySegment color) {
        var mh$ = ImageClearBackground.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageClearBackground", dst, color);
            }
            mh$.invokeExact(dst, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawPixel$descriptor() {
        return ImageDrawPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static MethodHandle ImageDrawPixel$handle() {
        return ImageDrawPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static MemorySegment ImageDrawPixel$address() {
        return ImageDrawPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawPixel(Image *dst, int posX, int posY, Color color)
     * }
     */
    public static void ImageDrawPixel(MemorySegment dst, int posX, int posY, MemorySegment color) {
        var mh$ = ImageDrawPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawPixel", dst, posX, posY, color);
            }
            mh$.invokeExact(dst, posX, posY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawPixelV$descriptor() {
        return ImageDrawPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static MethodHandle ImageDrawPixelV$handle() {
        return ImageDrawPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static MemorySegment ImageDrawPixelV$address() {
        return ImageDrawPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawPixelV(Image *dst, Vector2 position, Color color)
     * }
     */
    public static void ImageDrawPixelV(MemorySegment dst, MemorySegment position, MemorySegment color) {
        var mh$ = ImageDrawPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawPixelV", dst, position, color);
            }
            mh$.invokeExact(dst, position, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawLine$descriptor() {
        return ImageDrawLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MethodHandle ImageDrawLine$handle() {
        return ImageDrawLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static MemorySegment ImageDrawLine$address() {
        return ImageDrawLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color)
     * }
     */
    public static void ImageDrawLine(MemorySegment dst, int startPosX, int startPosY, int endPosX, int endPosY, MemorySegment color) {
        var mh$ = ImageDrawLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawLine", dst, startPosX, startPosY, endPosX, endPosY, color);
            }
            mh$.invokeExact(dst, startPosX, startPosY, endPosX, endPosY, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawLineV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawLineV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawLineV$descriptor() {
        return ImageDrawLineV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static MethodHandle ImageDrawLineV$handle() {
        return ImageDrawLineV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static MemorySegment ImageDrawLineV$address() {
        return ImageDrawLineV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color)
     * }
     */
    public static void ImageDrawLineV(MemorySegment dst, MemorySegment start, MemorySegment end, MemorySegment color) {
        var mh$ = ImageDrawLineV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawLineV", dst, start, end, color);
            }
            mh$.invokeExact(dst, start, end, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircle$descriptor() {
        return ImageDrawCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircle$handle() {
        return ImageDrawCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircle$address() {
        return ImageDrawCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static void ImageDrawCircle(MemorySegment dst, int centerX, int centerY, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircle", dst, centerX, centerY, radius, color);
            }
            mh$.invokeExact(dst, centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleV$descriptor() {
        return ImageDrawCircleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleV$handle() {
        return ImageDrawCircleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleV$address() {
        return ImageDrawCircleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleV(MemorySegment dst, MemorySegment center, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleV", dst, center, radius, color);
            }
            mh$.invokeExact(dst, center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleLines$descriptor() {
        return ImageDrawCircleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleLines$handle() {
        return ImageDrawCircleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleLines$address() {
        return ImageDrawCircleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleLines(MemorySegment dst, int centerX, int centerY, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleLines", dst, centerX, centerY, radius, color);
            }
            mh$.invokeExact(dst, centerX, centerY, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawCircleLinesV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawCircleLinesV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawCircleLinesV$descriptor() {
        return ImageDrawCircleLinesV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MethodHandle ImageDrawCircleLinesV$handle() {
        return ImageDrawCircleLinesV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static MemorySegment ImageDrawCircleLinesV$address() {
        return ImageDrawCircleLinesV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color)
     * }
     */
    public static void ImageDrawCircleLinesV(MemorySegment dst, MemorySegment center, int radius, MemorySegment color) {
        var mh$ = ImageDrawCircleLinesV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawCircleLinesV", dst, center, radius, color);
            }
            mh$.invokeExact(dst, center, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangle$descriptor() {
        return ImageDrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangle$handle() {
        return ImageDrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangle$address() {
        return ImageDrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color)
     * }
     */
    public static void ImageDrawRectangle(MemorySegment dst, int posX, int posY, int width, int height, MemorySegment color) {
        var mh$ = ImageDrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangle", dst, posX, posY, width, height, color);
            }
            mh$.invokeExact(dst, posX, posY, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleV$descriptor() {
        return ImageDrawRectangleV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleV$handle() {
        return ImageDrawRectangleV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleV$address() {
        return ImageDrawRectangleV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color)
     * }
     */
    public static void ImageDrawRectangleV(MemorySegment dst, MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = ImageDrawRectangleV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleV", dst, position, size, color);
            }
            mh$.invokeExact(dst, position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Rectangle.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleRec$descriptor() {
        return ImageDrawRectangleRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleRec$handle() {
        return ImageDrawRectangleRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleRec$address() {
        return ImageDrawRectangleRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color)
     * }
     */
    public static void ImageDrawRectangleRec(MemorySegment dst, MemorySegment rec, MemorySegment color) {
        var mh$ = ImageDrawRectangleRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleRec", dst, rec, color);
            }
            mh$.invokeExact(dst, rec, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawRectangleLines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Rectangle.layout(),
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawRectangleLines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawRectangleLines$descriptor() {
        return ImageDrawRectangleLines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static MethodHandle ImageDrawRectangleLines$handle() {
        return ImageDrawRectangleLines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static MemorySegment ImageDrawRectangleLines$address() {
        return ImageDrawRectangleLines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color)
     * }
     */
    public static void ImageDrawRectangleLines(MemorySegment dst, MemorySegment rec, int thick, MemorySegment color) {
        var mh$ = ImageDrawRectangleLines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawRectangleLines", dst, rec, thick, color);
            }
            mh$.invokeExact(dst, rec, thick, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Image.layout(),
            Rectangle.layout(),
            Rectangle.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static FunctionDescriptor ImageDraw$descriptor() {
        return ImageDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static MethodHandle ImageDraw$handle() {
        return ImageDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static MemorySegment ImageDraw$address() {
        return ImageDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint)
     * }
     */
    public static void ImageDraw(MemorySegment dst, MemorySegment src, MemorySegment srcRec, MemorySegment dstRec, MemorySegment tint) {
        var mh$ = ImageDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDraw", dst, src, srcRec, dstRec, tint);
            }
            mh$.invokeExact(dst, src, srcRec, dstRec, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor ImageDrawText$descriptor() {
        return ImageDrawText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MethodHandle ImageDrawText$handle() {
        return ImageDrawText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MemorySegment ImageDrawText$address() {
        return ImageDrawText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static void ImageDrawText(MemorySegment dst, MemorySegment text, int posX, int posY, int fontSize, MemorySegment color) {
        var mh$ = ImageDrawText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawText", dst, text, posX, posY, fontSize, color);
            }
            mh$.invokeExact(dst, text, posX, posY, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageDrawTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ImageDrawTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor ImageDrawTextEx$descriptor() {
        return ImageDrawTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle ImageDrawTextEx$handle() {
        return ImageDrawTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment ImageDrawTextEx$address() {
        return ImageDrawTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void ImageDrawTextEx(MemorySegment dst, MemorySegment font, MemorySegment text, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = ImageDrawTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageDrawTextEx", dst, font, text, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(dst, font, text, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadTexture$descriptor() {
        return LoadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MethodHandle LoadTexture$handle() {
        return LoadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MemorySegment LoadTexture$address() {
        return LoadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Texture2D LoadTexture(const char *fileName)
     * }
     */
    public static MemorySegment LoadTexture(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTexture", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTextureFromImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            Image.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTextureFromImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static FunctionDescriptor LoadTextureFromImage$descriptor() {
        return LoadTextureFromImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MethodHandle LoadTextureFromImage$handle() {
        return LoadTextureFromImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MemorySegment LoadTextureFromImage$address() {
        return LoadTextureFromImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Texture2D LoadTextureFromImage(Image image)
     * }
     */
    public static MemorySegment LoadTextureFromImage(SegmentAllocator allocator, MemorySegment image) {
        var mh$ = LoadTextureFromImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTextureFromImage", allocator, image);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadTextureCubemap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Texture.layout(),
            Image.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadTextureCubemap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static FunctionDescriptor LoadTextureCubemap$descriptor() {
        return LoadTextureCubemap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MethodHandle LoadTextureCubemap$handle() {
        return LoadTextureCubemap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MemorySegment LoadTextureCubemap$address() {
        return LoadTextureCubemap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TextureCubemap LoadTextureCubemap(Image image, int layout)
     * }
     */
    public static MemorySegment LoadTextureCubemap(SegmentAllocator allocator, MemorySegment image, int layout) {
        var mh$ = LoadTextureCubemap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadTextureCubemap", allocator, image, layout);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadRenderTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RenderTexture.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadRenderTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static FunctionDescriptor LoadRenderTexture$descriptor() {
        return LoadRenderTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MethodHandle LoadRenderTexture$handle() {
        return LoadRenderTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MemorySegment LoadRenderTexture$address() {
        return LoadRenderTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RenderTexture2D LoadRenderTexture(int width, int height)
     * }
     */
    public static MemorySegment LoadRenderTexture(SegmentAllocator allocator, int width, int height) {
        var mh$ = LoadRenderTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadRenderTexture", allocator, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTextureReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsTextureReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static FunctionDescriptor IsTextureReady$descriptor() {
        return IsTextureReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static MethodHandle IsTextureReady$handle() {
        return IsTextureReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static MemorySegment IsTextureReady$address() {
        return IsTextureReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsTextureReady(Texture2D texture)
     * }
     */
    public static boolean IsTextureReady(MemorySegment texture) {
        var mh$ = IsTextureReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTextureReady", texture);
            }
            return (boolean)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static FunctionDescriptor UnloadTexture$descriptor() {
        return UnloadTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static MethodHandle UnloadTexture$handle() {
        return UnloadTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static MemorySegment UnloadTexture$address() {
        return UnloadTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadTexture(Texture2D texture)
     * }
     */
    public static void UnloadTexture(MemorySegment texture) {
        var mh$ = UnloadTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsRenderTextureReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            RenderTexture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsRenderTextureReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static FunctionDescriptor IsRenderTextureReady$descriptor() {
        return IsRenderTextureReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static MethodHandle IsRenderTextureReady$handle() {
        return IsRenderTextureReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static MemorySegment IsRenderTextureReady$address() {
        return IsRenderTextureReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsRenderTextureReady(RenderTexture2D target)
     * }
     */
    public static boolean IsRenderTextureReady(MemorySegment target) {
        var mh$ = IsRenderTextureReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsRenderTextureReady", target);
            }
            return (boolean)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadRenderTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RenderTexture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadRenderTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static FunctionDescriptor UnloadRenderTexture$descriptor() {
        return UnloadRenderTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static MethodHandle UnloadRenderTexture$handle() {
        return UnloadRenderTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static MemorySegment UnloadRenderTexture$address() {
        return UnloadRenderTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadRenderTexture(RenderTexture2D target)
     * }
     */
    public static void UnloadRenderTexture(MemorySegment target) {
        var mh$ = UnloadRenderTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadRenderTexture", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static FunctionDescriptor UpdateTexture$descriptor() {
        return UpdateTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static MethodHandle UpdateTexture$handle() {
        return UpdateTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static MemorySegment UpdateTexture$address() {
        return UpdateTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateTexture(Texture2D texture, const void *pixels)
     * }
     */
    public static void UpdateTexture(MemorySegment texture, MemorySegment pixels) {
        var mh$ = UpdateTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateTexture", texture, pixels);
            }
            mh$.invokeExact(texture, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateTextureRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateTextureRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static FunctionDescriptor UpdateTextureRec$descriptor() {
        return UpdateTextureRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static MethodHandle UpdateTextureRec$handle() {
        return UpdateTextureRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static MemorySegment UpdateTextureRec$address() {
        return UpdateTextureRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels)
     * }
     */
    public static void UpdateTextureRec(MemorySegment texture, MemorySegment rec, MemorySegment pixels) {
        var mh$ = UpdateTextureRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateTextureRec", texture, rec, pixels);
            }
            mh$.invokeExact(texture, rec, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenTextureMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenTextureMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static FunctionDescriptor GenTextureMipmaps$descriptor() {
        return GenTextureMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static MethodHandle GenTextureMipmaps$handle() {
        return GenTextureMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static MemorySegment GenTextureMipmaps$address() {
        return GenTextureMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GenTextureMipmaps(Texture2D *texture)
     * }
     */
    public static void GenTextureMipmaps(MemorySegment texture) {
        var mh$ = GenTextureMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenTextureMipmaps", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextureFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextureFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static FunctionDescriptor SetTextureFilter$descriptor() {
        return SetTextureFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MethodHandle SetTextureFilter$handle() {
        return SetTextureFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MemorySegment SetTextureFilter$address() {
        return SetTextureFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static void SetTextureFilter(MemorySegment texture, int filter) {
        var mh$ = SetTextureFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextureFilter", texture, filter);
            }
            mh$.invokeExact(texture, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextureWrap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextureWrap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static FunctionDescriptor SetTextureWrap$descriptor() {
        return SetTextureWrap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static MethodHandle SetTextureWrap$handle() {
        return SetTextureWrap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static MemorySegment SetTextureWrap$address() {
        return SetTextureWrap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextureWrap(Texture2D texture, int wrap)
     * }
     */
    public static void SetTextureWrap(MemorySegment texture, int wrap) {
        var mh$ = SetTextureWrap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextureWrap", texture, wrap);
            }
            mh$.invokeExact(texture, wrap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexture$descriptor() {
        return DrawTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MethodHandle DrawTexture$handle() {
        return DrawTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MemorySegment DrawTexture$address() {
        return DrawTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static void DrawTexture(MemorySegment texture, int posX, int posY, MemorySegment tint) {
        var mh$ = DrawTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexture", texture, posX, posY, tint);
            }
            mh$.invokeExact(texture, posX, posY, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureV$descriptor() {
        return DrawTextureV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static MethodHandle DrawTextureV$handle() {
        return DrawTextureV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static MemorySegment DrawTextureV$address() {
        return DrawTextureV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureV(Texture2D texture, Vector2 position, Color tint)
     * }
     */
    public static void DrawTextureV(MemorySegment texture, MemorySegment position, MemorySegment tint) {
        var mh$ = DrawTextureV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureV", texture, position, tint);
            }
            mh$.invokeExact(texture, position, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureEx$descriptor() {
        return DrawTextureEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawTextureEx$handle() {
        return DrawTextureEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawTextureEx$address() {
        return DrawTextureEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint)
     * }
     */
    public static void DrawTextureEx(MemorySegment texture, MemorySegment position, float rotation, float scale, MemorySegment tint) {
        var mh$ = DrawTextureEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureEx", texture, position, rotation, scale, tint);
            }
            mh$.invokeExact(texture, position, rotation, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureRec$descriptor() {
        return DrawTextureRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static MethodHandle DrawTextureRec$handle() {
        return DrawTextureRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static MemorySegment DrawTextureRec$address() {
        return DrawTextureRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint)
     * }
     */
    public static void DrawTextureRec(MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment tint) {
        var mh$ = DrawTextureRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureRec", texture, source, position, tint);
            }
            mh$.invokeExact(texture, source, position, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexturePro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            Rectangle.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTexturePro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexturePro$descriptor() {
        return DrawTexturePro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawTexturePro$handle() {
        return DrawTexturePro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawTexturePro$address() {
        return DrawTexturePro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawTexturePro(MemorySegment texture, MemorySegment source, MemorySegment dest, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawTexturePro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexturePro", texture, source, dest, origin, rotation, tint);
            }
            mh$.invokeExact(texture, source, dest, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextureNPatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Texture.layout(),
            NPatchInfo.layout(),
            Rectangle.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextureNPatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextureNPatch$descriptor() {
        return DrawTextureNPatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawTextureNPatch$handle() {
        return DrawTextureNPatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawTextureNPatch$address() {
        return DrawTextureNPatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawTextureNPatch(MemorySegment texture, MemorySegment nPatchInfo, MemorySegment dest, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawTextureNPatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextureNPatch", texture, nPatchInfo, dest, origin, rotation, tint);
            }
            mh$.invokeExact(texture, nPatchInfo, dest, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorIsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorIsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static FunctionDescriptor ColorIsEqual$descriptor() {
        return ColorIsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static MethodHandle ColorIsEqual$handle() {
        return ColorIsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static MemorySegment ColorIsEqual$address() {
        return ColorIsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ColorIsEqual(Color col1, Color col2)
     * }
     */
    public static boolean ColorIsEqual(MemorySegment col1, MemorySegment col2) {
        var mh$ = ColorIsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorIsEqual", col1, col2);
            }
            return (boolean)mh$.invokeExact(col1, col2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Fade {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("Fade");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static FunctionDescriptor Fade$descriptor() {
        return Fade.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MethodHandle Fade$handle() {
        return Fade.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MemorySegment Fade$address() {
        return Fade.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color Fade(Color color, float alpha)
     * }
     */
    public static MemorySegment Fade(SegmentAllocator allocator, MemorySegment color, float alpha) {
        var mh$ = Fade.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Fade", allocator, color, alpha);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static FunctionDescriptor ColorToInt$descriptor() {
        return ColorToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static MethodHandle ColorToInt$handle() {
        return ColorToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static MemorySegment ColorToInt$address() {
        return ColorToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ColorToInt(Color color)
     * }
     */
    public static int ColorToInt(MemorySegment color) {
        var mh$ = ColorToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorToInt", color);
            }
            return (int)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorNormalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector4.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorNormalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static FunctionDescriptor ColorNormalize$descriptor() {
        return ColorNormalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MethodHandle ColorNormalize$handle() {
        return ColorNormalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MemorySegment ColorNormalize$address() {
        return ColorNormalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector4 ColorNormalize(Color color)
     * }
     */
    public static MemorySegment ColorNormalize(SegmentAllocator allocator, MemorySegment color) {
        var mh$ = ColorNormalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorNormalize", allocator, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorFromNormalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorFromNormalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static FunctionDescriptor ColorFromNormalized$descriptor() {
        return ColorFromNormalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MethodHandle ColorFromNormalized$handle() {
        return ColorFromNormalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MemorySegment ColorFromNormalized$address() {
        return ColorFromNormalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorFromNormalized(Vector4 normalized)
     * }
     */
    public static MemorySegment ColorFromNormalized(SegmentAllocator allocator, MemorySegment normalized) {
        var mh$ = ColorFromNormalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorFromNormalized", allocator, normalized);
            }
            return (MemorySegment)mh$.invokeExact(allocator, normalized);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorToHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorToHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static FunctionDescriptor ColorToHSV$descriptor() {
        return ColorToHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MethodHandle ColorToHSV$handle() {
        return ColorToHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MemorySegment ColorToHSV$address() {
        return ColorToHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 ColorToHSV(Color color)
     * }
     */
    public static MemorySegment ColorToHSV(SegmentAllocator allocator, MemorySegment color) {
        var mh$ = ColorToHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorToHSV", allocator, color);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorFromHSV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorFromHSV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static FunctionDescriptor ColorFromHSV$descriptor() {
        return ColorFromHSV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MethodHandle ColorFromHSV$handle() {
        return ColorFromHSV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MemorySegment ColorFromHSV$address() {
        return ColorFromHSV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorFromHSV(float hue, float saturation, float value)
     * }
     */
    public static MemorySegment ColorFromHSV(SegmentAllocator allocator, float hue, float saturation, float value) {
        var mh$ = ColorFromHSV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorFromHSV", allocator, hue, saturation, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hue, saturation, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorTint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorTint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static FunctionDescriptor ColorTint$descriptor() {
        return ColorTint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MethodHandle ColorTint$handle() {
        return ColorTint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MemorySegment ColorTint$address() {
        return ColorTint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorTint(Color color, Color tint)
     * }
     */
    public static MemorySegment ColorTint(SegmentAllocator allocator, MemorySegment color, MemorySegment tint) {
        var mh$ = ColorTint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorTint", allocator, color, tint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorBrightness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorBrightness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static FunctionDescriptor ColorBrightness$descriptor() {
        return ColorBrightness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MethodHandle ColorBrightness$handle() {
        return ColorBrightness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MemorySegment ColorBrightness$address() {
        return ColorBrightness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorBrightness(Color color, float factor)
     * }
     */
    public static MemorySegment ColorBrightness(SegmentAllocator allocator, MemorySegment color, float factor) {
        var mh$ = ColorBrightness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorBrightness", allocator, color, factor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, factor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorContrast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorContrast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static FunctionDescriptor ColorContrast$descriptor() {
        return ColorContrast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MethodHandle ColorContrast$handle() {
        return ColorContrast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MemorySegment ColorContrast$address() {
        return ColorContrast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorContrast(Color color, float contrast)
     * }
     */
    public static MemorySegment ColorContrast(SegmentAllocator allocator, MemorySegment color, float contrast) {
        var mh$ = ColorContrast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorContrast", allocator, color, contrast);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, contrast);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static FunctionDescriptor ColorAlpha$descriptor() {
        return ColorAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MethodHandle ColorAlpha$handle() {
        return ColorAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MemorySegment ColorAlpha$address() {
        return ColorAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorAlpha(Color color, float alpha)
     * }
     */
    public static MemorySegment ColorAlpha(SegmentAllocator allocator, MemorySegment color, float alpha) {
        var mh$ = ColorAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorAlpha", allocator, color, alpha);
            }
            return (MemorySegment)mh$.invokeExact(allocator, color, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            Color.layout(),
            Color.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ColorAlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static FunctionDescriptor ColorAlphaBlend$descriptor() {
        return ColorAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MethodHandle ColorAlphaBlend$handle() {
        return ColorAlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MemorySegment ColorAlphaBlend$address() {
        return ColorAlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color ColorAlphaBlend(Color dst, Color src, Color tint)
     * }
     */
    public static MemorySegment ColorAlphaBlend(SegmentAllocator allocator, MemorySegment dst, MemorySegment src, MemorySegment tint) {
        var mh$ = ColorAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorAlphaBlend", allocator, dst, src, tint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, dst, src, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static FunctionDescriptor GetColor$descriptor() {
        return GetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MethodHandle GetColor$handle() {
        return GetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MemorySegment GetColor$address() {
        return GetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetColor(unsigned int hexValue)
     * }
     */
    public static MemorySegment GetColor(SegmentAllocator allocator, int hexValue) {
        var mh$ = GetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColor", allocator, hexValue);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hexValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Color.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetPixelColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static FunctionDescriptor GetPixelColor$descriptor() {
        return GetPixelColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MethodHandle GetPixelColor$handle() {
        return GetPixelColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MemorySegment GetPixelColor$address() {
        return GetPixelColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Color GetPixelColor(void *srcPtr, int format)
     * }
     */
    public static MemorySegment GetPixelColor(SegmentAllocator allocator, MemorySegment srcPtr, int format) {
        var mh$ = GetPixelColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelColor", allocator, srcPtr, format);
            }
            return (MemorySegment)mh$.invokeExact(allocator, srcPtr, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetPixelColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static FunctionDescriptor SetPixelColor$descriptor() {
        return SetPixelColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static MethodHandle SetPixelColor$handle() {
        return SetPixelColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static MemorySegment SetPixelColor$address() {
        return SetPixelColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetPixelColor(void *dstPtr, Color color, int format)
     * }
     */
    public static void SetPixelColor(MemorySegment dstPtr, MemorySegment color, int format) {
        var mh$ = SetPixelColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelColor", dstPtr, color, format);
            }
            mh$.invokeExact(dstPtr, color, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelDataSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetPixelDataSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static FunctionDescriptor GetPixelDataSize$descriptor() {
        return GetPixelDataSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static MethodHandle GetPixelDataSize$handle() {
        return GetPixelDataSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static MemorySegment GetPixelDataSize$address() {
        return GetPixelDataSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPixelDataSize(int width, int height, int format)
     * }
     */
    public static int GetPixelDataSize(int width, int height, int format) {
        var mh$ = GetPixelDataSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelDataSize", width, height, format);
            }
            return (int)mh$.invokeExact(width, height, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetFontDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static FunctionDescriptor GetFontDefault$descriptor() {
        return GetFontDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MethodHandle GetFontDefault$handle() {
        return GetFontDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault$address() {
        return GetFontDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault(SegmentAllocator allocator) {
        var mh$ = GetFontDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontDefault", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadFont$descriptor() {
        return LoadFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MethodHandle LoadFont$handle() {
        return LoadFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont$address() {
        return LoadFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFont", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static FunctionDescriptor LoadFontEx$descriptor() {
        return LoadFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MethodHandle LoadFontEx$handle() {
        return LoadFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx$address() {
        return LoadFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx(SegmentAllocator allocator, MemorySegment fileName, int fontSize, MemorySegment codepoints, int codepointCount) {
        var mh$ = LoadFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontEx", allocator, fileName, fontSize, codepoints, codepointCount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName, fontSize, codepoints, codepointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontFromImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            Image.layout(),
            Color.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontFromImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static FunctionDescriptor LoadFontFromImage$descriptor() {
        return LoadFontFromImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MethodHandle LoadFontFromImage$handle() {
        return LoadFontFromImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MemorySegment LoadFontFromImage$address() {
        return LoadFontFromImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontFromImage(Image image, Color key, int firstChar)
     * }
     */
    public static MemorySegment LoadFontFromImage(SegmentAllocator allocator, MemorySegment image, MemorySegment key, int firstChar) {
        var mh$ = LoadFontFromImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontFromImage", allocator, image, key, firstChar);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, key, firstChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static FunctionDescriptor LoadFontFromMemory$descriptor() {
        return LoadFontFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MethodHandle LoadFontFromMemory$handle() {
        return LoadFontFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontFromMemory$address() {
        return LoadFontFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize, int fontSize, MemorySegment codepoints, int codepointCount) {
        var mh$ = LoadFontFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontFromMemory", allocator, fileType, fileData, dataSize, fontSize, codepoints, codepointCount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize, fontSize, codepoints, codepointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsFontReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Font.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsFontReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static FunctionDescriptor IsFontReady$descriptor() {
        return IsFontReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static MethodHandle IsFontReady$handle() {
        return IsFontReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static MemorySegment IsFontReady$address() {
        return IsFontReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsFontReady(Font font)
     * }
     */
    public static boolean IsFontReady(MemorySegment font) {
        var mh$ = IsFontReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsFontReady", font);
            }
            return (boolean)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static FunctionDescriptor LoadFontData$descriptor() {
        return LoadFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MethodHandle LoadFontData$handle() {
        return LoadFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MemorySegment LoadFontData$address() {
        return LoadFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type)
     * }
     */
    public static MemorySegment LoadFontData(MemorySegment fileData, int dataSize, int fontSize, MemorySegment codepoints, int codepointCount, int type) {
        var mh$ = LoadFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontData", fileData, dataSize, fontSize, codepoints, codepointCount, type);
            }
            return (MemorySegment)mh$.invokeExact(fileData, dataSize, fontSize, codepoints, codepointCount, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenImageFontAtlas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Image.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenImageFontAtlas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static FunctionDescriptor GenImageFontAtlas$descriptor() {
        return GenImageFontAtlas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MethodHandle GenImageFontAtlas$handle() {
        return GenImageFontAtlas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MemorySegment GenImageFontAtlas$address() {
        return GenImageFontAtlas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod)
     * }
     */
    public static MemorySegment GenImageFontAtlas(SegmentAllocator allocator, MemorySegment glyphs, MemorySegment glyphRecs, int glyphCount, int fontSize, int padding, int packMethod) {
        var mh$ = GenImageFontAtlas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenImageFontAtlas", allocator, glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);
            }
            return (MemorySegment)mh$.invokeExact(allocator, glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static FunctionDescriptor UnloadFontData$descriptor() {
        return UnloadFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static MethodHandle UnloadFontData$handle() {
        return UnloadFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static MemorySegment UnloadFontData$address() {
        return UnloadFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFontData(GlyphInfo *glyphs, int glyphCount)
     * }
     */
    public static void UnloadFontData(MemorySegment glyphs, int glyphCount) {
        var mh$ = UnloadFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFontData", glyphs, glyphCount);
            }
            mh$.invokeExact(glyphs, glyphCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static FunctionDescriptor UnloadFont$descriptor() {
        return UnloadFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static MethodHandle UnloadFont$handle() {
        return UnloadFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static MemorySegment UnloadFont$address() {
        return UnloadFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadFont(Font font)
     * }
     */
    public static void UnloadFont(MemorySegment font) {
        var mh$ = UnloadFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadFont", font);
            }
            mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportFontAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Font.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportFontAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportFontAsCode$descriptor() {
        return ExportFontAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static MethodHandle ExportFontAsCode$handle() {
        return ExportFontAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static MemorySegment ExportFontAsCode$address() {
        return ExportFontAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportFontAsCode(Font font, const char *fileName)
     * }
     */
    public static boolean ExportFontAsCode(MemorySegment font, MemorySegment fileName) {
        var mh$ = ExportFontAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportFontAsCode", font, fileName);
            }
            return (boolean)mh$.invokeExact(font, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFPS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawFPS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static FunctionDescriptor DrawFPS$descriptor() {
        return DrawFPS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static MethodHandle DrawFPS$handle() {
        return DrawFPS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static MemorySegment DrawFPS$address() {
        return DrawFPS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawFPS(int posX, int posY)
     * }
     */
    public static void DrawFPS(int posX, int posY) {
        var mh$ = DrawFPS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFPS", posX, posY);
            }
            mh$.invokeExact(posX, posY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor DrawText$descriptor() {
        return DrawText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MethodHandle DrawText$handle() {
        return DrawText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MemorySegment DrawText$address() {
        return DrawText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static void DrawText(MemorySegment text, int posX, int posY, int fontSize, MemorySegment color) {
        var mh$ = DrawText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawText", text, posX, posY, fontSize, color);
            }
            mh$.invokeExact(text, posX, posY, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextEx$descriptor() {
        return DrawTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextEx$handle() {
        return DrawTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextEx$address() {
        return DrawTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextEx(MemorySegment font, MemorySegment text, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextEx", font, text, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, text, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextPro$descriptor() {
        return DrawTextPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextPro$handle() {
        return DrawTextPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextPro$address() {
        return DrawTextPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextPro(MemorySegment font, MemorySegment text, MemorySegment position, MemorySegment origin, float rotation, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextPro", font, text, position, origin, rotation, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, text, position, origin, rotation, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextCodepoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_INT,
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextCodepoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextCodepoint$descriptor() {
        return DrawTextCodepoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static MethodHandle DrawTextCodepoint$handle() {
        return DrawTextCodepoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static MemorySegment DrawTextCodepoint$address() {
        return DrawTextCodepoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint)
     * }
     */
    public static void DrawTextCodepoint(MemorySegment font, int codepoint, MemorySegment position, float fontSize, MemorySegment tint) {
        var mh$ = DrawTextCodepoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextCodepoint", font, codepoint, position, fontSize, tint);
            }
            mh$.invokeExact(font, codepoint, position, fontSize, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_INT,
            Vector2.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTextCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextCodepoints$descriptor() {
        return DrawTextCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextCodepoints$handle() {
        return DrawTextCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextCodepoints$address() {
        return DrawTextCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextCodepoints(MemorySegment font, MemorySegment codepoints, int codepointCount, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextCodepoints", font, codepoints, codepointCount, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, codepoints, codepointCount, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextLineSpacing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetTextLineSpacing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static FunctionDescriptor SetTextLineSpacing$descriptor() {
        return SetTextLineSpacing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static MethodHandle SetTextLineSpacing$handle() {
        return SetTextLineSpacing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static MemorySegment SetTextLineSpacing$address() {
        return SetTextLineSpacing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextLineSpacing(int spacing)
     * }
     */
    public static void SetTextLineSpacing(int spacing) {
        var mh$ = SetTextLineSpacing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextLineSpacing", spacing);
            }
            mh$.invokeExact(spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MeasureText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MeasureText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static FunctionDescriptor MeasureText$descriptor() {
        return MeasureText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MethodHandle MeasureText$handle() {
        return MeasureText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MemorySegment MeasureText$address() {
        return MeasureText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static int MeasureText(MemorySegment text, int fontSize) {
        var mh$ = MeasureText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MeasureText", text, fontSize);
            }
            return (int)mh$.invokeExact(text, fontSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MeasureTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector2.layout(),
            Font.layout(),
            raylib.C_POINTER,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("MeasureTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static FunctionDescriptor MeasureTextEx$descriptor() {
        return MeasureTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MethodHandle MeasureTextEx$handle() {
        return MeasureTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MemorySegment MeasureTextEx$address() {
        return MeasureTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing)
     * }
     */
    public static MemorySegment MeasureTextEx(SegmentAllocator allocator, MemorySegment font, MemorySegment text, float fontSize, float spacing) {
        var mh$ = MeasureTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MeasureTextEx", allocator, font, text, fontSize, spacing);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, text, fontSize, spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphIndex$descriptor() {
        return GetGlyphIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphIndex$handle() {
        return GetGlyphIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphIndex$address() {
        return GetGlyphIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGlyphIndex(Font font, int codepoint)
     * }
     */
    public static int GetGlyphIndex(MemorySegment font, int codepoint) {
        var mh$ = GetGlyphIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndex", font, codepoint);
            }
            return (int)mh$.invokeExact(font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            GlyphInfo.layout(),
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphInfo$descriptor() {
        return GetGlyphInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphInfo$handle() {
        return GetGlyphInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphInfo$address() {
        return GetGlyphInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GlyphInfo GetGlyphInfo(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphInfo(SegmentAllocator allocator, MemorySegment font, int codepoint) {
        var mh$ = GetGlyphInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphInfo", allocator, font, codepoint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphAtlasRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rectangle.layout(),
            Font.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetGlyphAtlasRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static FunctionDescriptor GetGlyphAtlasRec$descriptor() {
        return GetGlyphAtlasRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MethodHandle GetGlyphAtlasRec$handle() {
        return GetGlyphAtlasRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphAtlasRec$address() {
        return GetGlyphAtlasRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Rectangle GetGlyphAtlasRec(Font font, int codepoint)
     * }
     */
    public static MemorySegment GetGlyphAtlasRec(SegmentAllocator allocator, MemorySegment font, int codepoint) {
        var mh$ = GetGlyphAtlasRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphAtlasRec", allocator, font, codepoint);
            }
            return (MemorySegment)mh$.invokeExact(allocator, font, codepoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static FunctionDescriptor LoadUTF8$descriptor() {
        return LoadUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MethodHandle LoadUTF8$handle() {
        return LoadUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MemorySegment LoadUTF8$address() {
        return LoadUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LoadUTF8(const int *codepoints, int length)
     * }
     */
    public static MemorySegment LoadUTF8(MemorySegment codepoints, int length) {
        var mh$ = LoadUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadUTF8", codepoints, length);
            }
            return (MemorySegment)mh$.invokeExact(codepoints, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static FunctionDescriptor UnloadUTF8$descriptor() {
        return UnloadUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static MethodHandle UnloadUTF8$handle() {
        return UnloadUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static MemorySegment UnloadUTF8$address() {
        return UnloadUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadUTF8(char *text)
     * }
     */
    public static void UnloadUTF8(MemorySegment text) {
        var mh$ = UnloadUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadUTF8", text);
            }
            mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static FunctionDescriptor LoadCodepoints$descriptor() {
        return LoadCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MethodHandle LoadCodepoints$handle() {
        return LoadCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MemorySegment LoadCodepoints$address() {
        return LoadCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *LoadCodepoints(const char *text, int *count)
     * }
     */
    public static MemorySegment LoadCodepoints(MemorySegment text, MemorySegment count) {
        var mh$ = LoadCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCodepoints", text, count);
            }
            return (MemorySegment)mh$.invokeExact(text, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadCodepoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadCodepoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static FunctionDescriptor UnloadCodepoints$descriptor() {
        return UnloadCodepoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static MethodHandle UnloadCodepoints$handle() {
        return UnloadCodepoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static MemorySegment UnloadCodepoints$address() {
        return UnloadCodepoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadCodepoints(int *codepoints)
     * }
     */
    public static void UnloadCodepoints(MemorySegment codepoints) {
        var mh$ = UnloadCodepoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadCodepoints", codepoints);
            }
            mh$.invokeExact(codepoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static FunctionDescriptor GetCodepointCount$descriptor() {
        return GetCodepointCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static MethodHandle GetCodepointCount$handle() {
        return GetCodepointCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static MemorySegment GetCodepointCount$address() {
        return GetCodepointCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointCount(const char *text)
     * }
     */
    public static int GetCodepointCount(MemorySegment text) {
        var mh$ = GetCodepointCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointCount", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepoint$descriptor() {
        return GetCodepoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepoint$handle() {
        return GetCodepoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepoint$address() {
        return GetCodepoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepoint(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepoint(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepoint", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointNext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepointNext$descriptor() {
        return GetCodepointNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepointNext$handle() {
        return GetCodepointNext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepointNext$address() {
        return GetCodepointNext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointNext(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepointNext(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepointNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointNext", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCodepointPrevious {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetCodepointPrevious");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static FunctionDescriptor GetCodepointPrevious$descriptor() {
        return GetCodepointPrevious.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static MethodHandle GetCodepointPrevious$handle() {
        return GetCodepointPrevious.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static MemorySegment GetCodepointPrevious$address() {
        return GetCodepointPrevious.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCodepointPrevious(const char *text, int *codepointSize)
     * }
     */
    public static int GetCodepointPrevious(MemorySegment text, MemorySegment codepointSize) {
        var mh$ = GetCodepointPrevious.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCodepointPrevious", text, codepointSize);
            }
            return (int)mh$.invokeExact(text, codepointSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CodepointToUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CodepointToUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static FunctionDescriptor CodepointToUTF8$descriptor() {
        return CodepointToUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MethodHandle CodepointToUTF8$handle() {
        return CodepointToUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MemorySegment CodepointToUTF8$address() {
        return CodepointToUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *CodepointToUTF8(int codepoint, int *utf8Size)
     * }
     */
    public static MemorySegment CodepointToUTF8(int codepoint, MemorySegment utf8Size) {
        var mh$ = CodepointToUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CodepointToUTF8", codepoint, utf8Size);
            }
            return (MemorySegment)mh$.invokeExact(codepoint, utf8Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static FunctionDescriptor TextCopy$descriptor() {
        return TextCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static MethodHandle TextCopy$handle() {
        return TextCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static MemorySegment TextCopy$address() {
        return TextCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextCopy(char *dst, const char *src)
     * }
     */
    public static int TextCopy(MemorySegment dst, MemorySegment src) {
        var mh$ = TextCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextCopy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextIsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextIsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static FunctionDescriptor TextIsEqual$descriptor() {
        return TextIsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static MethodHandle TextIsEqual$handle() {
        return TextIsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static MemorySegment TextIsEqual$address() {
        return TextIsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool TextIsEqual(const char *text1, const char *text2)
     * }
     */
    public static boolean TextIsEqual(MemorySegment text1, MemorySegment text2) {
        var mh$ = TextIsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextIsEqual", text1, text2);
            }
            return (boolean)mh$.invokeExact(text1, text2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static FunctionDescriptor TextLength$descriptor() {
        return TextLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static MethodHandle TextLength$handle() {
        return TextLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static MemorySegment TextLength$address() {
        return TextLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int TextLength(const char *text)
     * }
     */
    public static int TextLength(MemorySegment text) {
        var mh$ = TextLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextLength", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * const char *TextFormat(const char *text, ...)
     * }
     */
    public static class TextFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                raylib.C_POINTER,
                raylib.C_POINTER
            );
        private static final MemorySegment ADDR = raylib.findOrThrow("TextFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private TextFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * const char *TextFormat(const char *text, ...)
         * }
         */
        public static TextFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new TextFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment text, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("TextFormat", text, x1);
                }
                return (MemorySegment)spreader.invokeExact(text, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class TextSubtext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextSubtext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static FunctionDescriptor TextSubtext$descriptor() {
        return TextSubtext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MethodHandle TextSubtext$handle() {
        return TextSubtext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MemorySegment TextSubtext$address() {
        return TextSubtext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextSubtext(const char *text, int position, int length)
     * }
     */
    public static MemorySegment TextSubtext(MemorySegment text, int position, int length) {
        var mh$ = TextSubtext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextSubtext", text, position, length);
            }
            return (MemorySegment)mh$.invokeExact(text, position, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextReplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextReplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static FunctionDescriptor TextReplace$descriptor() {
        return TextReplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MethodHandle TextReplace$handle() {
        return TextReplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MemorySegment TextReplace$address() {
        return TextReplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *TextReplace(const char *text, const char *replace, const char *by)
     * }
     */
    public static MemorySegment TextReplace(MemorySegment text, MemorySegment replace, MemorySegment by) {
        var mh$ = TextReplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextReplace", text, replace, by);
            }
            return (MemorySegment)mh$.invokeExact(text, replace, by);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextInsert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextInsert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static FunctionDescriptor TextInsert$descriptor() {
        return TextInsert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MethodHandle TextInsert$handle() {
        return TextInsert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MemorySegment TextInsert$address() {
        return TextInsert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *TextInsert(const char *text, const char *insert, int position)
     * }
     */
    public static MemorySegment TextInsert(MemorySegment text, MemorySegment insert, int position) {
        var mh$ = TextInsert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextInsert", text, insert, position);
            }
            return (MemorySegment)mh$.invokeExact(text, insert, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static FunctionDescriptor TextJoin$descriptor() {
        return TextJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MethodHandle TextJoin$handle() {
        return TextJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MemorySegment TextJoin$address() {
        return TextJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextJoin(const char **textList, int count, const char *delimiter)
     * }
     */
    public static MemorySegment TextJoin(MemorySegment textList, int count, MemorySegment delimiter) {
        var mh$ = TextJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextJoin", textList, count, delimiter);
            }
            return (MemorySegment)mh$.invokeExact(textList, count, delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_CHAR,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static FunctionDescriptor TextSplit$descriptor() {
        return TextSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MethodHandle TextSplit$handle() {
        return TextSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MemorySegment TextSplit$address() {
        return TextSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char **TextSplit(const char *text, char delimiter, int *count)
     * }
     */
    public static MemorySegment TextSplit(MemorySegment text, byte delimiter, MemorySegment count) {
        var mh$ = TextSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextSplit", text, delimiter, count);
            }
            return (MemorySegment)mh$.invokeExact(text, delimiter, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextAppend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextAppend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static FunctionDescriptor TextAppend$descriptor() {
        return TextAppend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static MethodHandle TextAppend$handle() {
        return TextAppend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static MemorySegment TextAppend$address() {
        return TextAppend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TextAppend(char *text, const char *append, int *position)
     * }
     */
    public static void TextAppend(MemorySegment text, MemorySegment append, MemorySegment position) {
        var mh$ = TextAppend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextAppend", text, append, position);
            }
            mh$.invokeExact(text, append, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextFindIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextFindIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static FunctionDescriptor TextFindIndex$descriptor() {
        return TextFindIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static MethodHandle TextFindIndex$handle() {
        return TextFindIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static MemorySegment TextFindIndex$address() {
        return TextFindIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextFindIndex(const char *text, const char *find)
     * }
     */
    public static int TextFindIndex(MemorySegment text, MemorySegment find) {
        var mh$ = TextFindIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextFindIndex", text, find);
            }
            return (int)mh$.invokeExact(text, find);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToUpper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToUpper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static FunctionDescriptor TextToUpper$descriptor() {
        return TextToUpper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MethodHandle TextToUpper$handle() {
        return TextToUpper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MemorySegment TextToUpper$address() {
        return TextToUpper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToUpper(const char *text)
     * }
     */
    public static MemorySegment TextToUpper(MemorySegment text) {
        var mh$ = TextToUpper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToUpper", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToLower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToLower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static FunctionDescriptor TextToLower$descriptor() {
        return TextToLower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MethodHandle TextToLower$handle() {
        return TextToLower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MemorySegment TextToLower$address() {
        return TextToLower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToLower(const char *text)
     * }
     */
    public static MemorySegment TextToLower(MemorySegment text) {
        var mh$ = TextToLower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToLower", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToPascal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToPascal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static FunctionDescriptor TextToPascal$descriptor() {
        return TextToPascal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MethodHandle TextToPascal$handle() {
        return TextToPascal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MemorySegment TextToPascal$address() {
        return TextToPascal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *TextToPascal(const char *text)
     * }
     */
    public static MemorySegment TextToPascal(MemorySegment text) {
        var mh$ = TextToPascal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToPascal", text);
            }
            return (MemorySegment)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToInteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToInteger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static FunctionDescriptor TextToInteger$descriptor() {
        return TextToInteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static MethodHandle TextToInteger$handle() {
        return TextToInteger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static MemorySegment TextToInteger$address() {
        return TextToInteger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TextToInteger(const char *text)
     * }
     */
    public static int TextToInteger(MemorySegment text) {
        var mh$ = TextToInteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToInteger", text);
            }
            return (int)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextToFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("TextToFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static FunctionDescriptor TextToFloat$descriptor() {
        return TextToFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static MethodHandle TextToFloat$handle() {
        return TextToFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static MemorySegment TextToFloat$address() {
        return TextToFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float TextToFloat(const char *text)
     * }
     */
    public static float TextToFloat(MemorySegment text) {
        var mh$ = TextToFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextToFloat", text);
            }
            return (float)mh$.invokeExact(text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLine3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawLine3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static FunctionDescriptor DrawLine3D$descriptor() {
        return DrawLine3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static MethodHandle DrawLine3D$handle() {
        return DrawLine3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static MemorySegment DrawLine3D$address() {
        return DrawLine3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)
     * }
     */
    public static void DrawLine3D(MemorySegment startPos, MemorySegment endPos, MemorySegment color) {
        var mh$ = DrawLine3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLine3D", startPos, endPos, color);
            }
            mh$.invokeExact(startPos, endPos, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPoint3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPoint3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static FunctionDescriptor DrawPoint3D$descriptor() {
        return DrawPoint3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static MethodHandle DrawPoint3D$handle() {
        return DrawPoint3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static MemorySegment DrawPoint3D$address() {
        return DrawPoint3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPoint3D(Vector3 position, Color color)
     * }
     */
    public static void DrawPoint3D(MemorySegment position, MemorySegment color) {
        var mh$ = DrawPoint3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPoint3D", position, color);
            }
            mh$.invokeExact(position, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircle3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCircle3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static FunctionDescriptor DrawCircle3D$descriptor() {
        return DrawCircle3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static MethodHandle DrawCircle3D$handle() {
        return DrawCircle3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static MemorySegment DrawCircle3D$address() {
        return DrawCircle3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color)
     * }
     */
    public static void DrawCircle3D(MemorySegment center, float radius, MemorySegment rotationAxis, float rotationAngle, MemorySegment color) {
        var mh$ = DrawCircle3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircle3D", center, radius, rotationAxis, rotationAngle, color);
            }
            mh$.invokeExact(center, radius, rotationAxis, rotationAngle, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangle3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangle3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangle3D$descriptor() {
        return DrawTriangle3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static MethodHandle DrawTriangle3D$handle() {
        return DrawTriangle3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static MemorySegment DrawTriangle3D$address() {
        return DrawTriangle3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color)
     * }
     */
    public static void DrawTriangle3D(MemorySegment v1, MemorySegment v2, MemorySegment v3, MemorySegment color) {
        var mh$ = DrawTriangle3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangle3D", v1, v2, v3, color);
            }
            mh$.invokeExact(v1, v2, v3, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTriangleStrip3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawTriangleStrip3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static FunctionDescriptor DrawTriangleStrip3D$descriptor() {
        return DrawTriangleStrip3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static MethodHandle DrawTriangleStrip3D$handle() {
        return DrawTriangleStrip3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static MemorySegment DrawTriangleStrip3D$address() {
        return DrawTriangleStrip3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color)
     * }
     */
    public static void DrawTriangleStrip3D(MemorySegment points, int pointCount, MemorySegment color) {
        var mh$ = DrawTriangleStrip3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTriangleStrip3D", points, pointCount, color);
            }
            mh$.invokeExact(points, pointCount, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static FunctionDescriptor DrawCube$descriptor() {
        return DrawCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MethodHandle DrawCube$handle() {
        return DrawCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MemorySegment DrawCube$address() {
        return DrawCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCube(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static void DrawCube(MemorySegment position, float width, float height, float length, MemorySegment color) {
        var mh$ = DrawCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCube", position, width, height, length, color);
            }
            mh$.invokeExact(position, width, height, length, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeV$descriptor() {
        return DrawCubeV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MethodHandle DrawCubeV$handle() {
        return DrawCubeV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MemorySegment DrawCubeV$address() {
        return DrawCubeV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static void DrawCubeV(MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = DrawCubeV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeV", position, size, color);
            }
            mh$.invokeExact(position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeWires$descriptor() {
        return DrawCubeWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MethodHandle DrawCubeWires$handle() {
        return DrawCubeWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static MemorySegment DrawCubeWires$address() {
        return DrawCubeWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)
     * }
     */
    public static void DrawCubeWires(MemorySegment position, float width, float height, float length, MemorySegment color) {
        var mh$ = DrawCubeWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeWires", position, width, height, length, color);
            }
            mh$.invokeExact(position, width, height, length, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCubeWiresV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCubeWiresV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawCubeWiresV$descriptor() {
        return DrawCubeWiresV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MethodHandle DrawCubeWiresV$handle() {
        return DrawCubeWiresV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static MemorySegment DrawCubeWiresV$address() {
        return DrawCubeWiresV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCubeWiresV(Vector3 position, Vector3 size, Color color)
     * }
     */
    public static void DrawCubeWiresV(MemorySegment position, MemorySegment size, MemorySegment color) {
        var mh$ = DrawCubeWiresV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCubeWiresV", position, size, color);
            }
            mh$.invokeExact(position, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphere$descriptor() {
        return DrawSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static MethodHandle DrawSphere$handle() {
        return DrawSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static MemorySegment DrawSphere$address() {
        return DrawSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphere(Vector3 centerPos, float radius, Color color)
     * }
     */
    public static void DrawSphere(MemorySegment centerPos, float radius, MemorySegment color) {
        var mh$ = DrawSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphere", centerPos, radius, color);
            }
            mh$.invokeExact(centerPos, radius, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphereEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphereEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphereEx$descriptor() {
        return DrawSphereEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MethodHandle DrawSphereEx$handle() {
        return DrawSphereEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MemorySegment DrawSphereEx$address() {
        return DrawSphereEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static void DrawSphereEx(MemorySegment centerPos, float radius, int rings, int slices, MemorySegment color) {
        var mh$ = DrawSphereEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphereEx", centerPos, radius, rings, slices, color);
            }
            mh$.invokeExact(centerPos, radius, rings, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSphereWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawSphereWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawSphereWires$descriptor() {
        return DrawSphereWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MethodHandle DrawSphereWires$handle() {
        return DrawSphereWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static MemorySegment DrawSphereWires$address() {
        return DrawSphereWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color)
     * }
     */
    public static void DrawSphereWires(MemorySegment centerPos, float radius, int rings, int slices, MemorySegment color) {
        var mh$ = DrawSphereWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSphereWires", centerPos, radius, rings, slices, color);
            }
            mh$.invokeExact(centerPos, radius, rings, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinder$descriptor() {
        return DrawCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MethodHandle DrawCylinder$handle() {
        return DrawCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MemorySegment DrawCylinder$address() {
        return DrawCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static void DrawCylinder(MemorySegment position, float radiusTop, float radiusBottom, float height, int slices, MemorySegment color) {
        var mh$ = DrawCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinder", position, radiusTop, radiusBottom, height, slices, color);
            }
            mh$.invokeExact(position, radiusTop, radiusBottom, height, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderEx$descriptor() {
        return DrawCylinderEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MethodHandle DrawCylinderEx$handle() {
        return DrawCylinderEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MemorySegment DrawCylinderEx$address() {
        return DrawCylinderEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static void DrawCylinderEx(MemorySegment startPos, MemorySegment endPos, float startRadius, float endRadius, int sides, MemorySegment color) {
        var mh$ = DrawCylinderEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderEx", startPos, endPos, startRadius, endRadius, sides, color);
            }
            mh$.invokeExact(startPos, endPos, startRadius, endRadius, sides, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderWires$descriptor() {
        return DrawCylinderWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MethodHandle DrawCylinderWires$handle() {
        return DrawCylinderWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static MemorySegment DrawCylinderWires$address() {
        return DrawCylinderWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color)
     * }
     */
    public static void DrawCylinderWires(MemorySegment position, float radiusTop, float radiusBottom, float height, int slices, MemorySegment color) {
        var mh$ = DrawCylinderWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderWires", position, radiusTop, radiusBottom, height, slices, color);
            }
            mh$.invokeExact(position, radiusTop, radiusBottom, height, slices, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCylinderWiresEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCylinderWiresEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static FunctionDescriptor DrawCylinderWiresEx$descriptor() {
        return DrawCylinderWiresEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MethodHandle DrawCylinderWiresEx$handle() {
        return DrawCylinderWiresEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static MemorySegment DrawCylinderWiresEx$address() {
        return DrawCylinderWiresEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color)
     * }
     */
    public static void DrawCylinderWiresEx(MemorySegment startPos, MemorySegment endPos, float startRadius, float endRadius, int sides, MemorySegment color) {
        var mh$ = DrawCylinderWiresEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCylinderWiresEx", startPos, endPos, startRadius, endRadius, sides, color);
            }
            mh$.invokeExact(startPos, endPos, startRadius, endRadius, sides, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCapsule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCapsule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static FunctionDescriptor DrawCapsule$descriptor() {
        return DrawCapsule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MethodHandle DrawCapsule$handle() {
        return DrawCapsule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MemorySegment DrawCapsule$address() {
        return DrawCapsule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static void DrawCapsule(MemorySegment startPos, MemorySegment endPos, float radius, int slices, int rings, MemorySegment color) {
        var mh$ = DrawCapsule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCapsule", startPos, endPos, radius, slices, rings, color);
            }
            mh$.invokeExact(startPos, endPos, radius, slices, rings, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCapsuleWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawCapsuleWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static FunctionDescriptor DrawCapsuleWires$descriptor() {
        return DrawCapsuleWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MethodHandle DrawCapsuleWires$handle() {
        return DrawCapsuleWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static MemorySegment DrawCapsuleWires$address() {
        return DrawCapsuleWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color)
     * }
     */
    public static void DrawCapsuleWires(MemorySegment startPos, MemorySegment endPos, float radius, int slices, int rings, MemorySegment color) {
        var mh$ = DrawCapsuleWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCapsuleWires", startPos, endPos, radius, slices, rings, color);
            }
            mh$.invokeExact(startPos, endPos, radius, slices, rings, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Vector3.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static FunctionDescriptor DrawPlane$descriptor() {
        return DrawPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static MethodHandle DrawPlane$handle() {
        return DrawPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static MemorySegment DrawPlane$address() {
        return DrawPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawPlane(Vector3 centerPos, Vector2 size, Color color)
     * }
     */
    public static void DrawPlane(MemorySegment centerPos, MemorySegment size, MemorySegment color) {
        var mh$ = DrawPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPlane", centerPos, size, color);
            }
            mh$.invokeExact(centerPos, size, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ray.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static FunctionDescriptor DrawRay$descriptor() {
        return DrawRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static MethodHandle DrawRay$handle() {
        return DrawRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static MemorySegment DrawRay$address() {
        return DrawRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRay(Ray ray, Color color)
     * }
     */
    public static void DrawRay(MemorySegment ray, MemorySegment color) {
        var mh$ = DrawRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRay", ray, color);
            }
            mh$.invokeExact(ray, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawGrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static FunctionDescriptor DrawGrid$descriptor() {
        return DrawGrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static MethodHandle DrawGrid$handle() {
        return DrawGrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static MemorySegment DrawGrid$address() {
        return DrawGrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawGrid(int slices, float spacing)
     * }
     */
    public static void DrawGrid(int slices, float spacing) {
        var mh$ = DrawGrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGrid", slices, spacing);
            }
            mh$.invokeExact(slices, spacing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Model.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadModel$descriptor() {
        return LoadModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MethodHandle LoadModel$handle() {
        return LoadModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MemorySegment LoadModel$address() {
        return LoadModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Model LoadModel(const char *fileName)
     * }
     */
    public static MemorySegment LoadModel(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModel", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModelFromMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Model.layout(),
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModelFromMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static FunctionDescriptor LoadModelFromMesh$descriptor() {
        return LoadModelFromMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MethodHandle LoadModelFromMesh$handle() {
        return LoadModelFromMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MemorySegment LoadModelFromMesh$address() {
        return LoadModelFromMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Model LoadModelFromMesh(Mesh mesh)
     * }
     */
    public static MemorySegment LoadModelFromMesh(SegmentAllocator allocator, MemorySegment mesh) {
        var mh$ = LoadModelFromMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModelFromMesh", allocator, mesh);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsModelReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsModelReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static FunctionDescriptor IsModelReady$descriptor() {
        return IsModelReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static MethodHandle IsModelReady$handle() {
        return IsModelReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static MemorySegment IsModelReady$address() {
        return IsModelReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsModelReady(Model model)
     * }
     */
    public static boolean IsModelReady(MemorySegment model) {
        var mh$ = IsModelReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsModelReady", model);
            }
            return (boolean)mh$.invokeExact(model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static FunctionDescriptor UnloadModel$descriptor() {
        return UnloadModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static MethodHandle UnloadModel$handle() {
        return UnloadModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static MemorySegment UnloadModel$address() {
        return UnloadModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModel(Model model)
     * }
     */
    public static void UnloadModel(MemorySegment model) {
        var mh$ = UnloadModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModel", model);
            }
            mh$.invokeExact(model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModelBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BoundingBox.layout(),
            Model.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetModelBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static FunctionDescriptor GetModelBoundingBox$descriptor() {
        return GetModelBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MethodHandle GetModelBoundingBox$handle() {
        return GetModelBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MemorySegment GetModelBoundingBox$address() {
        return GetModelBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BoundingBox GetModelBoundingBox(Model model)
     * }
     */
    public static MemorySegment GetModelBoundingBox(SegmentAllocator allocator, MemorySegment model) {
        var mh$ = GetModelBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModelBoundingBox", allocator, model);
            }
            return (MemorySegment)mh$.invokeExact(allocator, model);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModel$descriptor() {
        return DrawModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawModel$handle() {
        return DrawModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawModel$address() {
        return DrawModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModel(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static void DrawModel(MemorySegment model, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = DrawModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModel", model, position, scale, tint);
            }
            mh$.invokeExact(model, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelEx$descriptor() {
        return DrawModelEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelEx$handle() {
        return DrawModelEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelEx$address() {
        return DrawModelEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void DrawModelEx(MemorySegment model, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = DrawModelEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelEx", model, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(model, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelWires {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelWires");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelWires$descriptor() {
        return DrawModelWires.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelWires$handle() {
        return DrawModelWires.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelWires$address() {
        return DrawModelWires.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelWires(Model model, Vector3 position, float scale, Color tint)
     * }
     */
    public static void DrawModelWires(MemorySegment model, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = DrawModelWires.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelWires", model, position, scale, tint);
            }
            mh$.invokeExact(model, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawModelWiresEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawModelWiresEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor DrawModelWiresEx$descriptor() {
        return DrawModelWiresEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle DrawModelWiresEx$handle() {
        return DrawModelWiresEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment DrawModelWiresEx$address() {
        return DrawModelWiresEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void DrawModelWiresEx(MemorySegment model, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = DrawModelWiresEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawModelWiresEx", model, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(model, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            BoundingBox.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static FunctionDescriptor DrawBoundingBox$descriptor() {
        return DrawBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static MethodHandle DrawBoundingBox$handle() {
        return DrawBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static MemorySegment DrawBoundingBox$address() {
        return DrawBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBoundingBox(BoundingBox box, Color color)
     * }
     */
    public static void DrawBoundingBox(MemorySegment box, MemorySegment color) {
        var mh$ = DrawBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBoundingBox", box, color);
            }
            mh$.invokeExact(box, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboard$descriptor() {
        return DrawBillboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static MethodHandle DrawBillboard$handle() {
        return DrawBillboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static MemorySegment DrawBillboard$address() {
        return DrawBillboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint)
     * }
     */
    public static void DrawBillboard(MemorySegment camera, MemorySegment texture, MemorySegment position, float size, MemorySegment tint) {
        var mh$ = DrawBillboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboard", camera, texture, position, size, tint);
            }
            mh$.invokeExact(camera, texture, position, size, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboardRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Rectangle.layout(),
            Vector3.layout(),
            Vector2.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboardRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboardRec$descriptor() {
        return DrawBillboardRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static MethodHandle DrawBillboardRec$handle() {
        return DrawBillboardRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static MemorySegment DrawBillboardRec$address() {
        return DrawBillboardRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint)
     * }
     */
    public static void DrawBillboardRec(MemorySegment camera, MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment size, MemorySegment tint) {
        var mh$ = DrawBillboardRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboardRec", camera, texture, source, position, size, tint);
            }
            mh$.invokeExact(camera, texture, source, position, size, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBillboardPro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Camera3D.layout(),
            Texture.layout(),
            Rectangle.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector2.layout(),
            Vector2.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawBillboardPro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawBillboardPro$descriptor() {
        return DrawBillboardPro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawBillboardPro$handle() {
        return DrawBillboardPro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawBillboardPro$address() {
        return DrawBillboardPro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawBillboardPro(MemorySegment camera, MemorySegment texture, MemorySegment source, MemorySegment position, MemorySegment up, MemorySegment size, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawBillboardPro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBillboardPro", camera, texture, source, position, up, size, origin, rotation, tint);
            }
            mh$.invokeExact(camera, texture, source, position, up, size, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UploadMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_BOOL
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UploadMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static FunctionDescriptor UploadMesh$descriptor() {
        return UploadMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static MethodHandle UploadMesh$handle() {
        return UploadMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static MemorySegment UploadMesh$address() {
        return UploadMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UploadMesh(Mesh *mesh, bool dynamic)
     * }
     */
    public static void UploadMesh(MemorySegment mesh, boolean dynamic) {
        var mh$ = UploadMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UploadMesh", mesh, dynamic);
            }
            mh$.invokeExact(mesh, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateMeshBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            raylib.C_INT,
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateMeshBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static FunctionDescriptor UpdateMeshBuffer$descriptor() {
        return UpdateMeshBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static MethodHandle UpdateMeshBuffer$handle() {
        return UpdateMeshBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static MemorySegment UpdateMeshBuffer$address() {
        return UpdateMeshBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset)
     * }
     */
    public static void UpdateMeshBuffer(MemorySegment mesh, int index, MemorySegment data, int dataSize, int offset) {
        var mh$ = UpdateMeshBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateMeshBuffer", mesh, index, data, dataSize, offset);
            }
            mh$.invokeExact(mesh, index, data, dataSize, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static FunctionDescriptor UnloadMesh$descriptor() {
        return UnloadMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static MethodHandle UnloadMesh$handle() {
        return UnloadMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static MemorySegment UnloadMesh$address() {
        return UnloadMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMesh(Mesh mesh)
     * }
     */
    public static void UnloadMesh(MemorySegment mesh) {
        var mh$ = UnloadMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMesh", mesh);
            }
            mh$.invokeExact(mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            Material.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static FunctionDescriptor DrawMesh$descriptor() {
        return DrawMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static MethodHandle DrawMesh$handle() {
        return DrawMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static MemorySegment DrawMesh$address() {
        return DrawMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawMesh(Mesh mesh, Material material, Matrix transform)
     * }
     */
    public static void DrawMesh(MemorySegment mesh, MemorySegment material, MemorySegment transform) {
        var mh$ = DrawMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMesh", mesh, material, transform);
            }
            mh$.invokeExact(mesh, material, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMeshInstanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Mesh.layout(),
            Material.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DrawMeshInstanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static FunctionDescriptor DrawMeshInstanced$descriptor() {
        return DrawMeshInstanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static MethodHandle DrawMeshInstanced$handle() {
        return DrawMeshInstanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static MemorySegment DrawMeshInstanced$address() {
        return DrawMeshInstanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)
     * }
     */
    public static void DrawMeshInstanced(MemorySegment mesh, MemorySegment material, MemorySegment transforms, int instances) {
        var mh$ = DrawMeshInstanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMeshInstanced", mesh, material, transforms, instances);
            }
            mh$.invokeExact(mesh, material, transforms, instances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMeshBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BoundingBox.layout(),
            Mesh.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMeshBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static FunctionDescriptor GetMeshBoundingBox$descriptor() {
        return GetMeshBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MethodHandle GetMeshBoundingBox$handle() {
        return GetMeshBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MemorySegment GetMeshBoundingBox$address() {
        return GetMeshBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BoundingBox GetMeshBoundingBox(Mesh mesh)
     * }
     */
    public static MemorySegment GetMeshBoundingBox(SegmentAllocator allocator, MemorySegment mesh) {
        var mh$ = GetMeshBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMeshBoundingBox", allocator, mesh);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshTangents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshTangents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static FunctionDescriptor GenMeshTangents$descriptor() {
        return GenMeshTangents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static MethodHandle GenMeshTangents$handle() {
        return GenMeshTangents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static MemorySegment GenMeshTangents$address() {
        return GenMeshTangents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GenMeshTangents(Mesh *mesh)
     * }
     */
    public static void GenMeshTangents(MemorySegment mesh) {
        var mh$ = GenMeshTangents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshTangents", mesh);
            }
            mh$.invokeExact(mesh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Mesh.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportMesh$descriptor() {
        return ExportMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static MethodHandle ExportMesh$handle() {
        return ExportMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static MemorySegment ExportMesh$address() {
        return ExportMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportMesh(Mesh mesh, const char *fileName)
     * }
     */
    public static boolean ExportMesh(MemorySegment mesh, MemorySegment fileName) {
        var mh$ = ExportMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportMesh", mesh, fileName);
            }
            return (boolean)mh$.invokeExact(mesh, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportMeshAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Mesh.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportMeshAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportMeshAsCode$descriptor() {
        return ExportMeshAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static MethodHandle ExportMeshAsCode$handle() {
        return ExportMeshAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static MemorySegment ExportMeshAsCode$address() {
        return ExportMeshAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportMeshAsCode(Mesh mesh, const char *fileName)
     * }
     */
    public static boolean ExportMeshAsCode(MemorySegment mesh, MemorySegment fileName) {
        var mh$ = ExportMeshAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportMeshAsCode", mesh, fileName);
            }
            return (boolean)mh$.invokeExact(mesh, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshPoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_INT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshPoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static FunctionDescriptor GenMeshPoly$descriptor() {
        return GenMeshPoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MethodHandle GenMeshPoly$handle() {
        return GenMeshPoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MemorySegment GenMeshPoly$address() {
        return GenMeshPoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshPoly(int sides, float radius)
     * }
     */
    public static MemorySegment GenMeshPoly(SegmentAllocator allocator, int sides, float radius) {
        var mh$ = GenMeshPoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshPoly", allocator, sides, radius);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sides, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static FunctionDescriptor GenMeshPlane$descriptor() {
        return GenMeshPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MethodHandle GenMeshPlane$handle() {
        return GenMeshPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MemorySegment GenMeshPlane$address() {
        return GenMeshPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshPlane(float width, float length, int resX, int resZ)
     * }
     */
    public static MemorySegment GenMeshPlane(SegmentAllocator allocator, float width, float length, int resX, int resZ) {
        var mh$ = GenMeshPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshPlane", allocator, width, length, resX, resZ);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, length, resX, resZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static FunctionDescriptor GenMeshCube$descriptor() {
        return GenMeshCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MethodHandle GenMeshCube$handle() {
        return GenMeshCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MemorySegment GenMeshCube$address() {
        return GenMeshCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCube(float width, float height, float length)
     * }
     */
    public static MemorySegment GenMeshCube(SegmentAllocator allocator, float width, float height, float length) {
        var mh$ = GenMeshCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCube", allocator, width, height, length);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshSphere$descriptor() {
        return GenMeshSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MethodHandle GenMeshSphere$handle() {
        return GenMeshSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshSphere$address() {
        return GenMeshSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshSphere(SegmentAllocator allocator, float radius, int rings, int slices) {
        var mh$ = GenMeshSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshSphere", allocator, radius, rings, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, rings, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshHemiSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshHemiSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshHemiSphere$descriptor() {
        return GenMeshHemiSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MethodHandle GenMeshHemiSphere$handle() {
        return GenMeshHemiSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshHemiSphere$address() {
        return GenMeshHemiSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshHemiSphere(float radius, int rings, int slices)
     * }
     */
    public static MemorySegment GenMeshHemiSphere(SegmentAllocator allocator, float radius, int rings, int slices) {
        var mh$ = GenMeshHemiSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshHemiSphere", allocator, radius, rings, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, rings, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshCylinder$descriptor() {
        return GenMeshCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MethodHandle GenMeshCylinder$handle() {
        return GenMeshCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCylinder$address() {
        return GenMeshCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCylinder(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCylinder(SegmentAllocator allocator, float radius, float height, int slices) {
        var mh$ = GenMeshCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCylinder", allocator, radius, height, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, height, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static FunctionDescriptor GenMeshCone$descriptor() {
        return GenMeshCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MethodHandle GenMeshCone$handle() {
        return GenMeshCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCone$address() {
        return GenMeshCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCone(float radius, float height, int slices)
     * }
     */
    public static MemorySegment GenMeshCone(SegmentAllocator allocator, float radius, float height, int slices) {
        var mh$ = GenMeshCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCone", allocator, radius, height, slices);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, height, slices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static FunctionDescriptor GenMeshTorus$descriptor() {
        return GenMeshTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MethodHandle GenMeshTorus$handle() {
        return GenMeshTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshTorus$address() {
        return GenMeshTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshTorus(SegmentAllocator allocator, float radius, float size, int radSeg, int sides) {
        var mh$ = GenMeshTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshTorus", allocator, radius, size, radSeg, sides);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, size, radSeg, sides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshKnot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            raylib.C_FLOAT,
            raylib.C_FLOAT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshKnot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static FunctionDescriptor GenMeshKnot$descriptor() {
        return GenMeshKnot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MethodHandle GenMeshKnot$handle() {
        return GenMeshKnot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshKnot$address() {
        return GenMeshKnot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
     * }
     */
    public static MemorySegment GenMeshKnot(SegmentAllocator allocator, float radius, float size, int radSeg, int sides) {
        var mh$ = GenMeshKnot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshKnot", allocator, radius, size, radSeg, sides);
            }
            return (MemorySegment)mh$.invokeExact(allocator, radius, size, radSeg, sides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshHeightmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            Image.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshHeightmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static FunctionDescriptor GenMeshHeightmap$descriptor() {
        return GenMeshHeightmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MethodHandle GenMeshHeightmap$handle() {
        return GenMeshHeightmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MemorySegment GenMeshHeightmap$address() {
        return GenMeshHeightmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshHeightmap(Image heightmap, Vector3 size)
     * }
     */
    public static MemorySegment GenMeshHeightmap(SegmentAllocator allocator, MemorySegment heightmap, MemorySegment size) {
        var mh$ = GenMeshHeightmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshHeightmap", allocator, heightmap, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, heightmap, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenMeshCubicmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Mesh.layout(),
            Image.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GenMeshCubicmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static FunctionDescriptor GenMeshCubicmap$descriptor() {
        return GenMeshCubicmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MethodHandle GenMeshCubicmap$handle() {
        return GenMeshCubicmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MemorySegment GenMeshCubicmap$address() {
        return GenMeshCubicmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize)
     * }
     */
    public static MemorySegment GenMeshCubicmap(SegmentAllocator allocator, MemorySegment cubicmap, MemorySegment cubeSize) {
        var mh$ = GenMeshCubicmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenMeshCubicmap", allocator, cubicmap, cubeSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, cubicmap, cubeSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMaterials {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMaterials");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static FunctionDescriptor LoadMaterials$descriptor() {
        return LoadMaterials.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MethodHandle LoadMaterials$handle() {
        return LoadMaterials.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MemorySegment LoadMaterials$address() {
        return LoadMaterials.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Material *LoadMaterials(const char *fileName, int *materialCount)
     * }
     */
    public static MemorySegment LoadMaterials(MemorySegment fileName, MemorySegment materialCount) {
        var mh$ = LoadMaterials.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMaterials", fileName, materialCount);
            }
            return (MemorySegment)mh$.invokeExact(fileName, materialCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMaterialDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Material.layout()    );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMaterialDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static FunctionDescriptor LoadMaterialDefault$descriptor() {
        return LoadMaterialDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MethodHandle LoadMaterialDefault$handle() {
        return LoadMaterialDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MemorySegment LoadMaterialDefault$address() {
        return LoadMaterialDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Material LoadMaterialDefault()
     * }
     */
    public static MemorySegment LoadMaterialDefault(SegmentAllocator allocator) {
        var mh$ = LoadMaterialDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMaterialDefault", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMaterialReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Material.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMaterialReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static FunctionDescriptor IsMaterialReady$descriptor() {
        return IsMaterialReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static MethodHandle IsMaterialReady$handle() {
        return IsMaterialReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static MemorySegment IsMaterialReady$address() {
        return IsMaterialReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMaterialReady(Material material)
     * }
     */
    public static boolean IsMaterialReady(MemorySegment material) {
        var mh$ = IsMaterialReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMaterialReady", material);
            }
            return (boolean)mh$.invokeExact(material);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Material.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static FunctionDescriptor UnloadMaterial$descriptor() {
        return UnloadMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static MethodHandle UnloadMaterial$handle() {
        return UnloadMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static MemorySegment UnloadMaterial$address() {
        return UnloadMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMaterial(Material material)
     * }
     */
    public static void UnloadMaterial(MemorySegment material) {
        var mh$ = UnloadMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMaterial", material);
            }
            mh$.invokeExact(material);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMaterialTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            Texture.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMaterialTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static FunctionDescriptor SetMaterialTexture$descriptor() {
        return SetMaterialTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static MethodHandle SetMaterialTexture$handle() {
        return SetMaterialTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static MemorySegment SetMaterialTexture$address() {
        return SetMaterialTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMaterialTexture(Material *material, int mapType, Texture2D texture)
     * }
     */
    public static void SetMaterialTexture(MemorySegment material, int mapType, MemorySegment texture) {
        var mh$ = SetMaterialTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMaterialTexture", material, mapType, texture);
            }
            mh$.invokeExact(material, mapType, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetModelMeshMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetModelMeshMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static FunctionDescriptor SetModelMeshMaterial$descriptor() {
        return SetModelMeshMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static MethodHandle SetModelMeshMaterial$handle() {
        return SetModelMeshMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static MemorySegment SetModelMeshMaterial$address() {
        return SetModelMeshMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetModelMeshMaterial(Model *model, int meshId, int materialId)
     * }
     */
    public static void SetModelMeshMaterial(MemorySegment model, int meshId, int materialId) {
        var mh$ = SetModelMeshMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetModelMeshMaterial", model, meshId, materialId);
            }
            mh$.invokeExact(model, meshId, materialId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModelAnimations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadModelAnimations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static FunctionDescriptor LoadModelAnimations$descriptor() {
        return LoadModelAnimations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MethodHandle LoadModelAnimations$handle() {
        return LoadModelAnimations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MemorySegment LoadModelAnimations$address() {
        return LoadModelAnimations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount)
     * }
     */
    public static MemorySegment LoadModelAnimations(MemorySegment fileName, MemorySegment animCount) {
        var mh$ = LoadModelAnimations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModelAnimations", fileName, animCount);
            }
            return (MemorySegment)mh$.invokeExact(fileName, animCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateModelAnimation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Model.layout(),
            ModelAnimation.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateModelAnimation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static FunctionDescriptor UpdateModelAnimation$descriptor() {
        return UpdateModelAnimation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static MethodHandle UpdateModelAnimation$handle() {
        return UpdateModelAnimation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static MemorySegment UpdateModelAnimation$address() {
        return UpdateModelAnimation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateModelAnimation(Model model, ModelAnimation anim, int frame)
     * }
     */
    public static void UpdateModelAnimation(MemorySegment model, MemorySegment anim, int frame) {
        var mh$ = UpdateModelAnimation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateModelAnimation", model, anim, frame);
            }
            mh$.invokeExact(model, anim, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModelAnimation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ModelAnimation.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModelAnimation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static FunctionDescriptor UnloadModelAnimation$descriptor() {
        return UnloadModelAnimation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static MethodHandle UnloadModelAnimation$handle() {
        return UnloadModelAnimation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static MemorySegment UnloadModelAnimation$address() {
        return UnloadModelAnimation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModelAnimation(ModelAnimation anim)
     * }
     */
    public static void UnloadModelAnimation(MemorySegment anim) {
        var mh$ = UnloadModelAnimation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModelAnimation", anim);
            }
            mh$.invokeExact(anim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadModelAnimations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadModelAnimations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static FunctionDescriptor UnloadModelAnimations$descriptor() {
        return UnloadModelAnimations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static MethodHandle UnloadModelAnimations$handle() {
        return UnloadModelAnimations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static MemorySegment UnloadModelAnimations$address() {
        return UnloadModelAnimations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadModelAnimations(ModelAnimation *animations, int animCount)
     * }
     */
    public static void UnloadModelAnimations(MemorySegment animations, int animCount) {
        var mh$ = UnloadModelAnimations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadModelAnimations", animations, animCount);
            }
            mh$.invokeExact(animations, animCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsModelAnimationValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Model.layout(),
            ModelAnimation.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsModelAnimationValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static FunctionDescriptor IsModelAnimationValid$descriptor() {
        return IsModelAnimationValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static MethodHandle IsModelAnimationValid$handle() {
        return IsModelAnimationValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static MemorySegment IsModelAnimationValid$address() {
        return IsModelAnimationValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsModelAnimationValid(Model model, ModelAnimation anim)
     * }
     */
    public static boolean IsModelAnimationValid(MemorySegment model, MemorySegment anim) {
        var mh$ = IsModelAnimationValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsModelAnimationValid", model, anim);
            }
            return (boolean)mh$.invokeExact(model, anim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionSpheres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionSpheres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static FunctionDescriptor CheckCollisionSpheres$descriptor() {
        return CheckCollisionSpheres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static MethodHandle CheckCollisionSpheres$handle() {
        return CheckCollisionSpheres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static MemorySegment CheckCollisionSpheres$address() {
        return CheckCollisionSpheres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2)
     * }
     */
    public static boolean CheckCollisionSpheres(MemorySegment center1, float radius1, MemorySegment center2, float radius2) {
        var mh$ = CheckCollisionSpheres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionSpheres", center1, radius1, center2, radius2);
            }
            return (boolean)mh$.invokeExact(center1, radius1, center2, radius2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionBoxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            BoundingBox.layout(),
            BoundingBox.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionBoxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static FunctionDescriptor CheckCollisionBoxes$descriptor() {
        return CheckCollisionBoxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static MethodHandle CheckCollisionBoxes$handle() {
        return CheckCollisionBoxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static MemorySegment CheckCollisionBoxes$address() {
        return CheckCollisionBoxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2)
     * }
     */
    public static boolean CheckCollisionBoxes(MemorySegment box1, MemorySegment box2) {
        var mh$ = CheckCollisionBoxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionBoxes", box1, box2);
            }
            return (boolean)mh$.invokeExact(box1, box2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckCollisionBoxSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            BoundingBox.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("CheckCollisionBoxSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static FunctionDescriptor CheckCollisionBoxSphere$descriptor() {
        return CheckCollisionBoxSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static MethodHandle CheckCollisionBoxSphere$handle() {
        return CheckCollisionBoxSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static MemorySegment CheckCollisionBoxSphere$address() {
        return CheckCollisionBoxSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius)
     * }
     */
    public static boolean CheckCollisionBoxSphere(MemorySegment box, MemorySegment center, float radius) {
        var mh$ = CheckCollisionBoxSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckCollisionBoxSphere", box, center, radius);
            }
            return (boolean)mh$.invokeExact(box, center, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static FunctionDescriptor GetRayCollisionSphere$descriptor() {
        return GetRayCollisionSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MethodHandle GetRayCollisionSphere$handle() {
        return GetRayCollisionSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MemorySegment GetRayCollisionSphere$address() {
        return GetRayCollisionSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius)
     * }
     */
    public static MemorySegment GetRayCollisionSphere(SegmentAllocator allocator, MemorySegment ray, MemorySegment center, float radius) {
        var mh$ = GetRayCollisionSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionSphere", allocator, ray, center, radius);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, center, radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            BoundingBox.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static FunctionDescriptor GetRayCollisionBox$descriptor() {
        return GetRayCollisionBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MethodHandle GetRayCollisionBox$handle() {
        return GetRayCollisionBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MemorySegment GetRayCollisionBox$address() {
        return GetRayCollisionBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionBox(Ray ray, BoundingBox box)
     * }
     */
    public static MemorySegment GetRayCollisionBox(SegmentAllocator allocator, MemorySegment ray, MemorySegment box) {
        var mh$ = GetRayCollisionBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionBox", allocator, ray, box);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionMesh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Mesh.layout(),
            Matrix.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionMesh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static FunctionDescriptor GetRayCollisionMesh$descriptor() {
        return GetRayCollisionMesh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MethodHandle GetRayCollisionMesh$handle() {
        return GetRayCollisionMesh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MemorySegment GetRayCollisionMesh$address() {
        return GetRayCollisionMesh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform)
     * }
     */
    public static MemorySegment GetRayCollisionMesh(SegmentAllocator allocator, MemorySegment ray, MemorySegment mesh, MemorySegment transform) {
        var mh$ = GetRayCollisionMesh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionMesh", allocator, ray, mesh, transform);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, mesh, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionTriangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionTriangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static FunctionDescriptor GetRayCollisionTriangle$descriptor() {
        return GetRayCollisionTriangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MethodHandle GetRayCollisionTriangle$handle() {
        return GetRayCollisionTriangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MemorySegment GetRayCollisionTriangle$address() {
        return GetRayCollisionTriangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3)
     * }
     */
    public static MemorySegment GetRayCollisionTriangle(SegmentAllocator allocator, MemorySegment ray, MemorySegment p1, MemorySegment p2, MemorySegment p3) {
        var mh$ = GetRayCollisionTriangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionTriangle", allocator, ray, p1, p2, p3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, p1, p2, p3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRayCollisionQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayCollision.layout(),
            Ray.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout(),
            Vector3.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetRayCollisionQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static FunctionDescriptor GetRayCollisionQuad$descriptor() {
        return GetRayCollisionQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MethodHandle GetRayCollisionQuad$handle() {
        return GetRayCollisionQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MemorySegment GetRayCollisionQuad$address() {
        return GetRayCollisionQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
     * }
     */
    public static MemorySegment GetRayCollisionQuad(SegmentAllocator allocator, MemorySegment ray, MemorySegment p1, MemorySegment p2, MemorySegment p3, MemorySegment p4) {
        var mh$ = GetRayCollisionQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRayCollisionQuad", allocator, ray, p1, p2, p3, p4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ray, p1, p2, p3, p4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitAudioDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("InitAudioDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static FunctionDescriptor InitAudioDevice$descriptor() {
        return InitAudioDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static MethodHandle InitAudioDevice$handle() {
        return InitAudioDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static MemorySegment InitAudioDevice$address() {
        return InitAudioDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitAudioDevice()
     * }
     */
    public static void InitAudioDevice() {
        var mh$ = InitAudioDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitAudioDevice");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseAudioDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = raylib.findOrThrow("CloseAudioDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static FunctionDescriptor CloseAudioDevice$descriptor() {
        return CloseAudioDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static MethodHandle CloseAudioDevice$handle() {
        return CloseAudioDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static MemorySegment CloseAudioDevice$address() {
        return CloseAudioDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseAudioDevice()
     * }
     */
    public static void CloseAudioDevice() {
        var mh$ = CloseAudioDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseAudioDevice");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioDeviceReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL    );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioDeviceReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static FunctionDescriptor IsAudioDeviceReady$descriptor() {
        return IsAudioDeviceReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static MethodHandle IsAudioDeviceReady$handle() {
        return IsAudioDeviceReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static MemorySegment IsAudioDeviceReady$address() {
        return IsAudioDeviceReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioDeviceReady()
     * }
     */
    public static boolean IsAudioDeviceReady() {
        var mh$ = IsAudioDeviceReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioDeviceReady");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMasterVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMasterVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static FunctionDescriptor SetMasterVolume$descriptor() {
        return SetMasterVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static MethodHandle SetMasterVolume$handle() {
        return SetMasterVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static MemorySegment SetMasterVolume$address() {
        return SetMasterVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMasterVolume(float volume)
     * }
     */
    public static void SetMasterVolume(float volume) {
        var mh$ = SetMasterVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMasterVolume", volume);
            }
            mh$.invokeExact(volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMasterVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT    );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMasterVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static FunctionDescriptor GetMasterVolume$descriptor() {
        return GetMasterVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static MethodHandle GetMasterVolume$handle() {
        return GetMasterVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static MemorySegment GetMasterVolume$address() {
        return GetMasterVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMasterVolume()
     * }
     */
    public static float GetMasterVolume() {
        var mh$ = GetMasterVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMasterVolume");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadWave$descriptor() {
        return LoadWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MethodHandle LoadWave$handle() {
        return LoadWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MemorySegment LoadWave$address() {
        return LoadWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave LoadWave(const char *fileName)
     * }
     */
    public static MemorySegment LoadWave(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWave", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWaveFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWaveFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static FunctionDescriptor LoadWaveFromMemory$descriptor() {
        return LoadWaveFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MethodHandle LoadWaveFromMemory$handle() {
        return LoadWaveFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadWaveFromMemory$address() {
        return LoadWaveFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize)
     * }
     */
    public static MemorySegment LoadWaveFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment fileData, int dataSize) {
        var mh$ = LoadWaveFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWaveFromMemory", allocator, fileType, fileData, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, fileData, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWaveReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsWaveReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static FunctionDescriptor IsWaveReady$descriptor() {
        return IsWaveReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static MethodHandle IsWaveReady$handle() {
        return IsWaveReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static MemorySegment IsWaveReady$address() {
        return IsWaveReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsWaveReady(Wave wave)
     * }
     */
    public static boolean IsWaveReady(MemorySegment wave) {
        var mh$ = IsWaveReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWaveReady", wave);
            }
            return (boolean)mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadSound$descriptor() {
        return LoadSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MethodHandle LoadSound$handle() {
        return LoadSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MemorySegment LoadSound$address() {
        return LoadSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSound(const char *fileName)
     * }
     */
    public static MemorySegment LoadSound(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSound", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSoundFromWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSoundFromWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static FunctionDescriptor LoadSoundFromWave$descriptor() {
        return LoadSoundFromWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MethodHandle LoadSoundFromWave$handle() {
        return LoadSoundFromWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MemorySegment LoadSoundFromWave$address() {
        return LoadSoundFromWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSoundFromWave(Wave wave)
     * }
     */
    public static MemorySegment LoadSoundFromWave(SegmentAllocator allocator, MemorySegment wave) {
        var mh$ = LoadSoundFromWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSoundFromWave", allocator, wave);
            }
            return (MemorySegment)mh$.invokeExact(allocator, wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadSoundAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Sound.layout(),
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadSoundAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static FunctionDescriptor LoadSoundAlias$descriptor() {
        return LoadSoundAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MethodHandle LoadSoundAlias$handle() {
        return LoadSoundAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MemorySegment LoadSoundAlias$address() {
        return LoadSoundAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Sound LoadSoundAlias(Sound source)
     * }
     */
    public static MemorySegment LoadSoundAlias(SegmentAllocator allocator, MemorySegment source) {
        var mh$ = LoadSoundAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadSoundAlias", allocator, source);
            }
            return (MemorySegment)mh$.invokeExact(allocator, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSoundReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsSoundReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static FunctionDescriptor IsSoundReady$descriptor() {
        return IsSoundReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static MethodHandle IsSoundReady$handle() {
        return IsSoundReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static MemorySegment IsSoundReady$address() {
        return IsSoundReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsSoundReady(Sound sound)
     * }
     */
    public static boolean IsSoundReady(MemorySegment sound) {
        var mh$ = IsSoundReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSoundReady", sound);
            }
            return (boolean)mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static FunctionDescriptor UpdateSound$descriptor() {
        return UpdateSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static MethodHandle UpdateSound$handle() {
        return UpdateSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static MemorySegment UpdateSound$address() {
        return UpdateSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateSound(Sound sound, const void *data, int sampleCount)
     * }
     */
    public static void UpdateSound(MemorySegment sound, MemorySegment data, int sampleCount) {
        var mh$ = UpdateSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateSound", sound, data, sampleCount);
            }
            mh$.invokeExact(sound, data, sampleCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static FunctionDescriptor UnloadWave$descriptor() {
        return UnloadWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static MethodHandle UnloadWave$handle() {
        return UnloadWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static MemorySegment UnloadWave$address() {
        return UnloadWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadWave(Wave wave)
     * }
     */
    public static void UnloadWave(MemorySegment wave) {
        var mh$ = UnloadWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadWave", wave);
            }
            mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static FunctionDescriptor UnloadSound$descriptor() {
        return UnloadSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static MethodHandle UnloadSound$handle() {
        return UnloadSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static MemorySegment UnloadSound$address() {
        return UnloadSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadSound(Sound sound)
     * }
     */
    public static void UnloadSound(MemorySegment sound) {
        var mh$ = UnloadSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadSoundAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadSoundAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static FunctionDescriptor UnloadSoundAlias$descriptor() {
        return UnloadSoundAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static MethodHandle UnloadSoundAlias$handle() {
        return UnloadSoundAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static MemorySegment UnloadSoundAlias$address() {
        return UnloadSoundAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadSoundAlias(Sound alias)
     * }
     */
    public static void UnloadSoundAlias(MemorySegment alias) {
        var mh$ = UnloadSoundAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadSoundAlias", alias);
            }
            mh$.invokeExact(alias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportWave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportWave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportWave$descriptor() {
        return ExportWave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static MethodHandle ExportWave$handle() {
        return ExportWave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static MemorySegment ExportWave$address() {
        return ExportWave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportWave(Wave wave, const char *fileName)
     * }
     */
    public static boolean ExportWave(MemorySegment wave, MemorySegment fileName) {
        var mh$ = ExportWave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportWave", wave, fileName);
            }
            return (boolean)mh$.invokeExact(wave, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportWaveAsCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Wave.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ExportWaveAsCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static FunctionDescriptor ExportWaveAsCode$descriptor() {
        return ExportWaveAsCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static MethodHandle ExportWaveAsCode$handle() {
        return ExportWaveAsCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static MemorySegment ExportWaveAsCode$address() {
        return ExportWaveAsCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ExportWaveAsCode(Wave wave, const char *fileName)
     * }
     */
    public static boolean ExportWaveAsCode(MemorySegment wave, MemorySegment fileName) {
        var mh$ = ExportWaveAsCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportWaveAsCode", wave, fileName);
            }
            return (boolean)mh$.invokeExact(wave, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlaySound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlaySound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static FunctionDescriptor PlaySound$descriptor() {
        return PlaySound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static MethodHandle PlaySound$handle() {
        return PlaySound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static MemorySegment PlaySound$address() {
        return PlaySound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlaySound(Sound sound)
     * }
     */
    public static void PlaySound(MemorySegment sound) {
        var mh$ = PlaySound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlaySound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static FunctionDescriptor StopSound$descriptor() {
        return StopSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static MethodHandle StopSound$handle() {
        return StopSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static MemorySegment StopSound$address() {
        return StopSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopSound(Sound sound)
     * }
     */
    public static void StopSound(MemorySegment sound) {
        var mh$ = StopSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static FunctionDescriptor PauseSound$descriptor() {
        return PauseSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static MethodHandle PauseSound$handle() {
        return PauseSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static MemorySegment PauseSound$address() {
        return PauseSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseSound(Sound sound)
     * }
     */
    public static void PauseSound(MemorySegment sound) {
        var mh$ = PauseSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static FunctionDescriptor ResumeSound$descriptor() {
        return ResumeSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static MethodHandle ResumeSound$handle() {
        return ResumeSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static MemorySegment ResumeSound$address() {
        return ResumeSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeSound(Sound sound)
     * }
     */
    public static void ResumeSound(MemorySegment sound) {
        var mh$ = ResumeSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeSound", sound);
            }
            mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSoundPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Sound.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsSoundPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static FunctionDescriptor IsSoundPlaying$descriptor() {
        return IsSoundPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static MethodHandle IsSoundPlaying$handle() {
        return IsSoundPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static MemorySegment IsSoundPlaying$address() {
        return IsSoundPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsSoundPlaying(Sound sound)
     * }
     */
    public static boolean IsSoundPlaying(MemorySegment sound) {
        var mh$ = IsSoundPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSoundPlaying", sound);
            }
            return (boolean)mh$.invokeExact(sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static FunctionDescriptor SetSoundVolume$descriptor() {
        return SetSoundVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static MethodHandle SetSoundVolume$handle() {
        return SetSoundVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static MemorySegment SetSoundVolume$address() {
        return SetSoundVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundVolume(Sound sound, float volume)
     * }
     */
    public static void SetSoundVolume(MemorySegment sound, float volume) {
        var mh$ = SetSoundVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundVolume", sound, volume);
            }
            mh$.invokeExact(sound, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static FunctionDescriptor SetSoundPitch$descriptor() {
        return SetSoundPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static MethodHandle SetSoundPitch$handle() {
        return SetSoundPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static MemorySegment SetSoundPitch$address() {
        return SetSoundPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundPitch(Sound sound, float pitch)
     * }
     */
    public static void SetSoundPitch(MemorySegment sound, float pitch) {
        var mh$ = SetSoundPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundPitch", sound, pitch);
            }
            mh$.invokeExact(sound, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSoundPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Sound.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetSoundPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static FunctionDescriptor SetSoundPan$descriptor() {
        return SetSoundPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static MethodHandle SetSoundPan$handle() {
        return SetSoundPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static MemorySegment SetSoundPan$address() {
        return SetSoundPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSoundPan(Sound sound, float pan)
     * }
     */
    public static void SetSoundPan(MemorySegment sound, float pan) {
        var mh$ = SetSoundPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSoundPan", sound, pan);
            }
            mh$.invokeExact(sound, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Wave.layout(),
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static FunctionDescriptor WaveCopy$descriptor() {
        return WaveCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MethodHandle WaveCopy$handle() {
        return WaveCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MemorySegment WaveCopy$address() {
        return WaveCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Wave WaveCopy(Wave wave)
     * }
     */
    public static MemorySegment WaveCopy(SegmentAllocator allocator, MemorySegment wave) {
        var mh$ = WaveCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveCopy", allocator, wave);
            }
            return (MemorySegment)mh$.invokeExact(allocator, wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveCrop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveCrop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static FunctionDescriptor WaveCrop$descriptor() {
        return WaveCrop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static MethodHandle WaveCrop$handle() {
        return WaveCrop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static MemorySegment WaveCrop$address() {
        return WaveCrop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaveCrop(Wave *wave, int initSample, int finalSample)
     * }
     */
    public static void WaveCrop(MemorySegment wave, int initSample, int finalSample) {
        var mh$ = WaveCrop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveCrop", wave, initSample, finalSample);
            }
            mh$.invokeExact(wave, initSample, finalSample);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER,
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("WaveFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static FunctionDescriptor WaveFormat$descriptor() {
        return WaveFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static MethodHandle WaveFormat$handle() {
        return WaveFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static MemorySegment WaveFormat$address() {
        return WaveFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels)
     * }
     */
    public static void WaveFormat(MemorySegment wave, int sampleRate, int sampleSize, int channels) {
        var mh$ = WaveFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveFormat", wave, sampleRate, sampleSize, channels);
            }
            mh$.invokeExact(wave, sampleRate, sampleSize, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadWaveSamples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_POINTER,
            Wave.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadWaveSamples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static FunctionDescriptor LoadWaveSamples$descriptor() {
        return LoadWaveSamples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MethodHandle LoadWaveSamples$handle() {
        return LoadWaveSamples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MemorySegment LoadWaveSamples$address() {
        return LoadWaveSamples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *LoadWaveSamples(Wave wave)
     * }
     */
    public static MemorySegment LoadWaveSamples(MemorySegment wave) {
        var mh$ = LoadWaveSamples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadWaveSamples", wave);
            }
            return (MemorySegment)mh$.invokeExact(wave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadWaveSamples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadWaveSamples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static FunctionDescriptor UnloadWaveSamples$descriptor() {
        return UnloadWaveSamples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static MethodHandle UnloadWaveSamples$handle() {
        return UnloadWaveSamples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static MemorySegment UnloadWaveSamples$address() {
        return UnloadWaveSamples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadWaveSamples(float *samples)
     * }
     */
    public static void UnloadWaveSamples(MemorySegment samples) {
        var mh$ = UnloadWaveSamples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadWaveSamples", samples);
            }
            mh$.invokeExact(samples);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Music.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadMusicStream$descriptor() {
        return LoadMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MethodHandle LoadMusicStream$handle() {
        return LoadMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MemorySegment LoadMusicStream$address() {
        return LoadMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Music LoadMusicStream(const char *fileName)
     * }
     */
    public static MemorySegment LoadMusicStream(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMusicStream", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMusicStreamFromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Music.layout(),
            raylib.C_POINTER,
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadMusicStreamFromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static FunctionDescriptor LoadMusicStreamFromMemory$descriptor() {
        return LoadMusicStreamFromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MethodHandle LoadMusicStreamFromMemory$handle() {
        return LoadMusicStreamFromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MemorySegment LoadMusicStreamFromMemory$address() {
        return LoadMusicStreamFromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize)
     * }
     */
    public static MemorySegment LoadMusicStreamFromMemory(SegmentAllocator allocator, MemorySegment fileType, MemorySegment data, int dataSize) {
        var mh$ = LoadMusicStreamFromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMusicStreamFromMemory", allocator, fileType, data, dataSize);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileType, data, dataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMusicReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMusicReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static FunctionDescriptor IsMusicReady$descriptor() {
        return IsMusicReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static MethodHandle IsMusicReady$handle() {
        return IsMusicReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static MemorySegment IsMusicReady$address() {
        return IsMusicReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMusicReady(Music music)
     * }
     */
    public static boolean IsMusicReady(MemorySegment music) {
        var mh$ = IsMusicReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMusicReady", music);
            }
            return (boolean)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor UnloadMusicStream$descriptor() {
        return UnloadMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static MethodHandle UnloadMusicStream$handle() {
        return UnloadMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static MemorySegment UnloadMusicStream$address() {
        return UnloadMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadMusicStream(Music music)
     * }
     */
    public static void UnloadMusicStream(MemorySegment music) {
        var mh$ = UnloadMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlayMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor PlayMusicStream$descriptor() {
        return PlayMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static MethodHandle PlayMusicStream$handle() {
        return PlayMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static MemorySegment PlayMusicStream$address() {
        return PlayMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlayMusicStream(Music music)
     * }
     */
    public static void PlayMusicStream(MemorySegment music) {
        var mh$ = PlayMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMusicStreamPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsMusicStreamPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static FunctionDescriptor IsMusicStreamPlaying$descriptor() {
        return IsMusicStreamPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static MethodHandle IsMusicStreamPlaying$handle() {
        return IsMusicStreamPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static MemorySegment IsMusicStreamPlaying$address() {
        return IsMusicStreamPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsMusicStreamPlaying(Music music)
     * }
     */
    public static boolean IsMusicStreamPlaying(MemorySegment music) {
        var mh$ = IsMusicStreamPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMusicStreamPlaying", music);
            }
            return (boolean)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor UpdateMusicStream$descriptor() {
        return UpdateMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static MethodHandle UpdateMusicStream$handle() {
        return UpdateMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static MemorySegment UpdateMusicStream$address() {
        return UpdateMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateMusicStream(Music music)
     * }
     */
    public static void UpdateMusicStream(MemorySegment music) {
        var mh$ = UpdateMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor StopMusicStream$descriptor() {
        return StopMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static MethodHandle StopMusicStream$handle() {
        return StopMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static MemorySegment StopMusicStream$address() {
        return StopMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopMusicStream(Music music)
     * }
     */
    public static void StopMusicStream(MemorySegment music) {
        var mh$ = StopMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor PauseMusicStream$descriptor() {
        return PauseMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static MethodHandle PauseMusicStream$handle() {
        return PauseMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static MemorySegment PauseMusicStream$address() {
        return PauseMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseMusicStream(Music music)
     * }
     */
    public static void PauseMusicStream(MemorySegment music) {
        var mh$ = PauseMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static FunctionDescriptor ResumeMusicStream$descriptor() {
        return ResumeMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static MethodHandle ResumeMusicStream$handle() {
        return ResumeMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static MemorySegment ResumeMusicStream$address() {
        return ResumeMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeMusicStream(Music music)
     * }
     */
    public static void ResumeMusicStream(MemorySegment music) {
        var mh$ = ResumeMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeMusicStream", music);
            }
            mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SeekMusicStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SeekMusicStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static FunctionDescriptor SeekMusicStream$descriptor() {
        return SeekMusicStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static MethodHandle SeekMusicStream$handle() {
        return SeekMusicStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static MemorySegment SeekMusicStream$address() {
        return SeekMusicStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SeekMusicStream(Music music, float position)
     * }
     */
    public static void SeekMusicStream(MemorySegment music, float position) {
        var mh$ = SeekMusicStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SeekMusicStream", music, position);
            }
            mh$.invokeExact(music, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static FunctionDescriptor SetMusicVolume$descriptor() {
        return SetMusicVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static MethodHandle SetMusicVolume$handle() {
        return SetMusicVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static MemorySegment SetMusicVolume$address() {
        return SetMusicVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicVolume(Music music, float volume)
     * }
     */
    public static void SetMusicVolume(MemorySegment music, float volume) {
        var mh$ = SetMusicVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicVolume", music, volume);
            }
            mh$.invokeExact(music, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static FunctionDescriptor SetMusicPitch$descriptor() {
        return SetMusicPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static MethodHandle SetMusicPitch$handle() {
        return SetMusicPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static MemorySegment SetMusicPitch$address() {
        return SetMusicPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicPitch(Music music, float pitch)
     * }
     */
    public static void SetMusicPitch(MemorySegment music, float pitch) {
        var mh$ = SetMusicPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicPitch", music, pitch);
            }
            mh$.invokeExact(music, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMusicPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Music.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetMusicPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static FunctionDescriptor SetMusicPan$descriptor() {
        return SetMusicPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static MethodHandle SetMusicPan$handle() {
        return SetMusicPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static MemorySegment SetMusicPan$address() {
        return SetMusicPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetMusicPan(Music music, float pan)
     * }
     */
    public static void SetMusicPan(MemorySegment music, float pan) {
        var mh$ = SetMusicPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMusicPan", music, pan);
            }
            mh$.invokeExact(music, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMusicTimeLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMusicTimeLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static FunctionDescriptor GetMusicTimeLength$descriptor() {
        return GetMusicTimeLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static MethodHandle GetMusicTimeLength$handle() {
        return GetMusicTimeLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static MemorySegment GetMusicTimeLength$address() {
        return GetMusicTimeLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMusicTimeLength(Music music)
     * }
     */
    public static float GetMusicTimeLength(MemorySegment music) {
        var mh$ = GetMusicTimeLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMusicTimeLength", music);
            }
            return (float)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMusicTimePlayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Music.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("GetMusicTimePlayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static FunctionDescriptor GetMusicTimePlayed$descriptor() {
        return GetMusicTimePlayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static MethodHandle GetMusicTimePlayed$handle() {
        return GetMusicTimePlayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static MemorySegment GetMusicTimePlayed$address() {
        return GetMusicTimePlayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetMusicTimePlayed(Music music)
     * }
     */
    public static float GetMusicTimePlayed(MemorySegment music) {
        var mh$ = GetMusicTimePlayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMusicTimePlayed", music);
            }
            return (float)mh$.invokeExact(music);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AudioStream.layout(),
            raylib.C_INT,
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("LoadAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static FunctionDescriptor LoadAudioStream$descriptor() {
        return LoadAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MethodHandle LoadAudioStream$handle() {
        return LoadAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MemorySegment LoadAudioStream$address() {
        return LoadAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels)
     * }
     */
    public static MemorySegment LoadAudioStream(SegmentAllocator allocator, int sampleRate, int sampleSize, int channels) {
        var mh$ = LoadAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAudioStream", allocator, sampleRate, sampleSize, channels);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sampleRate, sampleSize, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamReady {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamReady");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamReady$descriptor() {
        return IsAudioStreamReady.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamReady$handle() {
        return IsAudioStreamReady.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamReady$address() {
        return IsAudioStreamReady.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamReady(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamReady(MemorySegment stream) {
        var mh$ = IsAudioStreamReady.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamReady", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UnloadAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor UnloadAudioStream$descriptor() {
        return UnloadAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle UnloadAudioStream$handle() {
        return UnloadAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment UnloadAudioStream$address() {
        return UnloadAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnloadAudioStream(AudioStream stream)
     * }
     */
    public static void UnloadAudioStream(MemorySegment stream) {
        var mh$ = UnloadAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("UpdateAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static FunctionDescriptor UpdateAudioStream$descriptor() {
        return UpdateAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static MethodHandle UpdateAudioStream$handle() {
        return UpdateAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static MemorySegment UpdateAudioStream$address() {
        return UpdateAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UpdateAudioStream(AudioStream stream, const void *data, int frameCount)
     * }
     */
    public static void UpdateAudioStream(MemorySegment stream, MemorySegment data, int frameCount) {
        var mh$ = UpdateAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateAudioStream", stream, data, frameCount);
            }
            mh$.invokeExact(stream, data, frameCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamProcessed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamProcessed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamProcessed$descriptor() {
        return IsAudioStreamProcessed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamProcessed$handle() {
        return IsAudioStreamProcessed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamProcessed$address() {
        return IsAudioStreamProcessed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamProcessed(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamProcessed(MemorySegment stream) {
        var mh$ = IsAudioStreamProcessed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamProcessed", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PlayAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor PlayAudioStream$descriptor() {
        return PlayAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle PlayAudioStream$handle() {
        return PlayAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment PlayAudioStream$address() {
        return PlayAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PlayAudioStream(AudioStream stream)
     * }
     */
    public static void PlayAudioStream(MemorySegment stream) {
        var mh$ = PlayAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PauseAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("PauseAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor PauseAudioStream$descriptor() {
        return PauseAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle PauseAudioStream$handle() {
        return PauseAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment PauseAudioStream$address() {
        return PauseAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PauseAudioStream(AudioStream stream)
     * }
     */
    public static void PauseAudioStream(MemorySegment stream) {
        var mh$ = PauseAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PauseAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("ResumeAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor ResumeAudioStream$descriptor() {
        return ResumeAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle ResumeAudioStream$handle() {
        return ResumeAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment ResumeAudioStream$address() {
        return ResumeAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ResumeAudioStream(AudioStream stream)
     * }
     */
    public static void ResumeAudioStream(MemorySegment stream) {
        var mh$ = ResumeAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAudioStreamPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_BOOL,
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("IsAudioStreamPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static FunctionDescriptor IsAudioStreamPlaying$descriptor() {
        return IsAudioStreamPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static MethodHandle IsAudioStreamPlaying$handle() {
        return IsAudioStreamPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static MemorySegment IsAudioStreamPlaying$address() {
        return IsAudioStreamPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool IsAudioStreamPlaying(AudioStream stream)
     * }
     */
    public static boolean IsAudioStreamPlaying(MemorySegment stream) {
        var mh$ = IsAudioStreamPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAudioStreamPlaying", stream);
            }
            return (boolean)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopAudioStream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("StopAudioStream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static FunctionDescriptor StopAudioStream$descriptor() {
        return StopAudioStream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static MethodHandle StopAudioStream$handle() {
        return StopAudioStream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static MemorySegment StopAudioStream$address() {
        return StopAudioStream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StopAudioStream(AudioStream stream)
     * }
     */
    public static void StopAudioStream(MemorySegment stream) {
        var mh$ = StopAudioStream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopAudioStream", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static FunctionDescriptor SetAudioStreamVolume$descriptor() {
        return SetAudioStreamVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static MethodHandle SetAudioStreamVolume$handle() {
        return SetAudioStreamVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static MemorySegment SetAudioStreamVolume$address() {
        return SetAudioStreamVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamVolume(AudioStream stream, float volume)
     * }
     */
    public static void SetAudioStreamVolume(MemorySegment stream, float volume) {
        var mh$ = SetAudioStreamVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamVolume", stream, volume);
            }
            mh$.invokeExact(stream, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static FunctionDescriptor SetAudioStreamPitch$descriptor() {
        return SetAudioStreamPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static MethodHandle SetAudioStreamPitch$handle() {
        return SetAudioStreamPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static MemorySegment SetAudioStreamPitch$address() {
        return SetAudioStreamPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamPitch(AudioStream stream, float pitch)
     * }
     */
    public static void SetAudioStreamPitch(MemorySegment stream, float pitch) {
        var mh$ = SetAudioStreamPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamPitch", stream, pitch);
            }
            mh$.invokeExact(stream, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_FLOAT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static FunctionDescriptor SetAudioStreamPan$descriptor() {
        return SetAudioStreamPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static MethodHandle SetAudioStreamPan$handle() {
        return SetAudioStreamPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static MemorySegment SetAudioStreamPan$address() {
        return SetAudioStreamPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamPan(AudioStream stream, float pan)
     * }
     */
    public static void SetAudioStreamPan(MemorySegment stream, float pan) {
        var mh$ = SetAudioStreamPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamPan", stream, pan);
            }
            mh$.invokeExact(stream, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamBufferSizeDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamBufferSizeDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static FunctionDescriptor SetAudioStreamBufferSizeDefault$descriptor() {
        return SetAudioStreamBufferSizeDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static MethodHandle SetAudioStreamBufferSizeDefault$handle() {
        return SetAudioStreamBufferSizeDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static MemorySegment SetAudioStreamBufferSizeDefault$address() {
        return SetAudioStreamBufferSizeDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamBufferSizeDefault(int size)
     * }
     */
    public static void SetAudioStreamBufferSizeDefault(int size) {
        var mh$ = SetAudioStreamBufferSizeDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamBufferSizeDefault", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAudioStreamCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("SetAudioStreamCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static FunctionDescriptor SetAudioStreamCallback$descriptor() {
        return SetAudioStreamCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static MethodHandle SetAudioStreamCallback$handle() {
        return SetAudioStreamCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static MemorySegment SetAudioStreamCallback$address() {
        return SetAudioStreamCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetAudioStreamCallback(AudioStream stream, AudioCallback callback)
     * }
     */
    public static void SetAudioStreamCallback(MemorySegment stream, MemorySegment callback) {
        var mh$ = SetAudioStreamCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAudioStreamCallback", stream, callback);
            }
            mh$.invokeExact(stream, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachAudioStreamProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("AttachAudioStreamProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static FunctionDescriptor AttachAudioStreamProcessor$descriptor() {
        return AttachAudioStreamProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MethodHandle AttachAudioStreamProcessor$handle() {
        return AttachAudioStreamProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MemorySegment AttachAudioStreamProcessor$address() {
        return AttachAudioStreamProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static void AttachAudioStreamProcessor(MemorySegment stream, MemorySegment processor) {
        var mh$ = AttachAudioStreamProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachAudioStreamProcessor", stream, processor);
            }
            mh$.invokeExact(stream, processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DetachAudioStreamProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            AudioStream.layout(),
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DetachAudioStreamProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static FunctionDescriptor DetachAudioStreamProcessor$descriptor() {
        return DetachAudioStreamProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MethodHandle DetachAudioStreamProcessor$handle() {
        return DetachAudioStreamProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static MemorySegment DetachAudioStreamProcessor$address() {
        return DetachAudioStreamProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor)
     * }
     */
    public static void DetachAudioStreamProcessor(MemorySegment stream, MemorySegment processor) {
        var mh$ = DetachAudioStreamProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DetachAudioStreamProcessor", stream, processor);
            }
            mh$.invokeExact(stream, processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachAudioMixedProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("AttachAudioMixedProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static FunctionDescriptor AttachAudioMixedProcessor$descriptor() {
        return AttachAudioMixedProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MethodHandle AttachAudioMixedProcessor$handle() {
        return AttachAudioMixedProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MemorySegment AttachAudioMixedProcessor$address() {
        return AttachAudioMixedProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AttachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static void AttachAudioMixedProcessor(MemorySegment processor) {
        var mh$ = AttachAudioMixedProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachAudioMixedProcessor", processor);
            }
            mh$.invokeExact(processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DetachAudioMixedProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            raylib.C_POINTER
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("DetachAudioMixedProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static FunctionDescriptor DetachAudioMixedProcessor$descriptor() {
        return DetachAudioMixedProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MethodHandle DetachAudioMixedProcessor$handle() {
        return DetachAudioMixedProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static MemorySegment DetachAudioMixedProcessor$address() {
        return DetachAudioMixedProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DetachAudioMixedProcessor(AudioCallback processor)
     * }
     */
    public static void DetachAudioMixedProcessor(MemorySegment processor) {
        var mh$ = DetachAudioMixedProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DetachAudioMixedProcessor", processor);
            }
            mh$.invokeExact(processor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModel$descriptor() {
        return VyDrawModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModel$handle() {
        return VyDrawModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModel$address() {
        return VyDrawModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModel(VyModel vyModel, Vector3 position, float scale, Color tint)
     * }
     */
    public static void VyDrawModel(MemorySegment vyModel, MemorySegment position, float scale, MemorySegment tint) {
        var mh$ = VyDrawModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModel", vyModel, position, scale, tint);
            }
            mh$.invokeExact(vyModel, position, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModelEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            Vector3.layout(),
            raylib.C_FLOAT,
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModelEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModelEx$descriptor() {
        return VyDrawModelEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModelEx$handle() {
        return VyDrawModelEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModelEx$address() {
        return VyDrawModelEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModelEx(VyModel vyModel, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
     * }
     */
    public static void VyDrawModelEx(MemorySegment vyModel, MemorySegment position, MemorySegment rotationAxis, float rotationAngle, MemorySegment scale, MemorySegment tint) {
        var mh$ = VyDrawModelEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModelEx", vyModel, position, rotationAxis, rotationAngle, scale, tint);
            }
            mh$.invokeExact(vyModel, position, rotationAxis, rotationAngle, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyDrawModelExQuat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyModel.layout(),
            Vector3.layout(),
            Vector4.layout(),
            Vector3.layout(),
            Color.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyDrawModelExQuat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static FunctionDescriptor VyDrawModelExQuat$descriptor() {
        return VyDrawModelExQuat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static MethodHandle VyDrawModelExQuat$handle() {
        return VyDrawModelExQuat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static MemorySegment VyDrawModelExQuat$address() {
        return VyDrawModelExQuat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyDrawModelExQuat(VyModel vyModel, Vector3 position, Quaternion quaternion, Vector3 scale, Color tint)
     * }
     */
    public static void VyDrawModelExQuat(MemorySegment vyModel, MemorySegment position, MemorySegment quaternion, MemorySegment scale, MemorySegment tint) {
        var mh$ = VyDrawModelExQuat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyDrawModelExQuat", vyModel, position, quaternion, scale, tint);
            }
            mh$.invokeExact(vyModel, position, quaternion, scale, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyBeginMode3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            VyCamera.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyBeginMode3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static FunctionDescriptor VyBeginMode3D$descriptor() {
        return VyBeginMode3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static MethodHandle VyBeginMode3D$handle() {
        return VyBeginMode3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static MemorySegment VyBeginMode3D$address() {
        return VyBeginMode3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VyBeginMode3D(VyCamera camera)
     * }
     */
    public static void VyBeginMode3D(MemorySegment camera) {
        var mh$ = VyBeginMode3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyBeginMode3D", camera);
            }
            mh$.invokeExact(camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyQuaternionToAxisAngle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_FLOAT,
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyQuaternionToAxisAngle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static FunctionDescriptor VyQuaternionToAxisAngle$descriptor() {
        return VyQuaternionToAxisAngle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static MethodHandle VyQuaternionToAxisAngle$handle() {
        return VyQuaternionToAxisAngle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisAngle$address() {
        return VyQuaternionToAxisAngle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float VyQuaternionToAxisAngle(Quaternion q)
     * }
     */
    public static float VyQuaternionToAxisAngle(MemorySegment q) {
        var mh$ = VyQuaternionToAxisAngle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyQuaternionToAxisAngle", q);
            }
            return (float)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyQuaternionToAxisVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Vector3.layout(),
            Vector4.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyQuaternionToAxisVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static FunctionDescriptor VyQuaternionToAxisVector$descriptor() {
        return VyQuaternionToAxisVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MethodHandle VyQuaternionToAxisVector$handle() {
        return VyQuaternionToAxisVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisVector$address() {
        return VyQuaternionToAxisVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 VyQuaternionToAxisVector(Quaternion q)
     * }
     */
    public static MemorySegment VyQuaternionToAxisVector(SegmentAllocator allocator, MemorySegment q) {
        var mh$ = VyQuaternionToAxisVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyQuaternionToAxisVector", allocator, q);
            }
            return (MemorySegment)mh$.invokeExact(allocator, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGetScreenToWorldRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            VyCamera.layout()
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGetScreenToWorldRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static FunctionDescriptor VyGetScreenToWorldRay$descriptor() {
        return VyGetScreenToWorldRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MethodHandle VyGetScreenToWorldRay$handle() {
        return VyGetScreenToWorldRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRay$address() {
        return VyGetScreenToWorldRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRay(Vector2 position, VyCamera camera)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRay(SegmentAllocator allocator, MemorySegment position, MemorySegment camera) {
        var mh$ = VyGetScreenToWorldRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGetScreenToWorldRay", allocator, position, camera);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGetScreenToWorldRayEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ray.layout(),
            Vector2.layout(),
            VyCamera.layout(),
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGetScreenToWorldRayEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static FunctionDescriptor VyGetScreenToWorldRayEx$descriptor() {
        return VyGetScreenToWorldRayEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MethodHandle VyGetScreenToWorldRayEx$handle() {
        return VyGetScreenToWorldRayEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRayEx$address() {
        return VyGetScreenToWorldRayEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Ray VyGetScreenToWorldRayEx(Vector2 position, VyCamera camera, int width, int height)
     * }
     */
    public static MemorySegment VyGetScreenToWorldRayEx(SegmentAllocator allocator, MemorySegment position, MemorySegment camera, int width, int height) {
        var mh$ = VyGetScreenToWorldRayEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGetScreenToWorldRayEx", allocator, position, camera, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, position, camera, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            VyShaderParameters.layout(),
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveParameters$descriptor() {
        return VyGlGetActiveParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveParameters$handle() {
        return VyGlGetActiveParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveParameters$address() {
        return VyGlGetActiveParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VyShaderParameters VyGlGetActiveParameters(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveParameters(SegmentAllocator allocator, int id) {
        var mh$ = VyGlGetActiveParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveParameters", allocator, id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveUniformsCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveUniformsCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveUniformsCount$descriptor() {
        return VyGlGetActiveUniformsCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveUniformsCount$handle() {
        return VyGlGetActiveUniformsCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveUniformsCount$address() {
        return VyGlGetActiveUniformsCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VyGlGetActiveUniformsCount(int id)
     * }
     */
    public static int VyGlGetActiveUniformsCount(int id) {
        var mh$ = VyGlGetActiveUniformsCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveUniformsCount", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VyGlGetActiveAttributesCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            raylib.C_INT,
            raylib.C_INT
        );

        public static final MemorySegment ADDR = raylib.findOrThrow("VyGlGetActiveAttributesCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static FunctionDescriptor VyGlGetActiveAttributesCount$descriptor() {
        return VyGlGetActiveAttributesCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static MethodHandle VyGlGetActiveAttributesCount$handle() {
        return VyGlGetActiveAttributesCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static MemorySegment VyGlGetActiveAttributesCount$address() {
        return VyGlGetActiveAttributesCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VyGlGetActiveAttributesCount(int id)
     * }
     */
    public static int VyGlGetActiveAttributesCount(int id) {
        var mh$ = VyGlGetActiveAttributesCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VyGlGetActiveAttributesCount", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RL_OPENGL_11 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_11 = 1
     * }
     */
    public static int RL_OPENGL_11() {
        return RL_OPENGL_11;
    }
    private static final int RL_OPENGL_21 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_21 = 2
     * }
     */
    public static int RL_OPENGL_21() {
        return RL_OPENGL_21;
    }
    private static final int RL_OPENGL_33 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_33 = 3
     * }
     */
    public static int RL_OPENGL_33() {
        return RL_OPENGL_33;
    }
    private static final int RL_OPENGL_43 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_43 = 4
     * }
     */
    public static int RL_OPENGL_43() {
        return RL_OPENGL_43;
    }
    private static final int RL_OPENGL_ES_20 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_ES_20 = 5
     * }
     */
    public static int RL_OPENGL_ES_20() {
        return RL_OPENGL_ES_20;
    }
    private static final int RL_OPENGL_ES_30 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_OPENGL_ES_30 = 6
     * }
     */
    public static int RL_OPENGL_ES_30() {
        return RL_OPENGL_ES_30;
    }
    private static final int RL_LOG_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_ALL = 0
     * }
     */
    public static int RL_LOG_ALL() {
        return RL_LOG_ALL;
    }
    private static final int RL_LOG_TRACE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_TRACE = 1
     * }
     */
    public static int RL_LOG_TRACE() {
        return RL_LOG_TRACE;
    }
    private static final int RL_LOG_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_DEBUG = 2
     * }
     */
    public static int RL_LOG_DEBUG() {
        return RL_LOG_DEBUG;
    }
    private static final int RL_LOG_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_INFO = 3
     * }
     */
    public static int RL_LOG_INFO() {
        return RL_LOG_INFO;
    }
    private static final int RL_LOG_WARNING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_WARNING = 4
     * }
     */
    public static int RL_LOG_WARNING() {
        return RL_LOG_WARNING;
    }
    private static final int RL_LOG_ERROR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RL_LOG_ERROR = 5
     * }
     */
    public static int RL_LOG_ERROR() {
        return RL_LOG_ERROR;
    }
}

