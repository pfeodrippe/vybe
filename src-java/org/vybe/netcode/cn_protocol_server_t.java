// Generated by jextract

package org.vybe.netcode;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct cn_protocol_server_t {
 *     bool running;
 *     uint64_t application_id;
 *     uint64_t current_time;
 *     bool use_developer_mode_public_ip;
 *     cn_endpoint_t developer_mode_public_ip;
 *     cn_socket_t socket;
 *     cn_protocol_packet_allocator_t *packet_allocator;
 *     cn_crypto_sign_public_t public_key;
 *     cn_crypto_sign_secret_t secret_key;
 *     uint32_t connection_timeout;
 *     cn_circular_buffer_t event_queue;
 *     cn_simulator_t *sim;
 *     uint64_t challenge_nonce;
 *     cn_protocol_encryption_map_t encryption_map;
 *     cn_protocol_connect_token_cache_t token_cache;
 *     int client_count;
 *     cn_hashtable_t client_endpoint_table;
 *     cn_hashtable_t client_id_table;
 *     uint64_t client_id[32];
 *     bool client_is_connected[32];
 *     bool client_is_confirmed[32];
 *     double client_last_packet_received_time[32];
 *     double client_last_packet_sent_time[32];
 *     cn_endpoint_t client_endpoint[32];
 *     uint64_t client_sequence[32];
 *     cn_crypto_key_t client_client_to_server_key[32];
 *     cn_crypto_key_t client_server_to_client_key[32];
 *     cn_protocol_replay_buffer_t client_replay_buffer[32];
 *     uint8_t buffer[1280];
 *     void *mem_ctx;
 * }
 * }
 */
public class cn_protocol_server_t {

    cn_protocol_server_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        netcode.C_BOOL.withName("running"),
        MemoryLayout.paddingLayout(7),
        netcode.C_LONG_LONG.withName("application_id"),
        netcode.C_LONG_LONG.withName("current_time"),
        netcode.C_BOOL.withName("use_developer_mode_public_ip"),
        MemoryLayout.paddingLayout(3),
        cn_endpoint_t.layout().withName("developer_mode_public_ip"),
        cn_socket_t.layout().withName("socket"),
        netcode.C_POINTER.withName("packet_allocator"),
        cn_crypto_sign_public_t.layout().withName("public_key"),
        cn_crypto_sign_secret_t.layout().withName("secret_key"),
        netcode.C_INT.withName("connection_timeout"),
        MemoryLayout.paddingLayout(4),
        cn_circular_buffer_t.layout().withName("event_queue"),
        netcode.C_POINTER.withName("sim"),
        netcode.C_LONG_LONG.withName("challenge_nonce"),
        cn_protocol_encryption_map_t.layout().withName("encryption_map"),
        cn_protocol_connect_token_cache_t.layout().withName("token_cache"),
        netcode.C_INT.withName("client_count"),
        MemoryLayout.paddingLayout(4),
        cn_hashtable_t.layout().withName("client_endpoint_table"),
        cn_hashtable_t.layout().withName("client_id_table"),
        MemoryLayout.sequenceLayout(32, netcode.C_LONG_LONG).withName("client_id"),
        MemoryLayout.sequenceLayout(32, netcode.C_BOOL).withName("client_is_connected"),
        MemoryLayout.sequenceLayout(32, netcode.C_BOOL).withName("client_is_confirmed"),
        MemoryLayout.sequenceLayout(32, netcode.C_DOUBLE).withName("client_last_packet_received_time"),
        MemoryLayout.sequenceLayout(32, netcode.C_DOUBLE).withName("client_last_packet_sent_time"),
        MemoryLayout.sequenceLayout(32, cn_endpoint_t.layout()).withName("client_endpoint"),
        MemoryLayout.sequenceLayout(32, netcode.C_LONG_LONG).withName("client_sequence"),
        MemoryLayout.sequenceLayout(32, cn_crypto_key_t.layout()).withName("client_client_to_server_key"),
        MemoryLayout.sequenceLayout(32, cn_crypto_key_t.layout()).withName("client_server_to_client_key"),
        MemoryLayout.sequenceLayout(32, cn_protocol_replay_buffer_t.layout()).withName("client_replay_buffer"),
        MemoryLayout.sequenceLayout(1280, netcode.C_CHAR).withName("buffer"),
        netcode.C_POINTER.withName("mem_ctx")
    ).withName("cn_protocol_server_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfBoolean running$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("running"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool running
     * }
     */
    public static final OfBoolean running$layout() {
        return running$LAYOUT;
    }

    private static final long running$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool running
     * }
     */
    public static final long running$offset() {
        return running$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool running
     * }
     */
    public static boolean running(MemorySegment struct) {
        return struct.get(running$LAYOUT, running$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool running
     * }
     */
    public static void running(MemorySegment struct, boolean fieldValue) {
        struct.set(running$LAYOUT, running$OFFSET, fieldValue);
    }

    private static final OfLong application_id$LAYOUT = (OfLong)$LAYOUT.select(groupElement("application_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t application_id
     * }
     */
    public static final OfLong application_id$layout() {
        return application_id$LAYOUT;
    }

    private static final long application_id$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t application_id
     * }
     */
    public static final long application_id$offset() {
        return application_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t application_id
     * }
     */
    public static long application_id(MemorySegment struct) {
        return struct.get(application_id$LAYOUT, application_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t application_id
     * }
     */
    public static void application_id(MemorySegment struct, long fieldValue) {
        struct.set(application_id$LAYOUT, application_id$OFFSET, fieldValue);
    }

    private static final OfLong current_time$LAYOUT = (OfLong)$LAYOUT.select(groupElement("current_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t current_time
     * }
     */
    public static final OfLong current_time$layout() {
        return current_time$LAYOUT;
    }

    private static final long current_time$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t current_time
     * }
     */
    public static final long current_time$offset() {
        return current_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t current_time
     * }
     */
    public static long current_time(MemorySegment struct) {
        return struct.get(current_time$LAYOUT, current_time$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t current_time
     * }
     */
    public static void current_time(MemorySegment struct, long fieldValue) {
        struct.set(current_time$LAYOUT, current_time$OFFSET, fieldValue);
    }

    private static final OfBoolean use_developer_mode_public_ip$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("use_developer_mode_public_ip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool use_developer_mode_public_ip
     * }
     */
    public static final OfBoolean use_developer_mode_public_ip$layout() {
        return use_developer_mode_public_ip$LAYOUT;
    }

    private static final long use_developer_mode_public_ip$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool use_developer_mode_public_ip
     * }
     */
    public static final long use_developer_mode_public_ip$offset() {
        return use_developer_mode_public_ip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool use_developer_mode_public_ip
     * }
     */
    public static boolean use_developer_mode_public_ip(MemorySegment struct) {
        return struct.get(use_developer_mode_public_ip$LAYOUT, use_developer_mode_public_ip$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool use_developer_mode_public_ip
     * }
     */
    public static void use_developer_mode_public_ip(MemorySegment struct, boolean fieldValue) {
        struct.set(use_developer_mode_public_ip$LAYOUT, use_developer_mode_public_ip$OFFSET, fieldValue);
    }

    private static final GroupLayout developer_mode_public_ip$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("developer_mode_public_ip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_endpoint_t developer_mode_public_ip
     * }
     */
    public static final GroupLayout developer_mode_public_ip$layout() {
        return developer_mode_public_ip$LAYOUT;
    }

    private static final long developer_mode_public_ip$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_endpoint_t developer_mode_public_ip
     * }
     */
    public static final long developer_mode_public_ip$offset() {
        return developer_mode_public_ip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_endpoint_t developer_mode_public_ip
     * }
     */
    public static MemorySegment developer_mode_public_ip(MemorySegment struct) {
        return struct.asSlice(developer_mode_public_ip$OFFSET, developer_mode_public_ip$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_endpoint_t developer_mode_public_ip
     * }
     */
    public static void developer_mode_public_ip(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, developer_mode_public_ip$OFFSET, developer_mode_public_ip$LAYOUT.byteSize());
    }

    private static final GroupLayout socket$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("socket"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_socket_t socket
     * }
     */
    public static final GroupLayout socket$layout() {
        return socket$LAYOUT;
    }

    private static final long socket$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_socket_t socket
     * }
     */
    public static final long socket$offset() {
        return socket$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_socket_t socket
     * }
     */
    public static MemorySegment socket(MemorySegment struct) {
        return struct.asSlice(socket$OFFSET, socket$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_socket_t socket
     * }
     */
    public static void socket(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, socket$OFFSET, socket$LAYOUT.byteSize());
    }

    private static final AddressLayout packet_allocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("packet_allocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_protocol_packet_allocator_t *packet_allocator
     * }
     */
    public static final AddressLayout packet_allocator$layout() {
        return packet_allocator$LAYOUT;
    }

    private static final long packet_allocator$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_protocol_packet_allocator_t *packet_allocator
     * }
     */
    public static final long packet_allocator$offset() {
        return packet_allocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_protocol_packet_allocator_t *packet_allocator
     * }
     */
    public static MemorySegment packet_allocator(MemorySegment struct) {
        return struct.get(packet_allocator$LAYOUT, packet_allocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_protocol_packet_allocator_t *packet_allocator
     * }
     */
    public static void packet_allocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(packet_allocator$LAYOUT, packet_allocator$OFFSET, fieldValue);
    }

    private static final GroupLayout public_key$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("public_key"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_crypto_sign_public_t public_key
     * }
     */
    public static final GroupLayout public_key$layout() {
        return public_key$LAYOUT;
    }

    private static final long public_key$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_crypto_sign_public_t public_key
     * }
     */
    public static final long public_key$offset() {
        return public_key$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_crypto_sign_public_t public_key
     * }
     */
    public static MemorySegment public_key(MemorySegment struct) {
        return struct.asSlice(public_key$OFFSET, public_key$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_crypto_sign_public_t public_key
     * }
     */
    public static void public_key(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, public_key$OFFSET, public_key$LAYOUT.byteSize());
    }

    private static final GroupLayout secret_key$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("secret_key"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_crypto_sign_secret_t secret_key
     * }
     */
    public static final GroupLayout secret_key$layout() {
        return secret_key$LAYOUT;
    }

    private static final long secret_key$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_crypto_sign_secret_t secret_key
     * }
     */
    public static final long secret_key$offset() {
        return secret_key$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_crypto_sign_secret_t secret_key
     * }
     */
    public static MemorySegment secret_key(MemorySegment struct) {
        return struct.asSlice(secret_key$OFFSET, secret_key$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_crypto_sign_secret_t secret_key
     * }
     */
    public static void secret_key(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, secret_key$OFFSET, secret_key$LAYOUT.byteSize());
    }

    private static final OfInt connection_timeout$LAYOUT = (OfInt)$LAYOUT.select(groupElement("connection_timeout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t connection_timeout
     * }
     */
    public static final OfInt connection_timeout$layout() {
        return connection_timeout$LAYOUT;
    }

    private static final long connection_timeout$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t connection_timeout
     * }
     */
    public static final long connection_timeout$offset() {
        return connection_timeout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t connection_timeout
     * }
     */
    public static int connection_timeout(MemorySegment struct) {
        return struct.get(connection_timeout$LAYOUT, connection_timeout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t connection_timeout
     * }
     */
    public static void connection_timeout(MemorySegment struct, int fieldValue) {
        struct.set(connection_timeout$LAYOUT, connection_timeout$OFFSET, fieldValue);
    }

    private static final GroupLayout event_queue$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("event_queue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_circular_buffer_t event_queue
     * }
     */
    public static final GroupLayout event_queue$layout() {
        return event_queue$LAYOUT;
    }

    private static final long event_queue$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_circular_buffer_t event_queue
     * }
     */
    public static final long event_queue$offset() {
        return event_queue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_circular_buffer_t event_queue
     * }
     */
    public static MemorySegment event_queue(MemorySegment struct) {
        return struct.asSlice(event_queue$OFFSET, event_queue$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_circular_buffer_t event_queue
     * }
     */
    public static void event_queue(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, event_queue$OFFSET, event_queue$LAYOUT.byteSize());
    }

    private static final AddressLayout sim$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sim"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_simulator_t *sim
     * }
     */
    public static final AddressLayout sim$layout() {
        return sim$LAYOUT;
    }

    private static final long sim$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_simulator_t *sim
     * }
     */
    public static final long sim$offset() {
        return sim$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_simulator_t *sim
     * }
     */
    public static MemorySegment sim(MemorySegment struct) {
        return struct.get(sim$LAYOUT, sim$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_simulator_t *sim
     * }
     */
    public static void sim(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sim$LAYOUT, sim$OFFSET, fieldValue);
    }

    private static final OfLong challenge_nonce$LAYOUT = (OfLong)$LAYOUT.select(groupElement("challenge_nonce"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t challenge_nonce
     * }
     */
    public static final OfLong challenge_nonce$layout() {
        return challenge_nonce$LAYOUT;
    }

    private static final long challenge_nonce$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t challenge_nonce
     * }
     */
    public static final long challenge_nonce$offset() {
        return challenge_nonce$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t challenge_nonce
     * }
     */
    public static long challenge_nonce(MemorySegment struct) {
        return struct.get(challenge_nonce$LAYOUT, challenge_nonce$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t challenge_nonce
     * }
     */
    public static void challenge_nonce(MemorySegment struct, long fieldValue) {
        struct.set(challenge_nonce$LAYOUT, challenge_nonce$OFFSET, fieldValue);
    }

    private static final GroupLayout encryption_map$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("encryption_map"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_protocol_encryption_map_t encryption_map
     * }
     */
    public static final GroupLayout encryption_map$layout() {
        return encryption_map$LAYOUT;
    }

    private static final long encryption_map$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_protocol_encryption_map_t encryption_map
     * }
     */
    public static final long encryption_map$offset() {
        return encryption_map$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_protocol_encryption_map_t encryption_map
     * }
     */
    public static MemorySegment encryption_map(MemorySegment struct) {
        return struct.asSlice(encryption_map$OFFSET, encryption_map$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_protocol_encryption_map_t encryption_map
     * }
     */
    public static void encryption_map(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, encryption_map$OFFSET, encryption_map$LAYOUT.byteSize());
    }

    private static final GroupLayout token_cache$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("token_cache"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_protocol_connect_token_cache_t token_cache
     * }
     */
    public static final GroupLayout token_cache$layout() {
        return token_cache$LAYOUT;
    }

    private static final long token_cache$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_protocol_connect_token_cache_t token_cache
     * }
     */
    public static final long token_cache$offset() {
        return token_cache$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_protocol_connect_token_cache_t token_cache
     * }
     */
    public static MemorySegment token_cache(MemorySegment struct) {
        return struct.asSlice(token_cache$OFFSET, token_cache$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_protocol_connect_token_cache_t token_cache
     * }
     */
    public static void token_cache(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, token_cache$OFFSET, token_cache$LAYOUT.byteSize());
    }

    private static final OfInt client_count$LAYOUT = (OfInt)$LAYOUT.select(groupElement("client_count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int client_count
     * }
     */
    public static final OfInt client_count$layout() {
        return client_count$LAYOUT;
    }

    private static final long client_count$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int client_count
     * }
     */
    public static final long client_count$offset() {
        return client_count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int client_count
     * }
     */
    public static int client_count(MemorySegment struct) {
        return struct.get(client_count$LAYOUT, client_count$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int client_count
     * }
     */
    public static void client_count(MemorySegment struct, int fieldValue) {
        struct.set(client_count$LAYOUT, client_count$OFFSET, fieldValue);
    }

    private static final GroupLayout client_endpoint_table$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("client_endpoint_table"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_endpoint_table
     * }
     */
    public static final GroupLayout client_endpoint_table$layout() {
        return client_endpoint_table$LAYOUT;
    }

    private static final long client_endpoint_table$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_endpoint_table
     * }
     */
    public static final long client_endpoint_table$offset() {
        return client_endpoint_table$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_endpoint_table
     * }
     */
    public static MemorySegment client_endpoint_table(MemorySegment struct) {
        return struct.asSlice(client_endpoint_table$OFFSET, client_endpoint_table$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_endpoint_table
     * }
     */
    public static void client_endpoint_table(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_endpoint_table$OFFSET, client_endpoint_table$LAYOUT.byteSize());
    }

    private static final GroupLayout client_id_table$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("client_id_table"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_id_table
     * }
     */
    public static final GroupLayout client_id_table$layout() {
        return client_id_table$LAYOUT;
    }

    private static final long client_id_table$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_id_table
     * }
     */
    public static final long client_id_table$offset() {
        return client_id_table$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_id_table
     * }
     */
    public static MemorySegment client_id_table(MemorySegment struct) {
        return struct.asSlice(client_id_table$OFFSET, client_id_table$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_hashtable_t client_id_table
     * }
     */
    public static void client_id_table(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_id_table$OFFSET, client_id_table$LAYOUT.byteSize());
    }

    private static final SequenceLayout client_id$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static final SequenceLayout client_id$layout() {
        return client_id$LAYOUT;
    }

    private static final long client_id$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static final long client_id$offset() {
        return client_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static MemorySegment client_id(MemorySegment struct) {
        return struct.asSlice(client_id$OFFSET, client_id$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static void client_id(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_id$OFFSET, client_id$LAYOUT.byteSize());
    }

    private static long[] client_id$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static long[] client_id$dimensions() {
        return client_id$DIMS;
    }
    private static final VarHandle client_id$ELEM_HANDLE = client_id$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static long client_id(MemorySegment struct, long index0) {
        return (long)client_id$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint64_t client_id[32]
     * }
     */
    public static void client_id(MemorySegment struct, long index0, long fieldValue) {
        client_id$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_is_connected$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_is_connected"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static final SequenceLayout client_is_connected$layout() {
        return client_is_connected$LAYOUT;
    }

    private static final long client_is_connected$OFFSET = 1008;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static final long client_is_connected$offset() {
        return client_is_connected$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static MemorySegment client_is_connected(MemorySegment struct) {
        return struct.asSlice(client_is_connected$OFFSET, client_is_connected$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static void client_is_connected(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_is_connected$OFFSET, client_is_connected$LAYOUT.byteSize());
    }

    private static long[] client_is_connected$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static long[] client_is_connected$dimensions() {
        return client_is_connected$DIMS;
    }
    private static final VarHandle client_is_connected$ELEM_HANDLE = client_is_connected$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static boolean client_is_connected(MemorySegment struct, long index0) {
        return (boolean)client_is_connected$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * bool client_is_connected[32]
     * }
     */
    public static void client_is_connected(MemorySegment struct, long index0, boolean fieldValue) {
        client_is_connected$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_is_confirmed$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_is_confirmed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static final SequenceLayout client_is_confirmed$layout() {
        return client_is_confirmed$LAYOUT;
    }

    private static final long client_is_confirmed$OFFSET = 1040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static final long client_is_confirmed$offset() {
        return client_is_confirmed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static MemorySegment client_is_confirmed(MemorySegment struct) {
        return struct.asSlice(client_is_confirmed$OFFSET, client_is_confirmed$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static void client_is_confirmed(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_is_confirmed$OFFSET, client_is_confirmed$LAYOUT.byteSize());
    }

    private static long[] client_is_confirmed$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static long[] client_is_confirmed$dimensions() {
        return client_is_confirmed$DIMS;
    }
    private static final VarHandle client_is_confirmed$ELEM_HANDLE = client_is_confirmed$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static boolean client_is_confirmed(MemorySegment struct, long index0) {
        return (boolean)client_is_confirmed$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * bool client_is_confirmed[32]
     * }
     */
    public static void client_is_confirmed(MemorySegment struct, long index0, boolean fieldValue) {
        client_is_confirmed$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_last_packet_received_time$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_last_packet_received_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static final SequenceLayout client_last_packet_received_time$layout() {
        return client_last_packet_received_time$LAYOUT;
    }

    private static final long client_last_packet_received_time$OFFSET = 1072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static final long client_last_packet_received_time$offset() {
        return client_last_packet_received_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static MemorySegment client_last_packet_received_time(MemorySegment struct) {
        return struct.asSlice(client_last_packet_received_time$OFFSET, client_last_packet_received_time$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static void client_last_packet_received_time(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_last_packet_received_time$OFFSET, client_last_packet_received_time$LAYOUT.byteSize());
    }

    private static long[] client_last_packet_received_time$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static long[] client_last_packet_received_time$dimensions() {
        return client_last_packet_received_time$DIMS;
    }
    private static final VarHandle client_last_packet_received_time$ELEM_HANDLE = client_last_packet_received_time$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static double client_last_packet_received_time(MemorySegment struct, long index0) {
        return (double)client_last_packet_received_time$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * double client_last_packet_received_time[32]
     * }
     */
    public static void client_last_packet_received_time(MemorySegment struct, long index0, double fieldValue) {
        client_last_packet_received_time$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_last_packet_sent_time$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_last_packet_sent_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static final SequenceLayout client_last_packet_sent_time$layout() {
        return client_last_packet_sent_time$LAYOUT;
    }

    private static final long client_last_packet_sent_time$OFFSET = 1328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static final long client_last_packet_sent_time$offset() {
        return client_last_packet_sent_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static MemorySegment client_last_packet_sent_time(MemorySegment struct) {
        return struct.asSlice(client_last_packet_sent_time$OFFSET, client_last_packet_sent_time$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static void client_last_packet_sent_time(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_last_packet_sent_time$OFFSET, client_last_packet_sent_time$LAYOUT.byteSize());
    }

    private static long[] client_last_packet_sent_time$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static long[] client_last_packet_sent_time$dimensions() {
        return client_last_packet_sent_time$DIMS;
    }
    private static final VarHandle client_last_packet_sent_time$ELEM_HANDLE = client_last_packet_sent_time$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static double client_last_packet_sent_time(MemorySegment struct, long index0) {
        return (double)client_last_packet_sent_time$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * double client_last_packet_sent_time[32]
     * }
     */
    public static void client_last_packet_sent_time(MemorySegment struct, long index0, double fieldValue) {
        client_last_packet_sent_time$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_endpoint$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_endpoint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static final SequenceLayout client_endpoint$layout() {
        return client_endpoint$LAYOUT;
    }

    private static final long client_endpoint$OFFSET = 1584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static final long client_endpoint$offset() {
        return client_endpoint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static MemorySegment client_endpoint(MemorySegment struct) {
        return struct.asSlice(client_endpoint$OFFSET, client_endpoint$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static void client_endpoint(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_endpoint$OFFSET, client_endpoint$LAYOUT.byteSize());
    }

    private static long[] client_endpoint$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static long[] client_endpoint$dimensions() {
        return client_endpoint$DIMS;
    }
    private static final MethodHandle client_endpoint$ELEM_HANDLE = client_endpoint$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static MemorySegment client_endpoint(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)client_endpoint$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * cn_endpoint_t client_endpoint[32]
     * }
     */
    public static void client_endpoint(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, client_endpoint(struct, index0), 0L, cn_endpoint_t.layout().byteSize());
    }

    private static final SequenceLayout client_sequence$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_sequence"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static final SequenceLayout client_sequence$layout() {
        return client_sequence$LAYOUT;
    }

    private static final long client_sequence$OFFSET = 2352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static final long client_sequence$offset() {
        return client_sequence$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static MemorySegment client_sequence(MemorySegment struct) {
        return struct.asSlice(client_sequence$OFFSET, client_sequence$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static void client_sequence(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_sequence$OFFSET, client_sequence$LAYOUT.byteSize());
    }

    private static long[] client_sequence$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static long[] client_sequence$dimensions() {
        return client_sequence$DIMS;
    }
    private static final VarHandle client_sequence$ELEM_HANDLE = client_sequence$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static long client_sequence(MemorySegment struct, long index0) {
        return (long)client_sequence$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint64_t client_sequence[32]
     * }
     */
    public static void client_sequence(MemorySegment struct, long index0, long fieldValue) {
        client_sequence$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout client_client_to_server_key$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_client_to_server_key"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static final SequenceLayout client_client_to_server_key$layout() {
        return client_client_to_server_key$LAYOUT;
    }

    private static final long client_client_to_server_key$OFFSET = 2608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static final long client_client_to_server_key$offset() {
        return client_client_to_server_key$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static MemorySegment client_client_to_server_key(MemorySegment struct) {
        return struct.asSlice(client_client_to_server_key$OFFSET, client_client_to_server_key$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static void client_client_to_server_key(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_client_to_server_key$OFFSET, client_client_to_server_key$LAYOUT.byteSize());
    }

    private static long[] client_client_to_server_key$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static long[] client_client_to_server_key$dimensions() {
        return client_client_to_server_key$DIMS;
    }
    private static final MethodHandle client_client_to_server_key$ELEM_HANDLE = client_client_to_server_key$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static MemorySegment client_client_to_server_key(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)client_client_to_server_key$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_client_to_server_key[32]
     * }
     */
    public static void client_client_to_server_key(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, client_client_to_server_key(struct, index0), 0L, cn_crypto_key_t.layout().byteSize());
    }

    private static final SequenceLayout client_server_to_client_key$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_server_to_client_key"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static final SequenceLayout client_server_to_client_key$layout() {
        return client_server_to_client_key$LAYOUT;
    }

    private static final long client_server_to_client_key$OFFSET = 3632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static final long client_server_to_client_key$offset() {
        return client_server_to_client_key$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static MemorySegment client_server_to_client_key(MemorySegment struct) {
        return struct.asSlice(client_server_to_client_key$OFFSET, client_server_to_client_key$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static void client_server_to_client_key(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_server_to_client_key$OFFSET, client_server_to_client_key$LAYOUT.byteSize());
    }

    private static long[] client_server_to_client_key$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static long[] client_server_to_client_key$dimensions() {
        return client_server_to_client_key$DIMS;
    }
    private static final MethodHandle client_server_to_client_key$ELEM_HANDLE = client_server_to_client_key$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static MemorySegment client_server_to_client_key(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)client_server_to_client_key$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * cn_crypto_key_t client_server_to_client_key[32]
     * }
     */
    public static void client_server_to_client_key(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, client_server_to_client_key(struct, index0), 0L, cn_crypto_key_t.layout().byteSize());
    }

    private static final SequenceLayout client_replay_buffer$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("client_replay_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static final SequenceLayout client_replay_buffer$layout() {
        return client_replay_buffer$LAYOUT;
    }

    private static final long client_replay_buffer$OFFSET = 4656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static final long client_replay_buffer$offset() {
        return client_replay_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static MemorySegment client_replay_buffer(MemorySegment struct) {
        return struct.asSlice(client_replay_buffer$OFFSET, client_replay_buffer$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static void client_replay_buffer(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, client_replay_buffer$OFFSET, client_replay_buffer$LAYOUT.byteSize());
    }

    private static long[] client_replay_buffer$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static long[] client_replay_buffer$dimensions() {
        return client_replay_buffer$DIMS;
    }
    private static final MethodHandle client_replay_buffer$ELEM_HANDLE = client_replay_buffer$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static MemorySegment client_replay_buffer(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)client_replay_buffer$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * cn_protocol_replay_buffer_t client_replay_buffer[32]
     * }
     */
    public static void client_replay_buffer(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, client_replay_buffer(struct, index0), 0L, cn_protocol_replay_buffer_t.layout().byteSize());
    }

    private static final SequenceLayout buffer$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static final SequenceLayout buffer$layout() {
        return buffer$LAYOUT;
    }

    private static final long buffer$OFFSET = 70448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static final long buffer$offset() {
        return buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static MemorySegment buffer(MemorySegment struct) {
        return struct.asSlice(buffer$OFFSET, buffer$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static void buffer(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, buffer$OFFSET, buffer$LAYOUT.byteSize());
    }

    private static long[] buffer$DIMS = { 1280 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static long[] buffer$dimensions() {
        return buffer$DIMS;
    }
    private static final VarHandle buffer$ELEM_HANDLE = buffer$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static byte buffer(MemorySegment struct, long index0) {
        return (byte)buffer$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint8_t buffer[1280]
     * }
     */
    public static void buffer(MemorySegment struct, long index0, byte fieldValue) {
        buffer$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final AddressLayout mem_ctx$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mem_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *mem_ctx
     * }
     */
    public static final AddressLayout mem_ctx$layout() {
        return mem_ctx$LAYOUT;
    }

    private static final long mem_ctx$OFFSET = 71728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *mem_ctx
     * }
     */
    public static final long mem_ctx$offset() {
        return mem_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *mem_ctx
     * }
     */
    public static MemorySegment mem_ctx(MemorySegment struct) {
        return struct.get(mem_ctx$LAYOUT, mem_ctx$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *mem_ctx
     * }
     */
    public static void mem_ctx(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mem_ctx$LAYOUT, mem_ctx$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

