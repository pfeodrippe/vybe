// Generated by jextract

package org.vybe.netcode;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class netcode {

    netcode() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libsodium.dylib", LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libnetcode.dylib", LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int NETCODE_LITTLE_ENDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_LITTLE_ENDIAN 1
     * }
     */
    public static int NETCODE_LITTLE_ENDIAN() {
        return NETCODE_LITTLE_ENDIAN;
    }
    private static final int NETCODE_PLATFORM_WINDOWS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_PLATFORM_WINDOWS 1
     * }
     */
    public static int NETCODE_PLATFORM_WINDOWS() {
        return NETCODE_PLATFORM_WINDOWS;
    }
    private static final int NETCODE_PLATFORM_MAC = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_PLATFORM_MAC 2
     * }
     */
    public static int NETCODE_PLATFORM_MAC() {
        return NETCODE_PLATFORM_MAC;
    }
    private static final int NETCODE_PLATFORM_UNIX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_PLATFORM_UNIX 3
     * }
     */
    public static int NETCODE_PLATFORM_UNIX() {
        return NETCODE_PLATFORM_UNIX;
    }
    private static final int NETCODE_CONNECT_TOKEN_BYTES = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CONNECT_TOKEN_BYTES 2048
     * }
     */
    public static int NETCODE_CONNECT_TOKEN_BYTES() {
        return NETCODE_CONNECT_TOKEN_BYTES;
    }
    private static final int NETCODE_KEY_BYTES = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_KEY_BYTES 32
     * }
     */
    public static int NETCODE_KEY_BYTES() {
        return NETCODE_KEY_BYTES;
    }
    private static final int NETCODE_MAC_BYTES = (int)16L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_MAC_BYTES 16
     * }
     */
    public static int NETCODE_MAC_BYTES() {
        return NETCODE_MAC_BYTES;
    }
    private static final int NETCODE_USER_DATA_BYTES = (int)256L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_USER_DATA_BYTES 256
     * }
     */
    public static int NETCODE_USER_DATA_BYTES() {
        return NETCODE_USER_DATA_BYTES;
    }
    private static final int NETCODE_MAX_SERVERS_PER_CONNECT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_MAX_SERVERS_PER_CONNECT 32
     * }
     */
    public static int NETCODE_MAX_SERVERS_PER_CONNECT() {
        return NETCODE_MAX_SERVERS_PER_CONNECT;
    }
    private static final int NETCODE_CLIENT_STATE_DISCONNECTED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_DISCONNECTED 0
     * }
     */
    public static int NETCODE_CLIENT_STATE_DISCONNECTED() {
        return NETCODE_CLIENT_STATE_DISCONNECTED;
    }
    private static final int NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST 1
     * }
     */
    public static int NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST() {
        return NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST;
    }
    private static final int NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE 2
     * }
     */
    public static int NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE() {
        return NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECTED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECTED 3
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECTED() {
        return NETCODE_CLIENT_STATE_CONNECTED;
    }
    private static final int NETCODE_MAX_CLIENTS = (int)256L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_MAX_CLIENTS 256
     * }
     */
    public static int NETCODE_MAX_CLIENTS() {
        return NETCODE_MAX_CLIENTS;
    }
    private static final int NETCODE_MAX_PACKET_SIZE = (int)1200L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_MAX_PACKET_SIZE 1200
     * }
     */
    public static int NETCODE_MAX_PACKET_SIZE() {
        return NETCODE_MAX_PACKET_SIZE;
    }
    private static final int NETCODE_LOG_LEVEL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_LOG_LEVEL_NONE 0
     * }
     */
    public static int NETCODE_LOG_LEVEL_NONE() {
        return NETCODE_LOG_LEVEL_NONE;
    }
    private static final int NETCODE_LOG_LEVEL_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_LOG_LEVEL_ERROR 1
     * }
     */
    public static int NETCODE_LOG_LEVEL_ERROR() {
        return NETCODE_LOG_LEVEL_ERROR;
    }
    private static final int NETCODE_LOG_LEVEL_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_LOG_LEVEL_INFO 2
     * }
     */
    public static int NETCODE_LOG_LEVEL_INFO() {
        return NETCODE_LOG_LEVEL_INFO;
    }
    private static final int NETCODE_LOG_LEVEL_DEBUG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_LOG_LEVEL_DEBUG 3
     * }
     */
    public static int NETCODE_LOG_LEVEL_DEBUG() {
        return NETCODE_LOG_LEVEL_DEBUG;
    }
    private static final int NETCODE_OK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_OK 1
     * }
     */
    public static int NETCODE_OK() {
        return NETCODE_OK;
    }
    private static final int NETCODE_ERROR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_ERROR 0
     * }
     */
    public static int NETCODE_ERROR() {
        return NETCODE_ERROR;
    }
    private static final int NETCODE_ADDRESS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_ADDRESS_NONE 0
     * }
     */
    public static int NETCODE_ADDRESS_NONE() {
        return NETCODE_ADDRESS_NONE;
    }
    private static final int NETCODE_ADDRESS_IPV4 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_ADDRESS_IPV4 1
     * }
     */
    public static int NETCODE_ADDRESS_IPV4() {
        return NETCODE_ADDRESS_IPV4;
    }
    private static final int NETCODE_ADDRESS_IPV6 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_ADDRESS_IPV6 2
     * }
     */
    public static int NETCODE_ADDRESS_IPV6() {
        return NETCODE_ADDRESS_IPV6;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = netcode.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = netcode.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = netcode.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = netcode.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = netcode.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = netcode.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long rsize_t
     * }
     */
    public static final OfLong rsize_t = netcode.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = netcode.C_INT;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int netcode_init()
     * }
     */
    public static class netcode_init {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                netcode.C_INT        );
        private static final MemorySegment ADDR = netcode.findOrThrow("netcode_init");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private netcode_init(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int netcode_init()
         * }
         */
        public static netcode_init makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new netcode_init(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("netcode_init", x0);
                }
                return (int)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void netcode_term()
     * }
     */
    public static class netcode_term {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(        );
        private static final MemorySegment ADDR = netcode.findOrThrow("netcode_term");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private netcode_term(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void netcode_term()
         * }
         */
        public static netcode_term makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new netcode_term(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("netcode_term", x0);
                }
                spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class netcode_parse_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_parse_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_parse_address(const char *address_string_in, struct netcode_address_t *address)
     * }
     */
    public static FunctionDescriptor netcode_parse_address$descriptor() {
        return netcode_parse_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_parse_address(const char *address_string_in, struct netcode_address_t *address)
     * }
     */
    public static MethodHandle netcode_parse_address$handle() {
        return netcode_parse_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_parse_address(const char *address_string_in, struct netcode_address_t *address)
     * }
     */
    public static MemorySegment netcode_parse_address$address() {
        return netcode_parse_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_parse_address(const char *address_string_in, struct netcode_address_t *address)
     * }
     */
    public static int netcode_parse_address(MemorySegment address_string_in, MemorySegment address) {
        var mh$ = netcode_parse_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_parse_address", address_string_in, address);
            }
            return (int)mh$.invokeExact(address_string_in, address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_address_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_address_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *netcode_address_to_string(struct netcode_address_t *address, char *buffer)
     * }
     */
    public static FunctionDescriptor netcode_address_to_string$descriptor() {
        return netcode_address_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *netcode_address_to_string(struct netcode_address_t *address, char *buffer)
     * }
     */
    public static MethodHandle netcode_address_to_string$handle() {
        return netcode_address_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *netcode_address_to_string(struct netcode_address_t *address, char *buffer)
     * }
     */
    public static MemorySegment netcode_address_to_string$address() {
        return netcode_address_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *netcode_address_to_string(struct netcode_address_t *address, char *buffer)
     * }
     */
    public static MemorySegment netcode_address_to_string(MemorySegment address, MemorySegment buffer) {
        var mh$ = netcode_address_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_address_to_string", address, buffer);
            }
            return (MemorySegment)mh$.invokeExact(address, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_address_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_address_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_address_equal(struct netcode_address_t *a, struct netcode_address_t *b)
     * }
     */
    public static FunctionDescriptor netcode_address_equal$descriptor() {
        return netcode_address_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_address_equal(struct netcode_address_t *a, struct netcode_address_t *b)
     * }
     */
    public static MethodHandle netcode_address_equal$handle() {
        return netcode_address_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_address_equal(struct netcode_address_t *a, struct netcode_address_t *b)
     * }
     */
    public static MemorySegment netcode_address_equal$address() {
        return netcode_address_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_address_equal(struct netcode_address_t *a, struct netcode_address_t *b)
     * }
     */
    public static int netcode_address_equal(MemorySegment a, MemorySegment b) {
        var mh$ = netcode_address_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_address_equal", a, b);
            }
            return (int)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_default_client_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_default_client_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_default_client_config(struct netcode_client_config_t *config)
     * }
     */
    public static FunctionDescriptor netcode_default_client_config$descriptor() {
        return netcode_default_client_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_default_client_config(struct netcode_client_config_t *config)
     * }
     */
    public static MethodHandle netcode_default_client_config$handle() {
        return netcode_default_client_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_default_client_config(struct netcode_client_config_t *config)
     * }
     */
    public static MemorySegment netcode_default_client_config$address() {
        return netcode_default_client_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_default_client_config(struct netcode_client_config_t *config)
     * }
     */
    public static void netcode_default_client_config(MemorySegment config) {
        var mh$ = netcode_default_client_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_default_client_config", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_DOUBLE
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct netcode_client_t *netcode_client_create(const char *address, const struct netcode_client_config_t *config, double time)
     * }
     */
    public static FunctionDescriptor netcode_client_create$descriptor() {
        return netcode_client_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct netcode_client_t *netcode_client_create(const char *address, const struct netcode_client_config_t *config, double time)
     * }
     */
    public static MethodHandle netcode_client_create$handle() {
        return netcode_client_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct netcode_client_t *netcode_client_create(const char *address, const struct netcode_client_config_t *config, double time)
     * }
     */
    public static MemorySegment netcode_client_create$address() {
        return netcode_client_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct netcode_client_t *netcode_client_create(const char *address, const struct netcode_client_config_t *config, double time)
     * }
     */
    public static MemorySegment netcode_client_create(MemorySegment address, MemorySegment config, double time) {
        var mh$ = netcode_client_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_create", address, config, time);
            }
            return (MemorySegment)mh$.invokeExact(address, config, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_destroy(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_destroy$descriptor() {
        return netcode_client_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_destroy(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_destroy$handle() {
        return netcode_client_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_destroy(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_destroy$address() {
        return netcode_client_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_destroy(struct netcode_client_t *client)
     * }
     */
    public static void netcode_client_destroy(MemorySegment client) {
        var mh$ = netcode_client_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_destroy", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_connect(struct netcode_client_t *client, uint8_t *connect_token)
     * }
     */
    public static FunctionDescriptor netcode_client_connect$descriptor() {
        return netcode_client_connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_connect(struct netcode_client_t *client, uint8_t *connect_token)
     * }
     */
    public static MethodHandle netcode_client_connect$handle() {
        return netcode_client_connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_connect(struct netcode_client_t *client, uint8_t *connect_token)
     * }
     */
    public static MemorySegment netcode_client_connect$address() {
        return netcode_client_connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_connect(struct netcode_client_t *client, uint8_t *connect_token)
     * }
     */
    public static void netcode_client_connect(MemorySegment client, MemorySegment connect_token) {
        var mh$ = netcode_client_connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_connect", client, connect_token);
            }
            mh$.invokeExact(client, connect_token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_DOUBLE
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_update(struct netcode_client_t *client, double time)
     * }
     */
    public static FunctionDescriptor netcode_client_update$descriptor() {
        return netcode_client_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_update(struct netcode_client_t *client, double time)
     * }
     */
    public static MethodHandle netcode_client_update$handle() {
        return netcode_client_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_update(struct netcode_client_t *client, double time)
     * }
     */
    public static MemorySegment netcode_client_update$address() {
        return netcode_client_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_update(struct netcode_client_t *client, double time)
     * }
     */
    public static void netcode_client_update(MemorySegment client, double time) {
        var mh$ = netcode_client_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_update", client, time);
            }
            mh$.invokeExact(client, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_next_packet_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_LONG_LONG,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_next_packet_sequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t netcode_client_next_packet_sequence(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_next_packet_sequence$descriptor() {
        return netcode_client_next_packet_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t netcode_client_next_packet_sequence(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_next_packet_sequence$handle() {
        return netcode_client_next_packet_sequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t netcode_client_next_packet_sequence(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_next_packet_sequence$address() {
        return netcode_client_next_packet_sequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t netcode_client_next_packet_sequence(struct netcode_client_t *client)
     * }
     */
    public static long netcode_client_next_packet_sequence(MemorySegment client) {
        var mh$ = netcode_client_next_packet_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_next_packet_sequence", client);
            }
            return (long)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_send_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_send_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_send_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static FunctionDescriptor netcode_client_send_packet$descriptor() {
        return netcode_client_send_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_send_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MethodHandle netcode_client_send_packet$handle() {
        return netcode_client_send_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_send_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MemorySegment netcode_client_send_packet$address() {
        return netcode_client_send_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_send_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static void netcode_client_send_packet(MemorySegment client, MemorySegment packet_data, int packet_bytes) {
        var mh$ = netcode_client_send_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_send_packet", client, packet_data, packet_bytes);
            }
            mh$.invokeExact(client, packet_data, packet_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_receive_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_receive_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *netcode_client_receive_packet(struct netcode_client_t *client, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static FunctionDescriptor netcode_client_receive_packet$descriptor() {
        return netcode_client_receive_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *netcode_client_receive_packet(struct netcode_client_t *client, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MethodHandle netcode_client_receive_packet$handle() {
        return netcode_client_receive_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *netcode_client_receive_packet(struct netcode_client_t *client, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MemorySegment netcode_client_receive_packet$address() {
        return netcode_client_receive_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *netcode_client_receive_packet(struct netcode_client_t *client, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MemorySegment netcode_client_receive_packet(MemorySegment client, MemorySegment packet_bytes, MemorySegment packet_sequence) {
        var mh$ = netcode_client_receive_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_receive_packet", client, packet_bytes, packet_sequence);
            }
            return (MemorySegment)mh$.invokeExact(client, packet_bytes, packet_sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_free_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_free_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_free_packet(struct netcode_client_t *client, void *packet)
     * }
     */
    public static FunctionDescriptor netcode_client_free_packet$descriptor() {
        return netcode_client_free_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_free_packet(struct netcode_client_t *client, void *packet)
     * }
     */
    public static MethodHandle netcode_client_free_packet$handle() {
        return netcode_client_free_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_free_packet(struct netcode_client_t *client, void *packet)
     * }
     */
    public static MemorySegment netcode_client_free_packet$address() {
        return netcode_client_free_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_free_packet(struct netcode_client_t *client, void *packet)
     * }
     */
    public static void netcode_client_free_packet(MemorySegment client, MemorySegment packet) {
        var mh$ = netcode_client_free_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_free_packet", client, packet);
            }
            mh$.invokeExact(client, packet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_disconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_disconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_disconnect(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_disconnect$descriptor() {
        return netcode_client_disconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_disconnect(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_disconnect$handle() {
        return netcode_client_disconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_disconnect(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_disconnect$address() {
        return netcode_client_disconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_disconnect(struct netcode_client_t *client)
     * }
     */
    public static void netcode_client_disconnect(MemorySegment client) {
        var mh$ = netcode_client_disconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_disconnect", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_client_state(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_state$descriptor() {
        return netcode_client_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_client_state(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_state$handle() {
        return netcode_client_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_client_state(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_state$address() {
        return netcode_client_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_client_state(struct netcode_client_t *client)
     * }
     */
    public static int netcode_client_state(MemorySegment client) {
        var mh$ = netcode_client_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_state", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_client_index(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_index$descriptor() {
        return netcode_client_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_client_index(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_index$handle() {
        return netcode_client_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_client_index(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_index$address() {
        return netcode_client_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_client_index(struct netcode_client_t *client)
     * }
     */
    public static int netcode_client_index(MemorySegment client) {
        var mh$ = netcode_client_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_index", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_max_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_max_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_client_max_clients(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_max_clients$descriptor() {
        return netcode_client_max_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_client_max_clients(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_max_clients$handle() {
        return netcode_client_max_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_client_max_clients(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_max_clients$address() {
        return netcode_client_max_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_client_max_clients(struct netcode_client_t *client)
     * }
     */
    public static int netcode_client_max_clients(MemorySegment client) {
        var mh$ = netcode_client_max_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_max_clients", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_connect_loopback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_connect_loopback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_connect_loopback(struct netcode_client_t *client, int client_index, int max_clients)
     * }
     */
    public static FunctionDescriptor netcode_client_connect_loopback$descriptor() {
        return netcode_client_connect_loopback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_connect_loopback(struct netcode_client_t *client, int client_index, int max_clients)
     * }
     */
    public static MethodHandle netcode_client_connect_loopback$handle() {
        return netcode_client_connect_loopback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_connect_loopback(struct netcode_client_t *client, int client_index, int max_clients)
     * }
     */
    public static MemorySegment netcode_client_connect_loopback$address() {
        return netcode_client_connect_loopback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_connect_loopback(struct netcode_client_t *client, int client_index, int max_clients)
     * }
     */
    public static void netcode_client_connect_loopback(MemorySegment client, int client_index, int max_clients) {
        var mh$ = netcode_client_connect_loopback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_connect_loopback", client, client_index, max_clients);
            }
            mh$.invokeExact(client, client_index, max_clients);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_disconnect_loopback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_disconnect_loopback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_disconnect_loopback(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_disconnect_loopback$descriptor() {
        return netcode_client_disconnect_loopback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_disconnect_loopback(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_disconnect_loopback$handle() {
        return netcode_client_disconnect_loopback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_disconnect_loopback(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_disconnect_loopback$address() {
        return netcode_client_disconnect_loopback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_disconnect_loopback(struct netcode_client_t *client)
     * }
     */
    public static void netcode_client_disconnect_loopback(MemorySegment client) {
        var mh$ = netcode_client_disconnect_loopback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_disconnect_loopback", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_process_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_process_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_process_packet(struct netcode_client_t *client, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static FunctionDescriptor netcode_client_process_packet$descriptor() {
        return netcode_client_process_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_process_packet(struct netcode_client_t *client, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MethodHandle netcode_client_process_packet$handle() {
        return netcode_client_process_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_process_packet(struct netcode_client_t *client, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MemorySegment netcode_client_process_packet$address() {
        return netcode_client_process_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_process_packet(struct netcode_client_t *client, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static void netcode_client_process_packet(MemorySegment client, MemorySegment from, MemorySegment packet_data, int packet_bytes) {
        var mh$ = netcode_client_process_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_process_packet", client, from, packet_data, packet_bytes);
            }
            mh$.invokeExact(client, from, packet_data, packet_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_loopback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_loopback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_client_loopback(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_loopback$descriptor() {
        return netcode_client_loopback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_client_loopback(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_loopback$handle() {
        return netcode_client_loopback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_client_loopback(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_loopback$address() {
        return netcode_client_loopback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_client_loopback(struct netcode_client_t *client)
     * }
     */
    public static int netcode_client_loopback(MemorySegment client) {
        var mh$ = netcode_client_loopback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_loopback", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_process_loopback_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_LONG_LONG
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_process_loopback_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_client_process_loopback_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static FunctionDescriptor netcode_client_process_loopback_packet$descriptor() {
        return netcode_client_process_loopback_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_client_process_loopback_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static MethodHandle netcode_client_process_loopback_packet$handle() {
        return netcode_client_process_loopback_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_client_process_loopback_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static MemorySegment netcode_client_process_loopback_packet$address() {
        return netcode_client_process_loopback_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_client_process_loopback_packet(struct netcode_client_t *client, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static void netcode_client_process_loopback_packet(MemorySegment client, MemorySegment packet_data, int packet_bytes, long packet_sequence) {
        var mh$ = netcode_client_process_loopback_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_process_loopback_packet", client, packet_data, packet_bytes, packet_sequence);
            }
            mh$.invokeExact(client, packet_data, packet_bytes, packet_sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_get_port {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_SHORT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_get_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint16_t netcode_client_get_port(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_get_port$descriptor() {
        return netcode_client_get_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint16_t netcode_client_get_port(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_get_port$handle() {
        return netcode_client_get_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint16_t netcode_client_get_port(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_get_port$address() {
        return netcode_client_get_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint16_t netcode_client_get_port(struct netcode_client_t *client)
     * }
     */
    public static short netcode_client_get_port(MemorySegment client) {
        var mh$ = netcode_client_get_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_get_port", client);
            }
            return (short)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_client_server_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_client_server_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_client_server_address(struct netcode_client_t *client)
     * }
     */
    public static FunctionDescriptor netcode_client_server_address$descriptor() {
        return netcode_client_server_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_client_server_address(struct netcode_client_t *client)
     * }
     */
    public static MethodHandle netcode_client_server_address$handle() {
        return netcode_client_server_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_client_server_address(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_server_address$address() {
        return netcode_client_server_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_client_server_address(struct netcode_client_t *client)
     * }
     */
    public static MemorySegment netcode_client_server_address(MemorySegment client) {
        var mh$ = netcode_client_server_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_client_server_address", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_generate_connect_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_INT,
            netcode.C_LONG_LONG,
            netcode.C_LONG_LONG,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_generate_connect_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_generate_connect_token(int num_server_addresses, const char **public_server_addresses, const char **internal_server_addresses, int expire_seconds, int timeout_seconds, uint64_t client_id, uint64_t protocol_id, const uint8_t *private_key, uint8_t *user_data, uint8_t *connect_token)
     * }
     */
    public static FunctionDescriptor netcode_generate_connect_token$descriptor() {
        return netcode_generate_connect_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_generate_connect_token(int num_server_addresses, const char **public_server_addresses, const char **internal_server_addresses, int expire_seconds, int timeout_seconds, uint64_t client_id, uint64_t protocol_id, const uint8_t *private_key, uint8_t *user_data, uint8_t *connect_token)
     * }
     */
    public static MethodHandle netcode_generate_connect_token$handle() {
        return netcode_generate_connect_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_generate_connect_token(int num_server_addresses, const char **public_server_addresses, const char **internal_server_addresses, int expire_seconds, int timeout_seconds, uint64_t client_id, uint64_t protocol_id, const uint8_t *private_key, uint8_t *user_data, uint8_t *connect_token)
     * }
     */
    public static MemorySegment netcode_generate_connect_token$address() {
        return netcode_generate_connect_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_generate_connect_token(int num_server_addresses, const char **public_server_addresses, const char **internal_server_addresses, int expire_seconds, int timeout_seconds, uint64_t client_id, uint64_t protocol_id, const uint8_t *private_key, uint8_t *user_data, uint8_t *connect_token)
     * }
     */
    public static int netcode_generate_connect_token(int num_server_addresses, MemorySegment public_server_addresses, MemorySegment internal_server_addresses, int expire_seconds, int timeout_seconds, long client_id, long protocol_id, MemorySegment private_key, MemorySegment user_data, MemorySegment connect_token) {
        var mh$ = netcode_generate_connect_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_generate_connect_token", num_server_addresses, public_server_addresses, internal_server_addresses, expire_seconds, timeout_seconds, client_id, protocol_id, private_key, user_data, connect_token);
            }
            return (int)mh$.invokeExact(num_server_addresses, public_server_addresses, internal_server_addresses, expire_seconds, timeout_seconds, client_id, protocol_id, private_key, user_data, connect_token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_default_server_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_default_server_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_default_server_config(struct netcode_server_config_t *config)
     * }
     */
    public static FunctionDescriptor netcode_default_server_config$descriptor() {
        return netcode_default_server_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_default_server_config(struct netcode_server_config_t *config)
     * }
     */
    public static MethodHandle netcode_default_server_config$handle() {
        return netcode_default_server_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_default_server_config(struct netcode_server_config_t *config)
     * }
     */
    public static MemorySegment netcode_default_server_config$address() {
        return netcode_default_server_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_default_server_config(struct netcode_server_config_t *config)
     * }
     */
    public static void netcode_default_server_config(MemorySegment config) {
        var mh$ = netcode_default_server_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_default_server_config", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_DOUBLE
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct netcode_server_t *netcode_server_create(const char *server_address, const struct netcode_server_config_t *config, double time)
     * }
     */
    public static FunctionDescriptor netcode_server_create$descriptor() {
        return netcode_server_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct netcode_server_t *netcode_server_create(const char *server_address, const struct netcode_server_config_t *config, double time)
     * }
     */
    public static MethodHandle netcode_server_create$handle() {
        return netcode_server_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct netcode_server_t *netcode_server_create(const char *server_address, const struct netcode_server_config_t *config, double time)
     * }
     */
    public static MemorySegment netcode_server_create$address() {
        return netcode_server_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct netcode_server_t *netcode_server_create(const char *server_address, const struct netcode_server_config_t *config, double time)
     * }
     */
    public static MemorySegment netcode_server_create(MemorySegment server_address, MemorySegment config, double time) {
        var mh$ = netcode_server_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_create", server_address, config, time);
            }
            return (MemorySegment)mh$.invokeExact(server_address, config, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_destroy(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_destroy$descriptor() {
        return netcode_server_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_destroy(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_destroy$handle() {
        return netcode_server_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_destroy(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_destroy$address() {
        return netcode_server_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_destroy(struct netcode_server_t *server)
     * }
     */
    public static void netcode_server_destroy(MemorySegment server) {
        var mh$ = netcode_server_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_destroy", server);
            }
            mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_start(struct netcode_server_t *server, int max_clients)
     * }
     */
    public static FunctionDescriptor netcode_server_start$descriptor() {
        return netcode_server_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_start(struct netcode_server_t *server, int max_clients)
     * }
     */
    public static MethodHandle netcode_server_start$handle() {
        return netcode_server_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_start(struct netcode_server_t *server, int max_clients)
     * }
     */
    public static MemorySegment netcode_server_start$address() {
        return netcode_server_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_start(struct netcode_server_t *server, int max_clients)
     * }
     */
    public static void netcode_server_start(MemorySegment server, int max_clients) {
        var mh$ = netcode_server_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_start", server, max_clients);
            }
            mh$.invokeExact(server, max_clients);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_stop(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_stop$descriptor() {
        return netcode_server_stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_stop(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_stop$handle() {
        return netcode_server_stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_stop(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_stop$address() {
        return netcode_server_stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_stop(struct netcode_server_t *server)
     * }
     */
    public static void netcode_server_stop(MemorySegment server) {
        var mh$ = netcode_server_stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_stop", server);
            }
            mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_running {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_running");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_server_running(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_running$descriptor() {
        return netcode_server_running.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_server_running(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_running$handle() {
        return netcode_server_running.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_server_running(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_running$address() {
        return netcode_server_running.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_server_running(struct netcode_server_t *server)
     * }
     */
    public static int netcode_server_running(MemorySegment server) {
        var mh$ = netcode_server_running.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_running", server);
            }
            return (int)mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_max_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_max_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_server_max_clients(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_max_clients$descriptor() {
        return netcode_server_max_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_server_max_clients(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_max_clients$handle() {
        return netcode_server_max_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_server_max_clients(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_max_clients$address() {
        return netcode_server_max_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_server_max_clients(struct netcode_server_t *server)
     * }
     */
    public static int netcode_server_max_clients(MemorySegment server) {
        var mh$ = netcode_server_max_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_max_clients", server);
            }
            return (int)mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_DOUBLE
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_update(struct netcode_server_t *server, double time)
     * }
     */
    public static FunctionDescriptor netcode_server_update$descriptor() {
        return netcode_server_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_update(struct netcode_server_t *server, double time)
     * }
     */
    public static MethodHandle netcode_server_update$handle() {
        return netcode_server_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_update(struct netcode_server_t *server, double time)
     * }
     */
    public static MemorySegment netcode_server_update$address() {
        return netcode_server_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_update(struct netcode_server_t *server, double time)
     * }
     */
    public static void netcode_server_update(MemorySegment server, double time) {
        var mh$ = netcode_server_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_update", server, time);
            }
            mh$.invokeExact(server, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_client_connected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_client_connected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_server_client_connected(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_client_connected$descriptor() {
        return netcode_server_client_connected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_server_client_connected(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_client_connected$handle() {
        return netcode_server_client_connected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_server_client_connected(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_connected$address() {
        return netcode_server_client_connected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_server_client_connected(struct netcode_server_t *server, int client_index)
     * }
     */
    public static int netcode_server_client_connected(MemorySegment server, int client_index) {
        var mh$ = netcode_server_client_connected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_client_connected", server, client_index);
            }
            return (int)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_client_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_LONG_LONG,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_client_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t netcode_server_client_id(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_client_id$descriptor() {
        return netcode_server_client_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t netcode_server_client_id(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_client_id$handle() {
        return netcode_server_client_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t netcode_server_client_id(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_id$address() {
        return netcode_server_client_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t netcode_server_client_id(struct netcode_server_t *server, int client_index)
     * }
     */
    public static long netcode_server_client_id(MemorySegment server, int client_index) {
        var mh$ = netcode_server_client_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_client_id", server, client_index);
            }
            return (long)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_client_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_client_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_server_client_address(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_client_address$descriptor() {
        return netcode_server_client_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_server_client_address(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_client_address$handle() {
        return netcode_server_client_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_server_client_address(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_address$address() {
        return netcode_server_client_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct netcode_address_t *netcode_server_client_address(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_address(MemorySegment server, int client_index) {
        var mh$ = netcode_server_client_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_client_address", server, client_index);
            }
            return (MemorySegment)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_disconnect_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_disconnect_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_disconnect_client$descriptor() {
        return netcode_server_disconnect_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_disconnect_client$handle() {
        return netcode_server_disconnect_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_disconnect_client$address() {
        return netcode_server_disconnect_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_disconnect_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static void netcode_server_disconnect_client(MemorySegment server, int client_index) {
        var mh$ = netcode_server_disconnect_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_disconnect_client", server, client_index);
            }
            mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_disconnect_all_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_disconnect_all_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_all_clients(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_disconnect_all_clients$descriptor() {
        return netcode_server_disconnect_all_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_all_clients(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_disconnect_all_clients$handle() {
        return netcode_server_disconnect_all_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_all_clients(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_disconnect_all_clients$address() {
        return netcode_server_disconnect_all_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_disconnect_all_clients(struct netcode_server_t *server)
     * }
     */
    public static void netcode_server_disconnect_all_clients(MemorySegment server) {
        var mh$ = netcode_server_disconnect_all_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_disconnect_all_clients", server);
            }
            mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_next_packet_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_LONG_LONG,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_next_packet_sequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t netcode_server_next_packet_sequence(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_next_packet_sequence$descriptor() {
        return netcode_server_next_packet_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t netcode_server_next_packet_sequence(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_next_packet_sequence$handle() {
        return netcode_server_next_packet_sequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t netcode_server_next_packet_sequence(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_next_packet_sequence$address() {
        return netcode_server_next_packet_sequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t netcode_server_next_packet_sequence(struct netcode_server_t *server, int client_index)
     * }
     */
    public static long netcode_server_next_packet_sequence(MemorySegment server, int client_index) {
        var mh$ = netcode_server_next_packet_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_next_packet_sequence", server, client_index);
            }
            return (long)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_send_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_send_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_send_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static FunctionDescriptor netcode_server_send_packet$descriptor() {
        return netcode_server_send_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_send_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MethodHandle netcode_server_send_packet$handle() {
        return netcode_server_send_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_send_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MemorySegment netcode_server_send_packet$address() {
        return netcode_server_send_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_send_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static void netcode_server_send_packet(MemorySegment server, int client_index, MemorySegment packet_data, int packet_bytes) {
        var mh$ = netcode_server_send_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_send_packet", server, client_index, packet_data, packet_bytes);
            }
            mh$.invokeExact(server, client_index, packet_data, packet_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_receive_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_receive_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *netcode_server_receive_packet(struct netcode_server_t *server, int client_index, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static FunctionDescriptor netcode_server_receive_packet$descriptor() {
        return netcode_server_receive_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *netcode_server_receive_packet(struct netcode_server_t *server, int client_index, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MethodHandle netcode_server_receive_packet$handle() {
        return netcode_server_receive_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *netcode_server_receive_packet(struct netcode_server_t *server, int client_index, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MemorySegment netcode_server_receive_packet$address() {
        return netcode_server_receive_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *netcode_server_receive_packet(struct netcode_server_t *server, int client_index, int *packet_bytes, uint64_t *packet_sequence)
     * }
     */
    public static MemorySegment netcode_server_receive_packet(MemorySegment server, int client_index, MemorySegment packet_bytes, MemorySegment packet_sequence) {
        var mh$ = netcode_server_receive_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_receive_packet", server, client_index, packet_bytes, packet_sequence);
            }
            return (MemorySegment)mh$.invokeExact(server, client_index, packet_bytes, packet_sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_free_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_free_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_free_packet(struct netcode_server_t *server, void *packet)
     * }
     */
    public static FunctionDescriptor netcode_server_free_packet$descriptor() {
        return netcode_server_free_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_free_packet(struct netcode_server_t *server, void *packet)
     * }
     */
    public static MethodHandle netcode_server_free_packet$handle() {
        return netcode_server_free_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_free_packet(struct netcode_server_t *server, void *packet)
     * }
     */
    public static MemorySegment netcode_server_free_packet$address() {
        return netcode_server_free_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_free_packet(struct netcode_server_t *server, void *packet)
     * }
     */
    public static void netcode_server_free_packet(MemorySegment server, MemorySegment packet) {
        var mh$ = netcode_server_free_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_free_packet", server, packet);
            }
            mh$.invokeExact(server, packet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_num_connected_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_num_connected_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_server_num_connected_clients(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_num_connected_clients$descriptor() {
        return netcode_server_num_connected_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_server_num_connected_clients(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_num_connected_clients$handle() {
        return netcode_server_num_connected_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_server_num_connected_clients(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_num_connected_clients$address() {
        return netcode_server_num_connected_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_server_num_connected_clients(struct netcode_server_t *server)
     * }
     */
    public static int netcode_server_num_connected_clients(MemorySegment server) {
        var mh$ = netcode_server_num_connected_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_num_connected_clients", server);
            }
            return (int)mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_client_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_client_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *netcode_server_client_user_data(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_client_user_data$descriptor() {
        return netcode_server_client_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *netcode_server_client_user_data(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_client_user_data$handle() {
        return netcode_server_client_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *netcode_server_client_user_data(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_user_data$address() {
        return netcode_server_client_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *netcode_server_client_user_data(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_user_data(MemorySegment server, int client_index) {
        var mh$ = netcode_server_client_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_client_user_data", server, client_index);
            }
            return (MemorySegment)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_process_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_process_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_process_packet(struct netcode_server_t *server, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static FunctionDescriptor netcode_server_process_packet$descriptor() {
        return netcode_server_process_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_process_packet(struct netcode_server_t *server, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MethodHandle netcode_server_process_packet$handle() {
        return netcode_server_process_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_process_packet(struct netcode_server_t *server, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static MemorySegment netcode_server_process_packet$address() {
        return netcode_server_process_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_process_packet(struct netcode_server_t *server, struct netcode_address_t *from, uint8_t *packet_data, int packet_bytes)
     * }
     */
    public static void netcode_server_process_packet(MemorySegment server, MemorySegment from, MemorySegment packet_data, int packet_bytes) {
        var mh$ = netcode_server_process_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_process_packet", server, from, packet_data, packet_bytes);
            }
            mh$.invokeExact(server, from, packet_data, packet_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_connect_loopback_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_LONG_LONG,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_connect_loopback_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_connect_loopback_client(struct netcode_server_t *server, int client_index, uint64_t client_id, const uint8_t *user_data)
     * }
     */
    public static FunctionDescriptor netcode_server_connect_loopback_client$descriptor() {
        return netcode_server_connect_loopback_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_connect_loopback_client(struct netcode_server_t *server, int client_index, uint64_t client_id, const uint8_t *user_data)
     * }
     */
    public static MethodHandle netcode_server_connect_loopback_client$handle() {
        return netcode_server_connect_loopback_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_connect_loopback_client(struct netcode_server_t *server, int client_index, uint64_t client_id, const uint8_t *user_data)
     * }
     */
    public static MemorySegment netcode_server_connect_loopback_client$address() {
        return netcode_server_connect_loopback_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_connect_loopback_client(struct netcode_server_t *server, int client_index, uint64_t client_id, const uint8_t *user_data)
     * }
     */
    public static void netcode_server_connect_loopback_client(MemorySegment server, int client_index, long client_id, MemorySegment user_data) {
        var mh$ = netcode_server_connect_loopback_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_connect_loopback_client", server, client_index, client_id, user_data);
            }
            mh$.invokeExact(server, client_index, client_id, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_disconnect_loopback_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_disconnect_loopback_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_loopback_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_disconnect_loopback_client$descriptor() {
        return netcode_server_disconnect_loopback_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_loopback_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_disconnect_loopback_client$handle() {
        return netcode_server_disconnect_loopback_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_disconnect_loopback_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_disconnect_loopback_client$address() {
        return netcode_server_disconnect_loopback_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_disconnect_loopback_client(struct netcode_server_t *server, int client_index)
     * }
     */
    public static void netcode_server_disconnect_loopback_client(MemorySegment server, int client_index) {
        var mh$ = netcode_server_disconnect_loopback_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_disconnect_loopback_client", server, client_index);
            }
            mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_client_loopback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_client_loopback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int netcode_server_client_loopback(struct netcode_server_t *server, int client_index)
     * }
     */
    public static FunctionDescriptor netcode_server_client_loopback$descriptor() {
        return netcode_server_client_loopback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int netcode_server_client_loopback(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MethodHandle netcode_server_client_loopback$handle() {
        return netcode_server_client_loopback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int netcode_server_client_loopback(struct netcode_server_t *server, int client_index)
     * }
     */
    public static MemorySegment netcode_server_client_loopback$address() {
        return netcode_server_client_loopback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int netcode_server_client_loopback(struct netcode_server_t *server, int client_index)
     * }
     */
    public static int netcode_server_client_loopback(MemorySegment server, int client_index) {
        var mh$ = netcode_server_client_loopback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_client_loopback", server, client_index);
            }
            return (int)mh$.invokeExact(server, client_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_process_loopback_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_POINTER,
            netcode.C_INT,
            netcode.C_LONG_LONG
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_process_loopback_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_server_process_loopback_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static FunctionDescriptor netcode_server_process_loopback_packet$descriptor() {
        return netcode_server_process_loopback_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_server_process_loopback_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static MethodHandle netcode_server_process_loopback_packet$handle() {
        return netcode_server_process_loopback_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_server_process_loopback_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static MemorySegment netcode_server_process_loopback_packet$address() {
        return netcode_server_process_loopback_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_server_process_loopback_packet(struct netcode_server_t *server, int client_index, const uint8_t *packet_data, int packet_bytes, uint64_t packet_sequence)
     * }
     */
    public static void netcode_server_process_loopback_packet(MemorySegment server, int client_index, MemorySegment packet_data, int packet_bytes, long packet_sequence) {
        var mh$ = netcode_server_process_loopback_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_process_loopback_packet", server, client_index, packet_data, packet_bytes, packet_sequence);
            }
            mh$.invokeExact(server, client_index, packet_data, packet_bytes, packet_sequence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_server_get_port {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            netcode.C_SHORT,
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_server_get_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint16_t netcode_server_get_port(struct netcode_server_t *server)
     * }
     */
    public static FunctionDescriptor netcode_server_get_port$descriptor() {
        return netcode_server_get_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint16_t netcode_server_get_port(struct netcode_server_t *server)
     * }
     */
    public static MethodHandle netcode_server_get_port$handle() {
        return netcode_server_get_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint16_t netcode_server_get_port(struct netcode_server_t *server)
     * }
     */
    public static MemorySegment netcode_server_get_port$address() {
        return netcode_server_get_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint16_t netcode_server_get_port(struct netcode_server_t *server)
     * }
     */
    public static short netcode_server_get_port(MemorySegment server) {
        var mh$ = netcode_server_get_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_server_get_port", server);
            }
            return (short)mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_log_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_log_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_log_level(int level)
     * }
     */
    public static FunctionDescriptor netcode_log_level$descriptor() {
        return netcode_log_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_log_level(int level)
     * }
     */
    public static MethodHandle netcode_log_level$handle() {
        return netcode_log_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_log_level(int level)
     * }
     */
    public static MemorySegment netcode_log_level$address() {
        return netcode_log_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_log_level(int level)
     * }
     */
    public static void netcode_log_level(int level) {
        var mh$ = netcode_log_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_log_level", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_assert_function$constants {
        public static final AddressLayout LAYOUT = netcode.C_POINTER;
        public static final MemorySegment SEGMENT = netcode.findOrThrow("netcode_assert_function").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void (*netcode_assert_function)(const char *, const char *, const char *, int)
     * }
     */
    public static AddressLayout netcode_assert_function$layout() {
        return netcode_assert_function$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void (*netcode_assert_function)(const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment netcode_assert_function$segment() {
        return netcode_assert_function$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void (*netcode_assert_function)(const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment netcode_assert_function() {
        return netcode_assert_function$constants.SEGMENT.get(netcode_assert_function$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void (*netcode_assert_function)(const char *, const char *, const char *, int)
     * }
     */
    public static void netcode_assert_function(MemorySegment varValue) {
        netcode_assert_function$constants.SEGMENT.set(netcode_assert_function$constants.LAYOUT, 0L, varValue);
    }

    private static class netcode_set_assert_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_set_assert_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_set_assert_function(void (*function)(const char *, const char *, const char *, int))
     * }
     */
    public static FunctionDescriptor netcode_set_assert_function$descriptor() {
        return netcode_set_assert_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_set_assert_function(void (*function)(const char *, const char *, const char *, int))
     * }
     */
    public static MethodHandle netcode_set_assert_function$handle() {
        return netcode_set_assert_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_set_assert_function(void (*function)(const char *, const char *, const char *, int))
     * }
     */
    public static MemorySegment netcode_set_assert_function$address() {
        return netcode_set_assert_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_set_assert_function(void (*function)(const char *, const char *, const char *, int))
     * }
     */
    public static void netcode_set_assert_function(MemorySegment function) {
        var mh$ = netcode_set_assert_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_set_assert_function", function);
            }
            mh$.invokeExact(function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_random_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_POINTER,
            netcode.C_INT
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_random_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_random_bytes(uint8_t *data, int bytes)
     * }
     */
    public static FunctionDescriptor netcode_random_bytes$descriptor() {
        return netcode_random_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_random_bytes(uint8_t *data, int bytes)
     * }
     */
    public static MethodHandle netcode_random_bytes$handle() {
        return netcode_random_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_random_bytes(uint8_t *data, int bytes)
     * }
     */
    public static MemorySegment netcode_random_bytes$address() {
        return netcode_random_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_random_bytes(uint8_t *data, int bytes)
     * }
     */
    public static void netcode_random_bytes(MemorySegment data, int bytes) {
        var mh$ = netcode_random_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_random_bytes", data, bytes);
            }
            mh$.invokeExact(data, bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class netcode_sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            netcode.C_DOUBLE
        );

        public static final MemorySegment ADDR = netcode.findOrThrow("netcode_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void netcode_sleep(double seconds)
     * }
     */
    public static FunctionDescriptor netcode_sleep$descriptor() {
        return netcode_sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void netcode_sleep(double seconds)
     * }
     */
    public static MethodHandle netcode_sleep$handle() {
        return netcode_sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void netcode_sleep(double seconds)
     * }
     */
    public static MemorySegment netcode_sleep$address() {
        return netcode_sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void netcode_sleep(double seconds)
     * }
     */
    public static void netcode_sleep(double seconds) {
        var mh$ = netcode_sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("netcode_sleep", seconds);
            }
            mh$.invokeExact(seconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * double netcode_time()
     * }
     */
    public static class netcode_time {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                netcode.C_DOUBLE        );
        private static final MemorySegment ADDR = netcode.findOrThrow("netcode_time");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private netcode_time(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * double netcode_time()
         * }
         */
        public static netcode_time makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new netcode_time(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public double apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("netcode_time", x0);
                }
                return (double)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = netcode.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int NETCODE_PLATFORM = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_PLATFORM 2
     * }
     */
    public static int NETCODE_PLATFORM() {
        return NETCODE_PLATFORM;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED -6
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED() {
        return NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED;
    }
    private static final int NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN -5
     * }
     */
    public static int NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN() {
        return NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT -4
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT() {
        return NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT -3
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT() {
        return NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT -2
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT() {
        return NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT;
    }
    private static final int NETCODE_CLIENT_STATE_CONNECTION_DENIED = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define NETCODE_CLIENT_STATE_CONNECTION_DENIED -1
     * }
     */
    public static int NETCODE_CLIENT_STATE_CONNECTION_DENIED() {
        return NETCODE_CLIENT_STATE_CONNECTION_DENIED;
    }
}

