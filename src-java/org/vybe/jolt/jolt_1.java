// Generated by jextract

package org.vybe.jolt;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class jolt_1 {

    jolt_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libjoltc.dylib", LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libvybe_jolt.dylib", LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED() {
        return __API_TO_BE_DEPRECATED;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOS() {
        return __API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int __API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOS() {
        return __API_TO_BE_DEPRECATED_IOS;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYST = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYST 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYST() {
        return __API_TO_BE_DEPRECATED_MACCATALYST;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOS() {
        return __API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOS() {
        return __API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int __API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_DRIVERKIT() {
        return __API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOS() {
        return __API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int __MAC_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_0 1000
     * }
     */
    public static int __MAC_10_0() {
        return __MAC_10_0;
    }
    private static final int __MAC_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_1 1010
     * }
     */
    public static int __MAC_10_1() {
        return __MAC_10_1;
    }
    private static final int __MAC_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_2 1020
     * }
     */
    public static int __MAC_10_2() {
        return __MAC_10_2;
    }
    private static final int __MAC_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_3 1030
     * }
     */
    public static int __MAC_10_3() {
        return __MAC_10_3;
    }
    private static final int __MAC_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_4 1040
     * }
     */
    public static int __MAC_10_4() {
        return __MAC_10_4;
    }
    private static final int __MAC_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_5 1050
     * }
     */
    public static int __MAC_10_5() {
        return __MAC_10_5;
    }
    private static final int __MAC_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_6 1060
     * }
     */
    public static int __MAC_10_6() {
        return __MAC_10_6;
    }
    private static final int __MAC_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_7 1070
     * }
     */
    public static int __MAC_10_7() {
        return __MAC_10_7;
    }
    private static final int __MAC_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_8 1080
     * }
     */
    public static int __MAC_10_8() {
        return __MAC_10_8;
    }
    private static final int __MAC_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_9 1090
     * }
     */
    public static int __MAC_10_9() {
        return __MAC_10_9;
    }
    private static final int __MAC_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10 101000
     * }
     */
    public static int __MAC_10_10() {
        return __MAC_10_10;
    }
    private static final int __MAC_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_2 101002
     * }
     */
    public static int __MAC_10_10_2() {
        return __MAC_10_10_2;
    }
    private static final int __MAC_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_3 101003
     * }
     */
    public static int __MAC_10_10_3() {
        return __MAC_10_10_3;
    }
    private static final int __MAC_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11 101100
     * }
     */
    public static int __MAC_10_11() {
        return __MAC_10_11;
    }
    private static final int __MAC_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_2 101102
     * }
     */
    public static int __MAC_10_11_2() {
        return __MAC_10_11_2;
    }
    private static final int __MAC_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_3 101103
     * }
     */
    public static int __MAC_10_11_3() {
        return __MAC_10_11_3;
    }
    private static final int __MAC_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_4 101104
     * }
     */
    public static int __MAC_10_11_4() {
        return __MAC_10_11_4;
    }
    private static final int __MAC_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12 101200
     * }
     */
    public static int __MAC_10_12() {
        return __MAC_10_12;
    }
    private static final int __MAC_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_1 101201
     * }
     */
    public static int __MAC_10_12_1() {
        return __MAC_10_12_1;
    }
    private static final int __MAC_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_2 101202
     * }
     */
    public static int __MAC_10_12_2() {
        return __MAC_10_12_2;
    }
    private static final int __MAC_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_4 101204
     * }
     */
    public static int __MAC_10_12_4() {
        return __MAC_10_12_4;
    }
    private static final int __MAC_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13 101300
     * }
     */
    public static int __MAC_10_13() {
        return __MAC_10_13;
    }
    private static final int __MAC_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_1 101301
     * }
     */
    public static int __MAC_10_13_1() {
        return __MAC_10_13_1;
    }
    private static final int __MAC_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_2 101302
     * }
     */
    public static int __MAC_10_13_2() {
        return __MAC_10_13_2;
    }
    private static final int __MAC_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_4 101304
     * }
     */
    public static int __MAC_10_13_4() {
        return __MAC_10_13_4;
    }
    private static final int __MAC_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14 101400
     * }
     */
    public static int __MAC_10_14() {
        return __MAC_10_14;
    }
    private static final int __MAC_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_1 101401
     * }
     */
    public static int __MAC_10_14_1() {
        return __MAC_10_14_1;
    }
    private static final int __MAC_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_4 101404
     * }
     */
    public static int __MAC_10_14_4() {
        return __MAC_10_14_4;
    }
    private static final int __MAC_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_5 101405
     * }
     */
    public static int __MAC_10_14_5() {
        return __MAC_10_14_5;
    }
    private static final int __MAC_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_6 101406
     * }
     */
    public static int __MAC_10_14_6() {
        return __MAC_10_14_6;
    }
    private static final int __MAC_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15 101500
     * }
     */
    public static int __MAC_10_15() {
        return __MAC_10_15;
    }
    private static final int __MAC_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_1 101501
     * }
     */
    public static int __MAC_10_15_1() {
        return __MAC_10_15_1;
    }
    private static final int __MAC_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_4 101504
     * }
     */
    public static int __MAC_10_15_4() {
        return __MAC_10_15_4;
    }
    private static final int __MAC_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_16 101600
     * }
     */
    public static int __MAC_10_16() {
        return __MAC_10_16;
    }
    private static final int __MAC_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_0 110000
     * }
     */
    public static int __MAC_11_0() {
        return __MAC_11_0;
    }
    private static final int __MAC_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_1 110100
     * }
     */
    public static int __MAC_11_1() {
        return __MAC_11_1;
    }
    private static final int __MAC_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_3 110300
     * }
     */
    public static int __MAC_11_3() {
        return __MAC_11_3;
    }
    private static final int __MAC_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_4 110400
     * }
     */
    public static int __MAC_11_4() {
        return __MAC_11_4;
    }
    private static final int __MAC_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_5 110500
     * }
     */
    public static int __MAC_11_5() {
        return __MAC_11_5;
    }
    private static final int __MAC_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_6 110600
     * }
     */
    public static int __MAC_11_6() {
        return __MAC_11_6;
    }
    private static final int __MAC_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_0 120000
     * }
     */
    public static int __MAC_12_0() {
        return __MAC_12_0;
    }
    private static final int __MAC_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_1 120100
     * }
     */
    public static int __MAC_12_1() {
        return __MAC_12_1;
    }
    private static final int __MAC_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_2 120200
     * }
     */
    public static int __MAC_12_2() {
        return __MAC_12_2;
    }
    private static final int __MAC_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_3 120300
     * }
     */
    public static int __MAC_12_3() {
        return __MAC_12_3;
    }
    private static final int __MAC_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_4 120400
     * }
     */
    public static int __MAC_12_4() {
        return __MAC_12_4;
    }
    private static final int __MAC_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_5 120500
     * }
     */
    public static int __MAC_12_5() {
        return __MAC_12_5;
    }
    private static final int __MAC_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_6 120600
     * }
     */
    public static int __MAC_12_6() {
        return __MAC_12_6;
    }
    private static final int __MAC_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_7 120700
     * }
     */
    public static int __MAC_12_7() {
        return __MAC_12_7;
    }
    private static final int __MAC_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_0 130000
     * }
     */
    public static int __MAC_13_0() {
        return __MAC_13_0;
    }
    private static final int __MAC_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_1 130100
     * }
     */
    public static int __MAC_13_1() {
        return __MAC_13_1;
    }
    private static final int __MAC_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_2 130200
     * }
     */
    public static int __MAC_13_2() {
        return __MAC_13_2;
    }
    private static final int __MAC_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_3 130300
     * }
     */
    public static int __MAC_13_3() {
        return __MAC_13_3;
    }
    private static final int __MAC_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_4 130400
     * }
     */
    public static int __MAC_13_4() {
        return __MAC_13_4;
    }
    private static final int __MAC_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_5 130500
     * }
     */
    public static int __MAC_13_5() {
        return __MAC_13_5;
    }
    private static final int __MAC_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_6 130600
     * }
     */
    public static int __MAC_13_6() {
        return __MAC_13_6;
    }
    private static final int __MAC_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_0 140000
     * }
     */
    public static int __MAC_14_0() {
        return __MAC_14_0;
    }
    private static final int __MAC_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_1 140100
     * }
     */
    public static int __MAC_14_1() {
        return __MAC_14_1;
    }
    private static final int __MAC_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_2 140200
     * }
     */
    public static int __MAC_14_2() {
        return __MAC_14_2;
    }
    private static final int __IPHONE_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_0 20000
     * }
     */
    public static int __IPHONE_2_0() {
        return __IPHONE_2_0;
    }
    private static final int __IPHONE_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_1 20100
     * }
     */
    public static int __IPHONE_2_1() {
        return __IPHONE_2_1;
    }
    private static final int __IPHONE_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_2 20200
     * }
     */
    public static int __IPHONE_2_2() {
        return __IPHONE_2_2;
    }
    private static final int __IPHONE_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_0 30000
     * }
     */
    public static int __IPHONE_3_0() {
        return __IPHONE_3_0;
    }
    private static final int __IPHONE_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_1 30100
     * }
     */
    public static int __IPHONE_3_1() {
        return __IPHONE_3_1;
    }
    private static final int __IPHONE_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_2 30200
     * }
     */
    public static int __IPHONE_3_2() {
        return __IPHONE_3_2;
    }
    private static final int __IPHONE_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_0 40000
     * }
     */
    public static int __IPHONE_4_0() {
        return __IPHONE_4_0;
    }
    private static final int __IPHONE_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_1 40100
     * }
     */
    public static int __IPHONE_4_1() {
        return __IPHONE_4_1;
    }
    private static final int __IPHONE_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_2 40200
     * }
     */
    public static int __IPHONE_4_2() {
        return __IPHONE_4_2;
    }
    private static final int __IPHONE_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_3 40300
     * }
     */
    public static int __IPHONE_4_3() {
        return __IPHONE_4_3;
    }
    private static final int __IPHONE_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_0 50000
     * }
     */
    public static int __IPHONE_5_0() {
        return __IPHONE_5_0;
    }
    private static final int __IPHONE_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_1 50100
     * }
     */
    public static int __IPHONE_5_1() {
        return __IPHONE_5_1;
    }
    private static final int __IPHONE_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_0 60000
     * }
     */
    public static int __IPHONE_6_0() {
        return __IPHONE_6_0;
    }
    private static final int __IPHONE_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_1 60100
     * }
     */
    public static int __IPHONE_6_1() {
        return __IPHONE_6_1;
    }
    private static final int __IPHONE_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_0 70000
     * }
     */
    public static int __IPHONE_7_0() {
        return __IPHONE_7_0;
    }
    private static final int __IPHONE_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_1 70100
     * }
     */
    public static int __IPHONE_7_1() {
        return __IPHONE_7_1;
    }
    private static final int __IPHONE_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_0 80000
     * }
     */
    public static int __IPHONE_8_0() {
        return __IPHONE_8_0;
    }
    private static final int __IPHONE_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_1 80100
     * }
     */
    public static int __IPHONE_8_1() {
        return __IPHONE_8_1;
    }
    private static final int __IPHONE_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_2 80200
     * }
     */
    public static int __IPHONE_8_2() {
        return __IPHONE_8_2;
    }
    private static final int __IPHONE_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_3 80300
     * }
     */
    public static int __IPHONE_8_3() {
        return __IPHONE_8_3;
    }
    private static final int __IPHONE_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_4 80400
     * }
     */
    public static int __IPHONE_8_4() {
        return __IPHONE_8_4;
    }
    private static final int __IPHONE_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_0 90000
     * }
     */
    public static int __IPHONE_9_0() {
        return __IPHONE_9_0;
    }
    private static final int __IPHONE_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_1 90100
     * }
     */
    public static int __IPHONE_9_1() {
        return __IPHONE_9_1;
    }
    private static final int __IPHONE_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_2 90200
     * }
     */
    public static int __IPHONE_9_2() {
        return __IPHONE_9_2;
    }
    private static final int __IPHONE_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_3 90300
     * }
     */
    public static int __IPHONE_9_3() {
        return __IPHONE_9_3;
    }
    private static final int __IPHONE_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_0 100000
     * }
     */
    public static int __IPHONE_10_0() {
        return __IPHONE_10_0;
    }
    private static final int __IPHONE_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_1 100100
     * }
     */
    public static int __IPHONE_10_1() {
        return __IPHONE_10_1;
    }
    private static final int __IPHONE_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_2 100200
     * }
     */
    public static int __IPHONE_10_2() {
        return __IPHONE_10_2;
    }
    private static final int __IPHONE_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_3 100300
     * }
     */
    public static int __IPHONE_10_3() {
        return __IPHONE_10_3;
    }
    private static final int __IPHONE_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_0 110000
     * }
     */
    public static int __IPHONE_11_0() {
        return __IPHONE_11_0;
    }
    private static final int __IPHONE_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_1 110100
     * }
     */
    public static int __IPHONE_11_1() {
        return __IPHONE_11_1;
    }
    private static final int __IPHONE_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_2 110200
     * }
     */
    public static int __IPHONE_11_2() {
        return __IPHONE_11_2;
    }
    private static final int __IPHONE_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_3 110300
     * }
     */
    public static int __IPHONE_11_3() {
        return __IPHONE_11_3;
    }
    private static final int __IPHONE_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_4 110400
     * }
     */
    public static int __IPHONE_11_4() {
        return __IPHONE_11_4;
    }
    private static final int __IPHONE_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_0 120000
     * }
     */
    public static int __IPHONE_12_0() {
        return __IPHONE_12_0;
    }
    private static final int __IPHONE_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_1 120100
     * }
     */
    public static int __IPHONE_12_1() {
        return __IPHONE_12_1;
    }
    private static final int __IPHONE_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_2 120200
     * }
     */
    public static int __IPHONE_12_2() {
        return __IPHONE_12_2;
    }
    private static final int __IPHONE_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_3 120300
     * }
     */
    public static int __IPHONE_12_3() {
        return __IPHONE_12_3;
    }
    private static final int __IPHONE_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_4 120400
     * }
     */
    public static int __IPHONE_12_4() {
        return __IPHONE_12_4;
    }
    private static final int __IPHONE_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_0 130000
     * }
     */
    public static int __IPHONE_13_0() {
        return __IPHONE_13_0;
    }
    private static final int __IPHONE_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_1 130100
     * }
     */
    public static int __IPHONE_13_1() {
        return __IPHONE_13_1;
    }
    private static final int __IPHONE_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_2 130200
     * }
     */
    public static int __IPHONE_13_2() {
        return __IPHONE_13_2;
    }
    private static final int __IPHONE_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_3 130300
     * }
     */
    public static int __IPHONE_13_3() {
        return __IPHONE_13_3;
    }
    private static final int __IPHONE_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_4 130400
     * }
     */
    public static int __IPHONE_13_4() {
        return __IPHONE_13_4;
    }
    private static final int __IPHONE_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_5 130500
     * }
     */
    public static int __IPHONE_13_5() {
        return __IPHONE_13_5;
    }
    private static final int __IPHONE_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_6 130600
     * }
     */
    public static int __IPHONE_13_6() {
        return __IPHONE_13_6;
    }
    private static final int __IPHONE_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_7 130700
     * }
     */
    public static int __IPHONE_13_7() {
        return __IPHONE_13_7;
    }
    private static final int __IPHONE_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_0 140000
     * }
     */
    public static int __IPHONE_14_0() {
        return __IPHONE_14_0;
    }
    private static final int __IPHONE_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_1 140100
     * }
     */
    public static int __IPHONE_14_1() {
        return __IPHONE_14_1;
    }
    private static final int __IPHONE_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_2 140200
     * }
     */
    public static int __IPHONE_14_2() {
        return __IPHONE_14_2;
    }
    private static final int __IPHONE_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_3 140300
     * }
     */
    public static int __IPHONE_14_3() {
        return __IPHONE_14_3;
    }
    private static final int __IPHONE_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_5 140500
     * }
     */
    public static int __IPHONE_14_5() {
        return __IPHONE_14_5;
    }
    private static final int __IPHONE_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_4 140400
     * }
     */
    public static int __IPHONE_14_4() {
        return __IPHONE_14_4;
    }
    private static final int __IPHONE_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_6 140600
     * }
     */
    public static int __IPHONE_14_6() {
        return __IPHONE_14_6;
    }
    private static final int __IPHONE_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_7 140700
     * }
     */
    public static int __IPHONE_14_7() {
        return __IPHONE_14_7;
    }
    private static final int __IPHONE_14_8 = (int)140800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_8 140800
     * }
     */
    public static int __IPHONE_14_8() {
        return __IPHONE_14_8;
    }
    private static final int __IPHONE_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_0 150000
     * }
     */
    public static int __IPHONE_15_0() {
        return __IPHONE_15_0;
    }
    private static final int __IPHONE_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_1 150100
     * }
     */
    public static int __IPHONE_15_1() {
        return __IPHONE_15_1;
    }
    private static final int __IPHONE_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_2 150200
     * }
     */
    public static int __IPHONE_15_2() {
        return __IPHONE_15_2;
    }
    private static final int __IPHONE_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_3 150300
     * }
     */
    public static int __IPHONE_15_3() {
        return __IPHONE_15_3;
    }
    private static final int __IPHONE_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_4 150400
     * }
     */
    public static int __IPHONE_15_4() {
        return __IPHONE_15_4;
    }
    private static final int __IPHONE_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_5 150500
     * }
     */
    public static int __IPHONE_15_5() {
        return __IPHONE_15_5;
    }
    private static final int __IPHONE_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_6 150600
     * }
     */
    public static int __IPHONE_15_6() {
        return __IPHONE_15_6;
    }
    private static final int __IPHONE_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_0 160000
     * }
     */
    public static int __IPHONE_16_0() {
        return __IPHONE_16_0;
    }
    private static final int __IPHONE_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_1 160100
     * }
     */
    public static int __IPHONE_16_1() {
        return __IPHONE_16_1;
    }
    private static final int __IPHONE_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_2 160200
     * }
     */
    public static int __IPHONE_16_2() {
        return __IPHONE_16_2;
    }
    private static final int __IPHONE_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_3 160300
     * }
     */
    public static int __IPHONE_16_3() {
        return __IPHONE_16_3;
    }
    private static final int __IPHONE_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_4 160400
     * }
     */
    public static int __IPHONE_16_4() {
        return __IPHONE_16_4;
    }
    private static final int __IPHONE_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_5 160500
     * }
     */
    public static int __IPHONE_16_5() {
        return __IPHONE_16_5;
    }
    private static final int __IPHONE_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_6 160600
     * }
     */
    public static int __IPHONE_16_6() {
        return __IPHONE_16_6;
    }
    private static final int __IPHONE_16_7 = (int)160700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_7 160700
     * }
     */
    public static int __IPHONE_16_7() {
        return __IPHONE_16_7;
    }
    private static final int __IPHONE_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_0 170000
     * }
     */
    public static int __IPHONE_17_0() {
        return __IPHONE_17_0;
    }
    private static final int __IPHONE_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_1 170100
     * }
     */
    public static int __IPHONE_17_1() {
        return __IPHONE_17_1;
    }
    private static final int __IPHONE_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_2 170200
     * }
     */
    public static int __IPHONE_17_2() {
        return __IPHONE_17_2;
    }
    private static final int __WATCHOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_1_0 10000
     * }
     */
    public static int __WATCHOS_1_0() {
        return __WATCHOS_1_0;
    }
    private static final int __WATCHOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_0 20000
     * }
     */
    public static int __WATCHOS_2_0() {
        return __WATCHOS_2_0;
    }
    private static final int __WATCHOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_1 20100
     * }
     */
    public static int __WATCHOS_2_1() {
        return __WATCHOS_2_1;
    }
    private static final int __WATCHOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_2 20200
     * }
     */
    public static int __WATCHOS_2_2() {
        return __WATCHOS_2_2;
    }
    private static final int __WATCHOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_0 30000
     * }
     */
    public static int __WATCHOS_3_0() {
        return __WATCHOS_3_0;
    }
    private static final int __WATCHOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1 30100
     * }
     */
    public static int __WATCHOS_3_1() {
        return __WATCHOS_3_1;
    }
    private static final int __WATCHOS_3_1_1 = (int)30101L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1_1 30101
     * }
     */
    public static int __WATCHOS_3_1_1() {
        return __WATCHOS_3_1_1;
    }
    private static final int __WATCHOS_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_2 30200
     * }
     */
    public static int __WATCHOS_3_2() {
        return __WATCHOS_3_2;
    }
    private static final int __WATCHOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_0 40000
     * }
     */
    public static int __WATCHOS_4_0() {
        return __WATCHOS_4_0;
    }
    private static final int __WATCHOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_1 40100
     * }
     */
    public static int __WATCHOS_4_1() {
        return __WATCHOS_4_1;
    }
    private static final int __WATCHOS_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_2 40200
     * }
     */
    public static int __WATCHOS_4_2() {
        return __WATCHOS_4_2;
    }
    private static final int __WATCHOS_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_3 40300
     * }
     */
    public static int __WATCHOS_4_3() {
        return __WATCHOS_4_3;
    }
    private static final int __WATCHOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_0 50000
     * }
     */
    public static int __WATCHOS_5_0() {
        return __WATCHOS_5_0;
    }
    private static final int __WATCHOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_1 50100
     * }
     */
    public static int __WATCHOS_5_1() {
        return __WATCHOS_5_1;
    }
    private static final int __WATCHOS_5_2 = (int)50200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_2 50200
     * }
     */
    public static int __WATCHOS_5_2() {
        return __WATCHOS_5_2;
    }
    private static final int __WATCHOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_3 50300
     * }
     */
    public static int __WATCHOS_5_3() {
        return __WATCHOS_5_3;
    }
    private static final int __WATCHOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_0 60000
     * }
     */
    public static int __WATCHOS_6_0() {
        return __WATCHOS_6_0;
    }
    private static final int __WATCHOS_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_1 60100
     * }
     */
    public static int __WATCHOS_6_1() {
        return __WATCHOS_6_1;
    }
    private static final int __WATCHOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_2 60200
     * }
     */
    public static int __WATCHOS_6_2() {
        return __WATCHOS_6_2;
    }
    private static final int __WATCHOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_0 70000
     * }
     */
    public static int __WATCHOS_7_0() {
        return __WATCHOS_7_0;
    }
    private static final int __WATCHOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_1 70100
     * }
     */
    public static int __WATCHOS_7_1() {
        return __WATCHOS_7_1;
    }
    private static final int __WATCHOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_2 70200
     * }
     */
    public static int __WATCHOS_7_2() {
        return __WATCHOS_7_2;
    }
    private static final int __WATCHOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_3 70300
     * }
     */
    public static int __WATCHOS_7_3() {
        return __WATCHOS_7_3;
    }
    private static final int __WATCHOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_4 70400
     * }
     */
    public static int __WATCHOS_7_4() {
        return __WATCHOS_7_4;
    }
    private static final int __WATCHOS_7_5 = (int)70500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_5 70500
     * }
     */
    public static int __WATCHOS_7_5() {
        return __WATCHOS_7_5;
    }
    private static final int __WATCHOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_6 70600
     * }
     */
    public static int __WATCHOS_7_6() {
        return __WATCHOS_7_6;
    }
    private static final int __WATCHOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_0 80000
     * }
     */
    public static int __WATCHOS_8_0() {
        return __WATCHOS_8_0;
    }
    private static final int __WATCHOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_1 80100
     * }
     */
    public static int __WATCHOS_8_1() {
        return __WATCHOS_8_1;
    }
    private static final int __WATCHOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_3 80300
     * }
     */
    public static int __WATCHOS_8_3() {
        return __WATCHOS_8_3;
    }
    private static final int __WATCHOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_4 80400
     * }
     */
    public static int __WATCHOS_8_4() {
        return __WATCHOS_8_4;
    }
    private static final int __WATCHOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_5 80500
     * }
     */
    public static int __WATCHOS_8_5() {
        return __WATCHOS_8_5;
    }
    private static final int __WATCHOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_6 80600
     * }
     */
    public static int __WATCHOS_8_6() {
        return __WATCHOS_8_6;
    }
    private static final int __WATCHOS_8_7 = (int)80700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_7 80700
     * }
     */
    public static int __WATCHOS_8_7() {
        return __WATCHOS_8_7;
    }
    private static final int __WATCHOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_0 90000
     * }
     */
    public static int __WATCHOS_9_0() {
        return __WATCHOS_9_0;
    }
    private static final int __WATCHOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_1 90100
     * }
     */
    public static int __WATCHOS_9_1() {
        return __WATCHOS_9_1;
    }
    private static final int __WATCHOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_2 90200
     * }
     */
    public static int __WATCHOS_9_2() {
        return __WATCHOS_9_2;
    }
    private static final int __WATCHOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_3 90300
     * }
     */
    public static int __WATCHOS_9_3() {
        return __WATCHOS_9_3;
    }
    private static final int __WATCHOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_4 90400
     * }
     */
    public static int __WATCHOS_9_4() {
        return __WATCHOS_9_4;
    }
    private static final int __WATCHOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_5 90500
     * }
     */
    public static int __WATCHOS_9_5() {
        return __WATCHOS_9_5;
    }
    private static final int __WATCHOS_9_6 = (int)90600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_6 90600
     * }
     */
    public static int __WATCHOS_9_6() {
        return __WATCHOS_9_6;
    }
    private static final int __WATCHOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_0 100000
     * }
     */
    public static int __WATCHOS_10_0() {
        return __WATCHOS_10_0;
    }
    private static final int __WATCHOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_1 100100
     * }
     */
    public static int __WATCHOS_10_1() {
        return __WATCHOS_10_1;
    }
    private static final int __WATCHOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_2 100200
     * }
     */
    public static int __WATCHOS_10_2() {
        return __WATCHOS_10_2;
    }
    private static final int __TVOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_0 90000
     * }
     */
    public static int __TVOS_9_0() {
        return __TVOS_9_0;
    }
    private static final int __TVOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_1 90100
     * }
     */
    public static int __TVOS_9_1() {
        return __TVOS_9_1;
    }
    private static final int __TVOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_2 90200
     * }
     */
    public static int __TVOS_9_2() {
        return __TVOS_9_2;
    }
    private static final int __TVOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0 100000
     * }
     */
    public static int __TVOS_10_0() {
        return __TVOS_10_0;
    }
    private static final int __TVOS_10_0_1 = (int)100001L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0_1 100001
     * }
     */
    public static int __TVOS_10_0_1() {
        return __TVOS_10_0_1;
    }
    private static final int __TVOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_1 100100
     * }
     */
    public static int __TVOS_10_1() {
        return __TVOS_10_1;
    }
    private static final int __TVOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_2 100200
     * }
     */
    public static int __TVOS_10_2() {
        return __TVOS_10_2;
    }
    private static final int __TVOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_0 110000
     * }
     */
    public static int __TVOS_11_0() {
        return __TVOS_11_0;
    }
    private static final int __TVOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_1 110100
     * }
     */
    public static int __TVOS_11_1() {
        return __TVOS_11_1;
    }
    private static final int __TVOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_2 110200
     * }
     */
    public static int __TVOS_11_2() {
        return __TVOS_11_2;
    }
    private static final int __TVOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_3 110300
     * }
     */
    public static int __TVOS_11_3() {
        return __TVOS_11_3;
    }
    private static final int __TVOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_4 110400
     * }
     */
    public static int __TVOS_11_4() {
        return __TVOS_11_4;
    }
    private static final int __TVOS_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_0 120000
     * }
     */
    public static int __TVOS_12_0() {
        return __TVOS_12_0;
    }
    private static final int __TVOS_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_1 120100
     * }
     */
    public static int __TVOS_12_1() {
        return __TVOS_12_1;
    }
    private static final int __TVOS_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_2 120200
     * }
     */
    public static int __TVOS_12_2() {
        return __TVOS_12_2;
    }
    private static final int __TVOS_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_3 120300
     * }
     */
    public static int __TVOS_12_3() {
        return __TVOS_12_3;
    }
    private static final int __TVOS_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_4 120400
     * }
     */
    public static int __TVOS_12_4() {
        return __TVOS_12_4;
    }
    private static final int __TVOS_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_0 130000
     * }
     */
    public static int __TVOS_13_0() {
        return __TVOS_13_0;
    }
    private static final int __TVOS_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_2 130200
     * }
     */
    public static int __TVOS_13_2() {
        return __TVOS_13_2;
    }
    private static final int __TVOS_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_3 130300
     * }
     */
    public static int __TVOS_13_3() {
        return __TVOS_13_3;
    }
    private static final int __TVOS_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_4 130400
     * }
     */
    public static int __TVOS_13_4() {
        return __TVOS_13_4;
    }
    private static final int __TVOS_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_0 140000
     * }
     */
    public static int __TVOS_14_0() {
        return __TVOS_14_0;
    }
    private static final int __TVOS_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_1 140100
     * }
     */
    public static int __TVOS_14_1() {
        return __TVOS_14_1;
    }
    private static final int __TVOS_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_2 140200
     * }
     */
    public static int __TVOS_14_2() {
        return __TVOS_14_2;
    }
    private static final int __TVOS_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_3 140300
     * }
     */
    public static int __TVOS_14_3() {
        return __TVOS_14_3;
    }
    private static final int __TVOS_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_5 140500
     * }
     */
    public static int __TVOS_14_5() {
        return __TVOS_14_5;
    }
    private static final int __TVOS_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_6 140600
     * }
     */
    public static int __TVOS_14_6() {
        return __TVOS_14_6;
    }
    private static final int __TVOS_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_7 140700
     * }
     */
    public static int __TVOS_14_7() {
        return __TVOS_14_7;
    }
    private static final int __TVOS_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_0 150000
     * }
     */
    public static int __TVOS_15_0() {
        return __TVOS_15_0;
    }
    private static final int __TVOS_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_1 150100
     * }
     */
    public static int __TVOS_15_1() {
        return __TVOS_15_1;
    }
    private static final int __TVOS_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_2 150200
     * }
     */
    public static int __TVOS_15_2() {
        return __TVOS_15_2;
    }
    private static final int __TVOS_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_3 150300
     * }
     */
    public static int __TVOS_15_3() {
        return __TVOS_15_3;
    }
    private static final int __TVOS_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_4 150400
     * }
     */
    public static int __TVOS_15_4() {
        return __TVOS_15_4;
    }
    private static final int __TVOS_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_5 150500
     * }
     */
    public static int __TVOS_15_5() {
        return __TVOS_15_5;
    }
    private static final int __TVOS_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_6 150600
     * }
     */
    public static int __TVOS_15_6() {
        return __TVOS_15_6;
    }
    private static final int __TVOS_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_0 160000
     * }
     */
    public static int __TVOS_16_0() {
        return __TVOS_16_0;
    }
    private static final int __TVOS_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_1 160100
     * }
     */
    public static int __TVOS_16_1() {
        return __TVOS_16_1;
    }
    private static final int __TVOS_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_2 160200
     * }
     */
    public static int __TVOS_16_2() {
        return __TVOS_16_2;
    }
    private static final int __TVOS_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_3 160300
     * }
     */
    public static int __TVOS_16_3() {
        return __TVOS_16_3;
    }
    private static final int __TVOS_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_4 160400
     * }
     */
    public static int __TVOS_16_4() {
        return __TVOS_16_4;
    }
    private static final int __TVOS_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_5 160500
     * }
     */
    public static int __TVOS_16_5() {
        return __TVOS_16_5;
    }
    private static final int __TVOS_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_6 160600
     * }
     */
    public static int __TVOS_16_6() {
        return __TVOS_16_6;
    }
    private static final int __TVOS_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_0 170000
     * }
     */
    public static int __TVOS_17_0() {
        return __TVOS_17_0;
    }
    private static final int __TVOS_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_1 170100
     * }
     */
    public static int __TVOS_17_1() {
        return __TVOS_17_1;
    }
    private static final int __TVOS_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_2 170200
     * }
     */
    public static int __TVOS_17_2() {
        return __TVOS_17_2;
    }
    private static final int __BRIDGEOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_2_0 20000
     * }
     */
    public static int __BRIDGEOS_2_0() {
        return __BRIDGEOS_2_0;
    }
    private static final int __BRIDGEOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_0 30000
     * }
     */
    public static int __BRIDGEOS_3_0() {
        return __BRIDGEOS_3_0;
    }
    private static final int __BRIDGEOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_1 30100
     * }
     */
    public static int __BRIDGEOS_3_1() {
        return __BRIDGEOS_3_1;
    }
    private static final int __BRIDGEOS_3_4 = (int)30400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_4 30400
     * }
     */
    public static int __BRIDGEOS_3_4() {
        return __BRIDGEOS_3_4;
    }
    private static final int __BRIDGEOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_0 40000
     * }
     */
    public static int __BRIDGEOS_4_0() {
        return __BRIDGEOS_4_0;
    }
    private static final int __BRIDGEOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_1 40100
     * }
     */
    public static int __BRIDGEOS_4_1() {
        return __BRIDGEOS_4_1;
    }
    private static final int __BRIDGEOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_0 50000
     * }
     */
    public static int __BRIDGEOS_5_0() {
        return __BRIDGEOS_5_0;
    }
    private static final int __BRIDGEOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_1 50100
     * }
     */
    public static int __BRIDGEOS_5_1() {
        return __BRIDGEOS_5_1;
    }
    private static final int __BRIDGEOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_3 50300
     * }
     */
    public static int __BRIDGEOS_5_3() {
        return __BRIDGEOS_5_3;
    }
    private static final int __BRIDGEOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_0 60000
     * }
     */
    public static int __BRIDGEOS_6_0() {
        return __BRIDGEOS_6_0;
    }
    private static final int __BRIDGEOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_2 60200
     * }
     */
    public static int __BRIDGEOS_6_2() {
        return __BRIDGEOS_6_2;
    }
    private static final int __BRIDGEOS_6_4 = (int)60400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_4 60400
     * }
     */
    public static int __BRIDGEOS_6_4() {
        return __BRIDGEOS_6_4;
    }
    private static final int __BRIDGEOS_6_5 = (int)60500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_5 60500
     * }
     */
    public static int __BRIDGEOS_6_5() {
        return __BRIDGEOS_6_5;
    }
    private static final int __BRIDGEOS_6_6 = (int)60600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_6 60600
     * }
     */
    public static int __BRIDGEOS_6_6() {
        return __BRIDGEOS_6_6;
    }
    private static final int __BRIDGEOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_0 70000
     * }
     */
    public static int __BRIDGEOS_7_0() {
        return __BRIDGEOS_7_0;
    }
    private static final int __BRIDGEOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_1 70100
     * }
     */
    public static int __BRIDGEOS_7_1() {
        return __BRIDGEOS_7_1;
    }
    private static final int __BRIDGEOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_2 70200
     * }
     */
    public static int __BRIDGEOS_7_2() {
        return __BRIDGEOS_7_2;
    }
    private static final int __BRIDGEOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_3 70300
     * }
     */
    public static int __BRIDGEOS_7_3() {
        return __BRIDGEOS_7_3;
    }
    private static final int __BRIDGEOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_4 70400
     * }
     */
    public static int __BRIDGEOS_7_4() {
        return __BRIDGEOS_7_4;
    }
    private static final int __BRIDGEOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_6 70600
     * }
     */
    public static int __BRIDGEOS_7_6() {
        return __BRIDGEOS_7_6;
    }
    private static final int __BRIDGEOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_0 80000
     * }
     */
    public static int __BRIDGEOS_8_0() {
        return __BRIDGEOS_8_0;
    }
    private static final int __BRIDGEOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_1 80100
     * }
     */
    public static int __BRIDGEOS_8_1() {
        return __BRIDGEOS_8_1;
    }
    private static final int __BRIDGEOS_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_2 80200
     * }
     */
    public static int __BRIDGEOS_8_2() {
        return __BRIDGEOS_8_2;
    }
    private static final int __DRIVERKIT_19_0 = (int)190000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_19_0 190000
     * }
     */
    public static int __DRIVERKIT_19_0() {
        return __DRIVERKIT_19_0;
    }
    private static final int __DRIVERKIT_20_0 = (int)200000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_20_0 200000
     * }
     */
    public static int __DRIVERKIT_20_0() {
        return __DRIVERKIT_20_0;
    }
    private static final int __DRIVERKIT_21_0 = (int)210000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_21_0 210000
     * }
     */
    public static int __DRIVERKIT_21_0() {
        return __DRIVERKIT_21_0;
    }
    private static final int __DRIVERKIT_22_0 = (int)220000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_0 220000
     * }
     */
    public static int __DRIVERKIT_22_0() {
        return __DRIVERKIT_22_0;
    }
    private static final int __DRIVERKIT_22_4 = (int)220400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_4 220400
     * }
     */
    public static int __DRIVERKIT_22_4() {
        return __DRIVERKIT_22_4;
    }
    private static final int __DRIVERKIT_22_5 = (int)220500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_5 220500
     * }
     */
    public static int __DRIVERKIT_22_5() {
        return __DRIVERKIT_22_5;
    }
    private static final int __DRIVERKIT_22_6 = (int)220600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_6 220600
     * }
     */
    public static int __DRIVERKIT_22_6() {
        return __DRIVERKIT_22_6;
    }
    private static final int __DRIVERKIT_23_0 = (int)230000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_0 230000
     * }
     */
    public static int __DRIVERKIT_23_0() {
        return __DRIVERKIT_23_0;
    }
    private static final int __DRIVERKIT_23_1 = (int)230100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_1 230100
     * }
     */
    public static int __DRIVERKIT_23_1() {
        return __DRIVERKIT_23_1;
    }
    private static final int __DRIVERKIT_23_2 = (int)230200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_2 230200
     * }
     */
    public static int __DRIVERKIT_23_2() {
        return __DRIVERKIT_23_2;
    }
    private static final int __VISIONOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_0 10000
     * }
     */
    public static int __VISIONOS_1_0() {
        return __VISIONOS_1_0;
    }
    private static final int __ENABLE_LEGACY_MAC_AVAILABILITY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ENABLE_LEGACY_MAC_AVAILABILITY 1
     * }
     */
    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {
        return __ENABLE_LEGACY_MAC_AVAILABILITY;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int _FORTIFY_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FORTIFY_SOURCE 2
     * }
     */
    public static int _FORTIFY_SOURCE() {
        return _FORTIFY_SOURCE;
    }
    private static final int __DARWIN_NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NSIG 32
     * }
     */
    public static int __DARWIN_NSIG() {
        return __DARWIN_NSIG;
    }
    private static final int _ARM_SIGNAL_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_SIGNAL_ 1
     * }
     */
    public static int _ARM_SIGNAL_() {
        return _ARM_SIGNAL_;
    }
    private static final int SIGHUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGHUP 1
     * }
     */
    public static int SIGHUP() {
        return SIGHUP;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGQUIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGQUIT 3
     * }
     */
    public static int SIGQUIT() {
        return SIGQUIT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGTRAP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SIGTRAP 5
     * }
     */
    public static int SIGTRAP() {
        return SIGTRAP;
    }
    private static final int SIGABRT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 6
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGEMT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SIGEMT 7
     * }
     */
    public static int SIGEMT() {
        return SIGEMT;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGKILL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SIGKILL 9
     * }
     */
    public static int SIGKILL() {
        return SIGKILL;
    }
    private static final int SIGBUS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SIGBUS 10
     * }
     */
    public static int SIGBUS() {
        return SIGBUS;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGSYS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SIGSYS 12
     * }
     */
    public static int SIGSYS() {
        return SIGSYS;
    }
    private static final int SIGPIPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SIGPIPE 13
     * }
     */
    public static int SIGPIPE() {
        return SIGPIPE;
    }
    private static final int SIGALRM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SIGALRM 14
     * }
     */
    public static int SIGALRM() {
        return SIGALRM;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGURG = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SIGURG 16
     * }
     */
    public static int SIGURG() {
        return SIGURG;
    }
    private static final int SIGSTOP = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGSTOP 17
     * }
     */
    public static int SIGSTOP() {
        return SIGSTOP;
    }
    private static final int SIGTSTP = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SIGTSTP 18
     * }
     */
    public static int SIGTSTP() {
        return SIGTSTP;
    }
    private static final int SIGCONT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SIGCONT 19
     * }
     */
    public static int SIGCONT() {
        return SIGCONT;
    }
    private static final int SIGCHLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SIGCHLD 20
     * }
     */
    public static int SIGCHLD() {
        return SIGCHLD;
    }
    private static final int SIGTTIN = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGTTIN 21
     * }
     */
    public static int SIGTTIN() {
        return SIGTTIN;
    }
    private static final int SIGTTOU = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGTTOU 22
     * }
     */
    public static int SIGTTOU() {
        return SIGTTOU;
    }
    private static final int SIGIO = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 23
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGXCPU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SIGXCPU 24
     * }
     */
    public static int SIGXCPU() {
        return SIGXCPU;
    }
    private static final int SIGXFSZ = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SIGXFSZ 25
     * }
     */
    public static int SIGXFSZ() {
        return SIGXFSZ;
    }
    private static final int SIGVTALRM = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SIGVTALRM 26
     * }
     */
    public static int SIGVTALRM() {
        return SIGVTALRM;
    }
    private static final int SIGPROF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SIGPROF 27
     * }
     */
    public static int SIGPROF() {
        return SIGPROF;
    }
    private static final int SIGWINCH = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SIGWINCH 28
     * }
     */
    public static int SIGWINCH() {
        return SIGWINCH;
    }
    private static final int SIGINFO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGINFO 29
     * }
     */
    public static int SIGINFO() {
        return SIGINFO;
    }
    private static final int SIGUSR1 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR1 30
     * }
     */
    public static int SIGUSR1() {
        return SIGUSR1;
    }
    private static final int SIGUSR2 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR2 31
     * }
     */
    public static int SIGUSR2() {
        return SIGUSR2;
    }
    private static final int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
     * }
     */
    public static int __DARWIN_OPAQUE_ARM_THREAD_STATE64() {
        return __DARWIN_OPAQUE_ARM_THREAD_STATE64;
    }
    private static final int SIGEV_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_NONE 0
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_SIGNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_SIGNAL 1
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_THREAD 3
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int ILL_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ILL_NOOP 0
     * }
     */
    public static int ILL_NOOP() {
        return ILL_NOOP;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPC 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLTRP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLTRP 2
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVOPC 3
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_ILLOPN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPN 4
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLADR 5
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVREG 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ILL_COPROC 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ILL_BADSTK 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int FPE_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FPE_NOOP 0
     * }
     */
    public static int FPE_NOOP() {
        return FPE_NOOP;
    }
    private static final int FPE_FLTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTDIV 1
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTOVF 2
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTUND 3
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTRES 4
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTINV 5
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTSUB 6
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_INTDIV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTDIV 7
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTOVF 8
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int SEGV_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEGV_NOOP 0
     * }
     */
    public static int SEGV_NOOP() {
        return SEGV_NOOP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEGV_MAPERR 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEGV_ACCERR 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int BUS_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define BUS_NOOP 0
     * }
     */
    public static int BUS_NOOP() {
        return BUS_NOOP;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRALN 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRERR 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define BUS_OBJERR 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int TRAP_BRKPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRAP_BRKPT 1
     * }
     */
    public static int TRAP_BRKPT() {
        return TRAP_BRKPT;
    }
    private static final int TRAP_TRACE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRAP_TRACE 2
     * }
     */
    public static int TRAP_TRACE() {
        return TRAP_TRACE;
    }
    private static final int CLD_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLD_NOOP 0
     * }
     */
    public static int CLD_NOOP() {
        return CLD_NOOP;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLD_EXITED 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLD_KILLED 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLD_DUMPED 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLD_TRAPPED 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLD_STOPPED 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLD_CONTINUED 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLL_IN 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLL_OUT 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define POLL_MSG 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLL_ERR 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLL_PRI 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLL_HUP 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SA_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SA_ONSTACK 1
     * }
     */
    public static int SA_ONSTACK() {
        return SA_ONSTACK;
    }
    private static final int SA_RESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SA_RESTART 2
     * }
     */
    public static int SA_RESTART() {
        return SA_RESTART;
    }
    private static final int SA_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 4
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDSTOP 8
     * }
     */
    public static int SA_NOCLDSTOP() {
        return SA_NOCLDSTOP;
    }
    private static final int SA_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SA_NODEFER 16
     * }
     */
    public static int SA_NODEFER() {
        return SA_NODEFER;
    }
    private static final int SA_NOCLDWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDWAIT 32
     * }
     */
    public static int SA_NOCLDWAIT() {
        return SA_NOCLDWAIT;
    }
    private static final int SA_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SA_SIGINFO 64
     * }
     */
    public static int SA_SIGINFO() {
        return SA_SIGINFO;
    }
    private static final int SA_USERTRAMP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SA_USERTRAMP 256
     * }
     */
    public static int SA_USERTRAMP() {
        return SA_USERTRAMP;
    }
    private static final int SA_64REGSET = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SA_64REGSET 512
     * }
     */
    public static int SA_64REGSET() {
        return SA_64REGSET;
    }
    private static final int SIG_BLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIG_BLOCK 1
     * }
     */
    public static int SIG_BLOCK() {
        return SIG_BLOCK;
    }
    private static final int SIG_UNBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIG_UNBLOCK 2
     * }
     */
    public static int SIG_UNBLOCK() {
        return SIG_UNBLOCK;
    }
    private static final int SIG_SETMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIG_SETMASK 3
     * }
     */
    public static int SIG_SETMASK() {
        return SIG_SETMASK;
    }
    private static final int SI_USER = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define SI_USER 65537
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_QUEUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define SI_QUEUE 65538
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_TIMER = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define SI_TIMER 65539
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_ASYNCIO = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define SI_ASYNCIO 65540
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)65541L;
    /**
     * {@snippet lang=c :
     * #define SI_MESGQ 65541
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SS_ONSTACK 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SS_DISABLE 4
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }
    private static final int MINSIGSTKSZ = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MINSIGSTKSZ 32768
     * }
     */
    public static int MINSIGSTKSZ() {
        return MINSIGSTKSZ;
    }
    private static final int SIGSTKSZ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SIGSTKSZ 131072
     * }
     */
    public static int SIGSTKSZ() {
        return SIGSTKSZ;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int PRIO_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PROCESS 0
     * }
     */
    public static int PRIO_PROCESS() {
        return PRIO_PROCESS;
    }
    private static final int PRIO_PGRP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PGRP 1
     * }
     */
    public static int PRIO_PGRP() {
        return PRIO_PGRP;
    }
    private static final int PRIO_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PRIO_USER 2
     * }
     */
    public static int PRIO_USER() {
        return PRIO_USER;
    }
    private static final int PRIO_DARWIN_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_THREAD 3
     * }
     */
    public static int PRIO_DARWIN_THREAD() {
        return PRIO_DARWIN_THREAD;
    }
    private static final int PRIO_DARWIN_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_PROCESS 4
     * }
     */
    public static int PRIO_DARWIN_PROCESS() {
        return PRIO_DARWIN_PROCESS;
    }
    private static final int PRIO_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MAX 20
     * }
     */
    public static int PRIO_MAX() {
        return PRIO_MAX;
    }
    private static final int PRIO_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_BG 4096
     * }
     */
    public static int PRIO_DARWIN_BG() {
        return PRIO_DARWIN_BG;
    }
    private static final int PRIO_DARWIN_NONUI = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_NONUI 4097
     * }
     */
    public static int PRIO_DARWIN_NONUI() {
        return PRIO_DARWIN_NONUI;
    }
    private static final int RUSAGE_SELF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_SELF 0
     * }
     */
    public static int RUSAGE_SELF() {
        return RUSAGE_SELF;
    }
    private static final int RUSAGE_INFO_V0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V0 0
     * }
     */
    public static int RUSAGE_INFO_V0() {
        return RUSAGE_INFO_V0;
    }
    private static final int RUSAGE_INFO_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V1 1
     * }
     */
    public static int RUSAGE_INFO_V1() {
        return RUSAGE_INFO_V1;
    }
    private static final int RUSAGE_INFO_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V2 2
     * }
     */
    public static int RUSAGE_INFO_V2() {
        return RUSAGE_INFO_V2;
    }
    private static final int RUSAGE_INFO_V3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V3 3
     * }
     */
    public static int RUSAGE_INFO_V3() {
        return RUSAGE_INFO_V3;
    }
    private static final int RUSAGE_INFO_V4 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V4 4
     * }
     */
    public static int RUSAGE_INFO_V4() {
        return RUSAGE_INFO_V4;
    }
    private static final int RUSAGE_INFO_V5 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V5 5
     * }
     */
    public static int RUSAGE_INFO_V5() {
        return RUSAGE_INFO_V5;
    }
    private static final int RUSAGE_INFO_V6 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V6 6
     * }
     */
    public static int RUSAGE_INFO_V6() {
        return RUSAGE_INFO_V6;
    }
    private static final int RU_PROC_RUNS_RESLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RU_PROC_RUNS_RESLIDE 1
     * }
     */
    public static int RU_PROC_RUNS_RESLIDE() {
        return RU_PROC_RUNS_RESLIDE;
    }
    private static final int RLIMIT_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU 0
     * }
     */
    public static int RLIMIT_CPU() {
        return RLIMIT_CPU;
    }
    private static final int RLIMIT_FSIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FSIZE 1
     * }
     */
    public static int RLIMIT_FSIZE() {
        return RLIMIT_FSIZE;
    }
    private static final int RLIMIT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_DATA 2
     * }
     */
    public static int RLIMIT_DATA() {
        return RLIMIT_DATA;
    }
    private static final int RLIMIT_STACK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_STACK 3
     * }
     */
    public static int RLIMIT_STACK() {
        return RLIMIT_STACK;
    }
    private static final int RLIMIT_CORE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CORE 4
     * }
     */
    public static int RLIMIT_CORE() {
        return RLIMIT_CORE;
    }
    private static final int RLIMIT_AS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_AS 5
     * }
     */
    public static int RLIMIT_AS() {
        return RLIMIT_AS;
    }
    private static final int RLIMIT_MEMLOCK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_MEMLOCK 6
     * }
     */
    public static int RLIMIT_MEMLOCK() {
        return RLIMIT_MEMLOCK;
    }
    private static final int RLIMIT_NPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NPROC 7
     * }
     */
    public static int RLIMIT_NPROC() {
        return RLIMIT_NPROC;
    }
    private static final int RLIMIT_NOFILE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NOFILE 8
     * }
     */
    public static int RLIMIT_NOFILE() {
        return RLIMIT_NOFILE;
    }
    private static final int RLIM_NLIMITS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define RLIM_NLIMITS 9
     * }
     */
    public static int RLIM_NLIMITS() {
        return RLIM_NLIMITS;
    }
    private static final int _RLIMIT_POSIX_FLAG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _RLIMIT_POSIX_FLAG 4096
     * }
     */
    public static int _RLIMIT_POSIX_FLAG() {
        return _RLIMIT_POSIX_FLAG;
    }
    private static final int RLIMIT_WAKEUPS_MONITOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_WAKEUPS_MONITOR 1
     * }
     */
    public static int RLIMIT_WAKEUPS_MONITOR() {
        return RLIMIT_WAKEUPS_MONITOR;
    }
    private static final int RLIMIT_CPU_USAGE_MONITOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU_USAGE_MONITOR 2
     * }
     */
    public static int RLIMIT_CPU_USAGE_MONITOR() {
        return RLIMIT_CPU_USAGE_MONITOR;
    }
    private static final int RLIMIT_THREAD_CPULIMITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_THREAD_CPULIMITS 3
     * }
     */
    public static int RLIMIT_THREAD_CPULIMITS() {
        return RLIMIT_THREAD_CPULIMITS;
    }
    private static final int RLIMIT_FOOTPRINT_INTERVAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FOOTPRINT_INTERVAL 4
     * }
     */
    public static int RLIMIT_FOOTPRINT_INTERVAL() {
        return RLIMIT_FOOTPRINT_INTERVAL;
    }
    private static final int WAKEMON_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_ENABLE 1
     * }
     */
    public static int WAKEMON_ENABLE() {
        return WAKEMON_ENABLE;
    }
    private static final int WAKEMON_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_DISABLE 2
     * }
     */
    public static int WAKEMON_DISABLE() {
        return WAKEMON_DISABLE;
    }
    private static final int WAKEMON_GET_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_GET_PARAMS 4
     * }
     */
    public static int WAKEMON_GET_PARAMS() {
        return WAKEMON_GET_PARAMS;
    }
    private static final int WAKEMON_SET_DEFAULTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_SET_DEFAULTS 8
     * }
     */
    public static int WAKEMON_SET_DEFAULTS() {
        return WAKEMON_SET_DEFAULTS;
    }
    private static final int WAKEMON_MAKE_FATAL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_MAKE_FATAL 16
     * }
     */
    public static int WAKEMON_MAKE_FATAL() {
        return WAKEMON_MAKE_FATAL;
    }
    private static final int CPUMON_MAKE_FATAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CPUMON_MAKE_FATAL 4096
     * }
     */
    public static int CPUMON_MAKE_FATAL() {
        return CPUMON_MAKE_FATAL;
    }
    private static final int FOOTPRINT_INTERVAL_RESET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FOOTPRINT_INTERVAL_RESET 1
     * }
     */
    public static int FOOTPRINT_INTERVAL_RESET() {
        return FOOTPRINT_INTERVAL_RESET;
    }
    private static final int IOPOL_TYPE_DISK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_DISK 0
     * }
     */
    public static int IOPOL_TYPE_DISK() {
        return IOPOL_TYPE_DISK;
    }
    private static final int IOPOL_TYPE_VFS_ATIME_UPDATES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ATIME_UPDATES 2
     * }
     */
    public static int IOPOL_TYPE_VFS_ATIME_UPDATES() {
        return IOPOL_TYPE_VFS_ATIME_UPDATES;
    }
    private static final int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
     * }
     */
    public static int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES() {
        return IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES;
    }
    private static final int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
     * }
     */
    public static int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME() {
        return IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME;
    }
    private static final int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
     * }
     */
    public static int IOPOL_TYPE_VFS_TRIGGER_RESOLVE() {
        return IOPOL_TYPE_VFS_TRIGGER_RESOLVE;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION() {
        return IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS() {
        return IOPOL_TYPE_VFS_IGNORE_PERMISSIONS;
    }
    private static final int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
     * }
     */
    public static int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE() {
        return IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE;
    }
    private static final int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
     * }
     */
    public static int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES() {
        return IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES;
    }
    private static final int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
     * }
     */
    public static int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY() {
        return IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY;
    }
    private static final int IOPOL_SCOPE_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_PROCESS 0
     * }
     */
    public static int IOPOL_SCOPE_PROCESS() {
        return IOPOL_SCOPE_PROCESS;
    }
    private static final int IOPOL_SCOPE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_THREAD 1
     * }
     */
    public static int IOPOL_SCOPE_THREAD() {
        return IOPOL_SCOPE_THREAD;
    }
    private static final int IOPOL_SCOPE_DARWIN_BG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_DARWIN_BG 2
     * }
     */
    public static int IOPOL_SCOPE_DARWIN_BG() {
        return IOPOL_SCOPE_DARWIN_BG;
    }
    private static final int IOPOL_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_DEFAULT 0
     * }
     */
    public static int IOPOL_DEFAULT() {
        return IOPOL_DEFAULT;
    }
    private static final int IOPOL_IMPORTANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_IMPORTANT 1
     * }
     */
    public static int IOPOL_IMPORTANT() {
        return IOPOL_IMPORTANT;
    }
    private static final int IOPOL_PASSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_PASSIVE 2
     * }
     */
    public static int IOPOL_PASSIVE() {
        return IOPOL_PASSIVE;
    }
    private static final int IOPOL_THROTTLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_THROTTLE 3
     * }
     */
    public static int IOPOL_THROTTLE() {
        return IOPOL_THROTTLE;
    }
    private static final int IOPOL_UTILITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_UTILITY 4
     * }
     */
    public static int IOPOL_UTILITY() {
        return IOPOL_UTILITY;
    }
    private static final int IOPOL_STANDARD = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_STANDARD 5
     * }
     */
    public static int IOPOL_STANDARD() {
        return IOPOL_STANDARD;
    }
    private static final int IOPOL_ATIME_UPDATES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_DEFAULT 0
     * }
     */
    public static int IOPOL_ATIME_UPDATES_DEFAULT() {
        return IOPOL_ATIME_UPDATES_DEFAULT;
    }
    private static final int IOPOL_ATIME_UPDATES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_OFF 1
     * }
     */
    public static int IOPOL_ATIME_UPDATES_OFF() {
        return IOPOL_ATIME_UPDATES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_OFF() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_ON() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_ON;
    }
    private static final int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT() {
        return IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT;
    }
    private static final int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
     * }
     */
    public static int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME() {
        return IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT() {
        return IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_OFF() {
        return IOPOL_VFS_TRIGGER_RESOLVE_OFF;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT() {
        return IOPOL_VFS_CONTENT_PROTECTION_DEFAULT;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_IGNORE() {
        return IOPOL_VFS_CONTENT_PROTECTION_IGNORE;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_OFF() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_OFF;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_ON() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_OFF;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_ON() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_ON;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int _WSTOPPED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _WSTOPPED 127
     * }
     */
    public static int _WSTOPPED() {
        return _WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WSTOPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 8
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WCONTINUED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 16
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 32
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int WAIT_MYPGRP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_MYPGRP 0
     * }
     */
    public static int WAIT_MYPGRP() {
        return WAIT_MYPGRP;
    }
    private static final int _QUAD_HIGHWORD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_HIGHWORD 1
     * }
     */
    public static int _QUAD_HIGHWORD() {
        return _QUAD_HIGHWORD;
    }
    private static final int _QUAD_LOWWORD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_LOWWORD 0
     * }
     */
    public static int _QUAD_LOWWORD() {
        return _QUAD_LOWWORD;
    }
    private static final int __DARWIN_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_LITTLE_ENDIAN 1234
     * }
     */
    public static int __DARWIN_LITTLE_ENDIAN() {
        return __DARWIN_LITTLE_ENDIAN;
    }
    private static final int __DARWIN_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BIG_ENDIAN 4321
     * }
     */
    public static int __DARWIN_BIG_ENDIAN() {
        return __DARWIN_BIG_ENDIAN;
    }
    private static final int __DARWIN_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_PDP_ENDIAN 3412
     * }
     */
    public static int __DARWIN_PDP_ENDIAN() {
        return __DARWIN_PDP_ENDIAN;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int __alignas_is_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __alignas_is_defined 1
     * }
     */
    public static int __alignas_is_defined() {
        return __alignas_is_defined;
    }
    private static final int __alignof_is_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __alignof_is_defined 1
     * }
     */
    public static int __alignof_is_defined() {
        return __alignof_is_defined;
    }
    private static final int FLT_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FLT_HAS_SUBNORM 1
     * }
     */
    public static int FLT_HAS_SUBNORM() {
        return FLT_HAS_SUBNORM;
    }
    private static final int DBL_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DBL_HAS_SUBNORM 1
     * }
     */
    public static int DBL_HAS_SUBNORM() {
        return DBL_HAS_SUBNORM;
    }
    private static final int LDBL_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LDBL_HAS_SUBNORM 1
     * }
     */
    public static int LDBL_HAS_SUBNORM() {
        return LDBL_HAS_SUBNORM;
    }
    private static final int JPC_ENABLE_ASSERTS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define JPC_ENABLE_ASSERTS 0
     * }
     */
    public static int JPC_ENABLE_ASSERTS() {
        return JPC_ENABLE_ASSERTS;
    }
    private static final int JPC_DOUBLE_PRECISION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define JPC_DOUBLE_PRECISION 0
     * }
     */
    public static int JPC_DOUBLE_PRECISION() {
        return JPC_DOUBLE_PRECISION;
    }
    private static final int JPC_DEBUG_RENDERER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define JPC_DEBUG_RENDERER 0
     * }
     */
    public static int JPC_DEBUG_RENDERER() {
        return JPC_DEBUG_RENDERER;
    }
    private static final int JPC_BODY_ID_INDEX_BITS = (int)8388607L;
    /**
     * {@snippet lang=c :
     * #define JPC_BODY_ID_INDEX_BITS 8388607
     * }
     */
    public static int JPC_BODY_ID_INDEX_BITS() {
        return JPC_BODY_ID_INDEX_BITS;
    }
    private static final int JPC_BODY_ID_SEQUENCE_SHIFT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define JPC_BODY_ID_SEQUENCE_SHIFT 24
     * }
     */
    public static int JPC_BODY_ID_SEQUENCE_SHIFT() {
        return JPC_BODY_ID_SEQUENCE_SHIFT;
    }
    private static final int _JPC_IS_FREED_BODY_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _JPC_IS_FREED_BODY_BIT 1
     * }
     */
    public static int _JPC_IS_FREED_BODY_BIT() {
        return _JPC_IS_FREED_BODY_BIT;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = jolt.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = jolt.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = jolt.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = jolt.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = jolt.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = jolt.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = jolt.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = jolt.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = jolt.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = jolt.C_INT;
        public static final MemorySegment SEGMENT = jolt.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = jolt.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_DOUBLE,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            jolt.C_LONG,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            jolt.C_LONG_LONG,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT    );

        public static final MemorySegment ADDR = jolt.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_DOUBLE,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_DOUBLE    );

        public static final MemorySegment ADDR = jolt.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_DOUBLE,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_DOUBLE,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_DOUBLE,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_DOUBLE,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG    );

        public static final MemorySegment ADDR = jolt.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG    );

        public static final MemorySegment ADDR = jolt.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG    );

        public static final MemorySegment ADDR = jolt.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = jolt.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT    );

        public static final MemorySegment ADDR = jolt.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT    );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_SHORT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_SHORT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER    );

        public static final MemorySegment ADDR = jolt.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG,
            jolt.C_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER,
            jolt.C_LONG_LONG,
            jolt.C_LONG_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = jolt.C_POINTER;
        public static final MemorySegment SEGMENT = jolt.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef float JPC_Real
     * }
     */
    public static final OfFloat JPC_Real = jolt.C_FLOAT;
    private static final int JPC_MAX_PHYSICS_JOBS = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MAX_PHYSICS_JOBS = 2048
     * }
     */
    public static int JPC_MAX_PHYSICS_JOBS() {
        return JPC_MAX_PHYSICS_JOBS;
    }
    private static final int JPC_MAX_PHYSICS_BARRIERS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MAX_PHYSICS_BARRIERS = 8
     * }
     */
    public static int JPC_MAX_PHYSICS_BARRIERS() {
        return JPC_MAX_PHYSICS_BARRIERS;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_PhysicsUpdateError
     * }
     */
    public static final OfByte JPC_PhysicsUpdateError = jolt.C_CHAR;
    private static final int JPC_PHYSICS_UPDATE_NO_ERROR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_PHYSICS_UPDATE_NO_ERROR = 0
     * }
     */
    public static int JPC_PHYSICS_UPDATE_NO_ERROR() {
        return JPC_PHYSICS_UPDATE_NO_ERROR;
    }
    private static final int JPC_PHYSICS_UPDATE_MANIFOLD_CACHE_FULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_PHYSICS_UPDATE_MANIFOLD_CACHE_FULL = 1
     * }
     */
    public static int JPC_PHYSICS_UPDATE_MANIFOLD_CACHE_FULL() {
        return JPC_PHYSICS_UPDATE_MANIFOLD_CACHE_FULL;
    }
    private static final int JPC_PHYSICS_UPDATE_BODY_PAIR_CACHE_FULL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_PHYSICS_UPDATE_BODY_PAIR_CACHE_FULL = 2
     * }
     */
    public static int JPC_PHYSICS_UPDATE_BODY_PAIR_CACHE_FULL() {
        return JPC_PHYSICS_UPDATE_BODY_PAIR_CACHE_FULL;
    }
    private static final int JPC_PHYSICS_UPDATE_CONTACT_CONSTRAINTS_FULL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_PHYSICS_UPDATE_CONTACT_CONSTRAINTS_FULL = 4
     * }
     */
    public static int JPC_PHYSICS_UPDATE_CONTACT_CONSTRAINTS_FULL() {
        return JPC_PHYSICS_UPDATE_CONTACT_CONSTRAINTS_FULL;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_ShapeType
     * }
     */
    public static final OfByte JPC_ShapeType = jolt.C_CHAR;
    private static final int JPC_SHAPE_TYPE_CONVEX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_CONVEX = 0
     * }
     */
    public static int JPC_SHAPE_TYPE_CONVEX() {
        return JPC_SHAPE_TYPE_CONVEX;
    }
    private static final int JPC_SHAPE_TYPE_COMPOUND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_COMPOUND = 1
     * }
     */
    public static int JPC_SHAPE_TYPE_COMPOUND() {
        return JPC_SHAPE_TYPE_COMPOUND;
    }
    private static final int JPC_SHAPE_TYPE_DECORATED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_DECORATED = 2
     * }
     */
    public static int JPC_SHAPE_TYPE_DECORATED() {
        return JPC_SHAPE_TYPE_DECORATED;
    }
    private static final int JPC_SHAPE_TYPE_MESH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_MESH = 3
     * }
     */
    public static int JPC_SHAPE_TYPE_MESH() {
        return JPC_SHAPE_TYPE_MESH;
    }
    private static final int JPC_SHAPE_TYPE_HEIGHT_FIELD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_HEIGHT_FIELD = 4
     * }
     */
    public static int JPC_SHAPE_TYPE_HEIGHT_FIELD() {
        return JPC_SHAPE_TYPE_HEIGHT_FIELD;
    }
    private static final int JPC_SHAPE_TYPE_USER1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_USER1 = 5
     * }
     */
    public static int JPC_SHAPE_TYPE_USER1() {
        return JPC_SHAPE_TYPE_USER1;
    }
    private static final int JPC_SHAPE_TYPE_USER2 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_USER2 = 6
     * }
     */
    public static int JPC_SHAPE_TYPE_USER2() {
        return JPC_SHAPE_TYPE_USER2;
    }
    private static final int JPC_SHAPE_TYPE_USER3 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_USER3 = 7
     * }
     */
    public static int JPC_SHAPE_TYPE_USER3() {
        return JPC_SHAPE_TYPE_USER3;
    }
    private static final int JPC_SHAPE_TYPE_USER4 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_TYPE_USER4 = 8
     * }
     */
    public static int JPC_SHAPE_TYPE_USER4() {
        return JPC_SHAPE_TYPE_USER4;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_ShapeSubType
     * }
     */
    public static final OfByte JPC_ShapeSubType = jolt.C_CHAR;
    private static final int JPC_SHAPE_SUB_TYPE_SPHERE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_SPHERE = 0
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_SPHERE() {
        return JPC_SHAPE_SUB_TYPE_SPHERE;
    }
    private static final int JPC_SHAPE_SUB_TYPE_BOX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_BOX = 1
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_BOX() {
        return JPC_SHAPE_SUB_TYPE_BOX;
    }
    private static final int JPC_SHAPE_SUB_TYPE_TRIANGLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_TRIANGLE = 2
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_TRIANGLE() {
        return JPC_SHAPE_SUB_TYPE_TRIANGLE;
    }
    private static final int JPC_SHAPE_SUB_TYPE_CAPSULE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_CAPSULE = 3
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_CAPSULE() {
        return JPC_SHAPE_SUB_TYPE_CAPSULE;
    }
    private static final int JPC_SHAPE_SUB_TYPE_TAPERED_CAPSULE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_TAPERED_CAPSULE = 4
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_TAPERED_CAPSULE() {
        return JPC_SHAPE_SUB_TYPE_TAPERED_CAPSULE;
    }
    private static final int JPC_SHAPE_SUB_TYPE_CYLINDER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_CYLINDER = 5
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_CYLINDER() {
        return JPC_SHAPE_SUB_TYPE_CYLINDER;
    }
    private static final int JPC_SHAPE_SUB_TYPE_CONVEX_HULL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_CONVEX_HULL = 6
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_CONVEX_HULL() {
        return JPC_SHAPE_SUB_TYPE_CONVEX_HULL;
    }
    private static final int JPC_SHAPE_SUB_TYPE_STATIC_COMPOUND = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_STATIC_COMPOUND = 7
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_STATIC_COMPOUND() {
        return JPC_SHAPE_SUB_TYPE_STATIC_COMPOUND;
    }
    private static final int JPC_SHAPE_SUB_TYPE_MUTABLE_COMPOUND = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_MUTABLE_COMPOUND = 8
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_MUTABLE_COMPOUND() {
        return JPC_SHAPE_SUB_TYPE_MUTABLE_COMPOUND;
    }
    private static final int JPC_SHAPE_SUB_TYPE_ROTATED_TRANSLATED = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_ROTATED_TRANSLATED = 9
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_ROTATED_TRANSLATED() {
        return JPC_SHAPE_SUB_TYPE_ROTATED_TRANSLATED;
    }
    private static final int JPC_SHAPE_SUB_TYPE_SCALED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_SCALED = 10
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_SCALED() {
        return JPC_SHAPE_SUB_TYPE_SCALED;
    }
    private static final int JPC_SHAPE_SUB_TYPE_OFFSET_CENTER_OF_MASS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_OFFSET_CENTER_OF_MASS = 11
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_OFFSET_CENTER_OF_MASS() {
        return JPC_SHAPE_SUB_TYPE_OFFSET_CENTER_OF_MASS;
    }
    private static final int JPC_SHAPE_SUB_TYPE_MESH = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_MESH = 12
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_MESH() {
        return JPC_SHAPE_SUB_TYPE_MESH;
    }
    private static final int JPC_SHAPE_SUB_TYPE_HEIGHT_FIELD = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_HEIGHT_FIELD = 13
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_HEIGHT_FIELD() {
        return JPC_SHAPE_SUB_TYPE_HEIGHT_FIELD;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER1 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER1 = 14
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER1() {
        return JPC_SHAPE_SUB_TYPE_USER1;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER2 = 15
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER2() {
        return JPC_SHAPE_SUB_TYPE_USER2;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER3 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER3 = 16
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER3() {
        return JPC_SHAPE_SUB_TYPE_USER3;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER4 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER4 = 17
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER4() {
        return JPC_SHAPE_SUB_TYPE_USER4;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER5 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER5 = 18
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER5() {
        return JPC_SHAPE_SUB_TYPE_USER5;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER6 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER6 = 19
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER6() {
        return JPC_SHAPE_SUB_TYPE_USER6;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER7 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER7 = 20
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER7() {
        return JPC_SHAPE_SUB_TYPE_USER7;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER8 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER8 = 21
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER8() {
        return JPC_SHAPE_SUB_TYPE_USER8;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX1 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX1 = 22
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX1() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX1;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX2 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX2 = 23
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX2() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX2;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX3 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX3 = 24
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX3() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX3;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX4 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX4 = 25
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX4() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX4;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX5 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX5 = 26
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX5() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX5;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX6 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX6 = 27
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX6() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX6;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX7 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX7 = 28
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX7() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX7;
    }
    private static final int JPC_SHAPE_SUB_TYPE_USER_CONVEX8 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_SHAPE_SUB_TYPE_USER_CONVEX8 = 29
     * }
     */
    public static int JPC_SHAPE_SUB_TYPE_USER_CONVEX8() {
        return JPC_SHAPE_SUB_TYPE_USER_CONVEX8;
    }
    private static final int JPC_CONSTRAINT_TYPE_CONSTRAINT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintType.JPC_CONSTRAINT_TYPE_CONSTRAINT = 0
     * }
     */
    public static int JPC_CONSTRAINT_TYPE_CONSTRAINT() {
        return JPC_CONSTRAINT_TYPE_CONSTRAINT;
    }
    private static final int JPC_CONSTRAINT_TYPE_TWO_BODY_CONSTRAINT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintType.JPC_CONSTRAINT_TYPE_TWO_BODY_CONSTRAINT = 1
     * }
     */
    public static int JPC_CONSTRAINT_TYPE_TWO_BODY_CONSTRAINT() {
        return JPC_CONSTRAINT_TYPE_TWO_BODY_CONSTRAINT;
    }
    private static final int _JPC_CONSTRAINT_TYPE_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintType._JPC_CONSTRAINT_TYPE_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_CONSTRAINT_TYPE_FORCEU32() {
        return _JPC_CONSTRAINT_TYPE_FORCEU32;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_FIXED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_FIXED = 0
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_FIXED() {
        return JPC_CONSTRAINT_SUB_TYPE_FIXED;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_POINT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_POINT = 1
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_POINT() {
        return JPC_CONSTRAINT_SUB_TYPE_POINT;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_HINGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_HINGE = 2
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_HINGE() {
        return JPC_CONSTRAINT_SUB_TYPE_HINGE;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_SLIDER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_SLIDER = 3
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_SLIDER() {
        return JPC_CONSTRAINT_SUB_TYPE_SLIDER;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_DISTANCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_DISTANCE = 4
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_DISTANCE() {
        return JPC_CONSTRAINT_SUB_TYPE_DISTANCE;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_CONE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_CONE = 5
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_CONE() {
        return JPC_CONSTRAINT_SUB_TYPE_CONE;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_SWING_TWIST = (int)6L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_SWING_TWIST = 6
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_SWING_TWIST() {
        return JPC_CONSTRAINT_SUB_TYPE_SWING_TWIST;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_SIX_DOF = (int)7L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_SIX_DOF = 7
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_SIX_DOF() {
        return JPC_CONSTRAINT_SUB_TYPE_SIX_DOF;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_PATH = (int)8L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_PATH = 8
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_PATH() {
        return JPC_CONSTRAINT_SUB_TYPE_PATH;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_VEHICLE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_VEHICLE = 9
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_VEHICLE() {
        return JPC_CONSTRAINT_SUB_TYPE_VEHICLE;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_RACK_AND_PINION = (int)10L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_RACK_AND_PINION = 10
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_RACK_AND_PINION() {
        return JPC_CONSTRAINT_SUB_TYPE_RACK_AND_PINION;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_GEAR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_GEAR = 11
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_GEAR() {
        return JPC_CONSTRAINT_SUB_TYPE_GEAR;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_PULLEY = (int)12L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_PULLEY = 12
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_PULLEY() {
        return JPC_CONSTRAINT_SUB_TYPE_PULLEY;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_USER1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_USER1 = 13
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_USER1() {
        return JPC_CONSTRAINT_SUB_TYPE_USER1;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_USER2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_USER2 = 14
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_USER2() {
        return JPC_CONSTRAINT_SUB_TYPE_USER2;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_USER3 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_USER3 = 15
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_USER3() {
        return JPC_CONSTRAINT_SUB_TYPE_USER3;
    }
    private static final int JPC_CONSTRAINT_SUB_TYPE_USER4 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType.JPC_CONSTRAINT_SUB_TYPE_USER4 = 16
     * }
     */
    public static int JPC_CONSTRAINT_SUB_TYPE_USER4() {
        return JPC_CONSTRAINT_SUB_TYPE_USER4;
    }
    private static final int _JPC_CONSTRAINT_SUB_TYPE_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSubType._JPC_CONSTRAINT_SUB_TYPE_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_CONSTRAINT_SUB_TYPE_FORCEU32() {
        return _JPC_CONSTRAINT_SUB_TYPE_FORCEU32;
    }
    private static final int JPC_CONSTRAINT_SPACE_LOCAL_TO_BODY_COM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSpace.JPC_CONSTRAINT_SPACE_LOCAL_TO_BODY_COM = 0
     * }
     */
    public static int JPC_CONSTRAINT_SPACE_LOCAL_TO_BODY_COM() {
        return JPC_CONSTRAINT_SPACE_LOCAL_TO_BODY_COM;
    }
    private static final int JPC_CONSTRAINT_SPACE_WORLD_SPACE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSpace.JPC_CONSTRAINT_SPACE_WORLD_SPACE = 1
     * }
     */
    public static int JPC_CONSTRAINT_SPACE_WORLD_SPACE() {
        return JPC_CONSTRAINT_SPACE_WORLD_SPACE;
    }
    private static final int _JPC_CONSTRAINT_SPACE_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_ConstraintSpace._JPC_CONSTRAINT_SPACE_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_CONSTRAINT_SPACE_FORCEU32() {
        return _JPC_CONSTRAINT_SPACE_FORCEU32;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_MotionType
     * }
     */
    public static final OfByte JPC_MotionType = jolt.C_CHAR;
    private static final int JPC_MOTION_TYPE_STATIC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MOTION_TYPE_STATIC = 0
     * }
     */
    public static int JPC_MOTION_TYPE_STATIC() {
        return JPC_MOTION_TYPE_STATIC;
    }
    private static final int JPC_MOTION_TYPE_KINEMATIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MOTION_TYPE_KINEMATIC = 1
     * }
     */
    public static int JPC_MOTION_TYPE_KINEMATIC() {
        return JPC_MOTION_TYPE_KINEMATIC;
    }
    private static final int JPC_MOTION_TYPE_DYNAMIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MOTION_TYPE_DYNAMIC = 2
     * }
     */
    public static int JPC_MOTION_TYPE_DYNAMIC() {
        return JPC_MOTION_TYPE_DYNAMIC;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_MotionQuality
     * }
     */
    public static final OfByte JPC_MotionQuality = jolt.C_CHAR;
    private static final int JPC_MOTION_QUALITY_DISCRETE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MOTION_QUALITY_DISCRETE = 0
     * }
     */
    public static int JPC_MOTION_QUALITY_DISCRETE() {
        return JPC_MOTION_QUALITY_DISCRETE;
    }
    private static final int JPC_MOTION_QUALITY_LINEAR_CAST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_MOTION_QUALITY_LINEAR_CAST = 1
     * }
     */
    public static int JPC_MOTION_QUALITY_LINEAR_CAST() {
        return JPC_MOTION_QUALITY_LINEAR_CAST;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_OverrideMassProperties
     * }
     */
    public static final OfByte JPC_OverrideMassProperties = jolt.C_CHAR;
    private static final int JPC_OVERRIDE_MASS_PROPS_CALC_MASS_INERTIA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_OVERRIDE_MASS_PROPS_CALC_MASS_INERTIA = 0
     * }
     */
    public static int JPC_OVERRIDE_MASS_PROPS_CALC_MASS_INERTIA() {
        return JPC_OVERRIDE_MASS_PROPS_CALC_MASS_INERTIA;
    }
    private static final int JPC_OVERRIDE_MASS_PROPS_CALC_INERTIA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_OVERRIDE_MASS_PROPS_CALC_INERTIA = 1
     * }
     */
    public static int JPC_OVERRIDE_MASS_PROPS_CALC_INERTIA() {
        return JPC_OVERRIDE_MASS_PROPS_CALC_INERTIA;
    }
    private static final int JPC_OVERRIDE_MASS_PROPS_MASS_INERTIA_PROVIDED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_OVERRIDE_MASS_PROPS_MASS_INERTIA_PROVIDED = 2
     * }
     */
    public static int JPC_OVERRIDE_MASS_PROPS_MASS_INERTIA_PROVIDED() {
        return JPC_OVERRIDE_MASS_PROPS_MASS_INERTIA_PROVIDED;
    }
    private static final int JPC_CHARACTER_GROUND_STATE_ON_GROUND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_CharacterGroundState.JPC_CHARACTER_GROUND_STATE_ON_GROUND = 0
     * }
     */
    public static int JPC_CHARACTER_GROUND_STATE_ON_GROUND() {
        return JPC_CHARACTER_GROUND_STATE_ON_GROUND;
    }
    private static final int JPC_CHARACTER_GROUND_STATE_ON_STEEP_GROUND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_CharacterGroundState.JPC_CHARACTER_GROUND_STATE_ON_STEEP_GROUND = 1
     * }
     */
    public static int JPC_CHARACTER_GROUND_STATE_ON_STEEP_GROUND() {
        return JPC_CHARACTER_GROUND_STATE_ON_STEEP_GROUND;
    }
    private static final int JPC_CHARACTER_GROUND_STATE_NOT_SUPPORTED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JPC_CharacterGroundState.JPC_CHARACTER_GROUND_STATE_NOT_SUPPORTED = 2
     * }
     */
    public static int JPC_CHARACTER_GROUND_STATE_NOT_SUPPORTED() {
        return JPC_CHARACTER_GROUND_STATE_NOT_SUPPORTED;
    }
    private static final int JPC_CHARACTER_GROUND_STATE_IN_AIR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum JPC_CharacterGroundState.JPC_CHARACTER_GROUND_STATE_IN_AIR = 3
     * }
     */
    public static int JPC_CHARACTER_GROUND_STATE_IN_AIR() {
        return JPC_CHARACTER_GROUND_STATE_IN_AIR;
    }
    private static final int _JPC_CHARACTER_GROUND_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_CharacterGroundState._JPC_CHARACTER_GROUND_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_CHARACTER_GROUND_FORCEU32() {
        return _JPC_CHARACTER_GROUND_FORCEU32;
    }
    private static final int JPC_ACTIVATION_ACTIVATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_Activation.JPC_ACTIVATION_ACTIVATE = 0
     * }
     */
    public static int JPC_ACTIVATION_ACTIVATE() {
        return JPC_ACTIVATION_ACTIVATE;
    }
    private static final int JPC_ACTIVATION_DONT_ACTIVATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_Activation.JPC_ACTIVATION_DONT_ACTIVATE = 1
     * }
     */
    public static int JPC_ACTIVATION_DONT_ACTIVATE() {
        return JPC_ACTIVATION_DONT_ACTIVATE;
    }
    private static final int _JPC_ACTIVATION_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_Activation._JPC_ACTIVATION_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_ACTIVATION_FORCEU32() {
        return _JPC_ACTIVATION_FORCEU32;
    }
    private static final int JPC_VALIDATE_RESULT_ACCEPT_ALL_CONTACTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum JPC_ValidateResult.JPC_VALIDATE_RESULT_ACCEPT_ALL_CONTACTS = 0
     * }
     */
    public static int JPC_VALIDATE_RESULT_ACCEPT_ALL_CONTACTS() {
        return JPC_VALIDATE_RESULT_ACCEPT_ALL_CONTACTS;
    }
    private static final int JPC_VALIDATE_RESULT_ACCEPT_CONTACT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JPC_ValidateResult.JPC_VALIDATE_RESULT_ACCEPT_CONTACT = 1
     * }
     */
    public static int JPC_VALIDATE_RESULT_ACCEPT_CONTACT() {
        return JPC_VALIDATE_RESULT_ACCEPT_CONTACT;
    }
    private static final int JPC_VALIDATE_RESULT_REJECT_CONTACT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JPC_ValidateResult.JPC_VALIDATE_RESULT_REJECT_CONTACT = 2
     * }
     */
    public static int JPC_VALIDATE_RESULT_REJECT_CONTACT() {
        return JPC_VALIDATE_RESULT_REJECT_CONTACT;
    }
    private static final int JPC_VALIDATE_RESULT_REJECT_ALL_CONTACTS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum JPC_ValidateResult.JPC_VALIDATE_RESULT_REJECT_ALL_CONTACTS = 3
     * }
     */
    public static int JPC_VALIDATE_RESULT_REJECT_ALL_CONTACTS() {
        return JPC_VALIDATE_RESULT_REJECT_ALL_CONTACTS;
    }
    private static final int _JPC_VALIDATE_RESULT_FORCEU32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum JPC_ValidateResult._JPC_VALIDATE_RESULT_FORCEU32 = 2147483647
     * }
     */
    public static int _JPC_VALIDATE_RESULT_FORCEU32() {
        return _JPC_VALIDATE_RESULT_FORCEU32;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_BackFaceMode
     * }
     */
    public static final OfByte JPC_BackFaceMode = jolt.C_CHAR;
    private static final int JPC_BACK_FACE_IGNORE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_BACK_FACE_IGNORE = 0
     * }
     */
    public static int JPC_BACK_FACE_IGNORE() {
        return JPC_BACK_FACE_IGNORE;
    }
    private static final int JPC_BACK_FACE_COLLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPC_BACK_FACE_COLLIDE = 1
     * }
     */
    public static int JPC_BACK_FACE_COLLIDE() {
        return JPC_BACK_FACE_COLLIDE;
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t JPC_ObjectLayer
     * }
     */
    public static final OfShort JPC_ObjectLayer = jolt.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t JPC_BroadPhaseLayer
     * }
     */
    public static final OfByte JPC_BroadPhaseLayer = jolt.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint32_t JPC_BodyID
     * }
     */
    public static final OfInt JPC_BodyID = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t JPC_SubShapeID
     * }
     */
    public static final OfInt JPC_SubShapeID = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t JPC_CollisionGroupID
     * }
     */
    public static final OfInt JPC_CollisionGroupID = jolt.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t JPC_CollisionSubGroupID
     * }
     */
    public static final OfInt JPC_CollisionSubGroupID = jolt.C_INT;

    private static class JPC_RegisterDefaultAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_RegisterDefaultAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_RegisterDefaultAllocator()
     * }
     */
    public static FunctionDescriptor JPC_RegisterDefaultAllocator$descriptor() {
        return JPC_RegisterDefaultAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_RegisterDefaultAllocator()
     * }
     */
    public static MethodHandle JPC_RegisterDefaultAllocator$handle() {
        return JPC_RegisterDefaultAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_RegisterDefaultAllocator()
     * }
     */
    public static MemorySegment JPC_RegisterDefaultAllocator$address() {
        return JPC_RegisterDefaultAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_RegisterDefaultAllocator()
     * }
     */
    public static void JPC_RegisterDefaultAllocator() {
        var mh$ = JPC_RegisterDefaultAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_RegisterDefaultAllocator");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_RegisterCustomAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_RegisterCustomAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_RegisterCustomAllocator(JPC_AllocateFunction in_alloc, JPC_FreeFunction in_free, JPC_AlignedAllocateFunction in_aligned_alloc, JPC_AlignedFreeFunction in_aligned_free)
     * }
     */
    public static FunctionDescriptor JPC_RegisterCustomAllocator$descriptor() {
        return JPC_RegisterCustomAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_RegisterCustomAllocator(JPC_AllocateFunction in_alloc, JPC_FreeFunction in_free, JPC_AlignedAllocateFunction in_aligned_alloc, JPC_AlignedFreeFunction in_aligned_free)
     * }
     */
    public static MethodHandle JPC_RegisterCustomAllocator$handle() {
        return JPC_RegisterCustomAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_RegisterCustomAllocator(JPC_AllocateFunction in_alloc, JPC_FreeFunction in_free, JPC_AlignedAllocateFunction in_aligned_alloc, JPC_AlignedFreeFunction in_aligned_free)
     * }
     */
    public static MemorySegment JPC_RegisterCustomAllocator$address() {
        return JPC_RegisterCustomAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_RegisterCustomAllocator(JPC_AllocateFunction in_alloc, JPC_FreeFunction in_free, JPC_AlignedAllocateFunction in_aligned_alloc, JPC_AlignedFreeFunction in_aligned_free)
     * }
     */
    public static void JPC_RegisterCustomAllocator(MemorySegment in_alloc, MemorySegment in_free, MemorySegment in_aligned_alloc, MemorySegment in_aligned_free) {
        var mh$ = JPC_RegisterCustomAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_RegisterCustomAllocator", in_alloc, in_free, in_aligned_alloc, in_aligned_free);
            }
            mh$.invokeExact(in_alloc, in_free, in_aligned_alloc, in_aligned_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CreateFactory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CreateFactory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CreateFactory()
     * }
     */
    public static FunctionDescriptor JPC_CreateFactory$descriptor() {
        return JPC_CreateFactory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CreateFactory()
     * }
     */
    public static MethodHandle JPC_CreateFactory$handle() {
        return JPC_CreateFactory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CreateFactory()
     * }
     */
    public static MemorySegment JPC_CreateFactory$address() {
        return JPC_CreateFactory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CreateFactory()
     * }
     */
    public static void JPC_CreateFactory() {
        var mh$ = JPC_CreateFactory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CreateFactory");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_DestroyFactory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_DestroyFactory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_DestroyFactory()
     * }
     */
    public static FunctionDescriptor JPC_DestroyFactory$descriptor() {
        return JPC_DestroyFactory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_DestroyFactory()
     * }
     */
    public static MethodHandle JPC_DestroyFactory$handle() {
        return JPC_DestroyFactory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_DestroyFactory()
     * }
     */
    public static MemorySegment JPC_DestroyFactory$address() {
        return JPC_DestroyFactory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_DestroyFactory()
     * }
     */
    public static void JPC_DestroyFactory() {
        var mh$ = JPC_DestroyFactory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_DestroyFactory");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_RegisterTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_RegisterTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_RegisterTypes()
     * }
     */
    public static FunctionDescriptor JPC_RegisterTypes$descriptor() {
        return JPC_RegisterTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_RegisterTypes()
     * }
     */
    public static MethodHandle JPC_RegisterTypes$handle() {
        return JPC_RegisterTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_RegisterTypes()
     * }
     */
    public static MemorySegment JPC_RegisterTypes$address() {
        return JPC_RegisterTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_RegisterTypes()
     * }
     */
    public static void JPC_RegisterTypes() {
        var mh$ = JPC_RegisterTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_RegisterTypes");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyCreationSettings_SetDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyCreationSettings_SetDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_SetDefault(JPC_BodyCreationSettings *out_settings)
     * }
     */
    public static FunctionDescriptor JPC_BodyCreationSettings_SetDefault$descriptor() {
        return JPC_BodyCreationSettings_SetDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_SetDefault(JPC_BodyCreationSettings *out_settings)
     * }
     */
    public static MethodHandle JPC_BodyCreationSettings_SetDefault$handle() {
        return JPC_BodyCreationSettings_SetDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_SetDefault(JPC_BodyCreationSettings *out_settings)
     * }
     */
    public static MemorySegment JPC_BodyCreationSettings_SetDefault$address() {
        return JPC_BodyCreationSettings_SetDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_SetDefault(JPC_BodyCreationSettings *out_settings)
     * }
     */
    public static void JPC_BodyCreationSettings_SetDefault(MemorySegment out_settings) {
        var mh$ = JPC_BodyCreationSettings_SetDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyCreationSettings_SetDefault", out_settings);
            }
            mh$.invokeExact(out_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyCreationSettings_Set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_CHAR,
            jolt.C_SHORT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyCreationSettings_Set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_Set(JPC_BodyCreationSettings *out_settings, const JPC_Shape *in_shape, const JPC_Real in_position[3], const float in_rotation[4], JPC_MotionType in_motion_type, JPC_ObjectLayer in_layer)
     * }
     */
    public static FunctionDescriptor JPC_BodyCreationSettings_Set$descriptor() {
        return JPC_BodyCreationSettings_Set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_Set(JPC_BodyCreationSettings *out_settings, const JPC_Shape *in_shape, const JPC_Real in_position[3], const float in_rotation[4], JPC_MotionType in_motion_type, JPC_ObjectLayer in_layer)
     * }
     */
    public static MethodHandle JPC_BodyCreationSettings_Set$handle() {
        return JPC_BodyCreationSettings_Set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_Set(JPC_BodyCreationSettings *out_settings, const JPC_Shape *in_shape, const JPC_Real in_position[3], const float in_rotation[4], JPC_MotionType in_motion_type, JPC_ObjectLayer in_layer)
     * }
     */
    public static MemorySegment JPC_BodyCreationSettings_Set$address() {
        return JPC_BodyCreationSettings_Set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyCreationSettings_Set(JPC_BodyCreationSettings *out_settings, const JPC_Shape *in_shape, const JPC_Real in_position[3], const float in_rotation[4], JPC_MotionType in_motion_type, JPC_ObjectLayer in_layer)
     * }
     */
    public static void JPC_BodyCreationSettings_Set(MemorySegment out_settings, MemorySegment in_shape, MemorySegment in_position, MemorySegment in_rotation, byte in_motion_type, short in_layer) {
        var mh$ = JPC_BodyCreationSettings_Set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyCreationSettings_Set", out_settings, in_shape, in_position, in_rotation, in_motion_type, in_layer);
            }
            mh$.invokeExact(out_settings, in_shape, in_position, in_rotation, in_motion_type, in_layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetMotionQuality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_CHAR,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetMotionQuality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_MotionQuality JPC_MotionProperties_GetMotionQuality(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetMotionQuality$descriptor() {
        return JPC_MotionProperties_GetMotionQuality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_MotionQuality JPC_MotionProperties_GetMotionQuality(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetMotionQuality$handle() {
        return JPC_MotionProperties_GetMotionQuality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_MotionQuality JPC_MotionProperties_GetMotionQuality(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetMotionQuality$address() {
        return JPC_MotionProperties_GetMotionQuality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_MotionQuality JPC_MotionProperties_GetMotionQuality(const JPC_MotionProperties *in_properties)
     * }
     */
    public static byte JPC_MotionProperties_GetMotionQuality(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetMotionQuality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetMotionQuality", in_properties);
            }
            return (byte)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetLinearVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetLinearVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLinearVelocity(const JPC_MotionProperties *in_properties, float out_linear_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetLinearVelocity$descriptor() {
        return JPC_MotionProperties_GetLinearVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLinearVelocity(const JPC_MotionProperties *in_properties, float out_linear_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetLinearVelocity$handle() {
        return JPC_MotionProperties_GetLinearVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLinearVelocity(const JPC_MotionProperties *in_properties, float out_linear_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetLinearVelocity$address() {
        return JPC_MotionProperties_GetLinearVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLinearVelocity(const JPC_MotionProperties *in_properties, float out_linear_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_GetLinearVelocity(MemorySegment in_properties, MemorySegment out_linear_velocity) {
        var mh$ = JPC_MotionProperties_GetLinearVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetLinearVelocity", in_properties, out_linear_velocity);
            }
            mh$.invokeExact(in_properties, out_linear_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetLinearVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetLinearVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocity(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetLinearVelocity$descriptor() {
        return JPC_MotionProperties_SetLinearVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocity(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetLinearVelocity$handle() {
        return JPC_MotionProperties_SetLinearVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocity(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetLinearVelocity$address() {
        return JPC_MotionProperties_SetLinearVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocity(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_SetLinearVelocity(MemorySegment in_properties, MemorySegment in_linear_velocity) {
        var mh$ = JPC_MotionProperties_SetLinearVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetLinearVelocity", in_properties, in_linear_velocity);
            }
            mh$.invokeExact(in_properties, in_linear_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetLinearVelocityClamped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetLinearVelocityClamped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocityClamped(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetLinearVelocityClamped$descriptor() {
        return JPC_MotionProperties_SetLinearVelocityClamped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocityClamped(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetLinearVelocityClamped$handle() {
        return JPC_MotionProperties_SetLinearVelocityClamped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocityClamped(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetLinearVelocityClamped$address() {
        return JPC_MotionProperties_SetLinearVelocityClamped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearVelocityClamped(JPC_MotionProperties *in_properties, const float in_linear_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_SetLinearVelocityClamped(MemorySegment in_properties, MemorySegment in_linear_velocity) {
        var mh$ = JPC_MotionProperties_SetLinearVelocityClamped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetLinearVelocityClamped", in_properties, in_linear_velocity);
            }
            mh$.invokeExact(in_properties, in_linear_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetAngularVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetAngularVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetAngularVelocity(const JPC_MotionProperties *in_properties, float out_angular_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetAngularVelocity$descriptor() {
        return JPC_MotionProperties_GetAngularVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetAngularVelocity(const JPC_MotionProperties *in_properties, float out_angular_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetAngularVelocity$handle() {
        return JPC_MotionProperties_GetAngularVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetAngularVelocity(const JPC_MotionProperties *in_properties, float out_angular_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetAngularVelocity$address() {
        return JPC_MotionProperties_GetAngularVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetAngularVelocity(const JPC_MotionProperties *in_properties, float out_angular_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_GetAngularVelocity(MemorySegment in_properties, MemorySegment out_angular_velocity) {
        var mh$ = JPC_MotionProperties_GetAngularVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetAngularVelocity", in_properties, out_angular_velocity);
            }
            mh$.invokeExact(in_properties, out_angular_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetAngularVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetAngularVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocity(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetAngularVelocity$descriptor() {
        return JPC_MotionProperties_SetAngularVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocity(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetAngularVelocity$handle() {
        return JPC_MotionProperties_SetAngularVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocity(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetAngularVelocity$address() {
        return JPC_MotionProperties_SetAngularVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocity(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_SetAngularVelocity(MemorySegment in_properties, MemorySegment in_angular_velocity) {
        var mh$ = JPC_MotionProperties_SetAngularVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetAngularVelocity", in_properties, in_angular_velocity);
            }
            mh$.invokeExact(in_properties, in_angular_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetAngularVelocityClamped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetAngularVelocityClamped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocityClamped(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetAngularVelocityClamped$descriptor() {
        return JPC_MotionProperties_SetAngularVelocityClamped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocityClamped(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetAngularVelocityClamped$handle() {
        return JPC_MotionProperties_SetAngularVelocityClamped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocityClamped(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetAngularVelocityClamped$address() {
        return JPC_MotionProperties_SetAngularVelocityClamped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularVelocityClamped(JPC_MotionProperties *in_properties, const float in_angular_velocity[3])
     * }
     */
    public static void JPC_MotionProperties_SetAngularVelocityClamped(MemorySegment in_properties, MemorySegment in_angular_velocity) {
        var mh$ = JPC_MotionProperties_SetAngularVelocityClamped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetAngularVelocityClamped", in_properties, in_angular_velocity);
            }
            mh$.invokeExact(in_properties, in_angular_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_MoveKinematic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_MoveKinematic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MoveKinematic(JPC_MotionProperties *in_properties, const float in_delta_position[3], const float in_delta_rotation[4], float in_delta_time)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_MoveKinematic$descriptor() {
        return JPC_MotionProperties_MoveKinematic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MoveKinematic(JPC_MotionProperties *in_properties, const float in_delta_position[3], const float in_delta_rotation[4], float in_delta_time)
     * }
     */
    public static MethodHandle JPC_MotionProperties_MoveKinematic$handle() {
        return JPC_MotionProperties_MoveKinematic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MoveKinematic(JPC_MotionProperties *in_properties, const float in_delta_position[3], const float in_delta_rotation[4], float in_delta_time)
     * }
     */
    public static MemorySegment JPC_MotionProperties_MoveKinematic$address() {
        return JPC_MotionProperties_MoveKinematic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_MoveKinematic(JPC_MotionProperties *in_properties, const float in_delta_position[3], const float in_delta_rotation[4], float in_delta_time)
     * }
     */
    public static void JPC_MotionProperties_MoveKinematic(MemorySegment in_properties, MemorySegment in_delta_position, MemorySegment in_delta_rotation, float in_delta_time) {
        var mh$ = JPC_MotionProperties_MoveKinematic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_MoveKinematic", in_properties, in_delta_position, in_delta_rotation, in_delta_time);
            }
            mh$.invokeExact(in_properties, in_delta_position, in_delta_rotation, in_delta_time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_ClampLinearVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_ClampLinearVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampLinearVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_ClampLinearVelocity$descriptor() {
        return JPC_MotionProperties_ClampLinearVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampLinearVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_ClampLinearVelocity$handle() {
        return JPC_MotionProperties_ClampLinearVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampLinearVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_ClampLinearVelocity$address() {
        return JPC_MotionProperties_ClampLinearVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampLinearVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static void JPC_MotionProperties_ClampLinearVelocity(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_ClampLinearVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_ClampLinearVelocity", in_properties);
            }
            mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_ClampAngularVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_ClampAngularVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampAngularVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_ClampAngularVelocity$descriptor() {
        return JPC_MotionProperties_ClampAngularVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampAngularVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_ClampAngularVelocity$handle() {
        return JPC_MotionProperties_ClampAngularVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampAngularVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_ClampAngularVelocity$address() {
        return JPC_MotionProperties_ClampAngularVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_ClampAngularVelocity(JPC_MotionProperties *in_properties)
     * }
     */
    public static void JPC_MotionProperties_ClampAngularVelocity(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_ClampAngularVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_ClampAngularVelocity", in_properties);
            }
            mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetLinearDamping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetLinearDamping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetLinearDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetLinearDamping$descriptor() {
        return JPC_MotionProperties_GetLinearDamping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetLinearDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetLinearDamping$handle() {
        return JPC_MotionProperties_GetLinearDamping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetLinearDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetLinearDamping$address() {
        return JPC_MotionProperties_GetLinearDamping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetLinearDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetLinearDamping(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetLinearDamping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetLinearDamping", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetLinearDamping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetLinearDamping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearDamping(JPC_MotionProperties *in_properties, float in_linear_damping)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetLinearDamping$descriptor() {
        return JPC_MotionProperties_SetLinearDamping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearDamping(JPC_MotionProperties *in_properties, float in_linear_damping)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetLinearDamping$handle() {
        return JPC_MotionProperties_SetLinearDamping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearDamping(JPC_MotionProperties *in_properties, float in_linear_damping)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetLinearDamping$address() {
        return JPC_MotionProperties_SetLinearDamping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetLinearDamping(JPC_MotionProperties *in_properties, float in_linear_damping)
     * }
     */
    public static void JPC_MotionProperties_SetLinearDamping(MemorySegment in_properties, float in_linear_damping) {
        var mh$ = JPC_MotionProperties_SetLinearDamping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetLinearDamping", in_properties, in_linear_damping);
            }
            mh$.invokeExact(in_properties, in_linear_damping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetAngularDamping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetAngularDamping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetAngularDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetAngularDamping$descriptor() {
        return JPC_MotionProperties_GetAngularDamping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetAngularDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetAngularDamping$handle() {
        return JPC_MotionProperties_GetAngularDamping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetAngularDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetAngularDamping$address() {
        return JPC_MotionProperties_GetAngularDamping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetAngularDamping(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetAngularDamping(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetAngularDamping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetAngularDamping", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetAngularDamping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetAngularDamping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularDamping(JPC_MotionProperties *in_properties, float in_angular_damping)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetAngularDamping$descriptor() {
        return JPC_MotionProperties_SetAngularDamping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularDamping(JPC_MotionProperties *in_properties, float in_angular_damping)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetAngularDamping$handle() {
        return JPC_MotionProperties_SetAngularDamping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularDamping(JPC_MotionProperties *in_properties, float in_angular_damping)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetAngularDamping$address() {
        return JPC_MotionProperties_SetAngularDamping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetAngularDamping(JPC_MotionProperties *in_properties, float in_angular_damping)
     * }
     */
    public static void JPC_MotionProperties_SetAngularDamping(MemorySegment in_properties, float in_angular_damping) {
        var mh$ = JPC_MotionProperties_SetAngularDamping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetAngularDamping", in_properties, in_angular_damping);
            }
            mh$.invokeExact(in_properties, in_angular_damping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetGravityFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetGravityFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetGravityFactor(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetGravityFactor$descriptor() {
        return JPC_MotionProperties_GetGravityFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetGravityFactor(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetGravityFactor$handle() {
        return JPC_MotionProperties_GetGravityFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetGravityFactor(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetGravityFactor$address() {
        return JPC_MotionProperties_GetGravityFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetGravityFactor(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetGravityFactor(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetGravityFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetGravityFactor", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetGravityFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetGravityFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetGravityFactor(JPC_MotionProperties *in_properties, float in_gravity_factor)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetGravityFactor$descriptor() {
        return JPC_MotionProperties_SetGravityFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetGravityFactor(JPC_MotionProperties *in_properties, float in_gravity_factor)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetGravityFactor$handle() {
        return JPC_MotionProperties_SetGravityFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetGravityFactor(JPC_MotionProperties *in_properties, float in_gravity_factor)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetGravityFactor$address() {
        return JPC_MotionProperties_SetGravityFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetGravityFactor(JPC_MotionProperties *in_properties, float in_gravity_factor)
     * }
     */
    public static void JPC_MotionProperties_SetGravityFactor(MemorySegment in_properties, float in_gravity_factor) {
        var mh$ = JPC_MotionProperties_SetGravityFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetGravityFactor", in_properties, in_gravity_factor);
            }
            mh$.invokeExact(in_properties, in_gravity_factor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetMassProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetMassProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMassProperties(JPC_MotionProperties *in_properties, const JPC_MassProperties *in_mass_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetMassProperties$descriptor() {
        return JPC_MotionProperties_SetMassProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMassProperties(JPC_MotionProperties *in_properties, const JPC_MassProperties *in_mass_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetMassProperties$handle() {
        return JPC_MotionProperties_SetMassProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMassProperties(JPC_MotionProperties *in_properties, const JPC_MassProperties *in_mass_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetMassProperties$address() {
        return JPC_MotionProperties_SetMassProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMassProperties(JPC_MotionProperties *in_properties, const JPC_MassProperties *in_mass_properties)
     * }
     */
    public static void JPC_MotionProperties_SetMassProperties(MemorySegment in_properties, MemorySegment in_mass_properties) {
        var mh$ = JPC_MotionProperties_SetMassProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetMassProperties", in_properties, in_mass_properties);
            }
            mh$.invokeExact(in_properties, in_mass_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetInverseMass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetInverseMass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetInverseMass(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetInverseMass$descriptor() {
        return JPC_MotionProperties_GetInverseMass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetInverseMass(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetInverseMass$handle() {
        return JPC_MotionProperties_GetInverseMass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetInverseMass(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetInverseMass$address() {
        return JPC_MotionProperties_GetInverseMass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetInverseMass(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetInverseMass(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetInverseMass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetInverseMass", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetInverseMass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetInverseMass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseMass(JPC_MotionProperties *in_properties, float in_inv_mass)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetInverseMass$descriptor() {
        return JPC_MotionProperties_SetInverseMass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseMass(JPC_MotionProperties *in_properties, float in_inv_mass)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetInverseMass$handle() {
        return JPC_MotionProperties_SetInverseMass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseMass(JPC_MotionProperties *in_properties, float in_inv_mass)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetInverseMass$address() {
        return JPC_MotionProperties_SetInverseMass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseMass(JPC_MotionProperties *in_properties, float in_inv_mass)
     * }
     */
    public static void JPC_MotionProperties_SetInverseMass(MemorySegment in_properties, float in_inv_mass) {
        var mh$ = JPC_MotionProperties_SetInverseMass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetInverseMass", in_properties, in_inv_mass);
            }
            mh$.invokeExact(in_properties, in_inv_mass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetInverseInertiaDiagonal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetInverseInertiaDiagonal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaDiagonal(const JPC_MotionProperties *in_properties, float out_inverse_inertia_diagonal[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetInverseInertiaDiagonal$descriptor() {
        return JPC_MotionProperties_GetInverseInertiaDiagonal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaDiagonal(const JPC_MotionProperties *in_properties, float out_inverse_inertia_diagonal[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetInverseInertiaDiagonal$handle() {
        return JPC_MotionProperties_GetInverseInertiaDiagonal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaDiagonal(const JPC_MotionProperties *in_properties, float out_inverse_inertia_diagonal[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetInverseInertiaDiagonal$address() {
        return JPC_MotionProperties_GetInverseInertiaDiagonal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaDiagonal(const JPC_MotionProperties *in_properties, float out_inverse_inertia_diagonal[3])
     * }
     */
    public static void JPC_MotionProperties_GetInverseInertiaDiagonal(MemorySegment in_properties, MemorySegment out_inverse_inertia_diagonal) {
        var mh$ = JPC_MotionProperties_GetInverseInertiaDiagonal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetInverseInertiaDiagonal", in_properties, out_inverse_inertia_diagonal);
            }
            mh$.invokeExact(in_properties, out_inverse_inertia_diagonal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetInertiaRotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetInertiaRotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInertiaRotation(const JPC_MotionProperties *in_properties, float out_inertia_rotation[4])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetInertiaRotation$descriptor() {
        return JPC_MotionProperties_GetInertiaRotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInertiaRotation(const JPC_MotionProperties *in_properties, float out_inertia_rotation[4])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetInertiaRotation$handle() {
        return JPC_MotionProperties_GetInertiaRotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInertiaRotation(const JPC_MotionProperties *in_properties, float out_inertia_rotation[4])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetInertiaRotation$address() {
        return JPC_MotionProperties_GetInertiaRotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInertiaRotation(const JPC_MotionProperties *in_properties, float out_inertia_rotation[4])
     * }
     */
    public static void JPC_MotionProperties_GetInertiaRotation(MemorySegment in_properties, MemorySegment out_inertia_rotation) {
        var mh$ = JPC_MotionProperties_GetInertiaRotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetInertiaRotation", in_properties, out_inertia_rotation);
            }
            mh$.invokeExact(in_properties, out_inertia_rotation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetInverseInertia {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetInverseInertia");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseInertia(JPC_MotionProperties *in_properties, const float in_diagonal[3], const float in_rotation[4])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetInverseInertia$descriptor() {
        return JPC_MotionProperties_SetInverseInertia.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseInertia(JPC_MotionProperties *in_properties, const float in_diagonal[3], const float in_rotation[4])
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetInverseInertia$handle() {
        return JPC_MotionProperties_SetInverseInertia.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseInertia(JPC_MotionProperties *in_properties, const float in_diagonal[3], const float in_rotation[4])
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetInverseInertia$address() {
        return JPC_MotionProperties_SetInverseInertia.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetInverseInertia(JPC_MotionProperties *in_properties, const float in_diagonal[3], const float in_rotation[4])
     * }
     */
    public static void JPC_MotionProperties_SetInverseInertia(MemorySegment in_properties, MemorySegment in_diagonal, MemorySegment in_rotation) {
        var mh$ = JPC_MotionProperties_SetInverseInertia.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetInverseInertia", in_properties, in_diagonal, in_rotation);
            }
            mh$.invokeExact(in_properties, in_diagonal, in_rotation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetLocalSpaceInverseInertia {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetLocalSpaceInverseInertia");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLocalSpaceInverseInertia(const JPC_MotionProperties *in_properties, float out_matrix[16])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetLocalSpaceInverseInertia$descriptor() {
        return JPC_MotionProperties_GetLocalSpaceInverseInertia.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLocalSpaceInverseInertia(const JPC_MotionProperties *in_properties, float out_matrix[16])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetLocalSpaceInverseInertia$handle() {
        return JPC_MotionProperties_GetLocalSpaceInverseInertia.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLocalSpaceInverseInertia(const JPC_MotionProperties *in_properties, float out_matrix[16])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetLocalSpaceInverseInertia$address() {
        return JPC_MotionProperties_GetLocalSpaceInverseInertia.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetLocalSpaceInverseInertia(const JPC_MotionProperties *in_properties, float out_matrix[16])
     * }
     */
    public static void JPC_MotionProperties_GetLocalSpaceInverseInertia(MemorySegment in_properties, MemorySegment out_matrix) {
        var mh$ = JPC_MotionProperties_GetLocalSpaceInverseInertia.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetLocalSpaceInverseInertia", in_properties, out_matrix);
            }
            mh$.invokeExact(in_properties, out_matrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetInverseInertiaForRotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetInverseInertiaForRotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaForRotation(const JPC_MotionProperties *in_properties, const float in_rotation_matrix[16], float out_matrix[16])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetInverseInertiaForRotation$descriptor() {
        return JPC_MotionProperties_GetInverseInertiaForRotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaForRotation(const JPC_MotionProperties *in_properties, const float in_rotation_matrix[16], float out_matrix[16])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetInverseInertiaForRotation$handle() {
        return JPC_MotionProperties_GetInverseInertiaForRotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaForRotation(const JPC_MotionProperties *in_properties, const float in_rotation_matrix[16], float out_matrix[16])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetInverseInertiaForRotation$address() {
        return JPC_MotionProperties_GetInverseInertiaForRotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetInverseInertiaForRotation(const JPC_MotionProperties *in_properties, const float in_rotation_matrix[16], float out_matrix[16])
     * }
     */
    public static void JPC_MotionProperties_GetInverseInertiaForRotation(MemorySegment in_properties, MemorySegment in_rotation_matrix, MemorySegment out_matrix) {
        var mh$ = JPC_MotionProperties_GetInverseInertiaForRotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetInverseInertiaForRotation", in_properties, in_rotation_matrix, out_matrix);
            }
            mh$.invokeExact(in_properties, in_rotation_matrix, out_matrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector(const JPC_MotionProperties *in_properties, const float in_body_rotation[4], const float in_vector[3], float out_vector[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector$descriptor() {
        return JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector(const JPC_MotionProperties *in_properties, const float in_body_rotation[4], const float in_vector[3], float out_vector[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector$handle() {
        return JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector(const JPC_MotionProperties *in_properties, const float in_body_rotation[4], const float in_vector[3], float out_vector[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector$address() {
        return JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector(const JPC_MotionProperties *in_properties, const float in_body_rotation[4], const float in_vector[3], float out_vector[3])
     * }
     */
    public static void JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector(MemorySegment in_properties, MemorySegment in_body_rotation, MemorySegment in_vector, MemorySegment out_vector) {
        var mh$ = JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_MultiplyWorldSpaceInverseInertiaByVector", in_properties, in_body_rotation, in_vector, out_vector);
            }
            mh$.invokeExact(in_properties, in_body_rotation, in_vector, out_vector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetPointVelocityCOM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetPointVelocityCOM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetPointVelocityCOM(const JPC_MotionProperties *in_properties, const float in_point_relative_to_com[3], float out_point[3])
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetPointVelocityCOM$descriptor() {
        return JPC_MotionProperties_GetPointVelocityCOM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetPointVelocityCOM(const JPC_MotionProperties *in_properties, const float in_point_relative_to_com[3], float out_point[3])
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetPointVelocityCOM$handle() {
        return JPC_MotionProperties_GetPointVelocityCOM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetPointVelocityCOM(const JPC_MotionProperties *in_properties, const float in_point_relative_to_com[3], float out_point[3])
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetPointVelocityCOM$address() {
        return JPC_MotionProperties_GetPointVelocityCOM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_GetPointVelocityCOM(const JPC_MotionProperties *in_properties, const float in_point_relative_to_com[3], float out_point[3])
     * }
     */
    public static void JPC_MotionProperties_GetPointVelocityCOM(MemorySegment in_properties, MemorySegment in_point_relative_to_com, MemorySegment out_point) {
        var mh$ = JPC_MotionProperties_GetPointVelocityCOM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetPointVelocityCOM", in_properties, in_point_relative_to_com, out_point);
            }
            mh$.invokeExact(in_properties, in_point_relative_to_com, out_point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetMaxLinearVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetMaxLinearVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxLinearVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetMaxLinearVelocity$descriptor() {
        return JPC_MotionProperties_GetMaxLinearVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxLinearVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetMaxLinearVelocity$handle() {
        return JPC_MotionProperties_GetMaxLinearVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxLinearVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetMaxLinearVelocity$address() {
        return JPC_MotionProperties_GetMaxLinearVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxLinearVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetMaxLinearVelocity(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetMaxLinearVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetMaxLinearVelocity", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetMaxLinearVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetMaxLinearVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxLinearVelocity(JPC_MotionProperties *in_properties, float in_max_linear_velocity)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetMaxLinearVelocity$descriptor() {
        return JPC_MotionProperties_SetMaxLinearVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxLinearVelocity(JPC_MotionProperties *in_properties, float in_max_linear_velocity)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetMaxLinearVelocity$handle() {
        return JPC_MotionProperties_SetMaxLinearVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxLinearVelocity(JPC_MotionProperties *in_properties, float in_max_linear_velocity)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetMaxLinearVelocity$address() {
        return JPC_MotionProperties_SetMaxLinearVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxLinearVelocity(JPC_MotionProperties *in_properties, float in_max_linear_velocity)
     * }
     */
    public static void JPC_MotionProperties_SetMaxLinearVelocity(MemorySegment in_properties, float in_max_linear_velocity) {
        var mh$ = JPC_MotionProperties_SetMaxLinearVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetMaxLinearVelocity", in_properties, in_max_linear_velocity);
            }
            mh$.invokeExact(in_properties, in_max_linear_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_GetMaxAngularVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_GetMaxAngularVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxAngularVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_GetMaxAngularVelocity$descriptor() {
        return JPC_MotionProperties_GetMaxAngularVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxAngularVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MethodHandle JPC_MotionProperties_GetMaxAngularVelocity$handle() {
        return JPC_MotionProperties_GetMaxAngularVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxAngularVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static MemorySegment JPC_MotionProperties_GetMaxAngularVelocity$address() {
        return JPC_MotionProperties_GetMaxAngularVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_MotionProperties_GetMaxAngularVelocity(const JPC_MotionProperties *in_properties)
     * }
     */
    public static float JPC_MotionProperties_GetMaxAngularVelocity(MemorySegment in_properties) {
        var mh$ = JPC_MotionProperties_GetMaxAngularVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_GetMaxAngularVelocity", in_properties);
            }
            return (float)mh$.invokeExact(in_properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MotionProperties_SetMaxAngularVelocity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MotionProperties_SetMaxAngularVelocity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxAngularVelocity(JPC_MotionProperties *in_properties, float in_max_angular_velocity)
     * }
     */
    public static FunctionDescriptor JPC_MotionProperties_SetMaxAngularVelocity$descriptor() {
        return JPC_MotionProperties_SetMaxAngularVelocity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxAngularVelocity(JPC_MotionProperties *in_properties, float in_max_angular_velocity)
     * }
     */
    public static MethodHandle JPC_MotionProperties_SetMaxAngularVelocity$handle() {
        return JPC_MotionProperties_SetMaxAngularVelocity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxAngularVelocity(JPC_MotionProperties *in_properties, float in_max_angular_velocity)
     * }
     */
    public static MemorySegment JPC_MotionProperties_SetMaxAngularVelocity$address() {
        return JPC_MotionProperties_SetMaxAngularVelocity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MotionProperties_SetMaxAngularVelocity(JPC_MotionProperties *in_properties, float in_max_angular_velocity)
     * }
     */
    public static void JPC_MotionProperties_SetMaxAngularVelocity(MemorySegment in_properties, float in_max_angular_velocity) {
        var mh$ = JPC_MotionProperties_SetMaxAngularVelocity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MotionProperties_SetMaxAngularVelocity", in_properties, in_max_angular_velocity);
            }
            mh$.invokeExact(in_properties, in_max_angular_velocity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TempAllocator_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TempAllocator_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_TempAllocator *JPC_TempAllocator_Create(uint32_t in_size)
     * }
     */
    public static FunctionDescriptor JPC_TempAllocator_Create$descriptor() {
        return JPC_TempAllocator_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_TempAllocator *JPC_TempAllocator_Create(uint32_t in_size)
     * }
     */
    public static MethodHandle JPC_TempAllocator_Create$handle() {
        return JPC_TempAllocator_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_TempAllocator *JPC_TempAllocator_Create(uint32_t in_size)
     * }
     */
    public static MemorySegment JPC_TempAllocator_Create$address() {
        return JPC_TempAllocator_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_TempAllocator *JPC_TempAllocator_Create(uint32_t in_size)
     * }
     */
    public static MemorySegment JPC_TempAllocator_Create(int in_size) {
        var mh$ = JPC_TempAllocator_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TempAllocator_Create", in_size);
            }
            return (MemorySegment)mh$.invokeExact(in_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TempAllocator_Destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TempAllocator_Destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TempAllocator_Destroy(JPC_TempAllocator *in_allocator)
     * }
     */
    public static FunctionDescriptor JPC_TempAllocator_Destroy$descriptor() {
        return JPC_TempAllocator_Destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TempAllocator_Destroy(JPC_TempAllocator *in_allocator)
     * }
     */
    public static MethodHandle JPC_TempAllocator_Destroy$handle() {
        return JPC_TempAllocator_Destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TempAllocator_Destroy(JPC_TempAllocator *in_allocator)
     * }
     */
    public static MemorySegment JPC_TempAllocator_Destroy$address() {
        return JPC_TempAllocator_Destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TempAllocator_Destroy(JPC_TempAllocator *in_allocator)
     * }
     */
    public static void JPC_TempAllocator_Destroy(MemorySegment in_allocator) {
        var mh$ = JPC_TempAllocator_Destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TempAllocator_Destroy", in_allocator);
            }
            mh$.invokeExact(in_allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_JobSystem_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_JobSystem_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_JobSystem *JPC_JobSystem_Create(uint32_t in_max_jobs, uint32_t in_max_barriers, int in_num_threads)
     * }
     */
    public static FunctionDescriptor JPC_JobSystem_Create$descriptor() {
        return JPC_JobSystem_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_JobSystem *JPC_JobSystem_Create(uint32_t in_max_jobs, uint32_t in_max_barriers, int in_num_threads)
     * }
     */
    public static MethodHandle JPC_JobSystem_Create$handle() {
        return JPC_JobSystem_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_JobSystem *JPC_JobSystem_Create(uint32_t in_max_jobs, uint32_t in_max_barriers, int in_num_threads)
     * }
     */
    public static MemorySegment JPC_JobSystem_Create$address() {
        return JPC_JobSystem_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_JobSystem *JPC_JobSystem_Create(uint32_t in_max_jobs, uint32_t in_max_barriers, int in_num_threads)
     * }
     */
    public static MemorySegment JPC_JobSystem_Create(int in_max_jobs, int in_max_barriers, int in_num_threads) {
        var mh$ = JPC_JobSystem_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_JobSystem_Create", in_max_jobs, in_max_barriers, in_num_threads);
            }
            return (MemorySegment)mh$.invokeExact(in_max_jobs, in_max_barriers, in_num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_JobSystem_Destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_JobSystem_Destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_JobSystem_Destroy(JPC_JobSystem *in_job_system)
     * }
     */
    public static FunctionDescriptor JPC_JobSystem_Destroy$descriptor() {
        return JPC_JobSystem_Destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_JobSystem_Destroy(JPC_JobSystem *in_job_system)
     * }
     */
    public static MethodHandle JPC_JobSystem_Destroy$handle() {
        return JPC_JobSystem_Destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_JobSystem_Destroy(JPC_JobSystem *in_job_system)
     * }
     */
    public static MemorySegment JPC_JobSystem_Destroy$address() {
        return JPC_JobSystem_Destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_JobSystem_Destroy(JPC_JobSystem *in_job_system)
     * }
     */
    public static void JPC_JobSystem_Destroy(MemorySegment in_job_system) {
        var mh$ = JPC_JobSystem_Destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_JobSystem_Destroy", in_job_system);
            }
            mh$.invokeExact(in_job_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_PhysicsSystem *JPC_PhysicsSystem_Create(uint32_t in_max_bodies, uint32_t in_num_body_mutexes, uint32_t in_max_body_pairs, uint32_t in_max_contact_constraints, const void *in_broad_phase_layer_interface, const void *in_object_vs_broad_phase_layer_filter, const void *in_object_layer_pair_filter)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_Create$descriptor() {
        return JPC_PhysicsSystem_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_PhysicsSystem *JPC_PhysicsSystem_Create(uint32_t in_max_bodies, uint32_t in_num_body_mutexes, uint32_t in_max_body_pairs, uint32_t in_max_contact_constraints, const void *in_broad_phase_layer_interface, const void *in_object_vs_broad_phase_layer_filter, const void *in_object_layer_pair_filter)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_Create$handle() {
        return JPC_PhysicsSystem_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_PhysicsSystem *JPC_PhysicsSystem_Create(uint32_t in_max_bodies, uint32_t in_num_body_mutexes, uint32_t in_max_body_pairs, uint32_t in_max_contact_constraints, const void *in_broad_phase_layer_interface, const void *in_object_vs_broad_phase_layer_filter, const void *in_object_layer_pair_filter)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_Create$address() {
        return JPC_PhysicsSystem_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_PhysicsSystem *JPC_PhysicsSystem_Create(uint32_t in_max_bodies, uint32_t in_num_body_mutexes, uint32_t in_max_body_pairs, uint32_t in_max_contact_constraints, const void *in_broad_phase_layer_interface, const void *in_object_vs_broad_phase_layer_filter, const void *in_object_layer_pair_filter)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_Create(int in_max_bodies, int in_num_body_mutexes, int in_max_body_pairs, int in_max_contact_constraints, MemorySegment in_broad_phase_layer_interface, MemorySegment in_object_vs_broad_phase_layer_filter, MemorySegment in_object_layer_pair_filter) {
        var mh$ = JPC_PhysicsSystem_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_Create", in_max_bodies, in_num_body_mutexes, in_max_body_pairs, in_max_contact_constraints, in_broad_phase_layer_interface, in_object_vs_broad_phase_layer_filter, in_object_layer_pair_filter);
            }
            return (MemorySegment)mh$.invokeExact(in_max_bodies, in_num_body_mutexes, in_max_body_pairs, in_max_contact_constraints, in_broad_phase_layer_interface, in_object_vs_broad_phase_layer_filter, in_object_layer_pair_filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_Destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_Destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_Destroy(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_Destroy$descriptor() {
        return JPC_PhysicsSystem_Destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_Destroy(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_Destroy$handle() {
        return JPC_PhysicsSystem_Destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_Destroy(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_Destroy$address() {
        return JPC_PhysicsSystem_Destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_Destroy(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static void JPC_PhysicsSystem_Destroy(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_Destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_Destroy", in_physics_system);
            }
            mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_SetBodyActivationListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_SetBodyActivationListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetBodyActivationListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_SetBodyActivationListener$descriptor() {
        return JPC_PhysicsSystem_SetBodyActivationListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetBodyActivationListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_SetBodyActivationListener$handle() {
        return JPC_PhysicsSystem_SetBodyActivationListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetBodyActivationListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_SetBodyActivationListener$address() {
        return JPC_PhysicsSystem_SetBodyActivationListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetBodyActivationListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static void JPC_PhysicsSystem_SetBodyActivationListener(MemorySegment in_physics_system, MemorySegment in_listener) {
        var mh$ = JPC_PhysicsSystem_SetBodyActivationListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_SetBodyActivationListener", in_physics_system, in_listener);
            }
            mh$.invokeExact(in_physics_system, in_listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyActivationListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyActivationListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetBodyActivationListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyActivationListener$descriptor() {
        return JPC_PhysicsSystem_GetBodyActivationListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetBodyActivationListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyActivationListener$handle() {
        return JPC_PhysicsSystem_GetBodyActivationListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetBodyActivationListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyActivationListener$address() {
        return JPC_PhysicsSystem_GetBodyActivationListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetBodyActivationListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyActivationListener(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodyActivationListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyActivationListener", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_SetContactListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_SetContactListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetContactListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_SetContactListener$descriptor() {
        return JPC_PhysicsSystem_SetContactListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetContactListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_SetContactListener$handle() {
        return JPC_PhysicsSystem_SetContactListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetContactListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_SetContactListener$address() {
        return JPC_PhysicsSystem_SetContactListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetContactListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static void JPC_PhysicsSystem_SetContactListener(MemorySegment in_physics_system, MemorySegment in_listener) {
        var mh$ = JPC_PhysicsSystem_SetContactListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_SetContactListener", in_physics_system, in_listener);
            }
            mh$.invokeExact(in_physics_system, in_listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetContactListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetContactListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetContactListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetContactListener$descriptor() {
        return JPC_PhysicsSystem_GetContactListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetContactListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetContactListener$handle() {
        return JPC_PhysicsSystem_GetContactListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetContactListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetContactListener$address() {
        return JPC_PhysicsSystem_GetContactListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *JPC_PhysicsSystem_GetContactListener(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetContactListener(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetContactListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetContactListener", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetNumBodies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetNumBodies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetNumBodies$descriptor() {
        return JPC_PhysicsSystem_GetNumBodies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetNumBodies$handle() {
        return JPC_PhysicsSystem_GetNumBodies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNumBodies$address() {
        return JPC_PhysicsSystem_GetNumBodies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static int JPC_PhysicsSystem_GetNumBodies(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetNumBodies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetNumBodies", in_physics_system);
            }
            return (int)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetNumActiveBodies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetNumActiveBodies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumActiveBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetNumActiveBodies$descriptor() {
        return JPC_PhysicsSystem_GetNumActiveBodies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumActiveBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetNumActiveBodies$handle() {
        return JPC_PhysicsSystem_GetNumActiveBodies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumActiveBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNumActiveBodies$address() {
        return JPC_PhysicsSystem_GetNumActiveBodies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetNumActiveBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static int JPC_PhysicsSystem_GetNumActiveBodies(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetNumActiveBodies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetNumActiveBodies", in_physics_system);
            }
            return (int)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetMaxBodies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetMaxBodies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetMaxBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetMaxBodies$descriptor() {
        return JPC_PhysicsSystem_GetMaxBodies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetMaxBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetMaxBodies$handle() {
        return JPC_PhysicsSystem_GetMaxBodies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetMaxBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetMaxBodies$address() {
        return JPC_PhysicsSystem_GetMaxBodies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_PhysicsSystem_GetMaxBodies(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static int JPC_PhysicsSystem_GetMaxBodies(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetMaxBodies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetMaxBodies", in_physics_system);
            }
            return (int)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetGravity(const JPC_PhysicsSystem *in_physics_system, float out_gravity[3])
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetGravity$descriptor() {
        return JPC_PhysicsSystem_GetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetGravity(const JPC_PhysicsSystem *in_physics_system, float out_gravity[3])
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetGravity$handle() {
        return JPC_PhysicsSystem_GetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetGravity(const JPC_PhysicsSystem *in_physics_system, float out_gravity[3])
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetGravity$address() {
        return JPC_PhysicsSystem_GetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetGravity(const JPC_PhysicsSystem *in_physics_system, float out_gravity[3])
     * }
     */
    public static void JPC_PhysicsSystem_GetGravity(MemorySegment in_physics_system, MemorySegment out_gravity) {
        var mh$ = JPC_PhysicsSystem_GetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetGravity", in_physics_system, out_gravity);
            }
            mh$.invokeExact(in_physics_system, out_gravity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_SetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_SetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetGravity(JPC_PhysicsSystem *in_physics_system, const float in_gravity[3])
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_SetGravity$descriptor() {
        return JPC_PhysicsSystem_SetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetGravity(JPC_PhysicsSystem *in_physics_system, const float in_gravity[3])
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_SetGravity$handle() {
        return JPC_PhysicsSystem_SetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetGravity(JPC_PhysicsSystem *in_physics_system, const float in_gravity[3])
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_SetGravity$address() {
        return JPC_PhysicsSystem_SetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_SetGravity(JPC_PhysicsSystem *in_physics_system, const float in_gravity[3])
     * }
     */
    public static void JPC_PhysicsSystem_SetGravity(MemorySegment in_physics_system, MemorySegment in_gravity) {
        var mh$ = JPC_PhysicsSystem_SetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_SetGravity", in_physics_system, in_gravity);
            }
            mh$.invokeExact(in_physics_system, in_gravity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyInterface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyInterface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterface(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyInterface$descriptor() {
        return JPC_PhysicsSystem_GetBodyInterface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterface(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyInterface$handle() {
        return JPC_PhysicsSystem_GetBodyInterface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterface(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyInterface$address() {
        return JPC_PhysicsSystem_GetBodyInterface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterface(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyInterface(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodyInterface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyInterface", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyInterfaceNoLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyInterfaceNoLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterfaceNoLock(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyInterfaceNoLock$descriptor() {
        return JPC_PhysicsSystem_GetBodyInterfaceNoLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterfaceNoLock(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyInterfaceNoLock$handle() {
        return JPC_PhysicsSystem_GetBodyInterfaceNoLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterfaceNoLock(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyInterfaceNoLock$address() {
        return JPC_PhysicsSystem_GetBodyInterfaceNoLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_BodyInterface *JPC_PhysicsSystem_GetBodyInterfaceNoLock(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyInterfaceNoLock(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodyInterfaceNoLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyInterfaceNoLock", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_OptimizeBroadPhase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_OptimizeBroadPhase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_OptimizeBroadPhase(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_OptimizeBroadPhase$descriptor() {
        return JPC_PhysicsSystem_OptimizeBroadPhase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_OptimizeBroadPhase(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_OptimizeBroadPhase$handle() {
        return JPC_PhysicsSystem_OptimizeBroadPhase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_OptimizeBroadPhase(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_OptimizeBroadPhase$address() {
        return JPC_PhysicsSystem_OptimizeBroadPhase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_OptimizeBroadPhase(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static void JPC_PhysicsSystem_OptimizeBroadPhase(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_OptimizeBroadPhase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_OptimizeBroadPhase", in_physics_system);
            }
            mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_AddStepListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_AddStepListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_AddStepListener$descriptor() {
        return JPC_PhysicsSystem_AddStepListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_AddStepListener$handle() {
        return JPC_PhysicsSystem_AddStepListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_AddStepListener$address() {
        return JPC_PhysicsSystem_AddStepListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static void JPC_PhysicsSystem_AddStepListener(MemorySegment in_physics_system, MemorySegment in_listener) {
        var mh$ = JPC_PhysicsSystem_AddStepListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_AddStepListener", in_physics_system, in_listener);
            }
            mh$.invokeExact(in_physics_system, in_listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_RemoveStepListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_RemoveStepListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_RemoveStepListener$descriptor() {
        return JPC_PhysicsSystem_RemoveStepListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_RemoveStepListener$handle() {
        return JPC_PhysicsSystem_RemoveStepListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_RemoveStepListener$address() {
        return JPC_PhysicsSystem_RemoveStepListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveStepListener(JPC_PhysicsSystem *in_physics_system, void *in_listener)
     * }
     */
    public static void JPC_PhysicsSystem_RemoveStepListener(MemorySegment in_physics_system, MemorySegment in_listener) {
        var mh$ = JPC_PhysicsSystem_RemoveStepListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_RemoveStepListener", in_physics_system, in_listener);
            }
            mh$.invokeExact(in_physics_system, in_listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_AddConstraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_AddConstraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_AddConstraint$descriptor() {
        return JPC_PhysicsSystem_AddConstraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_AddConstraint$handle() {
        return JPC_PhysicsSystem_AddConstraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_AddConstraint$address() {
        return JPC_PhysicsSystem_AddConstraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_AddConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static void JPC_PhysicsSystem_AddConstraint(MemorySegment in_physics_system, MemorySegment in_two_body_constraint) {
        var mh$ = JPC_PhysicsSystem_AddConstraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_AddConstraint", in_physics_system, in_two_body_constraint);
            }
            mh$.invokeExact(in_physics_system, in_two_body_constraint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_RemoveConstraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_RemoveConstraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_RemoveConstraint$descriptor() {
        return JPC_PhysicsSystem_RemoveConstraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_RemoveConstraint$handle() {
        return JPC_PhysicsSystem_RemoveConstraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_RemoveConstraint$address() {
        return JPC_PhysicsSystem_RemoveConstraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_RemoveConstraint(JPC_PhysicsSystem *in_physics_system, void *in_two_body_constraint)
     * }
     */
    public static void JPC_PhysicsSystem_RemoveConstraint(MemorySegment in_physics_system, MemorySegment in_two_body_constraint) {
        var mh$ = JPC_PhysicsSystem_RemoveConstraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_RemoveConstraint", in_physics_system, in_two_body_constraint);
            }
            mh$.invokeExact(in_physics_system, in_two_body_constraint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_Update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_CHAR,
            jolt.C_POINTER,
            jolt.C_FLOAT,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_Update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_PhysicsUpdateError JPC_PhysicsSystem_Update(JPC_PhysicsSystem *in_physics_system, float in_delta_time, int in_collision_steps, int in_integration_sub_steps, JPC_TempAllocator *in_temp_allocator, JPC_JobSystem *in_job_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_Update$descriptor() {
        return JPC_PhysicsSystem_Update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_PhysicsUpdateError JPC_PhysicsSystem_Update(JPC_PhysicsSystem *in_physics_system, float in_delta_time, int in_collision_steps, int in_integration_sub_steps, JPC_TempAllocator *in_temp_allocator, JPC_JobSystem *in_job_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_Update$handle() {
        return JPC_PhysicsSystem_Update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_PhysicsUpdateError JPC_PhysicsSystem_Update(JPC_PhysicsSystem *in_physics_system, float in_delta_time, int in_collision_steps, int in_integration_sub_steps, JPC_TempAllocator *in_temp_allocator, JPC_JobSystem *in_job_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_Update$address() {
        return JPC_PhysicsSystem_Update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_PhysicsUpdateError JPC_PhysicsSystem_Update(JPC_PhysicsSystem *in_physics_system, float in_delta_time, int in_collision_steps, int in_integration_sub_steps, JPC_TempAllocator *in_temp_allocator, JPC_JobSystem *in_job_system)
     * }
     */
    public static byte JPC_PhysicsSystem_Update(MemorySegment in_physics_system, float in_delta_time, int in_collision_steps, int in_integration_sub_steps, MemorySegment in_temp_allocator, MemorySegment in_job_system) {
        var mh$ = JPC_PhysicsSystem_Update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_Update", in_physics_system, in_delta_time, in_collision_steps, in_integration_sub_steps, in_temp_allocator, in_job_system);
            }
            return (byte)mh$.invokeExact(in_physics_system, in_delta_time, in_collision_steps, in_integration_sub_steps, in_temp_allocator, in_job_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyLockInterface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyLockInterface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterface(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyLockInterface$descriptor() {
        return JPC_PhysicsSystem_GetBodyLockInterface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterface(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyLockInterface$handle() {
        return JPC_PhysicsSystem_GetBodyLockInterface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterface(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyLockInterface$address() {
        return JPC_PhysicsSystem_GetBodyLockInterface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterface(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyLockInterface(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodyLockInterface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyLockInterface", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyLockInterfaceNoLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyLockInterfaceNoLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterfaceNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyLockInterfaceNoLock$descriptor() {
        return JPC_PhysicsSystem_GetBodyLockInterfaceNoLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterfaceNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyLockInterfaceNoLock$handle() {
        return JPC_PhysicsSystem_GetBodyLockInterfaceNoLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterfaceNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyLockInterfaceNoLock$address() {
        return JPC_PhysicsSystem_GetBodyLockInterfaceNoLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const JPC_BodyLockInterface *JPC_PhysicsSystem_GetBodyLockInterfaceNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyLockInterfaceNoLock(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodyLockInterfaceNoLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyLockInterfaceNoLock", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetNarrowPhaseQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetNarrowPhaseQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQuery(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetNarrowPhaseQuery$descriptor() {
        return JPC_PhysicsSystem_GetNarrowPhaseQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQuery(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetNarrowPhaseQuery$handle() {
        return JPC_PhysicsSystem_GetNarrowPhaseQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQuery(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNarrowPhaseQuery$address() {
        return JPC_PhysicsSystem_GetNarrowPhaseQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQuery(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNarrowPhaseQuery(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetNarrowPhaseQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetNarrowPhaseQuery", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock$descriptor() {
        return JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock$handle() {
        return JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock$address() {
        return JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const JPC_NarrowPhaseQuery *JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock(const JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetNarrowPhaseQueryNoLock", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodyIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodyIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodyIDs$descriptor() {
        return JPC_PhysicsSystem_GetBodyIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodyIDs$handle() {
        return JPC_PhysicsSystem_GetBodyIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodyIDs$address() {
        return JPC_PhysicsSystem_GetBodyIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static void JPC_PhysicsSystem_GetBodyIDs(MemorySegment in_physics_system, int in_max_body_ids, MemorySegment out_num_body_ids, MemorySegment out_body_ids) {
        var mh$ = JPC_PhysicsSystem_GetBodyIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodyIDs", in_physics_system, in_max_body_ids, out_num_body_ids, out_body_ids);
            }
            mh$.invokeExact(in_physics_system, in_max_body_ids, out_num_body_ids, out_body_ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetActiveBodyIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetActiveBodyIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetActiveBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetActiveBodyIDs$descriptor() {
        return JPC_PhysicsSystem_GetActiveBodyIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetActiveBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetActiveBodyIDs$handle() {
        return JPC_PhysicsSystem_GetActiveBodyIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetActiveBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetActiveBodyIDs$address() {
        return JPC_PhysicsSystem_GetActiveBodyIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_PhysicsSystem_GetActiveBodyIDs(const JPC_PhysicsSystem *in_physics_system, uint32_t in_max_body_ids, uint32_t *out_num_body_ids, JPC_BodyID *out_body_ids)
     * }
     */
    public static void JPC_PhysicsSystem_GetActiveBodyIDs(MemorySegment in_physics_system, int in_max_body_ids, MemorySegment out_num_body_ids, MemorySegment out_body_ids) {
        var mh$ = JPC_PhysicsSystem_GetActiveBodyIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetActiveBodyIDs", in_physics_system, in_max_body_ids, out_num_body_ids, out_body_ids);
            }
            mh$.invokeExact(in_physics_system, in_max_body_ids, out_num_body_ids, out_body_ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_PhysicsSystem_GetBodiesUnsafe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_PhysicsSystem_GetBodiesUnsafe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_Body **JPC_PhysicsSystem_GetBodiesUnsafe(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static FunctionDescriptor JPC_PhysicsSystem_GetBodiesUnsafe$descriptor() {
        return JPC_PhysicsSystem_GetBodiesUnsafe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_Body **JPC_PhysicsSystem_GetBodiesUnsafe(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MethodHandle JPC_PhysicsSystem_GetBodiesUnsafe$handle() {
        return JPC_PhysicsSystem_GetBodiesUnsafe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_Body **JPC_PhysicsSystem_GetBodiesUnsafe(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodiesUnsafe$address() {
        return JPC_PhysicsSystem_GetBodiesUnsafe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_Body **JPC_PhysicsSystem_GetBodiesUnsafe(JPC_PhysicsSystem *in_physics_system)
     * }
     */
    public static MemorySegment JPC_PhysicsSystem_GetBodiesUnsafe(MemorySegment in_physics_system) {
        var mh$ = JPC_PhysicsSystem_GetBodiesUnsafe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_PhysicsSystem_GetBodiesUnsafe", in_physics_system);
            }
            return (MemorySegment)mh$.invokeExact(in_physics_system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyLockInterface_LockRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyLockInterface_LockRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockRead *out_lock)
     * }
     */
    public static FunctionDescriptor JPC_BodyLockInterface_LockRead$descriptor() {
        return JPC_BodyLockInterface_LockRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockRead *out_lock)
     * }
     */
    public static MethodHandle JPC_BodyLockInterface_LockRead$handle() {
        return JPC_BodyLockInterface_LockRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockRead *out_lock)
     * }
     */
    public static MemorySegment JPC_BodyLockInterface_LockRead$address() {
        return JPC_BodyLockInterface_LockRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockRead *out_lock)
     * }
     */
    public static void JPC_BodyLockInterface_LockRead(MemorySegment in_lock_interface, int in_body_id, MemorySegment out_lock) {
        var mh$ = JPC_BodyLockInterface_LockRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyLockInterface_LockRead", in_lock_interface, in_body_id, out_lock);
            }
            mh$.invokeExact(in_lock_interface, in_body_id, out_lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyLockInterface_UnlockRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyLockInterface_UnlockRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockRead *io_lock)
     * }
     */
    public static FunctionDescriptor JPC_BodyLockInterface_UnlockRead$descriptor() {
        return JPC_BodyLockInterface_UnlockRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockRead *io_lock)
     * }
     */
    public static MethodHandle JPC_BodyLockInterface_UnlockRead$handle() {
        return JPC_BodyLockInterface_UnlockRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockRead *io_lock)
     * }
     */
    public static MemorySegment JPC_BodyLockInterface_UnlockRead$address() {
        return JPC_BodyLockInterface_UnlockRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockRead(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockRead *io_lock)
     * }
     */
    public static void JPC_BodyLockInterface_UnlockRead(MemorySegment in_lock_interface, MemorySegment io_lock) {
        var mh$ = JPC_BodyLockInterface_UnlockRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyLockInterface_UnlockRead", in_lock_interface, io_lock);
            }
            mh$.invokeExact(in_lock_interface, io_lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyLockInterface_LockWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyLockInterface_LockWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockWrite *out_lock)
     * }
     */
    public static FunctionDescriptor JPC_BodyLockInterface_LockWrite$descriptor() {
        return JPC_BodyLockInterface_LockWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockWrite *out_lock)
     * }
     */
    public static MethodHandle JPC_BodyLockInterface_LockWrite$handle() {
        return JPC_BodyLockInterface_LockWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockWrite *out_lock)
     * }
     */
    public static MemorySegment JPC_BodyLockInterface_LockWrite$address() {
        return JPC_BodyLockInterface_LockWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_LockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyID in_body_id, JPC_BodyLockWrite *out_lock)
     * }
     */
    public static void JPC_BodyLockInterface_LockWrite(MemorySegment in_lock_interface, int in_body_id, MemorySegment out_lock) {
        var mh$ = JPC_BodyLockInterface_LockWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyLockInterface_LockWrite", in_lock_interface, in_body_id, out_lock);
            }
            mh$.invokeExact(in_lock_interface, in_body_id, out_lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BodyLockInterface_UnlockWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BodyLockInterface_UnlockWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockWrite *io_lock)
     * }
     */
    public static FunctionDescriptor JPC_BodyLockInterface_UnlockWrite$descriptor() {
        return JPC_BodyLockInterface_UnlockWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockWrite *io_lock)
     * }
     */
    public static MethodHandle JPC_BodyLockInterface_UnlockWrite$handle() {
        return JPC_BodyLockInterface_UnlockWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockWrite *io_lock)
     * }
     */
    public static MemorySegment JPC_BodyLockInterface_UnlockWrite$address() {
        return JPC_BodyLockInterface_UnlockWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BodyLockInterface_UnlockWrite(const JPC_BodyLockInterface *in_lock_interface, JPC_BodyLockWrite *io_lock)
     * }
     */
    public static void JPC_BodyLockInterface_UnlockWrite(MemorySegment in_lock_interface, MemorySegment io_lock) {
        var mh$ = JPC_BodyLockInterface_UnlockWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BodyLockInterface_UnlockWrite", in_lock_interface, io_lock);
            }
            mh$.invokeExact(in_lock_interface, io_lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_NarrowPhaseQuery_CastRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_BOOL,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_NarrowPhaseQuery_CastRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool JPC_NarrowPhaseQuery_CastRay(const JPC_NarrowPhaseQuery *in_query, const JPC_RRayCast *in_ray, JPC_RayCastResult *io_hit, const void *in_broad_phase_layer_filter, const void *in_object_layer_filter, const void *in_body_filter)
     * }
     */
    public static FunctionDescriptor JPC_NarrowPhaseQuery_CastRay$descriptor() {
        return JPC_NarrowPhaseQuery_CastRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool JPC_NarrowPhaseQuery_CastRay(const JPC_NarrowPhaseQuery *in_query, const JPC_RRayCast *in_ray, JPC_RayCastResult *io_hit, const void *in_broad_phase_layer_filter, const void *in_object_layer_filter, const void *in_body_filter)
     * }
     */
    public static MethodHandle JPC_NarrowPhaseQuery_CastRay$handle() {
        return JPC_NarrowPhaseQuery_CastRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool JPC_NarrowPhaseQuery_CastRay(const JPC_NarrowPhaseQuery *in_query, const JPC_RRayCast *in_ray, JPC_RayCastResult *io_hit, const void *in_broad_phase_layer_filter, const void *in_object_layer_filter, const void *in_body_filter)
     * }
     */
    public static MemorySegment JPC_NarrowPhaseQuery_CastRay$address() {
        return JPC_NarrowPhaseQuery_CastRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool JPC_NarrowPhaseQuery_CastRay(const JPC_NarrowPhaseQuery *in_query, const JPC_RRayCast *in_ray, JPC_RayCastResult *io_hit, const void *in_broad_phase_layer_filter, const void *in_object_layer_filter, const void *in_body_filter)
     * }
     */
    public static boolean JPC_NarrowPhaseQuery_CastRay(MemorySegment in_query, MemorySegment in_ray, MemorySegment io_hit, MemorySegment in_broad_phase_layer_filter, MemorySegment in_object_layer_filter, MemorySegment in_body_filter) {
        var mh$ = JPC_NarrowPhaseQuery_CastRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_NarrowPhaseQuery_CastRay", in_query, in_ray, io_hit, in_broad_phase_layer_filter, in_object_layer_filter, in_body_filter);
            }
            return (boolean)mh$.invokeExact(in_query, in_ray, io_hit, in_broad_phase_layer_filter, in_object_layer_filter, in_body_filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_AddRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_AddRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_AddRef(JPC_ShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_AddRef$descriptor() {
        return JPC_ShapeSettings_AddRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_AddRef(JPC_ShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_AddRef$handle() {
        return JPC_ShapeSettings_AddRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_AddRef(JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_AddRef$address() {
        return JPC_ShapeSettings_AddRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ShapeSettings_AddRef(JPC_ShapeSettings *in_settings)
     * }
     */
    public static void JPC_ShapeSettings_AddRef(MemorySegment in_settings) {
        var mh$ = JPC_ShapeSettings_AddRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_AddRef", in_settings);
            }
            mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_Release(JPC_ShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_Release$descriptor() {
        return JPC_ShapeSettings_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_Release(JPC_ShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_Release$handle() {
        return JPC_ShapeSettings_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_Release(JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_Release$address() {
        return JPC_ShapeSettings_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ShapeSettings_Release(JPC_ShapeSettings *in_settings)
     * }
     */
    public static void JPC_ShapeSettings_Release(MemorySegment in_settings) {
        var mh$ = JPC_ShapeSettings_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_Release", in_settings);
            }
            mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_GetRefCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_GetRefCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_ShapeSettings_GetRefCount(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_GetRefCount$descriptor() {
        return JPC_ShapeSettings_GetRefCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_ShapeSettings_GetRefCount(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_GetRefCount$handle() {
        return JPC_ShapeSettings_GetRefCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_ShapeSettings_GetRefCount(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_GetRefCount$address() {
        return JPC_ShapeSettings_GetRefCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_ShapeSettings_GetRefCount(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static int JPC_ShapeSettings_GetRefCount(MemorySegment in_settings) {
        var mh$ = JPC_ShapeSettings_GetRefCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_GetRefCount", in_settings);
            }
            return (int)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_CreateShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_CreateShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_Shape *JPC_ShapeSettings_CreateShape(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_CreateShape$descriptor() {
        return JPC_ShapeSettings_CreateShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_Shape *JPC_ShapeSettings_CreateShape(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_CreateShape$handle() {
        return JPC_ShapeSettings_CreateShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_Shape *JPC_ShapeSettings_CreateShape(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_CreateShape$address() {
        return JPC_ShapeSettings_CreateShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_Shape *JPC_ShapeSettings_CreateShape(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_CreateShape(MemorySegment in_settings) {
        var mh$ = JPC_ShapeSettings_CreateShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_CreateShape", in_settings);
            }
            return (MemorySegment)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t JPC_ShapeSettings_GetUserData(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_GetUserData$descriptor() {
        return JPC_ShapeSettings_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t JPC_ShapeSettings_GetUserData(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_GetUserData$handle() {
        return JPC_ShapeSettings_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t JPC_ShapeSettings_GetUserData(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_GetUserData$address() {
        return JPC_ShapeSettings_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t JPC_ShapeSettings_GetUserData(const JPC_ShapeSettings *in_settings)
     * }
     */
    public static long JPC_ShapeSettings_GetUserData(MemorySegment in_settings) {
        var mh$ = JPC_ShapeSettings_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_GetUserData", in_settings);
            }
            return (long)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ShapeSettings_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ShapeSettings_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_SetUserData(JPC_ShapeSettings *in_settings, uint64_t in_user_data)
     * }
     */
    public static FunctionDescriptor JPC_ShapeSettings_SetUserData$descriptor() {
        return JPC_ShapeSettings_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_SetUserData(JPC_ShapeSettings *in_settings, uint64_t in_user_data)
     * }
     */
    public static MethodHandle JPC_ShapeSettings_SetUserData$handle() {
        return JPC_ShapeSettings_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ShapeSettings_SetUserData(JPC_ShapeSettings *in_settings, uint64_t in_user_data)
     * }
     */
    public static MemorySegment JPC_ShapeSettings_SetUserData$address() {
        return JPC_ShapeSettings_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ShapeSettings_SetUserData(JPC_ShapeSettings *in_settings, uint64_t in_user_data)
     * }
     */
    public static void JPC_ShapeSettings_SetUserData(MemorySegment in_settings, long in_user_data) {
        var mh$ = JPC_ShapeSettings_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ShapeSettings_SetUserData", in_settings, in_user_data);
            }
            mh$.invokeExact(in_settings, in_user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexShapeSettings_GetMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexShapeSettings_GetMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const JPC_PhysicsMaterial *JPC_ConvexShapeSettings_GetMaterial(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ConvexShapeSettings_GetMaterial$descriptor() {
        return JPC_ConvexShapeSettings_GetMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const JPC_PhysicsMaterial *JPC_ConvexShapeSettings_GetMaterial(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ConvexShapeSettings_GetMaterial$handle() {
        return JPC_ConvexShapeSettings_GetMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const JPC_PhysicsMaterial *JPC_ConvexShapeSettings_GetMaterial(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexShapeSettings_GetMaterial$address() {
        return JPC_ConvexShapeSettings_GetMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const JPC_PhysicsMaterial *JPC_ConvexShapeSettings_GetMaterial(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexShapeSettings_GetMaterial(MemorySegment in_settings) {
        var mh$ = JPC_ConvexShapeSettings_GetMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexShapeSettings_GetMaterial", in_settings);
            }
            return (MemorySegment)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexShapeSettings_SetMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexShapeSettings_SetMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetMaterial(JPC_ConvexShapeSettings *in_settings, const JPC_PhysicsMaterial *in_material)
     * }
     */
    public static FunctionDescriptor JPC_ConvexShapeSettings_SetMaterial$descriptor() {
        return JPC_ConvexShapeSettings_SetMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetMaterial(JPC_ConvexShapeSettings *in_settings, const JPC_PhysicsMaterial *in_material)
     * }
     */
    public static MethodHandle JPC_ConvexShapeSettings_SetMaterial$handle() {
        return JPC_ConvexShapeSettings_SetMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetMaterial(JPC_ConvexShapeSettings *in_settings, const JPC_PhysicsMaterial *in_material)
     * }
     */
    public static MemorySegment JPC_ConvexShapeSettings_SetMaterial$address() {
        return JPC_ConvexShapeSettings_SetMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetMaterial(JPC_ConvexShapeSettings *in_settings, const JPC_PhysicsMaterial *in_material)
     * }
     */
    public static void JPC_ConvexShapeSettings_SetMaterial(MemorySegment in_settings, MemorySegment in_material) {
        var mh$ = JPC_ConvexShapeSettings_SetMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexShapeSettings_SetMaterial", in_settings, in_material);
            }
            mh$.invokeExact(in_settings, in_material);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexShapeSettings_GetDensity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexShapeSettings_GetDensity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_ConvexShapeSettings_GetDensity(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ConvexShapeSettings_GetDensity$descriptor() {
        return JPC_ConvexShapeSettings_GetDensity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_ConvexShapeSettings_GetDensity(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ConvexShapeSettings_GetDensity$handle() {
        return JPC_ConvexShapeSettings_GetDensity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_ConvexShapeSettings_GetDensity(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexShapeSettings_GetDensity$address() {
        return JPC_ConvexShapeSettings_GetDensity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_ConvexShapeSettings_GetDensity(const JPC_ConvexShapeSettings *in_settings)
     * }
     */
    public static float JPC_ConvexShapeSettings_GetDensity(MemorySegment in_settings) {
        var mh$ = JPC_ConvexShapeSettings_GetDensity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexShapeSettings_GetDensity", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexShapeSettings_SetDensity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexShapeSettings_SetDensity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetDensity(JPC_ConvexShapeSettings *in_settings, float in_density)
     * }
     */
    public static FunctionDescriptor JPC_ConvexShapeSettings_SetDensity$descriptor() {
        return JPC_ConvexShapeSettings_SetDensity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetDensity(JPC_ConvexShapeSettings *in_settings, float in_density)
     * }
     */
    public static MethodHandle JPC_ConvexShapeSettings_SetDensity$handle() {
        return JPC_ConvexShapeSettings_SetDensity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetDensity(JPC_ConvexShapeSettings *in_settings, float in_density)
     * }
     */
    public static MemorySegment JPC_ConvexShapeSettings_SetDensity$address() {
        return JPC_ConvexShapeSettings_SetDensity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ConvexShapeSettings_SetDensity(JPC_ConvexShapeSettings *in_settings, float in_density)
     * }
     */
    public static void JPC_ConvexShapeSettings_SetDensity(MemorySegment in_settings, float in_density) {
        var mh$ = JPC_ConvexShapeSettings_SetDensity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexShapeSettings_SetDensity", in_settings, in_density);
            }
            mh$.invokeExact(in_settings, in_density);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BoxShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BoxShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_BoxShapeSettings *JPC_BoxShapeSettings_Create(const float in_half_extent[3])
     * }
     */
    public static FunctionDescriptor JPC_BoxShapeSettings_Create$descriptor() {
        return JPC_BoxShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_BoxShapeSettings *JPC_BoxShapeSettings_Create(const float in_half_extent[3])
     * }
     */
    public static MethodHandle JPC_BoxShapeSettings_Create$handle() {
        return JPC_BoxShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_BoxShapeSettings *JPC_BoxShapeSettings_Create(const float in_half_extent[3])
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_Create$address() {
        return JPC_BoxShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_BoxShapeSettings *JPC_BoxShapeSettings_Create(const float in_half_extent[3])
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_Create(MemorySegment in_half_extent) {
        var mh$ = JPC_BoxShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BoxShapeSettings_Create", in_half_extent);
            }
            return (MemorySegment)mh$.invokeExact(in_half_extent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BoxShapeSettings_GetHalfExtent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BoxShapeSettings_GetHalfExtent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_GetHalfExtent(const JPC_BoxShapeSettings *in_settings, float out_half_extent[3])
     * }
     */
    public static FunctionDescriptor JPC_BoxShapeSettings_GetHalfExtent$descriptor() {
        return JPC_BoxShapeSettings_GetHalfExtent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_GetHalfExtent(const JPC_BoxShapeSettings *in_settings, float out_half_extent[3])
     * }
     */
    public static MethodHandle JPC_BoxShapeSettings_GetHalfExtent$handle() {
        return JPC_BoxShapeSettings_GetHalfExtent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_GetHalfExtent(const JPC_BoxShapeSettings *in_settings, float out_half_extent[3])
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_GetHalfExtent$address() {
        return JPC_BoxShapeSettings_GetHalfExtent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_GetHalfExtent(const JPC_BoxShapeSettings *in_settings, float out_half_extent[3])
     * }
     */
    public static void JPC_BoxShapeSettings_GetHalfExtent(MemorySegment in_settings, MemorySegment out_half_extent) {
        var mh$ = JPC_BoxShapeSettings_GetHalfExtent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BoxShapeSettings_GetHalfExtent", in_settings, out_half_extent);
            }
            mh$.invokeExact(in_settings, out_half_extent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BoxShapeSettings_SetHalfExtent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BoxShapeSettings_SetHalfExtent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetHalfExtent(JPC_BoxShapeSettings *in_settings, const float in_half_extent[3])
     * }
     */
    public static FunctionDescriptor JPC_BoxShapeSettings_SetHalfExtent$descriptor() {
        return JPC_BoxShapeSettings_SetHalfExtent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetHalfExtent(JPC_BoxShapeSettings *in_settings, const float in_half_extent[3])
     * }
     */
    public static MethodHandle JPC_BoxShapeSettings_SetHalfExtent$handle() {
        return JPC_BoxShapeSettings_SetHalfExtent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetHalfExtent(JPC_BoxShapeSettings *in_settings, const float in_half_extent[3])
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_SetHalfExtent$address() {
        return JPC_BoxShapeSettings_SetHalfExtent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetHalfExtent(JPC_BoxShapeSettings *in_settings, const float in_half_extent[3])
     * }
     */
    public static void JPC_BoxShapeSettings_SetHalfExtent(MemorySegment in_settings, MemorySegment in_half_extent) {
        var mh$ = JPC_BoxShapeSettings_SetHalfExtent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BoxShapeSettings_SetHalfExtent", in_settings, in_half_extent);
            }
            mh$.invokeExact(in_settings, in_half_extent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BoxShapeSettings_GetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BoxShapeSettings_GetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_BoxShapeSettings_GetConvexRadius(const JPC_BoxShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_BoxShapeSettings_GetConvexRadius$descriptor() {
        return JPC_BoxShapeSettings_GetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_BoxShapeSettings_GetConvexRadius(const JPC_BoxShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_BoxShapeSettings_GetConvexRadius$handle() {
        return JPC_BoxShapeSettings_GetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_BoxShapeSettings_GetConvexRadius(const JPC_BoxShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_GetConvexRadius$address() {
        return JPC_BoxShapeSettings_GetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_BoxShapeSettings_GetConvexRadius(const JPC_BoxShapeSettings *in_settings)
     * }
     */
    public static float JPC_BoxShapeSettings_GetConvexRadius(MemorySegment in_settings) {
        var mh$ = JPC_BoxShapeSettings_GetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BoxShapeSettings_GetConvexRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_BoxShapeSettings_SetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_BoxShapeSettings_SetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetConvexRadius(JPC_BoxShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static FunctionDescriptor JPC_BoxShapeSettings_SetConvexRadius$descriptor() {
        return JPC_BoxShapeSettings_SetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetConvexRadius(JPC_BoxShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MethodHandle JPC_BoxShapeSettings_SetConvexRadius$handle() {
        return JPC_BoxShapeSettings_SetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetConvexRadius(JPC_BoxShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MemorySegment JPC_BoxShapeSettings_SetConvexRadius$address() {
        return JPC_BoxShapeSettings_SetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_BoxShapeSettings_SetConvexRadius(JPC_BoxShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static void JPC_BoxShapeSettings_SetConvexRadius(MemorySegment in_settings, float in_convex_radius) {
        var mh$ = JPC_BoxShapeSettings_SetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_BoxShapeSettings_SetConvexRadius", in_settings, in_convex_radius);
            }
            mh$.invokeExact(in_settings, in_convex_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_SphereShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_SphereShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_SphereShapeSettings *JPC_SphereShapeSettings_Create(float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_SphereShapeSettings_Create$descriptor() {
        return JPC_SphereShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_SphereShapeSettings *JPC_SphereShapeSettings_Create(float in_radius)
     * }
     */
    public static MethodHandle JPC_SphereShapeSettings_Create$handle() {
        return JPC_SphereShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_SphereShapeSettings *JPC_SphereShapeSettings_Create(float in_radius)
     * }
     */
    public static MemorySegment JPC_SphereShapeSettings_Create$address() {
        return JPC_SphereShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_SphereShapeSettings *JPC_SphereShapeSettings_Create(float in_radius)
     * }
     */
    public static MemorySegment JPC_SphereShapeSettings_Create(float in_radius) {
        var mh$ = JPC_SphereShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_SphereShapeSettings_Create", in_radius);
            }
            return (MemorySegment)mh$.invokeExact(in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_SphereShapeSettings_GetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_SphereShapeSettings_GetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_SphereShapeSettings_GetRadius(const JPC_SphereShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_SphereShapeSettings_GetRadius$descriptor() {
        return JPC_SphereShapeSettings_GetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_SphereShapeSettings_GetRadius(const JPC_SphereShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_SphereShapeSettings_GetRadius$handle() {
        return JPC_SphereShapeSettings_GetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_SphereShapeSettings_GetRadius(const JPC_SphereShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_SphereShapeSettings_GetRadius$address() {
        return JPC_SphereShapeSettings_GetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_SphereShapeSettings_GetRadius(const JPC_SphereShapeSettings *in_settings)
     * }
     */
    public static float JPC_SphereShapeSettings_GetRadius(MemorySegment in_settings) {
        var mh$ = JPC_SphereShapeSettings_GetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_SphereShapeSettings_GetRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_SphereShapeSettings_SetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_SphereShapeSettings_SetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_SphereShapeSettings_SetRadius(JPC_SphereShapeSettings *in_settings, float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_SphereShapeSettings_SetRadius$descriptor() {
        return JPC_SphereShapeSettings_SetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_SphereShapeSettings_SetRadius(JPC_SphereShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MethodHandle JPC_SphereShapeSettings_SetRadius$handle() {
        return JPC_SphereShapeSettings_SetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_SphereShapeSettings_SetRadius(JPC_SphereShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MemorySegment JPC_SphereShapeSettings_SetRadius$address() {
        return JPC_SphereShapeSettings_SetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_SphereShapeSettings_SetRadius(JPC_SphereShapeSettings *in_settings, float in_radius)
     * }
     */
    public static void JPC_SphereShapeSettings_SetRadius(MemorySegment in_settings, float in_radius) {
        var mh$ = JPC_SphereShapeSettings_SetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_SphereShapeSettings_SetRadius", in_settings, in_radius);
            }
            mh$.invokeExact(in_settings, in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TriangleShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TriangleShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_TriangleShapeSettings *JPC_TriangleShapeSettings_Create(const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static FunctionDescriptor JPC_TriangleShapeSettings_Create$descriptor() {
        return JPC_TriangleShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_TriangleShapeSettings *JPC_TriangleShapeSettings_Create(const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static MethodHandle JPC_TriangleShapeSettings_Create$handle() {
        return JPC_TriangleShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_TriangleShapeSettings *JPC_TriangleShapeSettings_Create(const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_Create$address() {
        return JPC_TriangleShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_TriangleShapeSettings *JPC_TriangleShapeSettings_Create(const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_Create(MemorySegment in_v1, MemorySegment in_v2, MemorySegment in_v3) {
        var mh$ = JPC_TriangleShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TriangleShapeSettings_Create", in_v1, in_v2, in_v3);
            }
            return (MemorySegment)mh$.invokeExact(in_v1, in_v2, in_v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TriangleShapeSettings_SetVertices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TriangleShapeSettings_SetVertices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetVertices(JPC_TriangleShapeSettings *in_settings, const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static FunctionDescriptor JPC_TriangleShapeSettings_SetVertices$descriptor() {
        return JPC_TriangleShapeSettings_SetVertices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetVertices(JPC_TriangleShapeSettings *in_settings, const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static MethodHandle JPC_TriangleShapeSettings_SetVertices$handle() {
        return JPC_TriangleShapeSettings_SetVertices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetVertices(JPC_TriangleShapeSettings *in_settings, const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_SetVertices$address() {
        return JPC_TriangleShapeSettings_SetVertices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetVertices(JPC_TriangleShapeSettings *in_settings, const float in_v1[3], const float in_v2[3], const float in_v3[3])
     * }
     */
    public static void JPC_TriangleShapeSettings_SetVertices(MemorySegment in_settings, MemorySegment in_v1, MemorySegment in_v2, MemorySegment in_v3) {
        var mh$ = JPC_TriangleShapeSettings_SetVertices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TriangleShapeSettings_SetVertices", in_settings, in_v1, in_v2, in_v3);
            }
            mh$.invokeExact(in_settings, in_v1, in_v2, in_v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TriangleShapeSettings_GetVertices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TriangleShapeSettings_GetVertices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_GetVertices(const JPC_TriangleShapeSettings *in_settings, float out_v1[3], float out_v2[3], float out_v3[3])
     * }
     */
    public static FunctionDescriptor JPC_TriangleShapeSettings_GetVertices$descriptor() {
        return JPC_TriangleShapeSettings_GetVertices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_GetVertices(const JPC_TriangleShapeSettings *in_settings, float out_v1[3], float out_v2[3], float out_v3[3])
     * }
     */
    public static MethodHandle JPC_TriangleShapeSettings_GetVertices$handle() {
        return JPC_TriangleShapeSettings_GetVertices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_GetVertices(const JPC_TriangleShapeSettings *in_settings, float out_v1[3], float out_v2[3], float out_v3[3])
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_GetVertices$address() {
        return JPC_TriangleShapeSettings_GetVertices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_GetVertices(const JPC_TriangleShapeSettings *in_settings, float out_v1[3], float out_v2[3], float out_v3[3])
     * }
     */
    public static void JPC_TriangleShapeSettings_GetVertices(MemorySegment in_settings, MemorySegment out_v1, MemorySegment out_v2, MemorySegment out_v3) {
        var mh$ = JPC_TriangleShapeSettings_GetVertices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TriangleShapeSettings_GetVertices", in_settings, out_v1, out_v2, out_v3);
            }
            mh$.invokeExact(in_settings, out_v1, out_v2, out_v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TriangleShapeSettings_GetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TriangleShapeSettings_GetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_TriangleShapeSettings_GetConvexRadius(const JPC_TriangleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_TriangleShapeSettings_GetConvexRadius$descriptor() {
        return JPC_TriangleShapeSettings_GetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_TriangleShapeSettings_GetConvexRadius(const JPC_TriangleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_TriangleShapeSettings_GetConvexRadius$handle() {
        return JPC_TriangleShapeSettings_GetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_TriangleShapeSettings_GetConvexRadius(const JPC_TriangleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_GetConvexRadius$address() {
        return JPC_TriangleShapeSettings_GetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_TriangleShapeSettings_GetConvexRadius(const JPC_TriangleShapeSettings *in_settings)
     * }
     */
    public static float JPC_TriangleShapeSettings_GetConvexRadius(MemorySegment in_settings) {
        var mh$ = JPC_TriangleShapeSettings_GetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TriangleShapeSettings_GetConvexRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TriangleShapeSettings_SetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TriangleShapeSettings_SetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetConvexRadius(JPC_TriangleShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static FunctionDescriptor JPC_TriangleShapeSettings_SetConvexRadius$descriptor() {
        return JPC_TriangleShapeSettings_SetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetConvexRadius(JPC_TriangleShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MethodHandle JPC_TriangleShapeSettings_SetConvexRadius$handle() {
        return JPC_TriangleShapeSettings_SetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetConvexRadius(JPC_TriangleShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MemorySegment JPC_TriangleShapeSettings_SetConvexRadius$address() {
        return JPC_TriangleShapeSettings_SetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TriangleShapeSettings_SetConvexRadius(JPC_TriangleShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static void JPC_TriangleShapeSettings_SetConvexRadius(MemorySegment in_settings, float in_convex_radius) {
        var mh$ = JPC_TriangleShapeSettings_SetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TriangleShapeSettings_SetConvexRadius", in_settings, in_convex_radius);
            }
            mh$.invokeExact(in_settings, in_convex_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CapsuleShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_FLOAT,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CapsuleShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_CapsuleShapeSettings *JPC_CapsuleShapeSettings_Create(float in_half_height_of_cylinder, float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_CapsuleShapeSettings_Create$descriptor() {
        return JPC_CapsuleShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_CapsuleShapeSettings *JPC_CapsuleShapeSettings_Create(float in_half_height_of_cylinder, float in_radius)
     * }
     */
    public static MethodHandle JPC_CapsuleShapeSettings_Create$handle() {
        return JPC_CapsuleShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_CapsuleShapeSettings *JPC_CapsuleShapeSettings_Create(float in_half_height_of_cylinder, float in_radius)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_Create$address() {
        return JPC_CapsuleShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_CapsuleShapeSettings *JPC_CapsuleShapeSettings_Create(float in_half_height_of_cylinder, float in_radius)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_Create(float in_half_height_of_cylinder, float in_radius) {
        var mh$ = JPC_CapsuleShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CapsuleShapeSettings_Create", in_half_height_of_cylinder, in_radius);
            }
            return (MemorySegment)mh$.invokeExact(in_half_height_of_cylinder, in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CapsuleShapeSettings_GetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CapsuleShapeSettings_GetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetHalfHeight(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_CapsuleShapeSettings_GetHalfHeight$descriptor() {
        return JPC_CapsuleShapeSettings_GetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetHalfHeight(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_CapsuleShapeSettings_GetHalfHeight$handle() {
        return JPC_CapsuleShapeSettings_GetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetHalfHeight(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_GetHalfHeight$address() {
        return JPC_CapsuleShapeSettings_GetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetHalfHeight(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static float JPC_CapsuleShapeSettings_GetHalfHeight(MemorySegment in_settings) {
        var mh$ = JPC_CapsuleShapeSettings_GetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CapsuleShapeSettings_GetHalfHeight", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CapsuleShapeSettings_SetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CapsuleShapeSettings_SetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetHalfHeight(JPC_CapsuleShapeSettings *in_settings, float in_half_height_of_cylinder)
     * }
     */
    public static FunctionDescriptor JPC_CapsuleShapeSettings_SetHalfHeight$descriptor() {
        return JPC_CapsuleShapeSettings_SetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetHalfHeight(JPC_CapsuleShapeSettings *in_settings, float in_half_height_of_cylinder)
     * }
     */
    public static MethodHandle JPC_CapsuleShapeSettings_SetHalfHeight$handle() {
        return JPC_CapsuleShapeSettings_SetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetHalfHeight(JPC_CapsuleShapeSettings *in_settings, float in_half_height_of_cylinder)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_SetHalfHeight$address() {
        return JPC_CapsuleShapeSettings_SetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetHalfHeight(JPC_CapsuleShapeSettings *in_settings, float in_half_height_of_cylinder)
     * }
     */
    public static void JPC_CapsuleShapeSettings_SetHalfHeight(MemorySegment in_settings, float in_half_height_of_cylinder) {
        var mh$ = JPC_CapsuleShapeSettings_SetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CapsuleShapeSettings_SetHalfHeight", in_settings, in_half_height_of_cylinder);
            }
            mh$.invokeExact(in_settings, in_half_height_of_cylinder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CapsuleShapeSettings_GetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CapsuleShapeSettings_GetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetRadius(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_CapsuleShapeSettings_GetRadius$descriptor() {
        return JPC_CapsuleShapeSettings_GetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetRadius(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_CapsuleShapeSettings_GetRadius$handle() {
        return JPC_CapsuleShapeSettings_GetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetRadius(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_GetRadius$address() {
        return JPC_CapsuleShapeSettings_GetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_CapsuleShapeSettings_GetRadius(const JPC_CapsuleShapeSettings *in_settings)
     * }
     */
    public static float JPC_CapsuleShapeSettings_GetRadius(MemorySegment in_settings) {
        var mh$ = JPC_CapsuleShapeSettings_GetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CapsuleShapeSettings_GetRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CapsuleShapeSettings_SetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CapsuleShapeSettings_SetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetRadius(JPC_CapsuleShapeSettings *in_settings, float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_CapsuleShapeSettings_SetRadius$descriptor() {
        return JPC_CapsuleShapeSettings_SetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetRadius(JPC_CapsuleShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MethodHandle JPC_CapsuleShapeSettings_SetRadius$handle() {
        return JPC_CapsuleShapeSettings_SetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetRadius(JPC_CapsuleShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MemorySegment JPC_CapsuleShapeSettings_SetRadius$address() {
        return JPC_CapsuleShapeSettings_SetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CapsuleShapeSettings_SetRadius(JPC_CapsuleShapeSettings *in_settings, float in_radius)
     * }
     */
    public static void JPC_CapsuleShapeSettings_SetRadius(MemorySegment in_settings, float in_radius) {
        var mh$ = JPC_CapsuleShapeSettings_SetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CapsuleShapeSettings_SetRadius", in_settings, in_radius);
            }
            mh$.invokeExact(in_settings, in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_FLOAT,
            jolt.C_FLOAT,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_TaperedCapsuleShapeSettings *JPC_TaperedCapsuleShapeSettings_Create(float in_half_height, float in_top_radius, float in_bottom_radius)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_Create$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_TaperedCapsuleShapeSettings *JPC_TaperedCapsuleShapeSettings_Create(float in_half_height, float in_top_radius, float in_bottom_radius)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_Create$handle() {
        return JPC_TaperedCapsuleShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_TaperedCapsuleShapeSettings *JPC_TaperedCapsuleShapeSettings_Create(float in_half_height, float in_top_radius, float in_bottom_radius)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_Create$address() {
        return JPC_TaperedCapsuleShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_TaperedCapsuleShapeSettings *JPC_TaperedCapsuleShapeSettings_Create(float in_half_height, float in_top_radius, float in_bottom_radius)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_Create(float in_half_height, float in_top_radius, float in_bottom_radius) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_Create", in_half_height, in_top_radius, in_bottom_radius);
            }
            return (MemorySegment)mh$.invokeExact(in_half_height, in_top_radius, in_bottom_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_GetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_GetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetHalfHeight(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_GetHalfHeight$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_GetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetHalfHeight(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_GetHalfHeight$handle() {
        return JPC_TaperedCapsuleShapeSettings_GetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetHalfHeight(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_GetHalfHeight$address() {
        return JPC_TaperedCapsuleShapeSettings_GetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetHalfHeight(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static float JPC_TaperedCapsuleShapeSettings_GetHalfHeight(MemorySegment in_settings) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_GetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_GetHalfHeight", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_SetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_SetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetHalfHeight(JPC_TaperedCapsuleShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_SetHalfHeight$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_SetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetHalfHeight(JPC_TaperedCapsuleShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_SetHalfHeight$handle() {
        return JPC_TaperedCapsuleShapeSettings_SetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetHalfHeight(JPC_TaperedCapsuleShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_SetHalfHeight$address() {
        return JPC_TaperedCapsuleShapeSettings_SetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetHalfHeight(JPC_TaperedCapsuleShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static void JPC_TaperedCapsuleShapeSettings_SetHalfHeight(MemorySegment in_settings, float in_half_height) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_SetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_SetHalfHeight", in_settings, in_half_height);
            }
            mh$.invokeExact(in_settings, in_half_height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_GetTopRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_GetTopRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetTopRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_GetTopRadius$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_GetTopRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetTopRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_GetTopRadius$handle() {
        return JPC_TaperedCapsuleShapeSettings_GetTopRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetTopRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_GetTopRadius$address() {
        return JPC_TaperedCapsuleShapeSettings_GetTopRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetTopRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static float JPC_TaperedCapsuleShapeSettings_GetTopRadius(MemorySegment in_settings) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_GetTopRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_GetTopRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_SetTopRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_SetTopRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetTopRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_top_radius)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_SetTopRadius$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_SetTopRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetTopRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_top_radius)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_SetTopRadius$handle() {
        return JPC_TaperedCapsuleShapeSettings_SetTopRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetTopRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_top_radius)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_SetTopRadius$address() {
        return JPC_TaperedCapsuleShapeSettings_SetTopRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetTopRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_top_radius)
     * }
     */
    public static void JPC_TaperedCapsuleShapeSettings_SetTopRadius(MemorySegment in_settings, float in_top_radius) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_SetTopRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_SetTopRadius", in_settings, in_top_radius);
            }
            mh$.invokeExact(in_settings, in_top_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_GetBottomRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_GetBottomRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetBottomRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_GetBottomRadius$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_GetBottomRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetBottomRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_GetBottomRadius$handle() {
        return JPC_TaperedCapsuleShapeSettings_GetBottomRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetBottomRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_GetBottomRadius$address() {
        return JPC_TaperedCapsuleShapeSettings_GetBottomRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_TaperedCapsuleShapeSettings_GetBottomRadius(const JPC_TaperedCapsuleShapeSettings *in_settings)
     * }
     */
    public static float JPC_TaperedCapsuleShapeSettings_GetBottomRadius(MemorySegment in_settings) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_GetBottomRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_GetBottomRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_TaperedCapsuleShapeSettings_SetBottomRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_TaperedCapsuleShapeSettings_SetBottomRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetBottomRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_bottom_radius)
     * }
     */
    public static FunctionDescriptor JPC_TaperedCapsuleShapeSettings_SetBottomRadius$descriptor() {
        return JPC_TaperedCapsuleShapeSettings_SetBottomRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetBottomRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_bottom_radius)
     * }
     */
    public static MethodHandle JPC_TaperedCapsuleShapeSettings_SetBottomRadius$handle() {
        return JPC_TaperedCapsuleShapeSettings_SetBottomRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetBottomRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_bottom_radius)
     * }
     */
    public static MemorySegment JPC_TaperedCapsuleShapeSettings_SetBottomRadius$address() {
        return JPC_TaperedCapsuleShapeSettings_SetBottomRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_TaperedCapsuleShapeSettings_SetBottomRadius(JPC_TaperedCapsuleShapeSettings *in_settings, float in_bottom_radius)
     * }
     */
    public static void JPC_TaperedCapsuleShapeSettings_SetBottomRadius(MemorySegment in_settings, float in_bottom_radius) {
        var mh$ = JPC_TaperedCapsuleShapeSettings_SetBottomRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_TaperedCapsuleShapeSettings_SetBottomRadius", in_settings, in_bottom_radius);
            }
            mh$.invokeExact(in_settings, in_bottom_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_FLOAT,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_CylinderShapeSettings *JPC_CylinderShapeSettings_Create(float in_half_height, float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_Create$descriptor() {
        return JPC_CylinderShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_CylinderShapeSettings *JPC_CylinderShapeSettings_Create(float in_half_height, float in_radius)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_Create$handle() {
        return JPC_CylinderShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_CylinderShapeSettings *JPC_CylinderShapeSettings_Create(float in_half_height, float in_radius)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_Create$address() {
        return JPC_CylinderShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_CylinderShapeSettings *JPC_CylinderShapeSettings_Create(float in_half_height, float in_radius)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_Create(float in_half_height, float in_radius) {
        var mh$ = JPC_CylinderShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_Create", in_half_height, in_radius);
            }
            return (MemorySegment)mh$.invokeExact(in_half_height, in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_GetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_GetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetConvexRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_GetConvexRadius$descriptor() {
        return JPC_CylinderShapeSettings_GetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetConvexRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_GetConvexRadius$handle() {
        return JPC_CylinderShapeSettings_GetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetConvexRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_GetConvexRadius$address() {
        return JPC_CylinderShapeSettings_GetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetConvexRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static float JPC_CylinderShapeSettings_GetConvexRadius(MemorySegment in_settings) {
        var mh$ = JPC_CylinderShapeSettings_GetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_GetConvexRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_SetConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_SetConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetConvexRadius(JPC_CylinderShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_SetConvexRadius$descriptor() {
        return JPC_CylinderShapeSettings_SetConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetConvexRadius(JPC_CylinderShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_SetConvexRadius$handle() {
        return JPC_CylinderShapeSettings_SetConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetConvexRadius(JPC_CylinderShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_SetConvexRadius$address() {
        return JPC_CylinderShapeSettings_SetConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetConvexRadius(JPC_CylinderShapeSettings *in_settings, float in_convex_radius)
     * }
     */
    public static void JPC_CylinderShapeSettings_SetConvexRadius(MemorySegment in_settings, float in_convex_radius) {
        var mh$ = JPC_CylinderShapeSettings_SetConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_SetConvexRadius", in_settings, in_convex_radius);
            }
            mh$.invokeExact(in_settings, in_convex_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_GetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_GetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetHalfHeight(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_GetHalfHeight$descriptor() {
        return JPC_CylinderShapeSettings_GetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetHalfHeight(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_GetHalfHeight$handle() {
        return JPC_CylinderShapeSettings_GetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetHalfHeight(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_GetHalfHeight$address() {
        return JPC_CylinderShapeSettings_GetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetHalfHeight(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static float JPC_CylinderShapeSettings_GetHalfHeight(MemorySegment in_settings) {
        var mh$ = JPC_CylinderShapeSettings_GetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_GetHalfHeight", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_SetHalfHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_SetHalfHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetHalfHeight(JPC_CylinderShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_SetHalfHeight$descriptor() {
        return JPC_CylinderShapeSettings_SetHalfHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetHalfHeight(JPC_CylinderShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_SetHalfHeight$handle() {
        return JPC_CylinderShapeSettings_SetHalfHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetHalfHeight(JPC_CylinderShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_SetHalfHeight$address() {
        return JPC_CylinderShapeSettings_SetHalfHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetHalfHeight(JPC_CylinderShapeSettings *in_settings, float in_half_height)
     * }
     */
    public static void JPC_CylinderShapeSettings_SetHalfHeight(MemorySegment in_settings, float in_half_height) {
        var mh$ = JPC_CylinderShapeSettings_SetHalfHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_SetHalfHeight", in_settings, in_half_height);
            }
            mh$.invokeExact(in_settings, in_half_height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_GetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_GetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_GetRadius$descriptor() {
        return JPC_CylinderShapeSettings_GetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_GetRadius$handle() {
        return JPC_CylinderShapeSettings_GetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_GetRadius$address() {
        return JPC_CylinderShapeSettings_GetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_CylinderShapeSettings_GetRadius(const JPC_CylinderShapeSettings *in_settings)
     * }
     */
    public static float JPC_CylinderShapeSettings_GetRadius(MemorySegment in_settings) {
        var mh$ = JPC_CylinderShapeSettings_GetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_GetRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_CylinderShapeSettings_SetRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CylinderShapeSettings_SetRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetRadius(JPC_CylinderShapeSettings *in_settings, float in_radius)
     * }
     */
    public static FunctionDescriptor JPC_CylinderShapeSettings_SetRadius$descriptor() {
        return JPC_CylinderShapeSettings_SetRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetRadius(JPC_CylinderShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MethodHandle JPC_CylinderShapeSettings_SetRadius$handle() {
        return JPC_CylinderShapeSettings_SetRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetRadius(JPC_CylinderShapeSettings *in_settings, float in_radius)
     * }
     */
    public static MemorySegment JPC_CylinderShapeSettings_SetRadius$address() {
        return JPC_CylinderShapeSettings_SetRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CylinderShapeSettings_SetRadius(JPC_CylinderShapeSettings *in_settings, float in_radius)
     * }
     */
    public static void JPC_CylinderShapeSettings_SetRadius(MemorySegment in_settings, float in_radius) {
        var mh$ = JPC_CylinderShapeSettings_SetRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CylinderShapeSettings_SetRadius", in_settings, in_radius);
            }
            mh$.invokeExact(in_settings, in_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_ConvexHullShapeSettings *JPC_ConvexHullShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_Create$descriptor() {
        return JPC_ConvexHullShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_ConvexHullShapeSettings *JPC_ConvexHullShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_Create$handle() {
        return JPC_ConvexHullShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_ConvexHullShapeSettings *JPC_ConvexHullShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_Create$address() {
        return JPC_ConvexHullShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_ConvexHullShapeSettings *JPC_ConvexHullShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_Create(MemorySegment in_vertices, int in_num_vertices, int in_vertex_size) {
        var mh$ = JPC_ConvexHullShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_Create", in_vertices, in_num_vertices, in_vertex_size);
            }
            return (MemorySegment)mh$.invokeExact(in_vertices, in_num_vertices, in_vertex_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_GetMaxConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_GetMaxConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_GetMaxConvexRadius$descriptor() {
        return JPC_ConvexHullShapeSettings_GetMaxConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_GetMaxConvexRadius$handle() {
        return JPC_ConvexHullShapeSettings_GetMaxConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_GetMaxConvexRadius$address() {
        return JPC_ConvexHullShapeSettings_GetMaxConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static float JPC_ConvexHullShapeSettings_GetMaxConvexRadius(MemorySegment in_settings) {
        var mh$ = JPC_ConvexHullShapeSettings_GetMaxConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_GetMaxConvexRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_SetMaxConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_SetMaxConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_convex_radius)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_SetMaxConvexRadius$descriptor() {
        return JPC_ConvexHullShapeSettings_SetMaxConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_convex_radius)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_SetMaxConvexRadius$handle() {
        return JPC_ConvexHullShapeSettings_SetMaxConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_convex_radius)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_SetMaxConvexRadius$address() {
        return JPC_ConvexHullShapeSettings_SetMaxConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_convex_radius)
     * }
     */
    public static void JPC_ConvexHullShapeSettings_SetMaxConvexRadius(MemorySegment in_settings, float in_max_convex_radius) {
        var mh$ = JPC_ConvexHullShapeSettings_SetMaxConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_SetMaxConvexRadius", in_settings, in_max_convex_radius);
            }
            mh$.invokeExact(in_settings, in_max_convex_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius$descriptor() {
        return JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius$handle() {
        return JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius$address() {
        return JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static float JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius(MemorySegment in_settings) {
        var mh$ = JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_GetMaxErrorConvexRadius", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_err_convex_radius)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius$descriptor() {
        return JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_err_convex_radius)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius$handle() {
        return JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_err_convex_radius)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius$address() {
        return JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius(JPC_ConvexHullShapeSettings *in_settings, float in_max_err_convex_radius)
     * }
     */
    public static void JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius(MemorySegment in_settings, float in_max_err_convex_radius) {
        var mh$ = JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_SetMaxErrorConvexRadius", in_settings, in_max_err_convex_radius);
            }
            mh$.invokeExact(in_settings, in_max_err_convex_radius);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_GetHullTolerance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_FLOAT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_GetHullTolerance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetHullTolerance(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_GetHullTolerance$descriptor() {
        return JPC_ConvexHullShapeSettings_GetHullTolerance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetHullTolerance(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_GetHullTolerance$handle() {
        return JPC_ConvexHullShapeSettings_GetHullTolerance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetHullTolerance(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_GetHullTolerance$address() {
        return JPC_ConvexHullShapeSettings_GetHullTolerance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float JPC_ConvexHullShapeSettings_GetHullTolerance(const JPC_ConvexHullShapeSettings *in_settings)
     * }
     */
    public static float JPC_ConvexHullShapeSettings_GetHullTolerance(MemorySegment in_settings) {
        var mh$ = JPC_ConvexHullShapeSettings_GetHullTolerance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_GetHullTolerance", in_settings);
            }
            return (float)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ConvexHullShapeSettings_SetHullTolerance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_FLOAT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ConvexHullShapeSettings_SetHullTolerance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetHullTolerance(JPC_ConvexHullShapeSettings *in_settings, float in_hull_tolerance)
     * }
     */
    public static FunctionDescriptor JPC_ConvexHullShapeSettings_SetHullTolerance$descriptor() {
        return JPC_ConvexHullShapeSettings_SetHullTolerance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetHullTolerance(JPC_ConvexHullShapeSettings *in_settings, float in_hull_tolerance)
     * }
     */
    public static MethodHandle JPC_ConvexHullShapeSettings_SetHullTolerance$handle() {
        return JPC_ConvexHullShapeSettings_SetHullTolerance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetHullTolerance(JPC_ConvexHullShapeSettings *in_settings, float in_hull_tolerance)
     * }
     */
    public static MemorySegment JPC_ConvexHullShapeSettings_SetHullTolerance$address() {
        return JPC_ConvexHullShapeSettings_SetHullTolerance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_ConvexHullShapeSettings_SetHullTolerance(JPC_ConvexHullShapeSettings *in_settings, float in_hull_tolerance)
     * }
     */
    public static void JPC_ConvexHullShapeSettings_SetHullTolerance(MemorySegment in_settings, float in_hull_tolerance) {
        var mh$ = JPC_ConvexHullShapeSettings_SetHullTolerance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ConvexHullShapeSettings_SetHullTolerance", in_settings, in_hull_tolerance);
            }
            mh$.invokeExact(in_settings, in_hull_tolerance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_HeightFieldShapeSettings *JPC_HeightFieldShapeSettings_Create(const float *in_samples, uint32_t in_height_field_size)
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_Create$descriptor() {
        return JPC_HeightFieldShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_HeightFieldShapeSettings *JPC_HeightFieldShapeSettings_Create(const float *in_samples, uint32_t in_height_field_size)
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_Create$handle() {
        return JPC_HeightFieldShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_HeightFieldShapeSettings *JPC_HeightFieldShapeSettings_Create(const float *in_samples, uint32_t in_height_field_size)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_Create$address() {
        return JPC_HeightFieldShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_HeightFieldShapeSettings *JPC_HeightFieldShapeSettings_Create(const float *in_samples, uint32_t in_height_field_size)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_Create(MemorySegment in_samples, int in_height_field_size) {
        var mh$ = JPC_HeightFieldShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_Create", in_samples, in_height_field_size);
            }
            return (MemorySegment)mh$.invokeExact(in_samples, in_height_field_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_GetOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_GetOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetOffset(const JPC_HeightFieldShapeSettings *in_settings, float out_offset[3])
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_GetOffset$descriptor() {
        return JPC_HeightFieldShapeSettings_GetOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetOffset(const JPC_HeightFieldShapeSettings *in_settings, float out_offset[3])
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_GetOffset$handle() {
        return JPC_HeightFieldShapeSettings_GetOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetOffset(const JPC_HeightFieldShapeSettings *in_settings, float out_offset[3])
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_GetOffset$address() {
        return JPC_HeightFieldShapeSettings_GetOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetOffset(const JPC_HeightFieldShapeSettings *in_settings, float out_offset[3])
     * }
     */
    public static void JPC_HeightFieldShapeSettings_GetOffset(MemorySegment in_settings, MemorySegment out_offset) {
        var mh$ = JPC_HeightFieldShapeSettings_GetOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_GetOffset", in_settings, out_offset);
            }
            mh$.invokeExact(in_settings, out_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_SetOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_SetOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetOffset(JPC_HeightFieldShapeSettings *in_settings, const float in_offset[3])
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_SetOffset$descriptor() {
        return JPC_HeightFieldShapeSettings_SetOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetOffset(JPC_HeightFieldShapeSettings *in_settings, const float in_offset[3])
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_SetOffset$handle() {
        return JPC_HeightFieldShapeSettings_SetOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetOffset(JPC_HeightFieldShapeSettings *in_settings, const float in_offset[3])
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_SetOffset$address() {
        return JPC_HeightFieldShapeSettings_SetOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetOffset(JPC_HeightFieldShapeSettings *in_settings, const float in_offset[3])
     * }
     */
    public static void JPC_HeightFieldShapeSettings_SetOffset(MemorySegment in_settings, MemorySegment in_offset) {
        var mh$ = JPC_HeightFieldShapeSettings_SetOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_SetOffset", in_settings, in_offset);
            }
            mh$.invokeExact(in_settings, in_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_GetScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_GetScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetScale(const JPC_HeightFieldShapeSettings *in_settings, float out_scale[3])
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_GetScale$descriptor() {
        return JPC_HeightFieldShapeSettings_GetScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetScale(const JPC_HeightFieldShapeSettings *in_settings, float out_scale[3])
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_GetScale$handle() {
        return JPC_HeightFieldShapeSettings_GetScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetScale(const JPC_HeightFieldShapeSettings *in_settings, float out_scale[3])
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_GetScale$address() {
        return JPC_HeightFieldShapeSettings_GetScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_GetScale(const JPC_HeightFieldShapeSettings *in_settings, float out_scale[3])
     * }
     */
    public static void JPC_HeightFieldShapeSettings_GetScale(MemorySegment in_settings, MemorySegment out_scale) {
        var mh$ = JPC_HeightFieldShapeSettings_GetScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_GetScale", in_settings, out_scale);
            }
            mh$.invokeExact(in_settings, out_scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_SetScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_SetScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetScale(JPC_HeightFieldShapeSettings *in_settings, const float in_scale[3])
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_SetScale$descriptor() {
        return JPC_HeightFieldShapeSettings_SetScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetScale(JPC_HeightFieldShapeSettings *in_settings, const float in_scale[3])
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_SetScale$handle() {
        return JPC_HeightFieldShapeSettings_SetScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetScale(JPC_HeightFieldShapeSettings *in_settings, const float in_scale[3])
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_SetScale$address() {
        return JPC_HeightFieldShapeSettings_SetScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetScale(JPC_HeightFieldShapeSettings *in_settings, const float in_scale[3])
     * }
     */
    public static void JPC_HeightFieldShapeSettings_SetScale(MemorySegment in_settings, MemorySegment in_scale) {
        var mh$ = JPC_HeightFieldShapeSettings_SetScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_SetScale", in_settings, in_scale);
            }
            mh$.invokeExact(in_settings, in_scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_GetBlockSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_GetBlockSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBlockSize(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_GetBlockSize$descriptor() {
        return JPC_HeightFieldShapeSettings_GetBlockSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBlockSize(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_GetBlockSize$handle() {
        return JPC_HeightFieldShapeSettings_GetBlockSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBlockSize(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_GetBlockSize$address() {
        return JPC_HeightFieldShapeSettings_GetBlockSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBlockSize(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static int JPC_HeightFieldShapeSettings_GetBlockSize(MemorySegment in_settings) {
        var mh$ = JPC_HeightFieldShapeSettings_GetBlockSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_GetBlockSize", in_settings);
            }
            return (int)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_SetBlockSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_SetBlockSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBlockSize(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_block_size)
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_SetBlockSize$descriptor() {
        return JPC_HeightFieldShapeSettings_SetBlockSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBlockSize(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_block_size)
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_SetBlockSize$handle() {
        return JPC_HeightFieldShapeSettings_SetBlockSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBlockSize(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_block_size)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_SetBlockSize$address() {
        return JPC_HeightFieldShapeSettings_SetBlockSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBlockSize(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_block_size)
     * }
     */
    public static void JPC_HeightFieldShapeSettings_SetBlockSize(MemorySegment in_settings, int in_block_size) {
        var mh$ = JPC_HeightFieldShapeSettings_SetBlockSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_SetBlockSize", in_settings, in_block_size);
            }
            mh$.invokeExact(in_settings, in_block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_GetBitsPerSample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_GetBitsPerSample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBitsPerSample(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_GetBitsPerSample$descriptor() {
        return JPC_HeightFieldShapeSettings_GetBitsPerSample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBitsPerSample(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_GetBitsPerSample$handle() {
        return JPC_HeightFieldShapeSettings_GetBitsPerSample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBitsPerSample(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_GetBitsPerSample$address() {
        return JPC_HeightFieldShapeSettings_GetBitsPerSample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_HeightFieldShapeSettings_GetBitsPerSample(const JPC_HeightFieldShapeSettings *in_settings)
     * }
     */
    public static int JPC_HeightFieldShapeSettings_GetBitsPerSample(MemorySegment in_settings) {
        var mh$ = JPC_HeightFieldShapeSettings_GetBitsPerSample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_GetBitsPerSample", in_settings);
            }
            return (int)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_HeightFieldShapeSettings_SetBitsPerSample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_HeightFieldShapeSettings_SetBitsPerSample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBitsPerSample(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_num_bits)
     * }
     */
    public static FunctionDescriptor JPC_HeightFieldShapeSettings_SetBitsPerSample$descriptor() {
        return JPC_HeightFieldShapeSettings_SetBitsPerSample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBitsPerSample(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_num_bits)
     * }
     */
    public static MethodHandle JPC_HeightFieldShapeSettings_SetBitsPerSample$handle() {
        return JPC_HeightFieldShapeSettings_SetBitsPerSample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBitsPerSample(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_num_bits)
     * }
     */
    public static MemorySegment JPC_HeightFieldShapeSettings_SetBitsPerSample$address() {
        return JPC_HeightFieldShapeSettings_SetBitsPerSample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_HeightFieldShapeSettings_SetBitsPerSample(JPC_HeightFieldShapeSettings *in_settings, uint32_t in_num_bits)
     * }
     */
    public static void JPC_HeightFieldShapeSettings_SetBitsPerSample(MemorySegment in_settings, int in_num_bits) {
        var mh$ = JPC_HeightFieldShapeSettings_SetBitsPerSample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_HeightFieldShapeSettings_SetBitsPerSample", in_settings, in_num_bits);
            }
            mh$.invokeExact(in_settings, in_num_bits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MeshShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT,
            jolt.C_INT,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MeshShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_MeshShapeSettings *JPC_MeshShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size, const uint32_t *in_indices, uint32_t in_num_indices)
     * }
     */
    public static FunctionDescriptor JPC_MeshShapeSettings_Create$descriptor() {
        return JPC_MeshShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_MeshShapeSettings *JPC_MeshShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size, const uint32_t *in_indices, uint32_t in_num_indices)
     * }
     */
    public static MethodHandle JPC_MeshShapeSettings_Create$handle() {
        return JPC_MeshShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_MeshShapeSettings *JPC_MeshShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size, const uint32_t *in_indices, uint32_t in_num_indices)
     * }
     */
    public static MemorySegment JPC_MeshShapeSettings_Create$address() {
        return JPC_MeshShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_MeshShapeSettings *JPC_MeshShapeSettings_Create(const void *in_vertices, uint32_t in_num_vertices, uint32_t in_vertex_size, const uint32_t *in_indices, uint32_t in_num_indices)
     * }
     */
    public static MemorySegment JPC_MeshShapeSettings_Create(MemorySegment in_vertices, int in_num_vertices, int in_vertex_size, MemorySegment in_indices, int in_num_indices) {
        var mh$ = JPC_MeshShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MeshShapeSettings_Create", in_vertices, in_num_vertices, in_vertex_size, in_indices, in_num_indices);
            }
            return (MemorySegment)mh$.invokeExact(in_vertices, in_num_vertices, in_vertex_size, in_indices, in_num_indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf(const JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf$descriptor() {
        return JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf(const JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf$handle() {
        return JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf(const JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf$address() {
        return JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf(const JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static int JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf(MemorySegment in_settings) {
        var mh$ = JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MeshShapeSettings_GetMaxTrianglesPerLeaf", in_settings);
            }
            return (int)mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf(JPC_MeshShapeSettings *in_settings, uint32_t in_max_triangles)
     * }
     */
    public static FunctionDescriptor JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf$descriptor() {
        return JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf(JPC_MeshShapeSettings *in_settings, uint32_t in_max_triangles)
     * }
     */
    public static MethodHandle JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf$handle() {
        return JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf(JPC_MeshShapeSettings *in_settings, uint32_t in_max_triangles)
     * }
     */
    public static MemorySegment JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf$address() {
        return JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf(JPC_MeshShapeSettings *in_settings, uint32_t in_max_triangles)
     * }
     */
    public static void JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf(MemorySegment in_settings, int in_max_triangles) {
        var mh$ = JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MeshShapeSettings_SetMaxTrianglesPerLeaf", in_settings, in_max_triangles);
            }
            mh$.invokeExact(in_settings, in_max_triangles);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_MeshShapeSettings_Sanitize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_MeshShapeSettings_Sanitize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_Sanitize(JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static FunctionDescriptor JPC_MeshShapeSettings_Sanitize$descriptor() {
        return JPC_MeshShapeSettings_Sanitize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_Sanitize(JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static MethodHandle JPC_MeshShapeSettings_Sanitize$handle() {
        return JPC_MeshShapeSettings_Sanitize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_Sanitize(JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static MemorySegment JPC_MeshShapeSettings_Sanitize$address() {
        return JPC_MeshShapeSettings_Sanitize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_MeshShapeSettings_Sanitize(JPC_MeshShapeSettings *in_settings)
     * }
     */
    public static void JPC_MeshShapeSettings_Sanitize(MemorySegment in_settings) {
        var mh$ = JPC_MeshShapeSettings_Sanitize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_MeshShapeSettings_Sanitize", in_settings);
            }
            mh$.invokeExact(in_settings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_RotatedTranslatedShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_RotatedTranslatedShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_RotatedTranslatedShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_rotated[4], const JPC_Real in_translated[3])
     * }
     */
    public static FunctionDescriptor JPC_RotatedTranslatedShapeSettings_Create$descriptor() {
        return JPC_RotatedTranslatedShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_RotatedTranslatedShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_rotated[4], const JPC_Real in_translated[3])
     * }
     */
    public static MethodHandle JPC_RotatedTranslatedShapeSettings_Create$handle() {
        return JPC_RotatedTranslatedShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_RotatedTranslatedShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_rotated[4], const JPC_Real in_translated[3])
     * }
     */
    public static MemorySegment JPC_RotatedTranslatedShapeSettings_Create$address() {
        return JPC_RotatedTranslatedShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_RotatedTranslatedShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_rotated[4], const JPC_Real in_translated[3])
     * }
     */
    public static MemorySegment JPC_RotatedTranslatedShapeSettings_Create(MemorySegment in_inner_shape_settings, MemorySegment in_rotated, MemorySegment in_translated) {
        var mh$ = JPC_RotatedTranslatedShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_RotatedTranslatedShapeSettings_Create", in_inner_shape_settings, in_rotated, in_translated);
            }
            return (MemorySegment)mh$.invokeExact(in_inner_shape_settings, in_rotated, in_translated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_ScaledShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_ScaledShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_ScaledShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_scale[3])
     * }
     */
    public static FunctionDescriptor JPC_ScaledShapeSettings_Create$descriptor() {
        return JPC_ScaledShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_ScaledShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_scale[3])
     * }
     */
    public static MethodHandle JPC_ScaledShapeSettings_Create$handle() {
        return JPC_ScaledShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_ScaledShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_scale[3])
     * }
     */
    public static MemorySegment JPC_ScaledShapeSettings_Create$address() {
        return JPC_ScaledShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_ScaledShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_scale[3])
     * }
     */
    public static MemorySegment JPC_ScaledShapeSettings_Create(MemorySegment in_inner_shape_settings, MemorySegment in_scale) {
        var mh$ = JPC_ScaledShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_ScaledShapeSettings_Create", in_inner_shape_settings, in_scale);
            }
            return (MemorySegment)mh$.invokeExact(in_inner_shape_settings, in_scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_OffsetCenterOfMassShapeSettings_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_OffsetCenterOfMassShapeSettings_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_OffsetCenterOfMassShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_center_of_mass[3])
     * }
     */
    public static FunctionDescriptor JPC_OffsetCenterOfMassShapeSettings_Create$descriptor() {
        return JPC_OffsetCenterOfMassShapeSettings_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_OffsetCenterOfMassShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_center_of_mass[3])
     * }
     */
    public static MethodHandle JPC_OffsetCenterOfMassShapeSettings_Create$handle() {
        return JPC_OffsetCenterOfMassShapeSettings_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_OffsetCenterOfMassShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_center_of_mass[3])
     * }
     */
    public static MemorySegment JPC_OffsetCenterOfMassShapeSettings_Create$address() {
        return JPC_OffsetCenterOfMassShapeSettings_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_DecoratedShapeSettings *JPC_OffsetCenterOfMassShapeSettings_Create(const JPC_ShapeSettings *in_inner_shape_settings, const JPC_Real in_center_of_mass[3])
     * }
     */
    public static MemorySegment JPC_OffsetCenterOfMassShapeSettings_Create(MemorySegment in_inner_shape_settings, MemorySegment in_center_of_mass) {
        var mh$ = JPC_OffsetCenterOfMassShapeSettings_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_OffsetCenterOfMassShapeSettings_Create", in_inner_shape_settings, in_center_of_mass);
            }
            return (MemorySegment)mh$.invokeExact(in_inner_shape_settings, in_center_of_mass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * JPC_CompoundShapeSettings *JPC_StaticCompoundShapeSettings_Create()
     * }
     */
    public static class JPC_StaticCompoundShapeSettings_Create {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jolt.C_POINTER        );
        private static final MemorySegment ADDR = jolt.findOrThrow("JPC_StaticCompoundShapeSettings_Create");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private JPC_StaticCompoundShapeSettings_Create(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * JPC_CompoundShapeSettings *JPC_StaticCompoundShapeSettings_Create()
         * }
         */
        public static JPC_StaticCompoundShapeSettings_Create makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new JPC_StaticCompoundShapeSettings_Create(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("JPC_StaticCompoundShapeSettings_Create", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * JPC_CompoundShapeSettings *JPC_MutableCompoundShapeSettings_Create()
     * }
     */
    public static class JPC_MutableCompoundShapeSettings_Create {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jolt.C_POINTER        );
        private static final MemorySegment ADDR = jolt.findOrThrow("JPC_MutableCompoundShapeSettings_Create");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private JPC_MutableCompoundShapeSettings_Create(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * JPC_CompoundShapeSettings *JPC_MutableCompoundShapeSettings_Create()
         * }
         */
        public static JPC_MutableCompoundShapeSettings_Create makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new JPC_MutableCompoundShapeSettings_Create(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("JPC_MutableCompoundShapeSettings_Create", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class JPC_CompoundShapeSettings_AddShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_POINTER,
            jolt.C_INT
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_CompoundShapeSettings_AddShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_CompoundShapeSettings_AddShape(JPC_CompoundShapeSettings *in_settings, const JPC_Real in_position[3], const JPC_Real in_rotation[4], const JPC_ShapeSettings *in_shape, const uint32_t in_user_data)
     * }
     */
    public static FunctionDescriptor JPC_CompoundShapeSettings_AddShape$descriptor() {
        return JPC_CompoundShapeSettings_AddShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_CompoundShapeSettings_AddShape(JPC_CompoundShapeSettings *in_settings, const JPC_Real in_position[3], const JPC_Real in_rotation[4], const JPC_ShapeSettings *in_shape, const uint32_t in_user_data)
     * }
     */
    public static MethodHandle JPC_CompoundShapeSettings_AddShape$handle() {
        return JPC_CompoundShapeSettings_AddShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_CompoundShapeSettings_AddShape(JPC_CompoundShapeSettings *in_settings, const JPC_Real in_position[3], const JPC_Real in_rotation[4], const JPC_ShapeSettings *in_shape, const uint32_t in_user_data)
     * }
     */
    public static MemorySegment JPC_CompoundShapeSettings_AddShape$address() {
        return JPC_CompoundShapeSettings_AddShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_CompoundShapeSettings_AddShape(JPC_CompoundShapeSettings *in_settings, const JPC_Real in_position[3], const JPC_Real in_rotation[4], const JPC_ShapeSettings *in_shape, const uint32_t in_user_data)
     * }
     */
    public static void JPC_CompoundShapeSettings_AddShape(MemorySegment in_settings, MemorySegment in_position, MemorySegment in_rotation, MemorySegment in_shape, int in_user_data) {
        var mh$ = JPC_CompoundShapeSettings_AddShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_CompoundShapeSettings_AddShape", in_settings, in_position, in_rotation, in_shape, in_user_data);
            }
            mh$.invokeExact(in_settings, in_position, in_rotation, in_shape, in_user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_AddRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_AddRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_Shape_AddRef(JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_AddRef$descriptor() {
        return JPC_Shape_AddRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_Shape_AddRef(JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_AddRef$handle() {
        return JPC_Shape_AddRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_Shape_AddRef(JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_AddRef$address() {
        return JPC_Shape_AddRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_Shape_AddRef(JPC_Shape *in_shape)
     * }
     */
    public static void JPC_Shape_AddRef(MemorySegment in_shape) {
        var mh$ = JPC_Shape_AddRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_AddRef", in_shape);
            }
            mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_Shape_Release(JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_Release$descriptor() {
        return JPC_Shape_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_Shape_Release(JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_Release$handle() {
        return JPC_Shape_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_Shape_Release(JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_Release$address() {
        return JPC_Shape_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_Shape_Release(JPC_Shape *in_shape)
     * }
     */
    public static void JPC_Shape_Release(MemorySegment in_shape) {
        var mh$ = JPC_Shape_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_Release", in_shape);
            }
            mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_GetRefCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_INT,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_GetRefCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t JPC_Shape_GetRefCount(const JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_GetRefCount$descriptor() {
        return JPC_Shape_GetRefCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t JPC_Shape_GetRefCount(const JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_GetRefCount$handle() {
        return JPC_Shape_GetRefCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t JPC_Shape_GetRefCount(const JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_GetRefCount$address() {
        return JPC_Shape_GetRefCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t JPC_Shape_GetRefCount(const JPC_Shape *in_shape)
     * }
     */
    public static int JPC_Shape_GetRefCount(MemorySegment in_shape) {
        var mh$ = JPC_Shape_GetRefCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_GetRefCount", in_shape);
            }
            return (int)mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_GetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_CHAR,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_GetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_ShapeType JPC_Shape_GetType(const JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_GetType$descriptor() {
        return JPC_Shape_GetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_ShapeType JPC_Shape_GetType(const JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_GetType$handle() {
        return JPC_Shape_GetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_ShapeType JPC_Shape_GetType(const JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_GetType$address() {
        return JPC_Shape_GetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_ShapeType JPC_Shape_GetType(const JPC_Shape *in_shape)
     * }
     */
    public static byte JPC_Shape_GetType(MemorySegment in_shape) {
        var mh$ = JPC_Shape_GetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_GetType", in_shape);
            }
            return (byte)mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_GetSubType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_CHAR,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_GetSubType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * JPC_ShapeSubType JPC_Shape_GetSubType(const JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_GetSubType$descriptor() {
        return JPC_Shape_GetSubType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * JPC_ShapeSubType JPC_Shape_GetSubType(const JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_GetSubType$handle() {
        return JPC_Shape_GetSubType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * JPC_ShapeSubType JPC_Shape_GetSubType(const JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_GetSubType$address() {
        return JPC_Shape_GetSubType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * JPC_ShapeSubType JPC_Shape_GetSubType(const JPC_Shape *in_shape)
     * }
     */
    public static byte JPC_Shape_GetSubType(MemorySegment in_shape) {
        var mh$ = JPC_Shape_GetSubType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_GetSubType", in_shape);
            }
            return (byte)mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jolt.C_LONG_LONG,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t JPC_Shape_GetUserData(const JPC_Shape *in_shape)
     * }
     */
    public static FunctionDescriptor JPC_Shape_GetUserData$descriptor() {
        return JPC_Shape_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t JPC_Shape_GetUserData(const JPC_Shape *in_shape)
     * }
     */
    public static MethodHandle JPC_Shape_GetUserData$handle() {
        return JPC_Shape_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t JPC_Shape_GetUserData(const JPC_Shape *in_shape)
     * }
     */
    public static MemorySegment JPC_Shape_GetUserData$address() {
        return JPC_Shape_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t JPC_Shape_GetUserData(const JPC_Shape *in_shape)
     * }
     */
    public static long JPC_Shape_GetUserData(MemorySegment in_shape) {
        var mh$ = JPC_Shape_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_GetUserData", in_shape);
            }
            return (long)mh$.invokeExact(in_shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_LONG_LONG
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_Shape_SetUserData(JPC_Shape *in_shape, uint64_t in_user_data)
     * }
     */
    public static FunctionDescriptor JPC_Shape_SetUserData$descriptor() {
        return JPC_Shape_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_Shape_SetUserData(JPC_Shape *in_shape, uint64_t in_user_data)
     * }
     */
    public static MethodHandle JPC_Shape_SetUserData$handle() {
        return JPC_Shape_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_Shape_SetUserData(JPC_Shape *in_shape, uint64_t in_user_data)
     * }
     */
    public static MemorySegment JPC_Shape_SetUserData$address() {
        return JPC_Shape_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_Shape_SetUserData(JPC_Shape *in_shape, uint64_t in_user_data)
     * }
     */
    public static void JPC_Shape_SetUserData(MemorySegment in_shape, long in_user_data) {
        var mh$ = JPC_Shape_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_SetUserData", in_shape, in_user_data);
            }
            mh$.invokeExact(in_shape, in_user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JPC_Shape_GetCenterOfMass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jolt.C_POINTER,
            jolt.C_POINTER
        );

        public static final MemorySegment ADDR = jolt.findOrThrow("JPC_Shape_GetCenterOfMass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JPC_Shape_GetCenterOfMass(const JPC_Shape *in_shape, JPC_Real out_position[3])
     * }
     */
    public static FunctionDescriptor JPC_Shape_GetCenterOfMass$descriptor() {
        return JPC_Shape_GetCenterOfMass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JPC_Shape_GetCenterOfMass(const JPC_Shape *in_shape, JPC_Real out_position[3])
     * }
     */
    public static MethodHandle JPC_Shape_GetCenterOfMass$handle() {
        return JPC_Shape_GetCenterOfMass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JPC_Shape_GetCenterOfMass(const JPC_Shape *in_shape, JPC_Real out_position[3])
     * }
     */
    public static MemorySegment JPC_Shape_GetCenterOfMass$address() {
        return JPC_Shape_GetCenterOfMass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JPC_Shape_GetCenterOfMass(const JPC_Shape *in_shape, JPC_Real out_position[3])
     * }
     */
    public static void JPC_Shape_GetCenterOfMass(MemorySegment in_shape, MemorySegment out_position) {
        var mh$ = JPC_Shape_GetCenterOfMass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JPC_Shape_GetCenterOfMass", in_shape, out_position);
            }
            mh$.invokeExact(in_shape, out_position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

