// Generated by jextract

package org.vybe.jolt;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct JPC_MotionProperties {
 *     float linear_velocity[4];
 *     float angular_velocity[4];
 *     float inv_inertia_diagonal[4];
 *     float inertia_rotation[4];
 *     float force[3];
 *     float torque[3];
 *     float inv_mass;
 *     float linear_damping;
 *     float angular_damping;
 *     float max_linear_velocity;
 *     float max_angular_velocity;
 *     float gravity_factor;
 *     uint32_t index_in_active_bodies;
 *     uint32_t island_index;
 *     JPC_MotionQuality motion_quality;
 *     bool allow_sleeping;
 *     JPC_AllowedDofs allowed_dofs;
 *     uint8_t num_velocity_steps_override;
 *     uint8_t num_position_steps_override;
 *     uint8_t reserved[52];
 * }
 * }
 */
public class JPC_MotionProperties {

    JPC_MotionProperties() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.sequenceLayout(4, jolt.C_FLOAT).withName("linear_velocity"),
        MemoryLayout.sequenceLayout(4, jolt.C_FLOAT).withName("angular_velocity"),
        MemoryLayout.sequenceLayout(4, jolt.C_FLOAT).withName("inv_inertia_diagonal"),
        MemoryLayout.sequenceLayout(4, jolt.C_FLOAT).withName("inertia_rotation"),
        MemoryLayout.sequenceLayout(3, jolt.C_FLOAT).withName("force"),
        MemoryLayout.sequenceLayout(3, jolt.C_FLOAT).withName("torque"),
        jolt.C_FLOAT.withName("inv_mass"),
        jolt.C_FLOAT.withName("linear_damping"),
        jolt.C_FLOAT.withName("angular_damping"),
        jolt.C_FLOAT.withName("max_linear_velocity"),
        jolt.C_FLOAT.withName("max_angular_velocity"),
        jolt.C_FLOAT.withName("gravity_factor"),
        jolt.C_INT.withName("index_in_active_bodies"),
        jolt.C_INT.withName("island_index"),
        jolt.C_CHAR.withName("motion_quality"),
        jolt.C_BOOL.withName("allow_sleeping"),
        jolt.C_CHAR.withName("allowed_dofs"),
        jolt.C_CHAR.withName("num_velocity_steps_override"),
        jolt.C_CHAR.withName("num_position_steps_override"),
        MemoryLayout.paddingLayout(3),
        MemoryLayout.sequenceLayout(52, jolt.C_CHAR).withName("reserved"),
        MemoryLayout.paddingLayout(12)
    ).withName("JPC_MotionProperties");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final SequenceLayout linear_velocity$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("linear_velocity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static final SequenceLayout linear_velocity$layout() {
        return linear_velocity$LAYOUT;
    }

    private static final long linear_velocity$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static final long linear_velocity$offset() {
        return linear_velocity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static MemorySegment linear_velocity(MemorySegment struct) {
        return struct.asSlice(linear_velocity$OFFSET, linear_velocity$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static void linear_velocity(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, linear_velocity$OFFSET, linear_velocity$LAYOUT.byteSize());
    }

    private static long[] linear_velocity$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static long[] linear_velocity$dimensions() {
        return linear_velocity$DIMS;
    }
    private static final VarHandle linear_velocity$ELEM_HANDLE = linear_velocity$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static float linear_velocity(MemorySegment struct, long index0) {
        return (float)linear_velocity$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float linear_velocity[4]
     * }
     */
    public static void linear_velocity(MemorySegment struct, long index0, float fieldValue) {
        linear_velocity$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout angular_velocity$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("angular_velocity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static final SequenceLayout angular_velocity$layout() {
        return angular_velocity$LAYOUT;
    }

    private static final long angular_velocity$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static final long angular_velocity$offset() {
        return angular_velocity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static MemorySegment angular_velocity(MemorySegment struct) {
        return struct.asSlice(angular_velocity$OFFSET, angular_velocity$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static void angular_velocity(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, angular_velocity$OFFSET, angular_velocity$LAYOUT.byteSize());
    }

    private static long[] angular_velocity$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static long[] angular_velocity$dimensions() {
        return angular_velocity$DIMS;
    }
    private static final VarHandle angular_velocity$ELEM_HANDLE = angular_velocity$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static float angular_velocity(MemorySegment struct, long index0) {
        return (float)angular_velocity$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float angular_velocity[4]
     * }
     */
    public static void angular_velocity(MemorySegment struct, long index0, float fieldValue) {
        angular_velocity$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout inv_inertia_diagonal$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("inv_inertia_diagonal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static final SequenceLayout inv_inertia_diagonal$layout() {
        return inv_inertia_diagonal$LAYOUT;
    }

    private static final long inv_inertia_diagonal$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static final long inv_inertia_diagonal$offset() {
        return inv_inertia_diagonal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static MemorySegment inv_inertia_diagonal(MemorySegment struct) {
        return struct.asSlice(inv_inertia_diagonal$OFFSET, inv_inertia_diagonal$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static void inv_inertia_diagonal(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, inv_inertia_diagonal$OFFSET, inv_inertia_diagonal$LAYOUT.byteSize());
    }

    private static long[] inv_inertia_diagonal$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static long[] inv_inertia_diagonal$dimensions() {
        return inv_inertia_diagonal$DIMS;
    }
    private static final VarHandle inv_inertia_diagonal$ELEM_HANDLE = inv_inertia_diagonal$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static float inv_inertia_diagonal(MemorySegment struct, long index0) {
        return (float)inv_inertia_diagonal$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float inv_inertia_diagonal[4]
     * }
     */
    public static void inv_inertia_diagonal(MemorySegment struct, long index0, float fieldValue) {
        inv_inertia_diagonal$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout inertia_rotation$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("inertia_rotation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static final SequenceLayout inertia_rotation$layout() {
        return inertia_rotation$LAYOUT;
    }

    private static final long inertia_rotation$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static final long inertia_rotation$offset() {
        return inertia_rotation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static MemorySegment inertia_rotation(MemorySegment struct) {
        return struct.asSlice(inertia_rotation$OFFSET, inertia_rotation$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static void inertia_rotation(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, inertia_rotation$OFFSET, inertia_rotation$LAYOUT.byteSize());
    }

    private static long[] inertia_rotation$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static long[] inertia_rotation$dimensions() {
        return inertia_rotation$DIMS;
    }
    private static final VarHandle inertia_rotation$ELEM_HANDLE = inertia_rotation$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static float inertia_rotation(MemorySegment struct, long index0) {
        return (float)inertia_rotation$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float inertia_rotation[4]
     * }
     */
    public static void inertia_rotation(MemorySegment struct, long index0, float fieldValue) {
        inertia_rotation$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout force$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("force"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static final SequenceLayout force$layout() {
        return force$LAYOUT;
    }

    private static final long force$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static final long force$offset() {
        return force$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static MemorySegment force(MemorySegment struct) {
        return struct.asSlice(force$OFFSET, force$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static void force(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, force$OFFSET, force$LAYOUT.byteSize());
    }

    private static long[] force$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static long[] force$dimensions() {
        return force$DIMS;
    }
    private static final VarHandle force$ELEM_HANDLE = force$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static float force(MemorySegment struct, long index0) {
        return (float)force$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float force[3]
     * }
     */
    public static void force(MemorySegment struct, long index0, float fieldValue) {
        force$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout torque$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("torque"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static final SequenceLayout torque$layout() {
        return torque$LAYOUT;
    }

    private static final long torque$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static final long torque$offset() {
        return torque$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static MemorySegment torque(MemorySegment struct) {
        return struct.asSlice(torque$OFFSET, torque$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static void torque(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, torque$OFFSET, torque$LAYOUT.byteSize());
    }

    private static long[] torque$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static long[] torque$dimensions() {
        return torque$DIMS;
    }
    private static final VarHandle torque$ELEM_HANDLE = torque$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static float torque(MemorySegment struct, long index0) {
        return (float)torque$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float torque[3]
     * }
     */
    public static void torque(MemorySegment struct, long index0, float fieldValue) {
        torque$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfFloat inv_mass$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("inv_mass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float inv_mass
     * }
     */
    public static final OfFloat inv_mass$layout() {
        return inv_mass$LAYOUT;
    }

    private static final long inv_mass$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float inv_mass
     * }
     */
    public static final long inv_mass$offset() {
        return inv_mass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float inv_mass
     * }
     */
    public static float inv_mass(MemorySegment struct) {
        return struct.get(inv_mass$LAYOUT, inv_mass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float inv_mass
     * }
     */
    public static void inv_mass(MemorySegment struct, float fieldValue) {
        struct.set(inv_mass$LAYOUT, inv_mass$OFFSET, fieldValue);
    }

    private static final OfFloat linear_damping$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("linear_damping"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float linear_damping
     * }
     */
    public static final OfFloat linear_damping$layout() {
        return linear_damping$LAYOUT;
    }

    private static final long linear_damping$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float linear_damping
     * }
     */
    public static final long linear_damping$offset() {
        return linear_damping$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float linear_damping
     * }
     */
    public static float linear_damping(MemorySegment struct) {
        return struct.get(linear_damping$LAYOUT, linear_damping$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float linear_damping
     * }
     */
    public static void linear_damping(MemorySegment struct, float fieldValue) {
        struct.set(linear_damping$LAYOUT, linear_damping$OFFSET, fieldValue);
    }

    private static final OfFloat angular_damping$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("angular_damping"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float angular_damping
     * }
     */
    public static final OfFloat angular_damping$layout() {
        return angular_damping$LAYOUT;
    }

    private static final long angular_damping$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float angular_damping
     * }
     */
    public static final long angular_damping$offset() {
        return angular_damping$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float angular_damping
     * }
     */
    public static float angular_damping(MemorySegment struct) {
        return struct.get(angular_damping$LAYOUT, angular_damping$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float angular_damping
     * }
     */
    public static void angular_damping(MemorySegment struct, float fieldValue) {
        struct.set(angular_damping$LAYOUT, angular_damping$OFFSET, fieldValue);
    }

    private static final OfFloat max_linear_velocity$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("max_linear_velocity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float max_linear_velocity
     * }
     */
    public static final OfFloat max_linear_velocity$layout() {
        return max_linear_velocity$LAYOUT;
    }

    private static final long max_linear_velocity$OFFSET = 100;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float max_linear_velocity
     * }
     */
    public static final long max_linear_velocity$offset() {
        return max_linear_velocity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float max_linear_velocity
     * }
     */
    public static float max_linear_velocity(MemorySegment struct) {
        return struct.get(max_linear_velocity$LAYOUT, max_linear_velocity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float max_linear_velocity
     * }
     */
    public static void max_linear_velocity(MemorySegment struct, float fieldValue) {
        struct.set(max_linear_velocity$LAYOUT, max_linear_velocity$OFFSET, fieldValue);
    }

    private static final OfFloat max_angular_velocity$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("max_angular_velocity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float max_angular_velocity
     * }
     */
    public static final OfFloat max_angular_velocity$layout() {
        return max_angular_velocity$LAYOUT;
    }

    private static final long max_angular_velocity$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float max_angular_velocity
     * }
     */
    public static final long max_angular_velocity$offset() {
        return max_angular_velocity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float max_angular_velocity
     * }
     */
    public static float max_angular_velocity(MemorySegment struct) {
        return struct.get(max_angular_velocity$LAYOUT, max_angular_velocity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float max_angular_velocity
     * }
     */
    public static void max_angular_velocity(MemorySegment struct, float fieldValue) {
        struct.set(max_angular_velocity$LAYOUT, max_angular_velocity$OFFSET, fieldValue);
    }

    private static final OfFloat gravity_factor$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("gravity_factor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float gravity_factor
     * }
     */
    public static final OfFloat gravity_factor$layout() {
        return gravity_factor$LAYOUT;
    }

    private static final long gravity_factor$OFFSET = 108;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float gravity_factor
     * }
     */
    public static final long gravity_factor$offset() {
        return gravity_factor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float gravity_factor
     * }
     */
    public static float gravity_factor(MemorySegment struct) {
        return struct.get(gravity_factor$LAYOUT, gravity_factor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float gravity_factor
     * }
     */
    public static void gravity_factor(MemorySegment struct, float fieldValue) {
        struct.set(gravity_factor$LAYOUT, gravity_factor$OFFSET, fieldValue);
    }

    private static final OfInt index_in_active_bodies$LAYOUT = (OfInt)$LAYOUT.select(groupElement("index_in_active_bodies"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t index_in_active_bodies
     * }
     */
    public static final OfInt index_in_active_bodies$layout() {
        return index_in_active_bodies$LAYOUT;
    }

    private static final long index_in_active_bodies$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t index_in_active_bodies
     * }
     */
    public static final long index_in_active_bodies$offset() {
        return index_in_active_bodies$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t index_in_active_bodies
     * }
     */
    public static int index_in_active_bodies(MemorySegment struct) {
        return struct.get(index_in_active_bodies$LAYOUT, index_in_active_bodies$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t index_in_active_bodies
     * }
     */
    public static void index_in_active_bodies(MemorySegment struct, int fieldValue) {
        struct.set(index_in_active_bodies$LAYOUT, index_in_active_bodies$OFFSET, fieldValue);
    }

    private static final OfInt island_index$LAYOUT = (OfInt)$LAYOUT.select(groupElement("island_index"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t island_index
     * }
     */
    public static final OfInt island_index$layout() {
        return island_index$LAYOUT;
    }

    private static final long island_index$OFFSET = 116;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t island_index
     * }
     */
    public static final long island_index$offset() {
        return island_index$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t island_index
     * }
     */
    public static int island_index(MemorySegment struct) {
        return struct.get(island_index$LAYOUT, island_index$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t island_index
     * }
     */
    public static void island_index(MemorySegment struct, int fieldValue) {
        struct.set(island_index$LAYOUT, island_index$OFFSET, fieldValue);
    }

    private static final OfByte motion_quality$LAYOUT = (OfByte)$LAYOUT.select(groupElement("motion_quality"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPC_MotionQuality motion_quality
     * }
     */
    public static final OfByte motion_quality$layout() {
        return motion_quality$LAYOUT;
    }

    private static final long motion_quality$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPC_MotionQuality motion_quality
     * }
     */
    public static final long motion_quality$offset() {
        return motion_quality$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPC_MotionQuality motion_quality
     * }
     */
    public static byte motion_quality(MemorySegment struct) {
        return struct.get(motion_quality$LAYOUT, motion_quality$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPC_MotionQuality motion_quality
     * }
     */
    public static void motion_quality(MemorySegment struct, byte fieldValue) {
        struct.set(motion_quality$LAYOUT, motion_quality$OFFSET, fieldValue);
    }

    private static final OfBoolean allow_sleeping$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("allow_sleeping"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool allow_sleeping
     * }
     */
    public static final OfBoolean allow_sleeping$layout() {
        return allow_sleeping$LAYOUT;
    }

    private static final long allow_sleeping$OFFSET = 121;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool allow_sleeping
     * }
     */
    public static final long allow_sleeping$offset() {
        return allow_sleeping$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool allow_sleeping
     * }
     */
    public static boolean allow_sleeping(MemorySegment struct) {
        return struct.get(allow_sleeping$LAYOUT, allow_sleeping$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool allow_sleeping
     * }
     */
    public static void allow_sleeping(MemorySegment struct, boolean fieldValue) {
        struct.set(allow_sleeping$LAYOUT, allow_sleeping$OFFSET, fieldValue);
    }

    private static final OfByte allowed_dofs$LAYOUT = (OfByte)$LAYOUT.select(groupElement("allowed_dofs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPC_AllowedDofs allowed_dofs
     * }
     */
    public static final OfByte allowed_dofs$layout() {
        return allowed_dofs$LAYOUT;
    }

    private static final long allowed_dofs$OFFSET = 122;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPC_AllowedDofs allowed_dofs
     * }
     */
    public static final long allowed_dofs$offset() {
        return allowed_dofs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPC_AllowedDofs allowed_dofs
     * }
     */
    public static byte allowed_dofs(MemorySegment struct) {
        return struct.get(allowed_dofs$LAYOUT, allowed_dofs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPC_AllowedDofs allowed_dofs
     * }
     */
    public static void allowed_dofs(MemorySegment struct, byte fieldValue) {
        struct.set(allowed_dofs$LAYOUT, allowed_dofs$OFFSET, fieldValue);
    }

    private static final OfByte num_velocity_steps_override$LAYOUT = (OfByte)$LAYOUT.select(groupElement("num_velocity_steps_override"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t num_velocity_steps_override
     * }
     */
    public static final OfByte num_velocity_steps_override$layout() {
        return num_velocity_steps_override$LAYOUT;
    }

    private static final long num_velocity_steps_override$OFFSET = 123;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t num_velocity_steps_override
     * }
     */
    public static final long num_velocity_steps_override$offset() {
        return num_velocity_steps_override$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t num_velocity_steps_override
     * }
     */
    public static byte num_velocity_steps_override(MemorySegment struct) {
        return struct.get(num_velocity_steps_override$LAYOUT, num_velocity_steps_override$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t num_velocity_steps_override
     * }
     */
    public static void num_velocity_steps_override(MemorySegment struct, byte fieldValue) {
        struct.set(num_velocity_steps_override$LAYOUT, num_velocity_steps_override$OFFSET, fieldValue);
    }

    private static final OfByte num_position_steps_override$LAYOUT = (OfByte)$LAYOUT.select(groupElement("num_position_steps_override"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t num_position_steps_override
     * }
     */
    public static final OfByte num_position_steps_override$layout() {
        return num_position_steps_override$LAYOUT;
    }

    private static final long num_position_steps_override$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t num_position_steps_override
     * }
     */
    public static final long num_position_steps_override$offset() {
        return num_position_steps_override$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t num_position_steps_override
     * }
     */
    public static byte num_position_steps_override(MemorySegment struct) {
        return struct.get(num_position_steps_override$LAYOUT, num_position_steps_override$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t num_position_steps_override
     * }
     */
    public static void num_position_steps_override(MemorySegment struct, byte fieldValue) {
        struct.set(num_position_steps_override$LAYOUT, num_position_steps_override$OFFSET, fieldValue);
    }

    private static final SequenceLayout reserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static final SequenceLayout reserved$layout() {
        return reserved$LAYOUT;
    }

    private static final long reserved$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static final long reserved$offset() {
        return reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static MemorySegment reserved(MemorySegment struct) {
        return struct.asSlice(reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static void reserved(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    private static long[] reserved$DIMS = { 52 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static long[] reserved$dimensions() {
        return reserved$DIMS;
    }
    private static final VarHandle reserved$ELEM_HANDLE = reserved$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static byte reserved(MemorySegment struct, long index0) {
        return (byte)reserved$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint8_t reserved[52]
     * }
     */
    public static void reserved(MemorySegment struct, long index0, byte fieldValue) {
        reserved$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

