// Generated by jextract

package org.vybe.flecs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ecs_world_stats_t {
 *     int64_t first_;
 *     struct {
 *         ecs_metric_t count;
 *         ecs_metric_t not_alive_count;
 *     } entities;
 *     struct {
 *         ecs_metric_t tag_count;
 *         ecs_metric_t component_count;
 *         ecs_metric_t pair_count;
 *         ecs_metric_t type_count;
 *         ecs_metric_t create_count;
 *         ecs_metric_t delete_count;
 *     } components;
 *     struct {
 *         ecs_metric_t count;
 *         ecs_metric_t empty_count;
 *         ecs_metric_t create_count;
 *         ecs_metric_t delete_count;
 *     } tables;
 *     struct {
 *         ecs_metric_t query_count;
 *         ecs_metric_t observer_count;
 *         ecs_metric_t system_count;
 *     } queries;
 *     struct {
 *         ecs_metric_t add_count;
 *         ecs_metric_t remove_count;
 *         ecs_metric_t delete_count;
 *         ecs_metric_t clear_count;
 *         ecs_metric_t set_count;
 *         ecs_metric_t ensure_count;
 *         ecs_metric_t modified_count;
 *         ecs_metric_t other_count;
 *         ecs_metric_t discard_count;
 *         ecs_metric_t batched_entity_count;
 *         ecs_metric_t batched_count;
 *     } commands;
 *     struct {
 *         ecs_metric_t frame_count;
 *         ecs_metric_t merge_count;
 *         ecs_metric_t rematch_count;
 *         ecs_metric_t pipeline_build_count;
 *         ecs_metric_t systems_ran;
 *         ecs_metric_t observers_ran;
 *         ecs_metric_t event_emit_count;
 *     } frame;
 *     struct {
 *         ecs_metric_t world_time_raw;
 *         ecs_metric_t world_time;
 *         ecs_metric_t frame_time;
 *         ecs_metric_t system_time;
 *         ecs_metric_t emit_time;
 *         ecs_metric_t merge_time;
 *         ecs_metric_t rematch_time;
 *         ecs_metric_t fps;
 *         ecs_metric_t delta_time;
 *     } performance;
 *     struct {
 *         ecs_metric_t alloc_count;
 *         ecs_metric_t realloc_count;
 *         ecs_metric_t free_count;
 *         ecs_metric_t outstanding_alloc_count;
 *         ecs_metric_t block_alloc_count;
 *         ecs_metric_t block_free_count;
 *         ecs_metric_t block_outstanding_alloc_count;
 *         ecs_metric_t stack_alloc_count;
 *         ecs_metric_t stack_free_count;
 *         ecs_metric_t stack_outstanding_alloc_count;
 *     } memory;
 *     struct {
 *         ecs_metric_t request_received_count;
 *         ecs_metric_t request_invalid_count;
 *         ecs_metric_t request_handled_ok_count;
 *         ecs_metric_t request_handled_error_count;
 *         ecs_metric_t request_not_handled_count;
 *         ecs_metric_t request_preflight_count;
 *         ecs_metric_t send_ok_count;
 *         ecs_metric_t send_error_count;
 *         ecs_metric_t busy_count;
 *     } http;
 *     int64_t last_;
 *     int32_t t;
 * }
 * }
 */
public class ecs_world_stats_t {

    ecs_world_stats_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        flecs.C_LONG_LONG.withName("first_"),
        ecs_world_stats_t.entities.layout().withName("entities"),
        ecs_world_stats_t.components.layout().withName("components"),
        ecs_world_stats_t.tables.layout().withName("tables"),
        ecs_world_stats_t.queries.layout().withName("queries"),
        ecs_world_stats_t.commands.layout().withName("commands"),
        ecs_world_stats_t.frame.layout().withName("frame"),
        ecs_world_stats_t.performance.layout().withName("performance"),
        ecs_world_stats_t.memory.layout().withName("memory"),
        ecs_world_stats_t.http.layout().withName("http"),
        flecs.C_LONG_LONG.withName("last_"),
        flecs.C_INT.withName("t"),
        MemoryLayout.paddingLayout(4)
    ).withName("ecs_world_stats_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfLong first_$LAYOUT = (OfLong)$LAYOUT.select(groupElement("first_"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t first_
     * }
     */
    public static final OfLong first_$layout() {
        return first_$LAYOUT;
    }

    private static final long first_$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t first_
     * }
     */
    public static final long first_$offset() {
        return first_$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t first_
     * }
     */
    public static long first_(MemorySegment struct) {
        return struct.get(first_$LAYOUT, first_$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t first_
     * }
     */
    public static void first_(MemorySegment struct, long fieldValue) {
        struct.set(first_$LAYOUT, first_$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t not_alive_count;
     * }
     * }
     */
    public static class entities {

        entities() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("count"),
            ecs_metric_t.layout().withName("not_alive_count")
        ).withName("$anon$12303:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static final GroupLayout count$layout() {
            return count$LAYOUT;
        }

        private static final long count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static final long count$offset() {
            return count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static MemorySegment count(MemorySegment struct) {
            return struct.asSlice(count$OFFSET, count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static void count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, count$OFFSET, count$LAYOUT.byteSize());
        }

        private static final GroupLayout not_alive_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("not_alive_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t not_alive_count
         * }
         */
        public static final GroupLayout not_alive_count$layout() {
            return not_alive_count$LAYOUT;
        }

        private static final long not_alive_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t not_alive_count
         * }
         */
        public static final long not_alive_count$offset() {
            return not_alive_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t not_alive_count
         * }
         */
        public static MemorySegment not_alive_count(MemorySegment struct) {
            return struct.asSlice(not_alive_count$OFFSET, not_alive_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t not_alive_count
         * }
         */
        public static void not_alive_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, not_alive_count$OFFSET, not_alive_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout entities$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("entities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t not_alive_count;
     * } entities
     * }
     */
    public static final GroupLayout entities$layout() {
        return entities$LAYOUT;
    }

    private static final long entities$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t not_alive_count;
     * } entities
     * }
     */
    public static final long entities$offset() {
        return entities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t not_alive_count;
     * } entities
     * }
     */
    public static MemorySegment entities(MemorySegment struct) {
        return struct.asSlice(entities$OFFSET, entities$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t not_alive_count;
     * } entities
     * }
     */
    public static void entities(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, entities$OFFSET, entities$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t tag_count;
     *     ecs_metric_t component_count;
     *     ecs_metric_t pair_count;
     *     ecs_metric_t type_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * }
     * }
     */
    public static class components {

        components() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("tag_count"),
            ecs_metric_t.layout().withName("component_count"),
            ecs_metric_t.layout().withName("pair_count"),
            ecs_metric_t.layout().withName("type_count"),
            ecs_metric_t.layout().withName("create_count"),
            ecs_metric_t.layout().withName("delete_count")
        ).withName("$anon$12309:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout tag_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("tag_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t tag_count
         * }
         */
        public static final GroupLayout tag_count$layout() {
            return tag_count$LAYOUT;
        }

        private static final long tag_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t tag_count
         * }
         */
        public static final long tag_count$offset() {
            return tag_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t tag_count
         * }
         */
        public static MemorySegment tag_count(MemorySegment struct) {
            return struct.asSlice(tag_count$OFFSET, tag_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t tag_count
         * }
         */
        public static void tag_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, tag_count$OFFSET, tag_count$LAYOUT.byteSize());
        }

        private static final GroupLayout component_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("component_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t component_count
         * }
         */
        public static final GroupLayout component_count$layout() {
            return component_count$LAYOUT;
        }

        private static final long component_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t component_count
         * }
         */
        public static final long component_count$offset() {
            return component_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t component_count
         * }
         */
        public static MemorySegment component_count(MemorySegment struct) {
            return struct.asSlice(component_count$OFFSET, component_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t component_count
         * }
         */
        public static void component_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, component_count$OFFSET, component_count$LAYOUT.byteSize());
        }

        private static final GroupLayout pair_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pair_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t pair_count
         * }
         */
        public static final GroupLayout pair_count$layout() {
            return pair_count$LAYOUT;
        }

        private static final long pair_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t pair_count
         * }
         */
        public static final long pair_count$offset() {
            return pair_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t pair_count
         * }
         */
        public static MemorySegment pair_count(MemorySegment struct) {
            return struct.asSlice(pair_count$OFFSET, pair_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t pair_count
         * }
         */
        public static void pair_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, pair_count$OFFSET, pair_count$LAYOUT.byteSize());
        }

        private static final GroupLayout type_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("type_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t type_count
         * }
         */
        public static final GroupLayout type_count$layout() {
            return type_count$LAYOUT;
        }

        private static final long type_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t type_count
         * }
         */
        public static final long type_count$offset() {
            return type_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t type_count
         * }
         */
        public static MemorySegment type_count(MemorySegment struct) {
            return struct.asSlice(type_count$OFFSET, type_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t type_count
         * }
         */
        public static void type_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, type_count$OFFSET, type_count$LAYOUT.byteSize());
        }

        private static final GroupLayout create_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("create_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static final GroupLayout create_count$layout() {
            return create_count$LAYOUT;
        }

        private static final long create_count$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static final long create_count$offset() {
            return create_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static MemorySegment create_count(MemorySegment struct) {
            return struct.asSlice(create_count$OFFSET, create_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static void create_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, create_count$OFFSET, create_count$LAYOUT.byteSize());
        }

        private static final GroupLayout delete_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("delete_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final GroupLayout delete_count$layout() {
            return delete_count$LAYOUT;
        }

        private static final long delete_count$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final long delete_count$offset() {
            return delete_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static MemorySegment delete_count(MemorySegment struct) {
            return struct.asSlice(delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static void delete_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout components$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("components"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t tag_count;
     *     ecs_metric_t component_count;
     *     ecs_metric_t pair_count;
     *     ecs_metric_t type_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } components
     * }
     */
    public static final GroupLayout components$layout() {
        return components$LAYOUT;
    }

    private static final long components$OFFSET = 2408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t tag_count;
     *     ecs_metric_t component_count;
     *     ecs_metric_t pair_count;
     *     ecs_metric_t type_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } components
     * }
     */
    public static final long components$offset() {
        return components$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t tag_count;
     *     ecs_metric_t component_count;
     *     ecs_metric_t pair_count;
     *     ecs_metric_t type_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } components
     * }
     */
    public static MemorySegment components(MemorySegment struct) {
        return struct.asSlice(components$OFFSET, components$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t tag_count;
     *     ecs_metric_t component_count;
     *     ecs_metric_t pair_count;
     *     ecs_metric_t type_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } components
     * }
     */
    public static void components(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, components$OFFSET, components$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t empty_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * }
     * }
     */
    public static class tables {

        tables() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("count"),
            ecs_metric_t.layout().withName("empty_count"),
            ecs_metric_t.layout().withName("create_count"),
            ecs_metric_t.layout().withName("delete_count")
        ).withName("$anon$12319:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static final GroupLayout count$layout() {
            return count$LAYOUT;
        }

        private static final long count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static final long count$offset() {
            return count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static MemorySegment count(MemorySegment struct) {
            return struct.asSlice(count$OFFSET, count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t count
         * }
         */
        public static void count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, count$OFFSET, count$LAYOUT.byteSize());
        }

        private static final GroupLayout empty_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("empty_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t empty_count
         * }
         */
        public static final GroupLayout empty_count$layout() {
            return empty_count$LAYOUT;
        }

        private static final long empty_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t empty_count
         * }
         */
        public static final long empty_count$offset() {
            return empty_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t empty_count
         * }
         */
        public static MemorySegment empty_count(MemorySegment struct) {
            return struct.asSlice(empty_count$OFFSET, empty_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t empty_count
         * }
         */
        public static void empty_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, empty_count$OFFSET, empty_count$LAYOUT.byteSize());
        }

        private static final GroupLayout create_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("create_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static final GroupLayout create_count$layout() {
            return create_count$LAYOUT;
        }

        private static final long create_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static final long create_count$offset() {
            return create_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static MemorySegment create_count(MemorySegment struct) {
            return struct.asSlice(create_count$OFFSET, create_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t create_count
         * }
         */
        public static void create_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, create_count$OFFSET, create_count$LAYOUT.byteSize());
        }

        private static final GroupLayout delete_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("delete_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final GroupLayout delete_count$layout() {
            return delete_count$LAYOUT;
        }

        private static final long delete_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final long delete_count$offset() {
            return delete_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static MemorySegment delete_count(MemorySegment struct) {
            return struct.asSlice(delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static void delete_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout tables$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("tables"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t empty_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } tables
     * }
     */
    public static final GroupLayout tables$layout() {
        return tables$LAYOUT;
    }

    private static final long tables$OFFSET = 9608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t empty_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } tables
     * }
     */
    public static final long tables$offset() {
        return tables$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t empty_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } tables
     * }
     */
    public static MemorySegment tables(MemorySegment struct) {
        return struct.asSlice(tables$OFFSET, tables$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t count;
     *     ecs_metric_t empty_count;
     *     ecs_metric_t create_count;
     *     ecs_metric_t delete_count;
     * } tables
     * }
     */
    public static void tables(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, tables$OFFSET, tables$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t query_count;
     *     ecs_metric_t observer_count;
     *     ecs_metric_t system_count;
     * }
     * }
     */
    public static class queries {

        queries() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("query_count"),
            ecs_metric_t.layout().withName("observer_count"),
            ecs_metric_t.layout().withName("system_count")
        ).withName("$anon$12327:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout query_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("query_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t query_count
         * }
         */
        public static final GroupLayout query_count$layout() {
            return query_count$LAYOUT;
        }

        private static final long query_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t query_count
         * }
         */
        public static final long query_count$offset() {
            return query_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t query_count
         * }
         */
        public static MemorySegment query_count(MemorySegment struct) {
            return struct.asSlice(query_count$OFFSET, query_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t query_count
         * }
         */
        public static void query_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, query_count$OFFSET, query_count$LAYOUT.byteSize());
        }

        private static final GroupLayout observer_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("observer_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t observer_count
         * }
         */
        public static final GroupLayout observer_count$layout() {
            return observer_count$LAYOUT;
        }

        private static final long observer_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t observer_count
         * }
         */
        public static final long observer_count$offset() {
            return observer_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t observer_count
         * }
         */
        public static MemorySegment observer_count(MemorySegment struct) {
            return struct.asSlice(observer_count$OFFSET, observer_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t observer_count
         * }
         */
        public static void observer_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, observer_count$OFFSET, observer_count$LAYOUT.byteSize());
        }

        private static final GroupLayout system_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("system_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t system_count
         * }
         */
        public static final GroupLayout system_count$layout() {
            return system_count$LAYOUT;
        }

        private static final long system_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t system_count
         * }
         */
        public static final long system_count$offset() {
            return system_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t system_count
         * }
         */
        public static MemorySegment system_count(MemorySegment struct) {
            return struct.asSlice(system_count$OFFSET, system_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t system_count
         * }
         */
        public static void system_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, system_count$OFFSET, system_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout queries$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("queries"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t query_count;
     *     ecs_metric_t observer_count;
     *     ecs_metric_t system_count;
     * } queries
     * }
     */
    public static final GroupLayout queries$layout() {
        return queries$LAYOUT;
    }

    private static final long queries$OFFSET = 14408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t query_count;
     *     ecs_metric_t observer_count;
     *     ecs_metric_t system_count;
     * } queries
     * }
     */
    public static final long queries$offset() {
        return queries$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t query_count;
     *     ecs_metric_t observer_count;
     *     ecs_metric_t system_count;
     * } queries
     * }
     */
    public static MemorySegment queries(MemorySegment struct) {
        return struct.asSlice(queries$OFFSET, queries$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t query_count;
     *     ecs_metric_t observer_count;
     *     ecs_metric_t system_count;
     * } queries
     * }
     */
    public static void queries(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, queries$OFFSET, queries$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t add_count;
     *     ecs_metric_t remove_count;
     *     ecs_metric_t delete_count;
     *     ecs_metric_t clear_count;
     *     ecs_metric_t set_count;
     *     ecs_metric_t ensure_count;
     *     ecs_metric_t modified_count;
     *     ecs_metric_t other_count;
     *     ecs_metric_t discard_count;
     *     ecs_metric_t batched_entity_count;
     *     ecs_metric_t batched_count;
     * }
     * }
     */
    public static class commands {

        commands() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("add_count"),
            ecs_metric_t.layout().withName("remove_count"),
            ecs_metric_t.layout().withName("delete_count"),
            ecs_metric_t.layout().withName("clear_count"),
            ecs_metric_t.layout().withName("set_count"),
            ecs_metric_t.layout().withName("ensure_count"),
            ecs_metric_t.layout().withName("modified_count"),
            ecs_metric_t.layout().withName("other_count"),
            ecs_metric_t.layout().withName("discard_count"),
            ecs_metric_t.layout().withName("batched_entity_count"),
            ecs_metric_t.layout().withName("batched_count")
        ).withName("$anon$12334:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout add_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("add_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t add_count
         * }
         */
        public static final GroupLayout add_count$layout() {
            return add_count$LAYOUT;
        }

        private static final long add_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t add_count
         * }
         */
        public static final long add_count$offset() {
            return add_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t add_count
         * }
         */
        public static MemorySegment add_count(MemorySegment struct) {
            return struct.asSlice(add_count$OFFSET, add_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t add_count
         * }
         */
        public static void add_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, add_count$OFFSET, add_count$LAYOUT.byteSize());
        }

        private static final GroupLayout remove_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("remove_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t remove_count
         * }
         */
        public static final GroupLayout remove_count$layout() {
            return remove_count$LAYOUT;
        }

        private static final long remove_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t remove_count
         * }
         */
        public static final long remove_count$offset() {
            return remove_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t remove_count
         * }
         */
        public static MemorySegment remove_count(MemorySegment struct) {
            return struct.asSlice(remove_count$OFFSET, remove_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t remove_count
         * }
         */
        public static void remove_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, remove_count$OFFSET, remove_count$LAYOUT.byteSize());
        }

        private static final GroupLayout delete_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("delete_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final GroupLayout delete_count$layout() {
            return delete_count$LAYOUT;
        }

        private static final long delete_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static final long delete_count$offset() {
            return delete_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static MemorySegment delete_count(MemorySegment struct) {
            return struct.asSlice(delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t delete_count
         * }
         */
        public static void delete_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, delete_count$OFFSET, delete_count$LAYOUT.byteSize());
        }

        private static final GroupLayout clear_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("clear_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t clear_count
         * }
         */
        public static final GroupLayout clear_count$layout() {
            return clear_count$LAYOUT;
        }

        private static final long clear_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t clear_count
         * }
         */
        public static final long clear_count$offset() {
            return clear_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t clear_count
         * }
         */
        public static MemorySegment clear_count(MemorySegment struct) {
            return struct.asSlice(clear_count$OFFSET, clear_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t clear_count
         * }
         */
        public static void clear_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, clear_count$OFFSET, clear_count$LAYOUT.byteSize());
        }

        private static final GroupLayout set_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("set_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t set_count
         * }
         */
        public static final GroupLayout set_count$layout() {
            return set_count$LAYOUT;
        }

        private static final long set_count$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t set_count
         * }
         */
        public static final long set_count$offset() {
            return set_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t set_count
         * }
         */
        public static MemorySegment set_count(MemorySegment struct) {
            return struct.asSlice(set_count$OFFSET, set_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t set_count
         * }
         */
        public static void set_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, set_count$OFFSET, set_count$LAYOUT.byteSize());
        }

        private static final GroupLayout ensure_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ensure_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t ensure_count
         * }
         */
        public static final GroupLayout ensure_count$layout() {
            return ensure_count$LAYOUT;
        }

        private static final long ensure_count$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t ensure_count
         * }
         */
        public static final long ensure_count$offset() {
            return ensure_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t ensure_count
         * }
         */
        public static MemorySegment ensure_count(MemorySegment struct) {
            return struct.asSlice(ensure_count$OFFSET, ensure_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t ensure_count
         * }
         */
        public static void ensure_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, ensure_count$OFFSET, ensure_count$LAYOUT.byteSize());
        }

        private static final GroupLayout modified_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("modified_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t modified_count
         * }
         */
        public static final GroupLayout modified_count$layout() {
            return modified_count$LAYOUT;
        }

        private static final long modified_count$OFFSET = 7200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t modified_count
         * }
         */
        public static final long modified_count$offset() {
            return modified_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t modified_count
         * }
         */
        public static MemorySegment modified_count(MemorySegment struct) {
            return struct.asSlice(modified_count$OFFSET, modified_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t modified_count
         * }
         */
        public static void modified_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, modified_count$OFFSET, modified_count$LAYOUT.byteSize());
        }

        private static final GroupLayout other_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("other_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t other_count
         * }
         */
        public static final GroupLayout other_count$layout() {
            return other_count$LAYOUT;
        }

        private static final long other_count$OFFSET = 8400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t other_count
         * }
         */
        public static final long other_count$offset() {
            return other_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t other_count
         * }
         */
        public static MemorySegment other_count(MemorySegment struct) {
            return struct.asSlice(other_count$OFFSET, other_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t other_count
         * }
         */
        public static void other_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, other_count$OFFSET, other_count$LAYOUT.byteSize());
        }

        private static final GroupLayout discard_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("discard_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t discard_count
         * }
         */
        public static final GroupLayout discard_count$layout() {
            return discard_count$LAYOUT;
        }

        private static final long discard_count$OFFSET = 9600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t discard_count
         * }
         */
        public static final long discard_count$offset() {
            return discard_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t discard_count
         * }
         */
        public static MemorySegment discard_count(MemorySegment struct) {
            return struct.asSlice(discard_count$OFFSET, discard_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t discard_count
         * }
         */
        public static void discard_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, discard_count$OFFSET, discard_count$LAYOUT.byteSize());
        }

        private static final GroupLayout batched_entity_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("batched_entity_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_entity_count
         * }
         */
        public static final GroupLayout batched_entity_count$layout() {
            return batched_entity_count$LAYOUT;
        }

        private static final long batched_entity_count$OFFSET = 10800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_entity_count
         * }
         */
        public static final long batched_entity_count$offset() {
            return batched_entity_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_entity_count
         * }
         */
        public static MemorySegment batched_entity_count(MemorySegment struct) {
            return struct.asSlice(batched_entity_count$OFFSET, batched_entity_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_entity_count
         * }
         */
        public static void batched_entity_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, batched_entity_count$OFFSET, batched_entity_count$LAYOUT.byteSize());
        }

        private static final GroupLayout batched_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("batched_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_count
         * }
         */
        public static final GroupLayout batched_count$layout() {
            return batched_count$LAYOUT;
        }

        private static final long batched_count$OFFSET = 12000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_count
         * }
         */
        public static final long batched_count$offset() {
            return batched_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_count
         * }
         */
        public static MemorySegment batched_count(MemorySegment struct) {
            return struct.asSlice(batched_count$OFFSET, batched_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t batched_count
         * }
         */
        public static void batched_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, batched_count$OFFSET, batched_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout commands$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("commands"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t add_count;
     *     ecs_metric_t remove_count;
     *     ecs_metric_t delete_count;
     *     ecs_metric_t clear_count;
     *     ecs_metric_t set_count;
     *     ecs_metric_t ensure_count;
     *     ecs_metric_t modified_count;
     *     ecs_metric_t other_count;
     *     ecs_metric_t discard_count;
     *     ecs_metric_t batched_entity_count;
     *     ecs_metric_t batched_count;
     * } commands
     * }
     */
    public static final GroupLayout commands$layout() {
        return commands$LAYOUT;
    }

    private static final long commands$OFFSET = 18008;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t add_count;
     *     ecs_metric_t remove_count;
     *     ecs_metric_t delete_count;
     *     ecs_metric_t clear_count;
     *     ecs_metric_t set_count;
     *     ecs_metric_t ensure_count;
     *     ecs_metric_t modified_count;
     *     ecs_metric_t other_count;
     *     ecs_metric_t discard_count;
     *     ecs_metric_t batched_entity_count;
     *     ecs_metric_t batched_count;
     * } commands
     * }
     */
    public static final long commands$offset() {
        return commands$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t add_count;
     *     ecs_metric_t remove_count;
     *     ecs_metric_t delete_count;
     *     ecs_metric_t clear_count;
     *     ecs_metric_t set_count;
     *     ecs_metric_t ensure_count;
     *     ecs_metric_t modified_count;
     *     ecs_metric_t other_count;
     *     ecs_metric_t discard_count;
     *     ecs_metric_t batched_entity_count;
     *     ecs_metric_t batched_count;
     * } commands
     * }
     */
    public static MemorySegment commands(MemorySegment struct) {
        return struct.asSlice(commands$OFFSET, commands$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t add_count;
     *     ecs_metric_t remove_count;
     *     ecs_metric_t delete_count;
     *     ecs_metric_t clear_count;
     *     ecs_metric_t set_count;
     *     ecs_metric_t ensure_count;
     *     ecs_metric_t modified_count;
     *     ecs_metric_t other_count;
     *     ecs_metric_t discard_count;
     *     ecs_metric_t batched_entity_count;
     *     ecs_metric_t batched_count;
     * } commands
     * }
     */
    public static void commands(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, commands$OFFSET, commands$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t frame_count;
     *     ecs_metric_t merge_count;
     *     ecs_metric_t rematch_count;
     *     ecs_metric_t pipeline_build_count;
     *     ecs_metric_t systems_ran;
     *     ecs_metric_t observers_ran;
     *     ecs_metric_t event_emit_count;
     * }
     * }
     */
    public static class frame {

        frame() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("frame_count"),
            ecs_metric_t.layout().withName("merge_count"),
            ecs_metric_t.layout().withName("rematch_count"),
            ecs_metric_t.layout().withName("pipeline_build_count"),
            ecs_metric_t.layout().withName("systems_ran"),
            ecs_metric_t.layout().withName("observers_ran"),
            ecs_metric_t.layout().withName("event_emit_count")
        ).withName("$anon$12349:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout frame_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("frame_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_count
         * }
         */
        public static final GroupLayout frame_count$layout() {
            return frame_count$LAYOUT;
        }

        private static final long frame_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_count
         * }
         */
        public static final long frame_count$offset() {
            return frame_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_count
         * }
         */
        public static MemorySegment frame_count(MemorySegment struct) {
            return struct.asSlice(frame_count$OFFSET, frame_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_count
         * }
         */
        public static void frame_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, frame_count$OFFSET, frame_count$LAYOUT.byteSize());
        }

        private static final GroupLayout merge_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("merge_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_count
         * }
         */
        public static final GroupLayout merge_count$layout() {
            return merge_count$LAYOUT;
        }

        private static final long merge_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_count
         * }
         */
        public static final long merge_count$offset() {
            return merge_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_count
         * }
         */
        public static MemorySegment merge_count(MemorySegment struct) {
            return struct.asSlice(merge_count$OFFSET, merge_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_count
         * }
         */
        public static void merge_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, merge_count$OFFSET, merge_count$LAYOUT.byteSize());
        }

        private static final GroupLayout rematch_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("rematch_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_count
         * }
         */
        public static final GroupLayout rematch_count$layout() {
            return rematch_count$LAYOUT;
        }

        private static final long rematch_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_count
         * }
         */
        public static final long rematch_count$offset() {
            return rematch_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_count
         * }
         */
        public static MemorySegment rematch_count(MemorySegment struct) {
            return struct.asSlice(rematch_count$OFFSET, rematch_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_count
         * }
         */
        public static void rematch_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, rematch_count$OFFSET, rematch_count$LAYOUT.byteSize());
        }

        private static final GroupLayout pipeline_build_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pipeline_build_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t pipeline_build_count
         * }
         */
        public static final GroupLayout pipeline_build_count$layout() {
            return pipeline_build_count$LAYOUT;
        }

        private static final long pipeline_build_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t pipeline_build_count
         * }
         */
        public static final long pipeline_build_count$offset() {
            return pipeline_build_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t pipeline_build_count
         * }
         */
        public static MemorySegment pipeline_build_count(MemorySegment struct) {
            return struct.asSlice(pipeline_build_count$OFFSET, pipeline_build_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t pipeline_build_count
         * }
         */
        public static void pipeline_build_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, pipeline_build_count$OFFSET, pipeline_build_count$LAYOUT.byteSize());
        }

        private static final GroupLayout systems_ran$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("systems_ran"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t systems_ran
         * }
         */
        public static final GroupLayout systems_ran$layout() {
            return systems_ran$LAYOUT;
        }

        private static final long systems_ran$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t systems_ran
         * }
         */
        public static final long systems_ran$offset() {
            return systems_ran$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t systems_ran
         * }
         */
        public static MemorySegment systems_ran(MemorySegment struct) {
            return struct.asSlice(systems_ran$OFFSET, systems_ran$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t systems_ran
         * }
         */
        public static void systems_ran(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, systems_ran$OFFSET, systems_ran$LAYOUT.byteSize());
        }

        private static final GroupLayout observers_ran$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("observers_ran"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t observers_ran
         * }
         */
        public static final GroupLayout observers_ran$layout() {
            return observers_ran$LAYOUT;
        }

        private static final long observers_ran$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t observers_ran
         * }
         */
        public static final long observers_ran$offset() {
            return observers_ran$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t observers_ran
         * }
         */
        public static MemorySegment observers_ran(MemorySegment struct) {
            return struct.asSlice(observers_ran$OFFSET, observers_ran$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t observers_ran
         * }
         */
        public static void observers_ran(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, observers_ran$OFFSET, observers_ran$LAYOUT.byteSize());
        }

        private static final GroupLayout event_emit_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("event_emit_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t event_emit_count
         * }
         */
        public static final GroupLayout event_emit_count$layout() {
            return event_emit_count$LAYOUT;
        }

        private static final long event_emit_count$OFFSET = 7200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t event_emit_count
         * }
         */
        public static final long event_emit_count$offset() {
            return event_emit_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t event_emit_count
         * }
         */
        public static MemorySegment event_emit_count(MemorySegment struct) {
            return struct.asSlice(event_emit_count$OFFSET, event_emit_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t event_emit_count
         * }
         */
        public static void event_emit_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, event_emit_count$OFFSET, event_emit_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout frame$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("frame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t frame_count;
     *     ecs_metric_t merge_count;
     *     ecs_metric_t rematch_count;
     *     ecs_metric_t pipeline_build_count;
     *     ecs_metric_t systems_ran;
     *     ecs_metric_t observers_ran;
     *     ecs_metric_t event_emit_count;
     * } frame
     * }
     */
    public static final GroupLayout frame$layout() {
        return frame$LAYOUT;
    }

    private static final long frame$OFFSET = 31208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t frame_count;
     *     ecs_metric_t merge_count;
     *     ecs_metric_t rematch_count;
     *     ecs_metric_t pipeline_build_count;
     *     ecs_metric_t systems_ran;
     *     ecs_metric_t observers_ran;
     *     ecs_metric_t event_emit_count;
     * } frame
     * }
     */
    public static final long frame$offset() {
        return frame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t frame_count;
     *     ecs_metric_t merge_count;
     *     ecs_metric_t rematch_count;
     *     ecs_metric_t pipeline_build_count;
     *     ecs_metric_t systems_ran;
     *     ecs_metric_t observers_ran;
     *     ecs_metric_t event_emit_count;
     * } frame
     * }
     */
    public static MemorySegment frame(MemorySegment struct) {
        return struct.asSlice(frame$OFFSET, frame$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t frame_count;
     *     ecs_metric_t merge_count;
     *     ecs_metric_t rematch_count;
     *     ecs_metric_t pipeline_build_count;
     *     ecs_metric_t systems_ran;
     *     ecs_metric_t observers_ran;
     *     ecs_metric_t event_emit_count;
     * } frame
     * }
     */
    public static void frame(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, frame$OFFSET, frame$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t world_time_raw;
     *     ecs_metric_t world_time;
     *     ecs_metric_t frame_time;
     *     ecs_metric_t system_time;
     *     ecs_metric_t emit_time;
     *     ecs_metric_t merge_time;
     *     ecs_metric_t rematch_time;
     *     ecs_metric_t fps;
     *     ecs_metric_t delta_time;
     * }
     * }
     */
    public static class performance {

        performance() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("world_time_raw"),
            ecs_metric_t.layout().withName("world_time"),
            ecs_metric_t.layout().withName("frame_time"),
            ecs_metric_t.layout().withName("system_time"),
            ecs_metric_t.layout().withName("emit_time"),
            ecs_metric_t.layout().withName("merge_time"),
            ecs_metric_t.layout().withName("rematch_time"),
            ecs_metric_t.layout().withName("fps"),
            ecs_metric_t.layout().withName("delta_time")
        ).withName("$anon$12360:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout world_time_raw$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("world_time_raw"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time_raw
         * }
         */
        public static final GroupLayout world_time_raw$layout() {
            return world_time_raw$LAYOUT;
        }

        private static final long world_time_raw$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time_raw
         * }
         */
        public static final long world_time_raw$offset() {
            return world_time_raw$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time_raw
         * }
         */
        public static MemorySegment world_time_raw(MemorySegment struct) {
            return struct.asSlice(world_time_raw$OFFSET, world_time_raw$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time_raw
         * }
         */
        public static void world_time_raw(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, world_time_raw$OFFSET, world_time_raw$LAYOUT.byteSize());
        }

        private static final GroupLayout world_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("world_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time
         * }
         */
        public static final GroupLayout world_time$layout() {
            return world_time$LAYOUT;
        }

        private static final long world_time$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time
         * }
         */
        public static final long world_time$offset() {
            return world_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time
         * }
         */
        public static MemorySegment world_time(MemorySegment struct) {
            return struct.asSlice(world_time$OFFSET, world_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t world_time
         * }
         */
        public static void world_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, world_time$OFFSET, world_time$LAYOUT.byteSize());
        }

        private static final GroupLayout frame_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("frame_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_time
         * }
         */
        public static final GroupLayout frame_time$layout() {
            return frame_time$LAYOUT;
        }

        private static final long frame_time$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_time
         * }
         */
        public static final long frame_time$offset() {
            return frame_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_time
         * }
         */
        public static MemorySegment frame_time(MemorySegment struct) {
            return struct.asSlice(frame_time$OFFSET, frame_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t frame_time
         * }
         */
        public static void frame_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, frame_time$OFFSET, frame_time$LAYOUT.byteSize());
        }

        private static final GroupLayout system_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("system_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t system_time
         * }
         */
        public static final GroupLayout system_time$layout() {
            return system_time$LAYOUT;
        }

        private static final long system_time$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t system_time
         * }
         */
        public static final long system_time$offset() {
            return system_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t system_time
         * }
         */
        public static MemorySegment system_time(MemorySegment struct) {
            return struct.asSlice(system_time$OFFSET, system_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t system_time
         * }
         */
        public static void system_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, system_time$OFFSET, system_time$LAYOUT.byteSize());
        }

        private static final GroupLayout emit_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("emit_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t emit_time
         * }
         */
        public static final GroupLayout emit_time$layout() {
            return emit_time$LAYOUT;
        }

        private static final long emit_time$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t emit_time
         * }
         */
        public static final long emit_time$offset() {
            return emit_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t emit_time
         * }
         */
        public static MemorySegment emit_time(MemorySegment struct) {
            return struct.asSlice(emit_time$OFFSET, emit_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t emit_time
         * }
         */
        public static void emit_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, emit_time$OFFSET, emit_time$LAYOUT.byteSize());
        }

        private static final GroupLayout merge_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("merge_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_time
         * }
         */
        public static final GroupLayout merge_time$layout() {
            return merge_time$LAYOUT;
        }

        private static final long merge_time$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_time
         * }
         */
        public static final long merge_time$offset() {
            return merge_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_time
         * }
         */
        public static MemorySegment merge_time(MemorySegment struct) {
            return struct.asSlice(merge_time$OFFSET, merge_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t merge_time
         * }
         */
        public static void merge_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, merge_time$OFFSET, merge_time$LAYOUT.byteSize());
        }

        private static final GroupLayout rematch_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("rematch_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_time
         * }
         */
        public static final GroupLayout rematch_time$layout() {
            return rematch_time$LAYOUT;
        }

        private static final long rematch_time$OFFSET = 7200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_time
         * }
         */
        public static final long rematch_time$offset() {
            return rematch_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_time
         * }
         */
        public static MemorySegment rematch_time(MemorySegment struct) {
            return struct.asSlice(rematch_time$OFFSET, rematch_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t rematch_time
         * }
         */
        public static void rematch_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, rematch_time$OFFSET, rematch_time$LAYOUT.byteSize());
        }

        private static final GroupLayout fps$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("fps"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t fps
         * }
         */
        public static final GroupLayout fps$layout() {
            return fps$LAYOUT;
        }

        private static final long fps$OFFSET = 8400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t fps
         * }
         */
        public static final long fps$offset() {
            return fps$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t fps
         * }
         */
        public static MemorySegment fps(MemorySegment struct) {
            return struct.asSlice(fps$OFFSET, fps$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t fps
         * }
         */
        public static void fps(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, fps$OFFSET, fps$LAYOUT.byteSize());
        }

        private static final GroupLayout delta_time$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("delta_time"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t delta_time
         * }
         */
        public static final GroupLayout delta_time$layout() {
            return delta_time$LAYOUT;
        }

        private static final long delta_time$OFFSET = 9600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t delta_time
         * }
         */
        public static final long delta_time$offset() {
            return delta_time$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t delta_time
         * }
         */
        public static MemorySegment delta_time(MemorySegment struct) {
            return struct.asSlice(delta_time$OFFSET, delta_time$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t delta_time
         * }
         */
        public static void delta_time(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, delta_time$OFFSET, delta_time$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout performance$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("performance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t world_time_raw;
     *     ecs_metric_t world_time;
     *     ecs_metric_t frame_time;
     *     ecs_metric_t system_time;
     *     ecs_metric_t emit_time;
     *     ecs_metric_t merge_time;
     *     ecs_metric_t rematch_time;
     *     ecs_metric_t fps;
     *     ecs_metric_t delta_time;
     * } performance
     * }
     */
    public static final GroupLayout performance$layout() {
        return performance$LAYOUT;
    }

    private static final long performance$OFFSET = 39608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t world_time_raw;
     *     ecs_metric_t world_time;
     *     ecs_metric_t frame_time;
     *     ecs_metric_t system_time;
     *     ecs_metric_t emit_time;
     *     ecs_metric_t merge_time;
     *     ecs_metric_t rematch_time;
     *     ecs_metric_t fps;
     *     ecs_metric_t delta_time;
     * } performance
     * }
     */
    public static final long performance$offset() {
        return performance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t world_time_raw;
     *     ecs_metric_t world_time;
     *     ecs_metric_t frame_time;
     *     ecs_metric_t system_time;
     *     ecs_metric_t emit_time;
     *     ecs_metric_t merge_time;
     *     ecs_metric_t rematch_time;
     *     ecs_metric_t fps;
     *     ecs_metric_t delta_time;
     * } performance
     * }
     */
    public static MemorySegment performance(MemorySegment struct) {
        return struct.asSlice(performance$OFFSET, performance$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t world_time_raw;
     *     ecs_metric_t world_time;
     *     ecs_metric_t frame_time;
     *     ecs_metric_t system_time;
     *     ecs_metric_t emit_time;
     *     ecs_metric_t merge_time;
     *     ecs_metric_t rematch_time;
     *     ecs_metric_t fps;
     *     ecs_metric_t delta_time;
     * } performance
     * }
     */
    public static void performance(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, performance$OFFSET, performance$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t alloc_count;
     *     ecs_metric_t realloc_count;
     *     ecs_metric_t free_count;
     *     ecs_metric_t outstanding_alloc_count;
     *     ecs_metric_t block_alloc_count;
     *     ecs_metric_t block_free_count;
     *     ecs_metric_t block_outstanding_alloc_count;
     *     ecs_metric_t stack_alloc_count;
     *     ecs_metric_t stack_free_count;
     *     ecs_metric_t stack_outstanding_alloc_count;
     * }
     * }
     */
    public static class memory {

        memory() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("alloc_count"),
            ecs_metric_t.layout().withName("realloc_count"),
            ecs_metric_t.layout().withName("free_count"),
            ecs_metric_t.layout().withName("outstanding_alloc_count"),
            ecs_metric_t.layout().withName("block_alloc_count"),
            ecs_metric_t.layout().withName("block_free_count"),
            ecs_metric_t.layout().withName("block_outstanding_alloc_count"),
            ecs_metric_t.layout().withName("stack_alloc_count"),
            ecs_metric_t.layout().withName("stack_free_count"),
            ecs_metric_t.layout().withName("stack_outstanding_alloc_count")
        ).withName("$anon$12372:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t alloc_count
         * }
         */
        public static final GroupLayout alloc_count$layout() {
            return alloc_count$LAYOUT;
        }

        private static final long alloc_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t alloc_count
         * }
         */
        public static final long alloc_count$offset() {
            return alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t alloc_count
         * }
         */
        public static MemorySegment alloc_count(MemorySegment struct) {
            return struct.asSlice(alloc_count$OFFSET, alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t alloc_count
         * }
         */
        public static void alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, alloc_count$OFFSET, alloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout realloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("realloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t realloc_count
         * }
         */
        public static final GroupLayout realloc_count$layout() {
            return realloc_count$LAYOUT;
        }

        private static final long realloc_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t realloc_count
         * }
         */
        public static final long realloc_count$offset() {
            return realloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t realloc_count
         * }
         */
        public static MemorySegment realloc_count(MemorySegment struct) {
            return struct.asSlice(realloc_count$OFFSET, realloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t realloc_count
         * }
         */
        public static void realloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, realloc_count$OFFSET, realloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout free_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("free_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t free_count
         * }
         */
        public static final GroupLayout free_count$layout() {
            return free_count$LAYOUT;
        }

        private static final long free_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t free_count
         * }
         */
        public static final long free_count$offset() {
            return free_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t free_count
         * }
         */
        public static MemorySegment free_count(MemorySegment struct) {
            return struct.asSlice(free_count$OFFSET, free_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t free_count
         * }
         */
        public static void free_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, free_count$OFFSET, free_count$LAYOUT.byteSize());
        }

        private static final GroupLayout outstanding_alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("outstanding_alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t outstanding_alloc_count
         * }
         */
        public static final GroupLayout outstanding_alloc_count$layout() {
            return outstanding_alloc_count$LAYOUT;
        }

        private static final long outstanding_alloc_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t outstanding_alloc_count
         * }
         */
        public static final long outstanding_alloc_count$offset() {
            return outstanding_alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t outstanding_alloc_count
         * }
         */
        public static MemorySegment outstanding_alloc_count(MemorySegment struct) {
            return struct.asSlice(outstanding_alloc_count$OFFSET, outstanding_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t outstanding_alloc_count
         * }
         */
        public static void outstanding_alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, outstanding_alloc_count$OFFSET, outstanding_alloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout block_alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("block_alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t block_alloc_count
         * }
         */
        public static final GroupLayout block_alloc_count$layout() {
            return block_alloc_count$LAYOUT;
        }

        private static final long block_alloc_count$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t block_alloc_count
         * }
         */
        public static final long block_alloc_count$offset() {
            return block_alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_alloc_count
         * }
         */
        public static MemorySegment block_alloc_count(MemorySegment struct) {
            return struct.asSlice(block_alloc_count$OFFSET, block_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_alloc_count
         * }
         */
        public static void block_alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, block_alloc_count$OFFSET, block_alloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout block_free_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("block_free_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t block_free_count
         * }
         */
        public static final GroupLayout block_free_count$layout() {
            return block_free_count$LAYOUT;
        }

        private static final long block_free_count$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t block_free_count
         * }
         */
        public static final long block_free_count$offset() {
            return block_free_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_free_count
         * }
         */
        public static MemorySegment block_free_count(MemorySegment struct) {
            return struct.asSlice(block_free_count$OFFSET, block_free_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_free_count
         * }
         */
        public static void block_free_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, block_free_count$OFFSET, block_free_count$LAYOUT.byteSize());
        }

        private static final GroupLayout block_outstanding_alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("block_outstanding_alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t block_outstanding_alloc_count
         * }
         */
        public static final GroupLayout block_outstanding_alloc_count$layout() {
            return block_outstanding_alloc_count$LAYOUT;
        }

        private static final long block_outstanding_alloc_count$OFFSET = 7200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t block_outstanding_alloc_count
         * }
         */
        public static final long block_outstanding_alloc_count$offset() {
            return block_outstanding_alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_outstanding_alloc_count
         * }
         */
        public static MemorySegment block_outstanding_alloc_count(MemorySegment struct) {
            return struct.asSlice(block_outstanding_alloc_count$OFFSET, block_outstanding_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t block_outstanding_alloc_count
         * }
         */
        public static void block_outstanding_alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, block_outstanding_alloc_count$OFFSET, block_outstanding_alloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout stack_alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("stack_alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_alloc_count
         * }
         */
        public static final GroupLayout stack_alloc_count$layout() {
            return stack_alloc_count$LAYOUT;
        }

        private static final long stack_alloc_count$OFFSET = 8400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_alloc_count
         * }
         */
        public static final long stack_alloc_count$offset() {
            return stack_alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_alloc_count
         * }
         */
        public static MemorySegment stack_alloc_count(MemorySegment struct) {
            return struct.asSlice(stack_alloc_count$OFFSET, stack_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_alloc_count
         * }
         */
        public static void stack_alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, stack_alloc_count$OFFSET, stack_alloc_count$LAYOUT.byteSize());
        }

        private static final GroupLayout stack_free_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("stack_free_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_free_count
         * }
         */
        public static final GroupLayout stack_free_count$layout() {
            return stack_free_count$LAYOUT;
        }

        private static final long stack_free_count$OFFSET = 9600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_free_count
         * }
         */
        public static final long stack_free_count$offset() {
            return stack_free_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_free_count
         * }
         */
        public static MemorySegment stack_free_count(MemorySegment struct) {
            return struct.asSlice(stack_free_count$OFFSET, stack_free_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_free_count
         * }
         */
        public static void stack_free_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, stack_free_count$OFFSET, stack_free_count$LAYOUT.byteSize());
        }

        private static final GroupLayout stack_outstanding_alloc_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("stack_outstanding_alloc_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_outstanding_alloc_count
         * }
         */
        public static final GroupLayout stack_outstanding_alloc_count$layout() {
            return stack_outstanding_alloc_count$LAYOUT;
        }

        private static final long stack_outstanding_alloc_count$OFFSET = 10800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_outstanding_alloc_count
         * }
         */
        public static final long stack_outstanding_alloc_count$offset() {
            return stack_outstanding_alloc_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_outstanding_alloc_count
         * }
         */
        public static MemorySegment stack_outstanding_alloc_count(MemorySegment struct) {
            return struct.asSlice(stack_outstanding_alloc_count$OFFSET, stack_outstanding_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t stack_outstanding_alloc_count
         * }
         */
        public static void stack_outstanding_alloc_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, stack_outstanding_alloc_count$OFFSET, stack_outstanding_alloc_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout memory$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("memory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t alloc_count;
     *     ecs_metric_t realloc_count;
     *     ecs_metric_t free_count;
     *     ecs_metric_t outstanding_alloc_count;
     *     ecs_metric_t block_alloc_count;
     *     ecs_metric_t block_free_count;
     *     ecs_metric_t block_outstanding_alloc_count;
     *     ecs_metric_t stack_alloc_count;
     *     ecs_metric_t stack_free_count;
     *     ecs_metric_t stack_outstanding_alloc_count;
     * } memory
     * }
     */
    public static final GroupLayout memory$layout() {
        return memory$LAYOUT;
    }

    private static final long memory$OFFSET = 50408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t alloc_count;
     *     ecs_metric_t realloc_count;
     *     ecs_metric_t free_count;
     *     ecs_metric_t outstanding_alloc_count;
     *     ecs_metric_t block_alloc_count;
     *     ecs_metric_t block_free_count;
     *     ecs_metric_t block_outstanding_alloc_count;
     *     ecs_metric_t stack_alloc_count;
     *     ecs_metric_t stack_free_count;
     *     ecs_metric_t stack_outstanding_alloc_count;
     * } memory
     * }
     */
    public static final long memory$offset() {
        return memory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t alloc_count;
     *     ecs_metric_t realloc_count;
     *     ecs_metric_t free_count;
     *     ecs_metric_t outstanding_alloc_count;
     *     ecs_metric_t block_alloc_count;
     *     ecs_metric_t block_free_count;
     *     ecs_metric_t block_outstanding_alloc_count;
     *     ecs_metric_t stack_alloc_count;
     *     ecs_metric_t stack_free_count;
     *     ecs_metric_t stack_outstanding_alloc_count;
     * } memory
     * }
     */
    public static MemorySegment memory(MemorySegment struct) {
        return struct.asSlice(memory$OFFSET, memory$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t alloc_count;
     *     ecs_metric_t realloc_count;
     *     ecs_metric_t free_count;
     *     ecs_metric_t outstanding_alloc_count;
     *     ecs_metric_t block_alloc_count;
     *     ecs_metric_t block_free_count;
     *     ecs_metric_t block_outstanding_alloc_count;
     *     ecs_metric_t stack_alloc_count;
     *     ecs_metric_t stack_free_count;
     *     ecs_metric_t stack_outstanding_alloc_count;
     * } memory
     * }
     */
    public static void memory(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, memory$OFFSET, memory$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t request_received_count;
     *     ecs_metric_t request_invalid_count;
     *     ecs_metric_t request_handled_ok_count;
     *     ecs_metric_t request_handled_error_count;
     *     ecs_metric_t request_not_handled_count;
     *     ecs_metric_t request_preflight_count;
     *     ecs_metric_t send_ok_count;
     *     ecs_metric_t send_error_count;
     *     ecs_metric_t busy_count;
     * }
     * }
     */
    public static class http {

        http() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            ecs_metric_t.layout().withName("request_received_count"),
            ecs_metric_t.layout().withName("request_invalid_count"),
            ecs_metric_t.layout().withName("request_handled_ok_count"),
            ecs_metric_t.layout().withName("request_handled_error_count"),
            ecs_metric_t.layout().withName("request_not_handled_count"),
            ecs_metric_t.layout().withName("request_preflight_count"),
            ecs_metric_t.layout().withName("send_ok_count"),
            ecs_metric_t.layout().withName("send_error_count"),
            ecs_metric_t.layout().withName("busy_count")
        ).withName("$anon$12389:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout request_received_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_received_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_received_count
         * }
         */
        public static final GroupLayout request_received_count$layout() {
            return request_received_count$LAYOUT;
        }

        private static final long request_received_count$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_received_count
         * }
         */
        public static final long request_received_count$offset() {
            return request_received_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_received_count
         * }
         */
        public static MemorySegment request_received_count(MemorySegment struct) {
            return struct.asSlice(request_received_count$OFFSET, request_received_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_received_count
         * }
         */
        public static void request_received_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_received_count$OFFSET, request_received_count$LAYOUT.byteSize());
        }

        private static final GroupLayout request_invalid_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_invalid_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_invalid_count
         * }
         */
        public static final GroupLayout request_invalid_count$layout() {
            return request_invalid_count$LAYOUT;
        }

        private static final long request_invalid_count$OFFSET = 1200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_invalid_count
         * }
         */
        public static final long request_invalid_count$offset() {
            return request_invalid_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_invalid_count
         * }
         */
        public static MemorySegment request_invalid_count(MemorySegment struct) {
            return struct.asSlice(request_invalid_count$OFFSET, request_invalid_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_invalid_count
         * }
         */
        public static void request_invalid_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_invalid_count$OFFSET, request_invalid_count$LAYOUT.byteSize());
        }

        private static final GroupLayout request_handled_ok_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_handled_ok_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_ok_count
         * }
         */
        public static final GroupLayout request_handled_ok_count$layout() {
            return request_handled_ok_count$LAYOUT;
        }

        private static final long request_handled_ok_count$OFFSET = 2400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_ok_count
         * }
         */
        public static final long request_handled_ok_count$offset() {
            return request_handled_ok_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_ok_count
         * }
         */
        public static MemorySegment request_handled_ok_count(MemorySegment struct) {
            return struct.asSlice(request_handled_ok_count$OFFSET, request_handled_ok_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_ok_count
         * }
         */
        public static void request_handled_ok_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_handled_ok_count$OFFSET, request_handled_ok_count$LAYOUT.byteSize());
        }

        private static final GroupLayout request_handled_error_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_handled_error_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_error_count
         * }
         */
        public static final GroupLayout request_handled_error_count$layout() {
            return request_handled_error_count$LAYOUT;
        }

        private static final long request_handled_error_count$OFFSET = 3600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_error_count
         * }
         */
        public static final long request_handled_error_count$offset() {
            return request_handled_error_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_error_count
         * }
         */
        public static MemorySegment request_handled_error_count(MemorySegment struct) {
            return struct.asSlice(request_handled_error_count$OFFSET, request_handled_error_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_handled_error_count
         * }
         */
        public static void request_handled_error_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_handled_error_count$OFFSET, request_handled_error_count$LAYOUT.byteSize());
        }

        private static final GroupLayout request_not_handled_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_not_handled_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_not_handled_count
         * }
         */
        public static final GroupLayout request_not_handled_count$layout() {
            return request_not_handled_count$LAYOUT;
        }

        private static final long request_not_handled_count$OFFSET = 4800;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_not_handled_count
         * }
         */
        public static final long request_not_handled_count$offset() {
            return request_not_handled_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_not_handled_count
         * }
         */
        public static MemorySegment request_not_handled_count(MemorySegment struct) {
            return struct.asSlice(request_not_handled_count$OFFSET, request_not_handled_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_not_handled_count
         * }
         */
        public static void request_not_handled_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_not_handled_count$OFFSET, request_not_handled_count$LAYOUT.byteSize());
        }

        private static final GroupLayout request_preflight_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("request_preflight_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t request_preflight_count
         * }
         */
        public static final GroupLayout request_preflight_count$layout() {
            return request_preflight_count$LAYOUT;
        }

        private static final long request_preflight_count$OFFSET = 6000;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t request_preflight_count
         * }
         */
        public static final long request_preflight_count$offset() {
            return request_preflight_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_preflight_count
         * }
         */
        public static MemorySegment request_preflight_count(MemorySegment struct) {
            return struct.asSlice(request_preflight_count$OFFSET, request_preflight_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t request_preflight_count
         * }
         */
        public static void request_preflight_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, request_preflight_count$OFFSET, request_preflight_count$LAYOUT.byteSize());
        }

        private static final GroupLayout send_ok_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("send_ok_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t send_ok_count
         * }
         */
        public static final GroupLayout send_ok_count$layout() {
            return send_ok_count$LAYOUT;
        }

        private static final long send_ok_count$OFFSET = 7200;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t send_ok_count
         * }
         */
        public static final long send_ok_count$offset() {
            return send_ok_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t send_ok_count
         * }
         */
        public static MemorySegment send_ok_count(MemorySegment struct) {
            return struct.asSlice(send_ok_count$OFFSET, send_ok_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t send_ok_count
         * }
         */
        public static void send_ok_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, send_ok_count$OFFSET, send_ok_count$LAYOUT.byteSize());
        }

        private static final GroupLayout send_error_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("send_error_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t send_error_count
         * }
         */
        public static final GroupLayout send_error_count$layout() {
            return send_error_count$LAYOUT;
        }

        private static final long send_error_count$OFFSET = 8400;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t send_error_count
         * }
         */
        public static final long send_error_count$offset() {
            return send_error_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t send_error_count
         * }
         */
        public static MemorySegment send_error_count(MemorySegment struct) {
            return struct.asSlice(send_error_count$OFFSET, send_error_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t send_error_count
         * }
         */
        public static void send_error_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, send_error_count$OFFSET, send_error_count$LAYOUT.byteSize());
        }

        private static final GroupLayout busy_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("busy_count"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ecs_metric_t busy_count
         * }
         */
        public static final GroupLayout busy_count$layout() {
            return busy_count$LAYOUT;
        }

        private static final long busy_count$OFFSET = 9600;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ecs_metric_t busy_count
         * }
         */
        public static final long busy_count$offset() {
            return busy_count$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ecs_metric_t busy_count
         * }
         */
        public static MemorySegment busy_count(MemorySegment struct) {
            return struct.asSlice(busy_count$OFFSET, busy_count$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ecs_metric_t busy_count
         * }
         */
        public static void busy_count(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, busy_count$OFFSET, busy_count$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout http$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("http"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t request_received_count;
     *     ecs_metric_t request_invalid_count;
     *     ecs_metric_t request_handled_ok_count;
     *     ecs_metric_t request_handled_error_count;
     *     ecs_metric_t request_not_handled_count;
     *     ecs_metric_t request_preflight_count;
     *     ecs_metric_t send_ok_count;
     *     ecs_metric_t send_error_count;
     *     ecs_metric_t busy_count;
     * } http
     * }
     */
    public static final GroupLayout http$layout() {
        return http$LAYOUT;
    }

    private static final long http$OFFSET = 62408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t request_received_count;
     *     ecs_metric_t request_invalid_count;
     *     ecs_metric_t request_handled_ok_count;
     *     ecs_metric_t request_handled_error_count;
     *     ecs_metric_t request_not_handled_count;
     *     ecs_metric_t request_preflight_count;
     *     ecs_metric_t send_ok_count;
     *     ecs_metric_t send_error_count;
     *     ecs_metric_t busy_count;
     * } http
     * }
     */
    public static final long http$offset() {
        return http$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t request_received_count;
     *     ecs_metric_t request_invalid_count;
     *     ecs_metric_t request_handled_ok_count;
     *     ecs_metric_t request_handled_error_count;
     *     ecs_metric_t request_not_handled_count;
     *     ecs_metric_t request_preflight_count;
     *     ecs_metric_t send_ok_count;
     *     ecs_metric_t send_error_count;
     *     ecs_metric_t busy_count;
     * } http
     * }
     */
    public static MemorySegment http(MemorySegment struct) {
        return struct.asSlice(http$OFFSET, http$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ecs_metric_t request_received_count;
     *     ecs_metric_t request_invalid_count;
     *     ecs_metric_t request_handled_ok_count;
     *     ecs_metric_t request_handled_error_count;
     *     ecs_metric_t request_not_handled_count;
     *     ecs_metric_t request_preflight_count;
     *     ecs_metric_t send_ok_count;
     *     ecs_metric_t send_error_count;
     *     ecs_metric_t busy_count;
     * } http
     * }
     */
    public static void http(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, http$OFFSET, http$LAYOUT.byteSize());
    }

    private static final OfLong last_$LAYOUT = (OfLong)$LAYOUT.select(groupElement("last_"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t last_
     * }
     */
    public static final OfLong last_$layout() {
        return last_$LAYOUT;
    }

    private static final long last_$OFFSET = 73208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t last_
     * }
     */
    public static final long last_$offset() {
        return last_$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t last_
     * }
     */
    public static long last_(MemorySegment struct) {
        return struct.get(last_$LAYOUT, last_$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t last_
     * }
     */
    public static void last_(MemorySegment struct, long fieldValue) {
        struct.set(last_$LAYOUT, last_$OFFSET, fieldValue);
    }

    private static final OfInt t$LAYOUT = (OfInt)$LAYOUT.select(groupElement("t"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int32_t t
     * }
     */
    public static final OfInt t$layout() {
        return t$LAYOUT;
    }

    private static final long t$OFFSET = 73216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int32_t t
     * }
     */
    public static final long t$offset() {
        return t$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int32_t t
     * }
     */
    public static int t(MemorySegment struct) {
        return struct.get(t$LAYOUT, t$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int32_t t
     * }
     */
    public static void t(MemorySegment struct, int fieldValue) {
        struct.set(t$LAYOUT, t$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

