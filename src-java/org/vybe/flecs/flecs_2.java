// Generated by jextract

package org.vybe.flecs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class flecs_2 {

    flecs_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libvybe_flecs.dylib", LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup("/tmp/pfeodrippe_vybe_native/libzig_vybe.dylib", LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int FLECS_VERSION_MAJOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_MAJOR 4
     * }
     */
    public static int FLECS_VERSION_MAJOR() {
        return FLECS_VERSION_MAJOR;
    }
    private static final int FLECS_VERSION_MINOR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_MINOR 0
     * }
     */
    public static int FLECS_VERSION_MINOR() {
        return FLECS_VERSION_MINOR;
    }
    private static final int FLECS_VERSION_PATCH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION_PATCH 1
     * }
     */
    public static int FLECS_VERSION_PATCH() {
        return FLECS_VERSION_PATCH;
    }
    private static final int FLECS_TERM_COUNT_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FLECS_TERM_COUNT_MAX 32
     * }
     */
    public static int FLECS_TERM_COUNT_MAX() {
        return FLECS_TERM_COUNT_MAX;
    }
    private static final int ECS_CLANG_VERSION = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ECS_CLANG_VERSION 12
     * }
     */
    public static int ECS_CLANG_VERSION() {
        return ECS_CLANG_VERSION;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int _FORTIFY_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FORTIFY_SOURCE 2
     * }
     */
    public static int _FORTIFY_SOURCE() {
        return _FORTIFY_SOURCE;
    }
    private static final int __API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED() {
        return __API_TO_BE_DEPRECATED;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOS() {
        return __API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int __API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOS() {
        return __API_TO_BE_DEPRECATED_IOS;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYST = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYST 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYST() {
        return __API_TO_BE_DEPRECATED_MACCATALYST;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOS() {
        return __API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOS() {
        return __API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int __API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_DRIVERKIT() {
        return __API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOS() {
        return __API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int __MAC_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_0 1000
     * }
     */
    public static int __MAC_10_0() {
        return __MAC_10_0;
    }
    private static final int __MAC_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_1 1010
     * }
     */
    public static int __MAC_10_1() {
        return __MAC_10_1;
    }
    private static final int __MAC_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_2 1020
     * }
     */
    public static int __MAC_10_2() {
        return __MAC_10_2;
    }
    private static final int __MAC_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_3 1030
     * }
     */
    public static int __MAC_10_3() {
        return __MAC_10_3;
    }
    private static final int __MAC_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_4 1040
     * }
     */
    public static int __MAC_10_4() {
        return __MAC_10_4;
    }
    private static final int __MAC_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_5 1050
     * }
     */
    public static int __MAC_10_5() {
        return __MAC_10_5;
    }
    private static final int __MAC_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_6 1060
     * }
     */
    public static int __MAC_10_6() {
        return __MAC_10_6;
    }
    private static final int __MAC_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_7 1070
     * }
     */
    public static int __MAC_10_7() {
        return __MAC_10_7;
    }
    private static final int __MAC_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_8 1080
     * }
     */
    public static int __MAC_10_8() {
        return __MAC_10_8;
    }
    private static final int __MAC_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_9 1090
     * }
     */
    public static int __MAC_10_9() {
        return __MAC_10_9;
    }
    private static final int __MAC_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10 101000
     * }
     */
    public static int __MAC_10_10() {
        return __MAC_10_10;
    }
    private static final int __MAC_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_2 101002
     * }
     */
    public static int __MAC_10_10_2() {
        return __MAC_10_10_2;
    }
    private static final int __MAC_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_3 101003
     * }
     */
    public static int __MAC_10_10_3() {
        return __MAC_10_10_3;
    }
    private static final int __MAC_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11 101100
     * }
     */
    public static int __MAC_10_11() {
        return __MAC_10_11;
    }
    private static final int __MAC_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_2 101102
     * }
     */
    public static int __MAC_10_11_2() {
        return __MAC_10_11_2;
    }
    private static final int __MAC_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_3 101103
     * }
     */
    public static int __MAC_10_11_3() {
        return __MAC_10_11_3;
    }
    private static final int __MAC_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_4 101104
     * }
     */
    public static int __MAC_10_11_4() {
        return __MAC_10_11_4;
    }
    private static final int __MAC_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12 101200
     * }
     */
    public static int __MAC_10_12() {
        return __MAC_10_12;
    }
    private static final int __MAC_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_1 101201
     * }
     */
    public static int __MAC_10_12_1() {
        return __MAC_10_12_1;
    }
    private static final int __MAC_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_2 101202
     * }
     */
    public static int __MAC_10_12_2() {
        return __MAC_10_12_2;
    }
    private static final int __MAC_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_4 101204
     * }
     */
    public static int __MAC_10_12_4() {
        return __MAC_10_12_4;
    }
    private static final int __MAC_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13 101300
     * }
     */
    public static int __MAC_10_13() {
        return __MAC_10_13;
    }
    private static final int __MAC_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_1 101301
     * }
     */
    public static int __MAC_10_13_1() {
        return __MAC_10_13_1;
    }
    private static final int __MAC_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_2 101302
     * }
     */
    public static int __MAC_10_13_2() {
        return __MAC_10_13_2;
    }
    private static final int __MAC_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_4 101304
     * }
     */
    public static int __MAC_10_13_4() {
        return __MAC_10_13_4;
    }
    private static final int __MAC_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14 101400
     * }
     */
    public static int __MAC_10_14() {
        return __MAC_10_14;
    }
    private static final int __MAC_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_1 101401
     * }
     */
    public static int __MAC_10_14_1() {
        return __MAC_10_14_1;
    }
    private static final int __MAC_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_4 101404
     * }
     */
    public static int __MAC_10_14_4() {
        return __MAC_10_14_4;
    }
    private static final int __MAC_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_5 101405
     * }
     */
    public static int __MAC_10_14_5() {
        return __MAC_10_14_5;
    }
    private static final int __MAC_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_6 101406
     * }
     */
    public static int __MAC_10_14_6() {
        return __MAC_10_14_6;
    }
    private static final int __MAC_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15 101500
     * }
     */
    public static int __MAC_10_15() {
        return __MAC_10_15;
    }
    private static final int __MAC_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_1 101501
     * }
     */
    public static int __MAC_10_15_1() {
        return __MAC_10_15_1;
    }
    private static final int __MAC_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_4 101504
     * }
     */
    public static int __MAC_10_15_4() {
        return __MAC_10_15_4;
    }
    private static final int __MAC_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_16 101600
     * }
     */
    public static int __MAC_10_16() {
        return __MAC_10_16;
    }
    private static final int __MAC_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_0 110000
     * }
     */
    public static int __MAC_11_0() {
        return __MAC_11_0;
    }
    private static final int __MAC_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_1 110100
     * }
     */
    public static int __MAC_11_1() {
        return __MAC_11_1;
    }
    private static final int __MAC_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_3 110300
     * }
     */
    public static int __MAC_11_3() {
        return __MAC_11_3;
    }
    private static final int __MAC_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_4 110400
     * }
     */
    public static int __MAC_11_4() {
        return __MAC_11_4;
    }
    private static final int __MAC_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_5 110500
     * }
     */
    public static int __MAC_11_5() {
        return __MAC_11_5;
    }
    private static final int __MAC_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_6 110600
     * }
     */
    public static int __MAC_11_6() {
        return __MAC_11_6;
    }
    private static final int __MAC_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_0 120000
     * }
     */
    public static int __MAC_12_0() {
        return __MAC_12_0;
    }
    private static final int __MAC_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_1 120100
     * }
     */
    public static int __MAC_12_1() {
        return __MAC_12_1;
    }
    private static final int __MAC_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_2 120200
     * }
     */
    public static int __MAC_12_2() {
        return __MAC_12_2;
    }
    private static final int __MAC_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_3 120300
     * }
     */
    public static int __MAC_12_3() {
        return __MAC_12_3;
    }
    private static final int __MAC_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_4 120400
     * }
     */
    public static int __MAC_12_4() {
        return __MAC_12_4;
    }
    private static final int __MAC_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_5 120500
     * }
     */
    public static int __MAC_12_5() {
        return __MAC_12_5;
    }
    private static final int __MAC_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_6 120600
     * }
     */
    public static int __MAC_12_6() {
        return __MAC_12_6;
    }
    private static final int __MAC_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_7 120700
     * }
     */
    public static int __MAC_12_7() {
        return __MAC_12_7;
    }
    private static final int __MAC_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_0 130000
     * }
     */
    public static int __MAC_13_0() {
        return __MAC_13_0;
    }
    private static final int __MAC_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_1 130100
     * }
     */
    public static int __MAC_13_1() {
        return __MAC_13_1;
    }
    private static final int __MAC_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_2 130200
     * }
     */
    public static int __MAC_13_2() {
        return __MAC_13_2;
    }
    private static final int __MAC_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_3 130300
     * }
     */
    public static int __MAC_13_3() {
        return __MAC_13_3;
    }
    private static final int __MAC_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_4 130400
     * }
     */
    public static int __MAC_13_4() {
        return __MAC_13_4;
    }
    private static final int __MAC_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_5 130500
     * }
     */
    public static int __MAC_13_5() {
        return __MAC_13_5;
    }
    private static final int __MAC_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_6 130600
     * }
     */
    public static int __MAC_13_6() {
        return __MAC_13_6;
    }
    private static final int __MAC_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_0 140000
     * }
     */
    public static int __MAC_14_0() {
        return __MAC_14_0;
    }
    private static final int __MAC_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_1 140100
     * }
     */
    public static int __MAC_14_1() {
        return __MAC_14_1;
    }
    private static final int __MAC_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_2 140200
     * }
     */
    public static int __MAC_14_2() {
        return __MAC_14_2;
    }
    private static final int __IPHONE_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_0 20000
     * }
     */
    public static int __IPHONE_2_0() {
        return __IPHONE_2_0;
    }
    private static final int __IPHONE_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_1 20100
     * }
     */
    public static int __IPHONE_2_1() {
        return __IPHONE_2_1;
    }
    private static final int __IPHONE_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_2 20200
     * }
     */
    public static int __IPHONE_2_2() {
        return __IPHONE_2_2;
    }
    private static final int __IPHONE_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_0 30000
     * }
     */
    public static int __IPHONE_3_0() {
        return __IPHONE_3_0;
    }
    private static final int __IPHONE_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_1 30100
     * }
     */
    public static int __IPHONE_3_1() {
        return __IPHONE_3_1;
    }
    private static final int __IPHONE_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_2 30200
     * }
     */
    public static int __IPHONE_3_2() {
        return __IPHONE_3_2;
    }
    private static final int __IPHONE_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_0 40000
     * }
     */
    public static int __IPHONE_4_0() {
        return __IPHONE_4_0;
    }
    private static final int __IPHONE_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_1 40100
     * }
     */
    public static int __IPHONE_4_1() {
        return __IPHONE_4_1;
    }
    private static final int __IPHONE_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_2 40200
     * }
     */
    public static int __IPHONE_4_2() {
        return __IPHONE_4_2;
    }
    private static final int __IPHONE_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_3 40300
     * }
     */
    public static int __IPHONE_4_3() {
        return __IPHONE_4_3;
    }
    private static final int __IPHONE_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_0 50000
     * }
     */
    public static int __IPHONE_5_0() {
        return __IPHONE_5_0;
    }
    private static final int __IPHONE_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_1 50100
     * }
     */
    public static int __IPHONE_5_1() {
        return __IPHONE_5_1;
    }
    private static final int __IPHONE_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_0 60000
     * }
     */
    public static int __IPHONE_6_0() {
        return __IPHONE_6_0;
    }
    private static final int __IPHONE_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_1 60100
     * }
     */
    public static int __IPHONE_6_1() {
        return __IPHONE_6_1;
    }
    private static final int __IPHONE_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_0 70000
     * }
     */
    public static int __IPHONE_7_0() {
        return __IPHONE_7_0;
    }
    private static final int __IPHONE_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_1 70100
     * }
     */
    public static int __IPHONE_7_1() {
        return __IPHONE_7_1;
    }
    private static final int __IPHONE_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_0 80000
     * }
     */
    public static int __IPHONE_8_0() {
        return __IPHONE_8_0;
    }
    private static final int __IPHONE_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_1 80100
     * }
     */
    public static int __IPHONE_8_1() {
        return __IPHONE_8_1;
    }
    private static final int __IPHONE_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_2 80200
     * }
     */
    public static int __IPHONE_8_2() {
        return __IPHONE_8_2;
    }
    private static final int __IPHONE_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_3 80300
     * }
     */
    public static int __IPHONE_8_3() {
        return __IPHONE_8_3;
    }
    private static final int __IPHONE_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_4 80400
     * }
     */
    public static int __IPHONE_8_4() {
        return __IPHONE_8_4;
    }
    private static final int __IPHONE_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_0 90000
     * }
     */
    public static int __IPHONE_9_0() {
        return __IPHONE_9_0;
    }
    private static final int __IPHONE_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_1 90100
     * }
     */
    public static int __IPHONE_9_1() {
        return __IPHONE_9_1;
    }
    private static final int __IPHONE_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_2 90200
     * }
     */
    public static int __IPHONE_9_2() {
        return __IPHONE_9_2;
    }
    private static final int __IPHONE_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_3 90300
     * }
     */
    public static int __IPHONE_9_3() {
        return __IPHONE_9_3;
    }
    private static final int __IPHONE_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_0 100000
     * }
     */
    public static int __IPHONE_10_0() {
        return __IPHONE_10_0;
    }
    private static final int __IPHONE_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_1 100100
     * }
     */
    public static int __IPHONE_10_1() {
        return __IPHONE_10_1;
    }
    private static final int __IPHONE_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_2 100200
     * }
     */
    public static int __IPHONE_10_2() {
        return __IPHONE_10_2;
    }
    private static final int __IPHONE_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_3 100300
     * }
     */
    public static int __IPHONE_10_3() {
        return __IPHONE_10_3;
    }
    private static final int __IPHONE_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_0 110000
     * }
     */
    public static int __IPHONE_11_0() {
        return __IPHONE_11_0;
    }
    private static final int __IPHONE_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_1 110100
     * }
     */
    public static int __IPHONE_11_1() {
        return __IPHONE_11_1;
    }
    private static final int __IPHONE_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_2 110200
     * }
     */
    public static int __IPHONE_11_2() {
        return __IPHONE_11_2;
    }
    private static final int __IPHONE_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_3 110300
     * }
     */
    public static int __IPHONE_11_3() {
        return __IPHONE_11_3;
    }
    private static final int __IPHONE_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_4 110400
     * }
     */
    public static int __IPHONE_11_4() {
        return __IPHONE_11_4;
    }
    private static final int __IPHONE_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_0 120000
     * }
     */
    public static int __IPHONE_12_0() {
        return __IPHONE_12_0;
    }
    private static final int __IPHONE_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_1 120100
     * }
     */
    public static int __IPHONE_12_1() {
        return __IPHONE_12_1;
    }
    private static final int __IPHONE_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_2 120200
     * }
     */
    public static int __IPHONE_12_2() {
        return __IPHONE_12_2;
    }
    private static final int __IPHONE_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_3 120300
     * }
     */
    public static int __IPHONE_12_3() {
        return __IPHONE_12_3;
    }
    private static final int __IPHONE_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_4 120400
     * }
     */
    public static int __IPHONE_12_4() {
        return __IPHONE_12_4;
    }
    private static final int __IPHONE_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_0 130000
     * }
     */
    public static int __IPHONE_13_0() {
        return __IPHONE_13_0;
    }
    private static final int __IPHONE_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_1 130100
     * }
     */
    public static int __IPHONE_13_1() {
        return __IPHONE_13_1;
    }
    private static final int __IPHONE_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_2 130200
     * }
     */
    public static int __IPHONE_13_2() {
        return __IPHONE_13_2;
    }
    private static final int __IPHONE_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_3 130300
     * }
     */
    public static int __IPHONE_13_3() {
        return __IPHONE_13_3;
    }
    private static final int __IPHONE_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_4 130400
     * }
     */
    public static int __IPHONE_13_4() {
        return __IPHONE_13_4;
    }
    private static final int __IPHONE_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_5 130500
     * }
     */
    public static int __IPHONE_13_5() {
        return __IPHONE_13_5;
    }
    private static final int __IPHONE_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_6 130600
     * }
     */
    public static int __IPHONE_13_6() {
        return __IPHONE_13_6;
    }
    private static final int __IPHONE_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_7 130700
     * }
     */
    public static int __IPHONE_13_7() {
        return __IPHONE_13_7;
    }
    private static final int __IPHONE_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_0 140000
     * }
     */
    public static int __IPHONE_14_0() {
        return __IPHONE_14_0;
    }
    private static final int __IPHONE_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_1 140100
     * }
     */
    public static int __IPHONE_14_1() {
        return __IPHONE_14_1;
    }
    private static final int __IPHONE_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_2 140200
     * }
     */
    public static int __IPHONE_14_2() {
        return __IPHONE_14_2;
    }
    private static final int __IPHONE_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_3 140300
     * }
     */
    public static int __IPHONE_14_3() {
        return __IPHONE_14_3;
    }
    private static final int __IPHONE_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_5 140500
     * }
     */
    public static int __IPHONE_14_5() {
        return __IPHONE_14_5;
    }
    private static final int __IPHONE_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_4 140400
     * }
     */
    public static int __IPHONE_14_4() {
        return __IPHONE_14_4;
    }
    private static final int __IPHONE_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_6 140600
     * }
     */
    public static int __IPHONE_14_6() {
        return __IPHONE_14_6;
    }
    private static final int __IPHONE_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_7 140700
     * }
     */
    public static int __IPHONE_14_7() {
        return __IPHONE_14_7;
    }
    private static final int __IPHONE_14_8 = (int)140800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_8 140800
     * }
     */
    public static int __IPHONE_14_8() {
        return __IPHONE_14_8;
    }
    private static final int __IPHONE_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_0 150000
     * }
     */
    public static int __IPHONE_15_0() {
        return __IPHONE_15_0;
    }
    private static final int __IPHONE_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_1 150100
     * }
     */
    public static int __IPHONE_15_1() {
        return __IPHONE_15_1;
    }
    private static final int __IPHONE_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_2 150200
     * }
     */
    public static int __IPHONE_15_2() {
        return __IPHONE_15_2;
    }
    private static final int __IPHONE_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_3 150300
     * }
     */
    public static int __IPHONE_15_3() {
        return __IPHONE_15_3;
    }
    private static final int __IPHONE_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_4 150400
     * }
     */
    public static int __IPHONE_15_4() {
        return __IPHONE_15_4;
    }
    private static final int __IPHONE_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_5 150500
     * }
     */
    public static int __IPHONE_15_5() {
        return __IPHONE_15_5;
    }
    private static final int __IPHONE_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_6 150600
     * }
     */
    public static int __IPHONE_15_6() {
        return __IPHONE_15_6;
    }
    private static final int __IPHONE_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_0 160000
     * }
     */
    public static int __IPHONE_16_0() {
        return __IPHONE_16_0;
    }
    private static final int __IPHONE_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_1 160100
     * }
     */
    public static int __IPHONE_16_1() {
        return __IPHONE_16_1;
    }
    private static final int __IPHONE_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_2 160200
     * }
     */
    public static int __IPHONE_16_2() {
        return __IPHONE_16_2;
    }
    private static final int __IPHONE_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_3 160300
     * }
     */
    public static int __IPHONE_16_3() {
        return __IPHONE_16_3;
    }
    private static final int __IPHONE_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_4 160400
     * }
     */
    public static int __IPHONE_16_4() {
        return __IPHONE_16_4;
    }
    private static final int __IPHONE_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_5 160500
     * }
     */
    public static int __IPHONE_16_5() {
        return __IPHONE_16_5;
    }
    private static final int __IPHONE_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_6 160600
     * }
     */
    public static int __IPHONE_16_6() {
        return __IPHONE_16_6;
    }
    private static final int __IPHONE_16_7 = (int)160700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_7 160700
     * }
     */
    public static int __IPHONE_16_7() {
        return __IPHONE_16_7;
    }
    private static final int __IPHONE_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_0 170000
     * }
     */
    public static int __IPHONE_17_0() {
        return __IPHONE_17_0;
    }
    private static final int __IPHONE_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_1 170100
     * }
     */
    public static int __IPHONE_17_1() {
        return __IPHONE_17_1;
    }
    private static final int __IPHONE_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_2 170200
     * }
     */
    public static int __IPHONE_17_2() {
        return __IPHONE_17_2;
    }
    private static final int __WATCHOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_1_0 10000
     * }
     */
    public static int __WATCHOS_1_0() {
        return __WATCHOS_1_0;
    }
    private static final int __WATCHOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_0 20000
     * }
     */
    public static int __WATCHOS_2_0() {
        return __WATCHOS_2_0;
    }
    private static final int __WATCHOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_1 20100
     * }
     */
    public static int __WATCHOS_2_1() {
        return __WATCHOS_2_1;
    }
    private static final int __WATCHOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_2 20200
     * }
     */
    public static int __WATCHOS_2_2() {
        return __WATCHOS_2_2;
    }
    private static final int __WATCHOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_0 30000
     * }
     */
    public static int __WATCHOS_3_0() {
        return __WATCHOS_3_0;
    }
    private static final int __WATCHOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1 30100
     * }
     */
    public static int __WATCHOS_3_1() {
        return __WATCHOS_3_1;
    }
    private static final int __WATCHOS_3_1_1 = (int)30101L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1_1 30101
     * }
     */
    public static int __WATCHOS_3_1_1() {
        return __WATCHOS_3_1_1;
    }
    private static final int __WATCHOS_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_2 30200
     * }
     */
    public static int __WATCHOS_3_2() {
        return __WATCHOS_3_2;
    }
    private static final int __WATCHOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_0 40000
     * }
     */
    public static int __WATCHOS_4_0() {
        return __WATCHOS_4_0;
    }
    private static final int __WATCHOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_1 40100
     * }
     */
    public static int __WATCHOS_4_1() {
        return __WATCHOS_4_1;
    }
    private static final int __WATCHOS_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_2 40200
     * }
     */
    public static int __WATCHOS_4_2() {
        return __WATCHOS_4_2;
    }
    private static final int __WATCHOS_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_3 40300
     * }
     */
    public static int __WATCHOS_4_3() {
        return __WATCHOS_4_3;
    }
    private static final int __WATCHOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_0 50000
     * }
     */
    public static int __WATCHOS_5_0() {
        return __WATCHOS_5_0;
    }
    private static final int __WATCHOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_1 50100
     * }
     */
    public static int __WATCHOS_5_1() {
        return __WATCHOS_5_1;
    }
    private static final int __WATCHOS_5_2 = (int)50200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_2 50200
     * }
     */
    public static int __WATCHOS_5_2() {
        return __WATCHOS_5_2;
    }
    private static final int __WATCHOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_3 50300
     * }
     */
    public static int __WATCHOS_5_3() {
        return __WATCHOS_5_3;
    }
    private static final int __WATCHOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_0 60000
     * }
     */
    public static int __WATCHOS_6_0() {
        return __WATCHOS_6_0;
    }
    private static final int __WATCHOS_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_1 60100
     * }
     */
    public static int __WATCHOS_6_1() {
        return __WATCHOS_6_1;
    }
    private static final int __WATCHOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_2 60200
     * }
     */
    public static int __WATCHOS_6_2() {
        return __WATCHOS_6_2;
    }
    private static final int __WATCHOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_0 70000
     * }
     */
    public static int __WATCHOS_7_0() {
        return __WATCHOS_7_0;
    }
    private static final int __WATCHOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_1 70100
     * }
     */
    public static int __WATCHOS_7_1() {
        return __WATCHOS_7_1;
    }
    private static final int __WATCHOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_2 70200
     * }
     */
    public static int __WATCHOS_7_2() {
        return __WATCHOS_7_2;
    }
    private static final int __WATCHOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_3 70300
     * }
     */
    public static int __WATCHOS_7_3() {
        return __WATCHOS_7_3;
    }
    private static final int __WATCHOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_4 70400
     * }
     */
    public static int __WATCHOS_7_4() {
        return __WATCHOS_7_4;
    }
    private static final int __WATCHOS_7_5 = (int)70500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_5 70500
     * }
     */
    public static int __WATCHOS_7_5() {
        return __WATCHOS_7_5;
    }
    private static final int __WATCHOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_6 70600
     * }
     */
    public static int __WATCHOS_7_6() {
        return __WATCHOS_7_6;
    }
    private static final int __WATCHOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_0 80000
     * }
     */
    public static int __WATCHOS_8_0() {
        return __WATCHOS_8_0;
    }
    private static final int __WATCHOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_1 80100
     * }
     */
    public static int __WATCHOS_8_1() {
        return __WATCHOS_8_1;
    }
    private static final int __WATCHOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_3 80300
     * }
     */
    public static int __WATCHOS_8_3() {
        return __WATCHOS_8_3;
    }
    private static final int __WATCHOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_4 80400
     * }
     */
    public static int __WATCHOS_8_4() {
        return __WATCHOS_8_4;
    }
    private static final int __WATCHOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_5 80500
     * }
     */
    public static int __WATCHOS_8_5() {
        return __WATCHOS_8_5;
    }
    private static final int __WATCHOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_6 80600
     * }
     */
    public static int __WATCHOS_8_6() {
        return __WATCHOS_8_6;
    }
    private static final int __WATCHOS_8_7 = (int)80700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_7 80700
     * }
     */
    public static int __WATCHOS_8_7() {
        return __WATCHOS_8_7;
    }
    private static final int __WATCHOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_0 90000
     * }
     */
    public static int __WATCHOS_9_0() {
        return __WATCHOS_9_0;
    }
    private static final int __WATCHOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_1 90100
     * }
     */
    public static int __WATCHOS_9_1() {
        return __WATCHOS_9_1;
    }
    private static final int __WATCHOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_2 90200
     * }
     */
    public static int __WATCHOS_9_2() {
        return __WATCHOS_9_2;
    }
    private static final int __WATCHOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_3 90300
     * }
     */
    public static int __WATCHOS_9_3() {
        return __WATCHOS_9_3;
    }
    private static final int __WATCHOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_4 90400
     * }
     */
    public static int __WATCHOS_9_4() {
        return __WATCHOS_9_4;
    }
    private static final int __WATCHOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_5 90500
     * }
     */
    public static int __WATCHOS_9_5() {
        return __WATCHOS_9_5;
    }
    private static final int __WATCHOS_9_6 = (int)90600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_6 90600
     * }
     */
    public static int __WATCHOS_9_6() {
        return __WATCHOS_9_6;
    }
    private static final int __WATCHOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_0 100000
     * }
     */
    public static int __WATCHOS_10_0() {
        return __WATCHOS_10_0;
    }
    private static final int __WATCHOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_1 100100
     * }
     */
    public static int __WATCHOS_10_1() {
        return __WATCHOS_10_1;
    }
    private static final int __WATCHOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_2 100200
     * }
     */
    public static int __WATCHOS_10_2() {
        return __WATCHOS_10_2;
    }
    private static final int __TVOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_0 90000
     * }
     */
    public static int __TVOS_9_0() {
        return __TVOS_9_0;
    }
    private static final int __TVOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_1 90100
     * }
     */
    public static int __TVOS_9_1() {
        return __TVOS_9_1;
    }
    private static final int __TVOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_2 90200
     * }
     */
    public static int __TVOS_9_2() {
        return __TVOS_9_2;
    }
    private static final int __TVOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0 100000
     * }
     */
    public static int __TVOS_10_0() {
        return __TVOS_10_0;
    }
    private static final int __TVOS_10_0_1 = (int)100001L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0_1 100001
     * }
     */
    public static int __TVOS_10_0_1() {
        return __TVOS_10_0_1;
    }
    private static final int __TVOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_1 100100
     * }
     */
    public static int __TVOS_10_1() {
        return __TVOS_10_1;
    }
    private static final int __TVOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_2 100200
     * }
     */
    public static int __TVOS_10_2() {
        return __TVOS_10_2;
    }
    private static final int __TVOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_0 110000
     * }
     */
    public static int __TVOS_11_0() {
        return __TVOS_11_0;
    }
    private static final int __TVOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_1 110100
     * }
     */
    public static int __TVOS_11_1() {
        return __TVOS_11_1;
    }
    private static final int __TVOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_2 110200
     * }
     */
    public static int __TVOS_11_2() {
        return __TVOS_11_2;
    }
    private static final int __TVOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_3 110300
     * }
     */
    public static int __TVOS_11_3() {
        return __TVOS_11_3;
    }
    private static final int __TVOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_4 110400
     * }
     */
    public static int __TVOS_11_4() {
        return __TVOS_11_4;
    }
    private static final int __TVOS_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_0 120000
     * }
     */
    public static int __TVOS_12_0() {
        return __TVOS_12_0;
    }
    private static final int __TVOS_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_1 120100
     * }
     */
    public static int __TVOS_12_1() {
        return __TVOS_12_1;
    }
    private static final int __TVOS_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_2 120200
     * }
     */
    public static int __TVOS_12_2() {
        return __TVOS_12_2;
    }
    private static final int __TVOS_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_3 120300
     * }
     */
    public static int __TVOS_12_3() {
        return __TVOS_12_3;
    }
    private static final int __TVOS_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_4 120400
     * }
     */
    public static int __TVOS_12_4() {
        return __TVOS_12_4;
    }
    private static final int __TVOS_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_0 130000
     * }
     */
    public static int __TVOS_13_0() {
        return __TVOS_13_0;
    }
    private static final int __TVOS_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_2 130200
     * }
     */
    public static int __TVOS_13_2() {
        return __TVOS_13_2;
    }
    private static final int __TVOS_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_3 130300
     * }
     */
    public static int __TVOS_13_3() {
        return __TVOS_13_3;
    }
    private static final int __TVOS_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_4 130400
     * }
     */
    public static int __TVOS_13_4() {
        return __TVOS_13_4;
    }
    private static final int __TVOS_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_0 140000
     * }
     */
    public static int __TVOS_14_0() {
        return __TVOS_14_0;
    }
    private static final int __TVOS_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_1 140100
     * }
     */
    public static int __TVOS_14_1() {
        return __TVOS_14_1;
    }
    private static final int __TVOS_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_2 140200
     * }
     */
    public static int __TVOS_14_2() {
        return __TVOS_14_2;
    }
    private static final int __TVOS_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_3 140300
     * }
     */
    public static int __TVOS_14_3() {
        return __TVOS_14_3;
    }
    private static final int __TVOS_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_5 140500
     * }
     */
    public static int __TVOS_14_5() {
        return __TVOS_14_5;
    }
    private static final int __TVOS_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_6 140600
     * }
     */
    public static int __TVOS_14_6() {
        return __TVOS_14_6;
    }
    private static final int __TVOS_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_7 140700
     * }
     */
    public static int __TVOS_14_7() {
        return __TVOS_14_7;
    }
    private static final int __TVOS_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_0 150000
     * }
     */
    public static int __TVOS_15_0() {
        return __TVOS_15_0;
    }
    private static final int __TVOS_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_1 150100
     * }
     */
    public static int __TVOS_15_1() {
        return __TVOS_15_1;
    }
    private static final int __TVOS_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_2 150200
     * }
     */
    public static int __TVOS_15_2() {
        return __TVOS_15_2;
    }
    private static final int __TVOS_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_3 150300
     * }
     */
    public static int __TVOS_15_3() {
        return __TVOS_15_3;
    }
    private static final int __TVOS_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_4 150400
     * }
     */
    public static int __TVOS_15_4() {
        return __TVOS_15_4;
    }
    private static final int __TVOS_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_5 150500
     * }
     */
    public static int __TVOS_15_5() {
        return __TVOS_15_5;
    }
    private static final int __TVOS_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_6 150600
     * }
     */
    public static int __TVOS_15_6() {
        return __TVOS_15_6;
    }
    private static final int __TVOS_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_0 160000
     * }
     */
    public static int __TVOS_16_0() {
        return __TVOS_16_0;
    }
    private static final int __TVOS_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_1 160100
     * }
     */
    public static int __TVOS_16_1() {
        return __TVOS_16_1;
    }
    private static final int __TVOS_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_2 160200
     * }
     */
    public static int __TVOS_16_2() {
        return __TVOS_16_2;
    }
    private static final int __TVOS_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_3 160300
     * }
     */
    public static int __TVOS_16_3() {
        return __TVOS_16_3;
    }
    private static final int __TVOS_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_4 160400
     * }
     */
    public static int __TVOS_16_4() {
        return __TVOS_16_4;
    }
    private static final int __TVOS_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_5 160500
     * }
     */
    public static int __TVOS_16_5() {
        return __TVOS_16_5;
    }
    private static final int __TVOS_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_6 160600
     * }
     */
    public static int __TVOS_16_6() {
        return __TVOS_16_6;
    }
    private static final int __TVOS_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_0 170000
     * }
     */
    public static int __TVOS_17_0() {
        return __TVOS_17_0;
    }
    private static final int __TVOS_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_1 170100
     * }
     */
    public static int __TVOS_17_1() {
        return __TVOS_17_1;
    }
    private static final int __TVOS_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_2 170200
     * }
     */
    public static int __TVOS_17_2() {
        return __TVOS_17_2;
    }
    private static final int __BRIDGEOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_2_0 20000
     * }
     */
    public static int __BRIDGEOS_2_0() {
        return __BRIDGEOS_2_0;
    }
    private static final int __BRIDGEOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_0 30000
     * }
     */
    public static int __BRIDGEOS_3_0() {
        return __BRIDGEOS_3_0;
    }
    private static final int __BRIDGEOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_1 30100
     * }
     */
    public static int __BRIDGEOS_3_1() {
        return __BRIDGEOS_3_1;
    }
    private static final int __BRIDGEOS_3_4 = (int)30400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_4 30400
     * }
     */
    public static int __BRIDGEOS_3_4() {
        return __BRIDGEOS_3_4;
    }
    private static final int __BRIDGEOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_0 40000
     * }
     */
    public static int __BRIDGEOS_4_0() {
        return __BRIDGEOS_4_0;
    }
    private static final int __BRIDGEOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_1 40100
     * }
     */
    public static int __BRIDGEOS_4_1() {
        return __BRIDGEOS_4_1;
    }
    private static final int __BRIDGEOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_0 50000
     * }
     */
    public static int __BRIDGEOS_5_0() {
        return __BRIDGEOS_5_0;
    }
    private static final int __BRIDGEOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_1 50100
     * }
     */
    public static int __BRIDGEOS_5_1() {
        return __BRIDGEOS_5_1;
    }
    private static final int __BRIDGEOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_3 50300
     * }
     */
    public static int __BRIDGEOS_5_3() {
        return __BRIDGEOS_5_3;
    }
    private static final int __BRIDGEOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_0 60000
     * }
     */
    public static int __BRIDGEOS_6_0() {
        return __BRIDGEOS_6_0;
    }
    private static final int __BRIDGEOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_2 60200
     * }
     */
    public static int __BRIDGEOS_6_2() {
        return __BRIDGEOS_6_2;
    }
    private static final int __BRIDGEOS_6_4 = (int)60400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_4 60400
     * }
     */
    public static int __BRIDGEOS_6_4() {
        return __BRIDGEOS_6_4;
    }
    private static final int __BRIDGEOS_6_5 = (int)60500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_5 60500
     * }
     */
    public static int __BRIDGEOS_6_5() {
        return __BRIDGEOS_6_5;
    }
    private static final int __BRIDGEOS_6_6 = (int)60600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_6 60600
     * }
     */
    public static int __BRIDGEOS_6_6() {
        return __BRIDGEOS_6_6;
    }
    private static final int __BRIDGEOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_0 70000
     * }
     */
    public static int __BRIDGEOS_7_0() {
        return __BRIDGEOS_7_0;
    }
    private static final int __BRIDGEOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_1 70100
     * }
     */
    public static int __BRIDGEOS_7_1() {
        return __BRIDGEOS_7_1;
    }
    private static final int __BRIDGEOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_2 70200
     * }
     */
    public static int __BRIDGEOS_7_2() {
        return __BRIDGEOS_7_2;
    }
    private static final int __BRIDGEOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_3 70300
     * }
     */
    public static int __BRIDGEOS_7_3() {
        return __BRIDGEOS_7_3;
    }
    private static final int __BRIDGEOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_4 70400
     * }
     */
    public static int __BRIDGEOS_7_4() {
        return __BRIDGEOS_7_4;
    }
    private static final int __BRIDGEOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_6 70600
     * }
     */
    public static int __BRIDGEOS_7_6() {
        return __BRIDGEOS_7_6;
    }
    private static final int __BRIDGEOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_0 80000
     * }
     */
    public static int __BRIDGEOS_8_0() {
        return __BRIDGEOS_8_0;
    }
    private static final int __BRIDGEOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_1 80100
     * }
     */
    public static int __BRIDGEOS_8_1() {
        return __BRIDGEOS_8_1;
    }
    private static final int __BRIDGEOS_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_2 80200
     * }
     */
    public static int __BRIDGEOS_8_2() {
        return __BRIDGEOS_8_2;
    }
    private static final int __DRIVERKIT_19_0 = (int)190000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_19_0 190000
     * }
     */
    public static int __DRIVERKIT_19_0() {
        return __DRIVERKIT_19_0;
    }
    private static final int __DRIVERKIT_20_0 = (int)200000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_20_0 200000
     * }
     */
    public static int __DRIVERKIT_20_0() {
        return __DRIVERKIT_20_0;
    }
    private static final int __DRIVERKIT_21_0 = (int)210000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_21_0 210000
     * }
     */
    public static int __DRIVERKIT_21_0() {
        return __DRIVERKIT_21_0;
    }
    private static final int __DRIVERKIT_22_0 = (int)220000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_0 220000
     * }
     */
    public static int __DRIVERKIT_22_0() {
        return __DRIVERKIT_22_0;
    }
    private static final int __DRIVERKIT_22_4 = (int)220400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_4 220400
     * }
     */
    public static int __DRIVERKIT_22_4() {
        return __DRIVERKIT_22_4;
    }
    private static final int __DRIVERKIT_22_5 = (int)220500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_5 220500
     * }
     */
    public static int __DRIVERKIT_22_5() {
        return __DRIVERKIT_22_5;
    }
    private static final int __DRIVERKIT_22_6 = (int)220600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_6 220600
     * }
     */
    public static int __DRIVERKIT_22_6() {
        return __DRIVERKIT_22_6;
    }
    private static final int __DRIVERKIT_23_0 = (int)230000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_0 230000
     * }
     */
    public static int __DRIVERKIT_23_0() {
        return __DRIVERKIT_23_0;
    }
    private static final int __DRIVERKIT_23_1 = (int)230100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_1 230100
     * }
     */
    public static int __DRIVERKIT_23_1() {
        return __DRIVERKIT_23_1;
    }
    private static final int __DRIVERKIT_23_2 = (int)230200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_2 230200
     * }
     */
    public static int __DRIVERKIT_23_2() {
        return __DRIVERKIT_23_2;
    }
    private static final int __VISIONOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_0 10000
     * }
     */
    public static int __VISIONOS_1_0() {
        return __VISIONOS_1_0;
    }
    private static final int __ENABLE_LEGACY_MAC_AVAILABILITY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ENABLE_LEGACY_MAC_AVAILABILITY 1
     * }
     */
    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {
        return __ENABLE_LEGACY_MAC_AVAILABILITY;
    }
    private static final int _USE_FORTIFY_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _USE_FORTIFY_LEVEL 2
     * }
     */
    public static int _USE_FORTIFY_LEVEL() {
        return _USE_FORTIFY_LEVEL;
    }
    private static final int __HAS_FIXED_CHK_PROTOTYPES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAS_FIXED_CHK_PROTOTYPES 1
     * }
     */
    public static int __HAS_FIXED_CHK_PROTOTYPES() {
        return __HAS_FIXED_CHK_PROTOTYPES;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EDEADLK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 11
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EAGAIN = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 35
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int EINPROGRESS = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 36
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int EALREADY = (int)37L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 37
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int ENOTSOCK = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 38
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 39
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)40L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 40
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)41L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 41
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 42
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 43
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 44
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int ENOTSUP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 45
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int EPFNOSUPPORT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 46
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 47
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)48L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 48
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 49
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 50
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)51L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 51
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)52L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 52
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)53L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 53
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)54L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 54
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 55
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 56
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)57L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 57
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)58L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 58
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 59
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 60
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 61
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int ELOOP = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 62
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENAMETOOLONG = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 63
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int EHOSTDOWN = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 64
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)65L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 65
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int ENOTEMPTY = (int)66L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 66
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int EPROCLIM = (int)67L;
    /**
     * {@snippet lang=c :
     * #define EPROCLIM 67
     * }
     */
    public static int EPROCLIM() {
        return EPROCLIM;
    }
    private static final int EUSERS = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 68
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int EDQUOT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 69
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ESTALE = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 70
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EREMOTE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 71
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int EBADRPC = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EBADRPC 72
     * }
     */
    public static int EBADRPC() {
        return EBADRPC;
    }
    private static final int ERPCMISMATCH = (int)73L;
    /**
     * {@snippet lang=c :
     * #define ERPCMISMATCH 73
     * }
     */
    public static int ERPCMISMATCH() {
        return ERPCMISMATCH;
    }
    private static final int EPROGUNAVAIL = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EPROGUNAVAIL 74
     * }
     */
    public static int EPROGUNAVAIL() {
        return EPROGUNAVAIL;
    }
    private static final int EPROGMISMATCH = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EPROGMISMATCH 75
     * }
     */
    public static int EPROGMISMATCH() {
        return EPROGMISMATCH;
    }
    private static final int EPROCUNAVAIL = (int)76L;
    /**
     * {@snippet lang=c :
     * #define EPROCUNAVAIL 76
     * }
     */
    public static int EPROCUNAVAIL() {
        return EPROCUNAVAIL;
    }
    private static final int ENOLCK = (int)77L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 77
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)78L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 78
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int EFTYPE = (int)79L;
    /**
     * {@snippet lang=c :
     * #define EFTYPE 79
     * }
     */
    public static int EFTYPE() {
        return EFTYPE;
    }
    private static final int EAUTH = (int)80L;
    /**
     * {@snippet lang=c :
     * #define EAUTH 80
     * }
     */
    public static int EAUTH() {
        return EAUTH;
    }
    private static final int ENEEDAUTH = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ENEEDAUTH 81
     * }
     */
    public static int ENEEDAUTH() {
        return ENEEDAUTH;
    }
    private static final int EPWROFF = (int)82L;
    /**
     * {@snippet lang=c :
     * #define EPWROFF 82
     * }
     */
    public static int EPWROFF() {
        return EPWROFF;
    }
    private static final int EDEVERR = (int)83L;
    /**
     * {@snippet lang=c :
     * #define EDEVERR 83
     * }
     */
    public static int EDEVERR() {
        return EDEVERR;
    }
    private static final int EOVERFLOW = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 84
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EBADEXEC = (int)85L;
    /**
     * {@snippet lang=c :
     * #define EBADEXEC 85
     * }
     */
    public static int EBADEXEC() {
        return EBADEXEC;
    }
    private static final int EBADARCH = (int)86L;
    /**
     * {@snippet lang=c :
     * #define EBADARCH 86
     * }
     */
    public static int EBADARCH() {
        return EBADARCH;
    }
    private static final int ESHLIBVERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define ESHLIBVERS 87
     * }
     */
    public static int ESHLIBVERS() {
        return ESHLIBVERS;
    }
    private static final int EBADMACHO = (int)88L;
    /**
     * {@snippet lang=c :
     * #define EBADMACHO 88
     * }
     */
    public static int EBADMACHO() {
        return EBADMACHO;
    }
    private static final int ECANCELED = (int)89L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 89
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int EIDRM = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 90
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ENOMSG = (int)91L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 91
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EILSEQ = (int)92L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 92
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ENOATTR = (int)93L;
    /**
     * {@snippet lang=c :
     * #define ENOATTR 93
     * }
     */
    public static int ENOATTR() {
        return ENOATTR;
    }
    private static final int EBADMSG = (int)94L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 94
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EMULTIHOP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 95
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int ENODATA = (int)96L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 96
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)97L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 97
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOSR = (int)98L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 98
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)99L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 99
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int EPROTO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 100
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int ETIME = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ETIME 101
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int EOPNOTSUPP = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 102
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int ENOPOLICY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ENOPOLICY 103
     * }
     */
    public static int ENOPOLICY() {
        return ENOPOLICY;
    }
    private static final int ENOTRECOVERABLE = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 104
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int EOWNERDEAD = (int)105L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 105
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EQFULL = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EQFULL 106
     * }
     */
    public static int EQFULL() {
        return EQFULL;
    }
    private static final int ELAST = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ELAST 106
     * }
     */
    public static int ELAST() {
        return ELAST;
    }
    private static final int RENAME_SECLUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SECLUDE 1
     * }
     */
    public static int RENAME_SECLUDE() {
        return RENAME_SECLUDE;
    }
    private static final int RENAME_SWAP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SWAP 2
     * }
     */
    public static int RENAME_SWAP() {
        return RENAME_SWAP;
    }
    private static final int RENAME_EXCL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RENAME_EXCL 4
     * }
     */
    public static int RENAME_EXCL() {
        return RENAME_EXCL;
    }
    private static final int RENAME_RESERVED1 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RENAME_RESERVED1 8
     * }
     */
    public static int RENAME_RESERVED1() {
        return RENAME_RESERVED1;
    }
    private static final int RENAME_NOFOLLOW_ANY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RENAME_NOFOLLOW_ANY 16
     * }
     */
    public static int RENAME_NOFOLLOW_ANY() {
        return RENAME_NOFOLLOW_ANY;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_HOLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SEEK_HOLE 3
     * }
     */
    public static int SEEK_HOLE() {
        return SEEK_HOLE;
    }
    private static final int SEEK_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SEEK_DATA 4
     * }
     */
    public static int SEEK_DATA() {
        return SEEK_DATA;
    }
    private static final int __SLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __SLBF 1
     * }
     */
    public static int __SLBF() {
        return __SLBF;
    }
    private static final int __SNBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __SNBF 2
     * }
     */
    public static int __SNBF() {
        return __SNBF;
    }
    private static final int __SRD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SRD 4
     * }
     */
    public static int __SRD() {
        return __SRD;
    }
    private static final int __SWR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SWR 8
     * }
     */
    public static int __SWR() {
        return __SWR;
    }
    private static final int __SRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __SRW 16
     * }
     */
    public static int __SRW() {
        return __SRW;
    }
    private static final int __SEOF = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SEOF 32
     * }
     */
    public static int __SEOF() {
        return __SEOF;
    }
    private static final int __SERR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SERR 64
     * }
     */
    public static int __SERR() {
        return __SERR;
    }
    private static final int __SMBF = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __SMBF 128
     * }
     */
    public static int __SMBF() {
        return __SMBF;
    }
    private static final int __SAPP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define __SAPP 256
     * }
     */
    public static int __SAPP() {
        return __SAPP;
    }
    private static final int __SSTR = (int)512L;
    /**
     * {@snippet lang=c :
     * #define __SSTR 512
     * }
     */
    public static int __SSTR() {
        return __SSTR;
    }
    private static final int __SOPT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __SOPT 1024
     * }
     */
    public static int __SOPT() {
        return __SOPT;
    }
    private static final int __SNPT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define __SNPT 2048
     * }
     */
    public static int __SNPT() {
        return __SNPT;
    }
    private static final int __SOFF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define __SOFF 4096
     * }
     */
    public static int __SOFF() {
        return __SOFF;
    }
    private static final int __SMOD = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define __SMOD 8192
     * }
     */
    public static int __SMOD() {
        return __SMOD;
    }
    private static final int __SALC = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define __SALC 16384
     * }
     */
    public static int __SALC() {
        return __SALC;
    }
    private static final int __SIGN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define __SIGN 32768
     * }
     */
    public static int __SIGN() {
        return __SIGN;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 1024
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int FILENAME_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 1024
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_tmpnam = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 1024
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)308915776L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 308915776
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int L_ctermid = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 1024
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FP_NAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_NAN 1
     * }
     */
    public static int FP_NAN() {
        return FP_NAN;
    }
    private static final int FP_INFINITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FP_INFINITE 2
     * }
     */
    public static int FP_INFINITE() {
        return FP_INFINITE;
    }
    private static final int FP_ZERO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 3
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int FP_NORMAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FP_NORMAL 4
     * }
     */
    public static int FP_NORMAL() {
        return FP_NORMAL;
    }
    private static final int FP_SUBNORMAL = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FP_SUBNORMAL 5
     * }
     */
    public static int FP_SUBNORMAL() {
        return FP_SUBNORMAL;
    }
    private static final int FP_SUPERNORMAL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FP_SUPERNORMAL 6
     * }
     */
    public static int FP_SUPERNORMAL() {
        return FP_SUPERNORMAL;
    }
    private static final int FP_FAST_FMA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMA 1
     * }
     */
    public static int FP_FAST_FMA() {
        return FP_FAST_FMA;
    }
    private static final int FP_FAST_FMAF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMAF 1
     * }
     */
    public static int FP_FAST_FMAF() {
        return FP_FAST_FMAF;
    }
    private static final int FP_FAST_FMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMAL 1
     * }
     */
    public static int FP_FAST_FMAL() {
        return FP_FAST_FMAL;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DOMAIN 1
     * }
     */
    public static int DOMAIN() {
        return DOMAIN;
    }
    private static final int SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SING 2
     * }
     */
    public static int SING() {
        return SING;
    }
    private static final int OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define OVERFLOW 3
     * }
     */
    public static int OVERFLOW() {
        return OVERFLOW;
    }
    private static final int UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UNDERFLOW 4
     * }
     */
    public static int UNDERFLOW() {
        return UNDERFLOW;
    }
    private static final int TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TLOSS 5
     * }
     */
    public static int TLOSS() {
        return TLOSS;
    }
    private static final int PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PLOSS 6
     * }
     */
    public static int PLOSS() {
        return PLOSS;
    }

    private static class __assert_rtn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__assert_rtn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor __assert_rtn$descriptor() {
        return __assert_rtn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MethodHandle __assert_rtn$handle() {
        return __assert_rtn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment __assert_rtn$address() {
        return __assert_rtn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static void __assert_rtn(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = __assert_rtn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_rtn", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = flecs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = flecs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = flecs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = flecs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = flecs.C_LONG;

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = flecs.C_INT;

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = flecs.C_LONG;

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static void bzero(MemorySegment x0, long x1) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t ecs_flags8_t
     * }
     */
    public static final OfByte ecs_flags8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t ecs_flags16_t
     * }
     */
    public static final OfShort ecs_flags16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t ecs_flags32_t
     * }
     */
    public static final OfInt ecs_flags32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_flags64_t
     * }
     */
    public static final OfLong ecs_flags64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t ecs_size_t
     * }
     */
    public static final OfInt ecs_size_t = flecs.C_INT;

    private static class ecs_vec_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_init$descriptor() {
        return ecs_vec_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_init$handle() {
        return ecs_vec_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_init$address() {
        return ecs_vec_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_init(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_init(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_init", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_init_if {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_init_if");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_init_if$descriptor() {
        return ecs_vec_init_if.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_init_if$handle() {
        return ecs_vec_init_if.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_init_if$address() {
        return ecs_vec_init_if.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_init_if(ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_init_if(MemorySegment vec, int size) {
        var mh$ = ecs_vec_init_if.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_init_if", vec, size);
            }
            mh$.invokeExact(vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_fini$descriptor() {
        return ecs_vec_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_fini$handle() {
        return ecs_vec_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_fini$address() {
        return ecs_vec_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_fini(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_fini(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_fini", allocator, vec, size);
            }
            mh$.invokeExact(allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_reset$descriptor() {
        return ecs_vec_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_reset$handle() {
        return ecs_vec_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reset$address() {
        return ecs_vec_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t *ecs_vec_reset(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reset(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_reset", allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_clear$descriptor() {
        return ecs_vec_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_clear$handle() {
        return ecs_vec_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_clear$address() {
        return ecs_vec_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_clear(ecs_vec_t *vec)
     * }
     */
    public static void ecs_vec_clear(MemorySegment vec) {
        var mh$ = ecs_vec_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_clear", vec);
            }
            mh$.invokeExact(vec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_append$descriptor() {
        return ecs_vec_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_append$handle() {
        return ecs_vec_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_append$address() {
        return ecs_vec_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_append(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_append(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_append", allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static FunctionDescriptor ecs_vec_remove$descriptor() {
        return ecs_vec_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static MethodHandle ecs_vec_remove$handle() {
        return ecs_vec_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static MemorySegment ecs_vec_remove$address() {
        return ecs_vec_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_remove(ecs_vec_t *vec, ecs_size_t size, int32_t elem)
     * }
     */
    public static void ecs_vec_remove(MemorySegment vec, int size, int elem) {
        var mh$ = ecs_vec_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_remove", vec, size, elem);
            }
            mh$.invokeExact(vec, size, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_remove_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_remove_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_remove_last$descriptor() {
        return ecs_vec_remove_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_remove_last$handle() {
        return ecs_vec_remove_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_remove_last$address() {
        return ecs_vec_remove_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_remove_last(ecs_vec_t *vec)
     * }
     */
    public static void ecs_vec_remove_last(MemorySegment vec) {
        var mh$ = ecs_vec_remove_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_remove_last", vec);
            }
            mh$.invokeExact(vec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_vec_t.layout(),
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_copy$descriptor() {
        return ecs_vec_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_copy$handle() {
        return ecs_vec_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy$address() {
        return ecs_vec_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy(SegmentAllocator _allocator, MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_copy", _allocator, allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(_allocator, allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_copy_shrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_vec_t.layout(),
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_copy_shrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_copy_shrink$descriptor() {
        return ecs_vec_copy_shrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_copy_shrink$handle() {
        return ecs_vec_copy_shrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy_shrink$address() {
        return ecs_vec_copy_shrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_vec_t ecs_vec_copy_shrink(struct ecs_allocator_t *allocator, const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_copy_shrink(SegmentAllocator _allocator, MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_copy_shrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_copy_shrink", _allocator, allocator, vec, size);
            }
            return (MemorySegment)mh$.invokeExact(_allocator, allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_reclaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_reclaim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_reclaim$descriptor() {
        return ecs_vec_reclaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_reclaim$handle() {
        return ecs_vec_reclaim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_reclaim$address() {
        return ecs_vec_reclaim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_reclaim(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static void ecs_vec_reclaim(MemorySegment allocator, MemorySegment vec, int size) {
        var mh$ = ecs_vec_reclaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_reclaim", allocator, vec, size);
            }
            mh$.invokeExact(allocator, vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_size$descriptor() {
        return ecs_vec_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_size$handle() {
        return ecs_vec_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_size$address() {
        return ecs_vec_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_size(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_size", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_set_min_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_size$descriptor() {
        return ecs_vec_set_min_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_size$handle() {
        return ecs_vec_set_min_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_size$address() {
        return ecs_vec_set_min_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_size(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_size(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_size", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_set_min_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_count$descriptor() {
        return ecs_vec_set_min_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_count$handle() {
        return ecs_vec_set_min_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_count$address() {
        return ecs_vec_set_min_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_count(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_count", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_min_count_zeromem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_set_min_count_zeromem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_min_count_zeromem$descriptor() {
        return ecs_vec_set_min_count_zeromem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_min_count_zeromem$handle() {
        return ecs_vec_set_min_count_zeromem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_min_count_zeromem$address() {
        return ecs_vec_set_min_count_zeromem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_min_count_zeromem(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_min_count_zeromem(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_min_count_zeromem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_min_count_zeromem", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_set_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_set_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_set_count$descriptor() {
        return ecs_vec_set_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_set_count$handle() {
        return ecs_vec_set_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_set_count$address() {
        return ecs_vec_set_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_vec_set_count(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static void ecs_vec_set_count(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_set_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_set_count", allocator, vec, size, elem_count);
            }
            mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_grow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_grow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static FunctionDescriptor ecs_vec_grow$descriptor() {
        return ecs_vec_grow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MethodHandle ecs_vec_grow$handle() {
        return ecs_vec_grow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_grow$address() {
        return ecs_vec_grow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_grow(struct ecs_allocator_t *allocator, ecs_vec_t *vec, ecs_size_t size, int32_t elem_count)
     * }
     */
    public static MemorySegment ecs_vec_grow(MemorySegment allocator, MemorySegment vec, int size, int elem_count) {
        var mh$ = ecs_vec_grow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_grow", allocator, vec, size, elem_count);
            }
            return (MemorySegment)mh$.invokeExact(allocator, vec, size, elem_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_count$descriptor() {
        return ecs_vec_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_count$handle() {
        return ecs_vec_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_count$address() {
        return ecs_vec_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_vec_count(const ecs_vec_t *vec)
     * }
     */
    public static int ecs_vec_count(MemorySegment vec) {
        var mh$ = ecs_vec_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_count", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_size$descriptor() {
        return ecs_vec_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_size$handle() {
        return ecs_vec_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_size$address() {
        return ecs_vec_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_vec_size(const ecs_vec_t *vec)
     * }
     */
    public static int ecs_vec_size(MemorySegment vec) {
        var mh$ = ecs_vec_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_size", vec);
            }
            return (int)mh$.invokeExact(vec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_vec_get$descriptor() {
        return ecs_vec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MethodHandle ecs_vec_get$handle() {
        return ecs_vec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MemorySegment ecs_vec_get$address() {
        return ecs_vec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_get(const ecs_vec_t *vec, ecs_size_t size, int32_t index)
     * }
     */
    public static MemorySegment ecs_vec_get(MemorySegment vec, int size, int index) {
        var mh$ = ecs_vec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_get", vec, size, index);
            }
            return (MemorySegment)mh$.invokeExact(vec, size, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static FunctionDescriptor ecs_vec_first$descriptor() {
        return ecs_vec_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MethodHandle ecs_vec_first$handle() {
        return ecs_vec_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_first$address() {
        return ecs_vec_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_first(const ecs_vec_t *vec)
     * }
     */
    public static MemorySegment ecs_vec_first(MemorySegment vec) {
        var mh$ = ecs_vec_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_first", vec);
            }
            return (MemorySegment)mh$.invokeExact(vec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vec_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vec_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_vec_last$descriptor() {
        return ecs_vec_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_vec_last$handle() {
        return ecs_vec_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_last$address() {
        return ecs_vec_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_vec_last(const ecs_vec_t *vec, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_vec_last(MemorySegment vec, int size) {
        var mh$ = ecs_vec_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vec_last", vec, size);
            }
            return (MemorySegment)mh$.invokeExact(vec, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_sparse_init$descriptor() {
        return flecs_sparse_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_sparse_init$handle() {
        return flecs_sparse_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_sparse_init$address() {
        return flecs_sparse_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_init(ecs_sparse_t *result, struct ecs_allocator_t *allocator, struct ecs_block_allocator_t *page_allocator, ecs_size_t size)
     * }
     */
    public static void flecs_sparse_init(MemorySegment result, MemorySegment allocator, MemorySegment page_allocator, int size) {
        var mh$ = flecs_sparse_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_init", result, allocator, page_allocator, size);
            }
            mh$.invokeExact(result, allocator, page_allocator, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_fini$descriptor() {
        return flecs_sparse_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_fini$handle() {
        return flecs_sparse_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_fini$address() {
        return flecs_sparse_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_fini(ecs_sparse_t *sparse)
     * }
     */
    public static void flecs_sparse_fini(MemorySegment sparse) {
        var mh$ = flecs_sparse_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_fini", sparse);
            }
            mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_clear$descriptor() {
        return flecs_sparse_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_clear$handle() {
        return flecs_sparse_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_clear$address() {
        return flecs_sparse_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_clear(ecs_sparse_t *sparse)
     * }
     */
    public static void flecs_sparse_clear(MemorySegment sparse) {
        var mh$ = flecs_sparse_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_clear", sparse);
            }
            mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor flecs_sparse_add$descriptor() {
        return flecs_sparse_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle flecs_sparse_add$handle() {
        return flecs_sparse_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment flecs_sparse_add$address() {
        return flecs_sparse_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment flecs_sparse_add(MemorySegment sparse, int elem_size) {
        var mh$ = flecs_sparse_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_add", sparse, elem_size);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_last_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_last_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_last_id$descriptor() {
        return flecs_sparse_last_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_last_id$handle() {
        return flecs_sparse_last_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_last_id$address() {
        return flecs_sparse_last_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static long flecs_sparse_last_id(MemorySegment sparse) {
        var mh$ = flecs_sparse_last_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_last_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_new_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_new_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_new_id$descriptor() {
        return flecs_sparse_new_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_new_id$handle() {
        return flecs_sparse_new_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_new_id$address() {
        return flecs_sparse_new_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_sparse_new_id(ecs_sparse_t *sparse)
     * }
     */
    public static long flecs_sparse_new_id(MemorySegment sparse) {
        var mh$ = flecs_sparse_new_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_new_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_remove$descriptor() {
        return flecs_sparse_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_remove$handle() {
        return flecs_sparse_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_remove$address() {
        return flecs_sparse_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_sparse_remove(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static void flecs_sparse_remove(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_remove", sparse, elem_size, id);
            }
            mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_remove_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_remove_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_remove_fast(ecs_sparse_t *sparse, ecs_size_t size, uint64_t index)
     * }
     */
    public static FunctionDescriptor flecs_sparse_remove_fast$descriptor() {
        return flecs_sparse_remove_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_remove_fast(ecs_sparse_t *sparse, ecs_size_t size, uint64_t index)
     * }
     */
    public static MethodHandle flecs_sparse_remove_fast$handle() {
        return flecs_sparse_remove_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_remove_fast(ecs_sparse_t *sparse, ecs_size_t size, uint64_t index)
     * }
     */
    public static MemorySegment flecs_sparse_remove_fast$address() {
        return flecs_sparse_remove_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_remove_fast(ecs_sparse_t *sparse, ecs_size_t size, uint64_t index)
     * }
     */
    public static MemorySegment flecs_sparse_remove_fast(MemorySegment sparse, int size, long index) {
        var mh$ = flecs_sparse_remove_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_remove_fast", sparse, size, index);
            }
            return (MemorySegment)mh$.invokeExact(sparse, size, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_is_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_is_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_is_alive$descriptor() {
        return flecs_sparse_is_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_is_alive$handle() {
        return flecs_sparse_is_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_is_alive$address() {
        return flecs_sparse_is_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool flecs_sparse_is_alive(const ecs_sparse_t *sparse, uint64_t id)
     * }
     */
    public static boolean flecs_sparse_is_alive(MemorySegment sparse, long id) {
        var mh$ = flecs_sparse_is_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_is_alive", sparse, id);
            }
            return (boolean)mh$.invokeExact(sparse, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_get_dense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_get_dense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_sparse_get_dense$descriptor() {
        return flecs_sparse_get_dense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MethodHandle flecs_sparse_get_dense$handle() {
        return flecs_sparse_get_dense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment flecs_sparse_get_dense$address() {
        return flecs_sparse_get_dense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment flecs_sparse_get_dense(MemorySegment sparse, int elem_size, int index) {
        var mh$ = flecs_sparse_get_dense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_get_dense", sparse, elem_size, index);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_count$descriptor() {
        return flecs_sparse_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_count$handle() {
        return flecs_sparse_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_count$address() {
        return flecs_sparse_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static int flecs_sparse_count(MemorySegment sparse) {
        var mh$ = flecs_sparse_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_count", sparse);
            }
            return (int)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_get$descriptor() {
        return flecs_sparse_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_get$handle() {
        return flecs_sparse_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get$address() {
        return flecs_sparse_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_get", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_try {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_try");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_try(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_try$descriptor() {
        return flecs_sparse_try.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_try(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_try$handle() {
        return flecs_sparse_try.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_try(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_try$address() {
        return flecs_sparse_try.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_try(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_try(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_try.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_try", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_get_any {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_get_any");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_any(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_get_any$descriptor() {
        return flecs_sparse_get_any.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_any(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_get_any$handle() {
        return flecs_sparse_get_any.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_get_any(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get_any$address() {
        return flecs_sparse_get_any.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_get_any(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_get_any(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_get_any.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_get_any", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ensure$descriptor() {
        return flecs_sparse_ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_ensure$handle() {
        return flecs_sparse_ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure$address() {
        return flecs_sparse_ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_ensure(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ensure", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ensure_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_ensure_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ensure_fast$descriptor() {
        return flecs_sparse_ensure_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle flecs_sparse_ensure_fast$handle() {
        return flecs_sparse_ensure_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure_fast$address() {
        return flecs_sparse_ensure_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_sparse_ensure_fast(ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment flecs_sparse_ensure_fast(MemorySegment sparse, int elem_size, long id) {
        var mh$ = flecs_sparse_ensure_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ensure_fast", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_sparse_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_sparse_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor flecs_sparse_ids$descriptor() {
        return flecs_sparse_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle flecs_sparse_ids$handle() {
        return flecs_sparse_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_ids$address() {
        return flecs_sparse_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint64_t *flecs_sparse_ids(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment flecs_sparse_ids(MemorySegment sparse) {
        var mh$ = flecs_sparse_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_sparse_ids", sparse);
            }
            return (MemorySegment)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor ecs_sparse_init$descriptor() {
        return ecs_sparse_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle ecs_sparse_init$handle() {
        return ecs_sparse_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_init$address() {
        return ecs_sparse_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_sparse_init(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static void ecs_sparse_init(MemorySegment sparse, int elem_size) {
        var mh$ = ecs_sparse_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_init", sparse, elem_size);
            }
            mh$.invokeExact(sparse, elem_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static FunctionDescriptor ecs_sparse_add$descriptor() {
        return ecs_sparse_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MethodHandle ecs_sparse_add$handle() {
        return ecs_sparse_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_add$address() {
        return ecs_sparse_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_add(ecs_sparse_t *sparse, ecs_size_t elem_size)
     * }
     */
    public static MemorySegment ecs_sparse_add(MemorySegment sparse, int elem_size) {
        var mh$ = ecs_sparse_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_add", sparse, elem_size);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_last_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_last_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor ecs_sparse_last_id$descriptor() {
        return ecs_sparse_last_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle ecs_sparse_last_id$handle() {
        return ecs_sparse_last_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment ecs_sparse_last_id$address() {
        return ecs_sparse_last_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t ecs_sparse_last_id(const ecs_sparse_t *sparse)
     * }
     */
    public static long ecs_sparse_last_id(MemorySegment sparse) {
        var mh$ = ecs_sparse_last_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_last_id", sparse);
            }
            return (long)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static FunctionDescriptor ecs_sparse_count$descriptor() {
        return ecs_sparse_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MethodHandle ecs_sparse_count$handle() {
        return ecs_sparse_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static MemorySegment ecs_sparse_count$address() {
        return ecs_sparse_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_sparse_count(const ecs_sparse_t *sparse)
     * }
     */
    public static int ecs_sparse_count(MemorySegment sparse) {
        var mh$ = ecs_sparse_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_count", sparse);
            }
            return (int)mh$.invokeExact(sparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_get_dense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_get_dense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_sparse_get_dense$descriptor() {
        return ecs_sparse_get_dense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MethodHandle ecs_sparse_get_dense$handle() {
        return ecs_sparse_get_dense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment ecs_sparse_get_dense$address() {
        return ecs_sparse_get_dense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_get_dense(const ecs_sparse_t *sparse, ecs_size_t elem_size, int32_t index)
     * }
     */
    public static MemorySegment ecs_sparse_get_dense(MemorySegment sparse, int elem_size, int index) {
        var mh$ = ecs_sparse_get_dense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_get_dense", sparse, elem_size, index);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sparse_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sparse_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static FunctionDescriptor ecs_sparse_get$descriptor() {
        return ecs_sparse_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MethodHandle ecs_sparse_get$handle() {
        return ecs_sparse_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment ecs_sparse_get$address() {
        return ecs_sparse_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_sparse_get(const ecs_sparse_t *sparse, ecs_size_t elem_size, uint64_t id)
     * }
     */
    public static MemorySegment ecs_sparse_get(MemorySegment sparse, int elem_size, long id) {
        var mh$ = ecs_sparse_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sparse_get", sparse, elem_size, id);
            }
            return (MemorySegment)mh$.invokeExact(sparse, elem_size, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_ballocator_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_init$descriptor() {
        return flecs_ballocator_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_ballocator_init$handle() {
        return flecs_ballocator_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_init$address() {
        return flecs_ballocator_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_init(ecs_block_allocator_t *ba, ecs_size_t size)
     * }
     */
    public static void flecs_ballocator_init(MemorySegment ba, int size) {
        var mh$ = flecs_ballocator_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_init", ba, size);
            }
            mh$.invokeExact(ba, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_ballocator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_new$descriptor() {
        return flecs_ballocator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_ballocator_new$handle() {
        return flecs_ballocator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_new$address() {
        return flecs_ballocator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_ballocator_new(ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_ballocator_new(int size) {
        var mh$ = flecs_ballocator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_new", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_ballocator_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_fini$descriptor() {
        return flecs_ballocator_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static MethodHandle flecs_ballocator_fini$handle() {
        return flecs_ballocator_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static MemorySegment flecs_ballocator_fini$address() {
        return flecs_ballocator_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_fini(ecs_block_allocator_t *ba)
     * }
     */
    public static void flecs_ballocator_fini(MemorySegment ba) {
        var mh$ = flecs_ballocator_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_fini", ba);
            }
            mh$.invokeExact(ba);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_ballocator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_ballocator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static FunctionDescriptor flecs_ballocator_free$descriptor() {
        return flecs_ballocator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static MethodHandle flecs_ballocator_free$handle() {
        return flecs_ballocator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static MemorySegment flecs_ballocator_free$address() {
        return flecs_ballocator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_ballocator_free(ecs_block_allocator_t *ba)
     * }
     */
    public static void flecs_ballocator_free(MemorySegment ba) {
        var mh$ = flecs_ballocator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_ballocator_free", ba);
            }
            mh$.invokeExact(ba);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_balloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_balloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_balloc$descriptor() {
        return flecs_balloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_balloc$handle() {
        return flecs_balloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_balloc$address() {
        return flecs_balloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_balloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_balloc(MemorySegment allocator) {
        var mh$ = flecs_balloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_balloc", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bcalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_bcalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_bcalloc$descriptor() {
        return flecs_bcalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_bcalloc$handle() {
        return flecs_bcalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_bcalloc$address() {
        return flecs_bcalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_bcalloc(ecs_block_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_bcalloc(MemorySegment allocator) {
        var mh$ = flecs_bcalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bcalloc", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bfree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_bfree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_bfree$descriptor() {
        return flecs_bfree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static MethodHandle flecs_bfree$handle() {
        return flecs_bfree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static MemorySegment flecs_bfree$address() {
        return flecs_bfree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_bfree(ecs_block_allocator_t *allocator, void *memory)
     * }
     */
    public static void flecs_bfree(MemorySegment allocator, MemorySegment memory) {
        var mh$ = flecs_bfree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bfree", allocator, memory);
            }
            mh$.invokeExact(allocator, memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bfree_w_dbg_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_bfree_w_dbg_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static FunctionDescriptor flecs_bfree_w_dbg_info$descriptor() {
        return flecs_bfree_w_dbg_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static MethodHandle flecs_bfree_w_dbg_info$handle() {
        return flecs_bfree_w_dbg_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static MemorySegment flecs_bfree_w_dbg_info$address() {
        return flecs_bfree_w_dbg_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_bfree_w_dbg_info(ecs_block_allocator_t *allocator, void *memory, const char *type_name)
     * }
     */
    public static void flecs_bfree_w_dbg_info(MemorySegment allocator, MemorySegment memory, MemorySegment type_name) {
        var mh$ = flecs_bfree_w_dbg_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bfree_w_dbg_info", allocator, memory, type_name);
            }
            mh$.invokeExact(allocator, memory, type_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_brealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_brealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_brealloc$descriptor() {
        return flecs_brealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MethodHandle flecs_brealloc$handle() {
        return flecs_brealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MemorySegment flecs_brealloc$address() {
        return flecs_brealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_brealloc(ecs_block_allocator_t *dst, ecs_block_allocator_t *src, void *memory)
     * }
     */
    public static MemorySegment flecs_brealloc(MemorySegment dst, MemorySegment src, MemorySegment memory) {
        var mh$ = flecs_brealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_brealloc", dst, src, memory);
            }
            return (MemorySegment)mh$.invokeExact(dst, src, memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_bdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_bdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static FunctionDescriptor flecs_bdup$descriptor() {
        return flecs_bdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MethodHandle flecs_bdup$handle() {
        return flecs_bdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MemorySegment flecs_bdup$address() {
        return flecs_bdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_bdup(ecs_block_allocator_t *ba, void *memory)
     * }
     */
    public static MemorySegment flecs_bdup(MemorySegment ba, MemorySegment memory) {
        var mh$ = flecs_bdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_bdup", ba, memory);
            }
            return (MemorySegment)mh$.invokeExact(ba, memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_init$descriptor() {
        return flecs_stack_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_init$handle() {
        return flecs_stack_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_init$address() {
        return flecs_stack_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_init(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_init(MemorySegment stack) {
        var mh$ = flecs_stack_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_init", stack);
            }
            mh$.invokeExact(stack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_fini$descriptor() {
        return flecs_stack_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_fini$handle() {
        return flecs_stack_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_fini$address() {
        return flecs_stack_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_fini(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_fini(MemorySegment stack) {
        var mh$ = flecs_stack_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_fini", stack);
            }
            mh$.invokeExact(stack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static FunctionDescriptor flecs_stack_alloc$descriptor() {
        return flecs_stack_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MethodHandle flecs_stack_alloc$handle() {
        return flecs_stack_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_alloc$address() {
        return flecs_stack_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_stack_alloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_alloc(MemorySegment stack, int size, int align) {
        var mh$ = flecs_stack_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_alloc", stack, size, align);
            }
            return (MemorySegment)mh$.invokeExact(stack, size, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static FunctionDescriptor flecs_stack_calloc$descriptor() {
        return flecs_stack_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MethodHandle flecs_stack_calloc$handle() {
        return flecs_stack_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_calloc$address() {
        return flecs_stack_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_stack_calloc(ecs_stack_t *stack, ecs_size_t size, ecs_size_t align)
     * }
     */
    public static MemorySegment flecs_stack_calloc(MemorySegment stack, int size, int align) {
        var mh$ = flecs_stack_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_calloc", stack, size, align);
            }
            return (MemorySegment)mh$.invokeExact(stack, size, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_stack_free$descriptor() {
        return flecs_stack_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_stack_free$handle() {
        return flecs_stack_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_stack_free$address() {
        return flecs_stack_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_free(void *ptr, ecs_size_t size)
     * }
     */
    public static void flecs_stack_free(MemorySegment ptr, int size) {
        var mh$ = flecs_stack_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_free", ptr, size);
            }
            mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_reset$descriptor() {
        return flecs_stack_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_reset$handle() {
        return flecs_stack_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_reset$address() {
        return flecs_stack_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_reset(ecs_stack_t *stack)
     * }
     */
    public static void flecs_stack_reset(MemorySegment stack) {
        var mh$ = flecs_stack_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_reset", stack);
            }
            mh$.invokeExact(stack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_get_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_get_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static FunctionDescriptor flecs_stack_get_cursor$descriptor() {
        return flecs_stack_get_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MethodHandle flecs_stack_get_cursor$handle() {
        return flecs_stack_get_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_get_cursor$address() {
        return flecs_stack_get_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_stack_cursor_t *flecs_stack_get_cursor(ecs_stack_t *stack)
     * }
     */
    public static MemorySegment flecs_stack_get_cursor(MemorySegment stack) {
        var mh$ = flecs_stack_get_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_get_cursor", stack);
            }
            return (MemorySegment)mh$.invokeExact(stack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stack_restore_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stack_restore_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor flecs_stack_restore_cursor$descriptor() {
        return flecs_stack_restore_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static MethodHandle flecs_stack_restore_cursor$handle() {
        return flecs_stack_restore_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static MemorySegment flecs_stack_restore_cursor$address() {
        return flecs_stack_restore_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_stack_restore_cursor(ecs_stack_t *stack, ecs_stack_cursor_t *cursor)
     * }
     */
    public static void flecs_stack_restore_cursor(MemorySegment stack, MemorySegment cursor) {
        var mh$ = flecs_stack_restore_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stack_restore_cursor", stack, cursor);
            }
            mh$.invokeExact(stack, cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_map_data_t
     * }
     */
    public static final OfLong ecs_map_data_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_map_data_t ecs_map_key_t
     * }
     */
    public static final OfLong ecs_map_key_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_map_data_t ecs_map_val_t
     * }
     */
    public static final OfLong ecs_map_val_t = flecs.C_LONG_LONG;

    private static class ecs_map_params_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_params_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_params_init(ecs_map_params_t *params, struct ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor ecs_map_params_init$descriptor() {
        return ecs_map_params_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_params_init(ecs_map_params_t *params, struct ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle ecs_map_params_init$handle() {
        return ecs_map_params_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_params_init(ecs_map_params_t *params, struct ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment ecs_map_params_init$address() {
        return ecs_map_params_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_params_init(ecs_map_params_t *params, struct ecs_allocator_t *allocator)
     * }
     */
    public static void ecs_map_params_init(MemorySegment params, MemorySegment allocator) {
        var mh$ = ecs_map_params_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_params_init", params, allocator);
            }
            mh$.invokeExact(params, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_params_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_params_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_params_fini(ecs_map_params_t *params)
     * }
     */
    public static FunctionDescriptor ecs_map_params_fini$descriptor() {
        return ecs_map_params_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_params_fini(ecs_map_params_t *params)
     * }
     */
    public static MethodHandle ecs_map_params_fini$handle() {
        return ecs_map_params_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_params_fini(ecs_map_params_t *params)
     * }
     */
    public static MemorySegment ecs_map_params_fini$address() {
        return ecs_map_params_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_params_fini(ecs_map_params_t *params)
     * }
     */
    public static void ecs_map_params_fini(MemorySegment params) {
        var mh$ = ecs_map_params_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_params_fini", params);
            }
            mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor ecs_map_init$descriptor() {
        return ecs_map_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle ecs_map_init$handle() {
        return ecs_map_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment ecs_map_init$address() {
        return ecs_map_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static void ecs_map_init(MemorySegment map, MemorySegment allocator) {
        var mh$ = ecs_map_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init", map, allocator);
            }
            mh$.invokeExact(map, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_init_w_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_init_w_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params(ecs_map_t *map, ecs_map_params_t *params)
     * }
     */
    public static FunctionDescriptor ecs_map_init_w_params$descriptor() {
        return ecs_map_init_w_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params(ecs_map_t *map, ecs_map_params_t *params)
     * }
     */
    public static MethodHandle ecs_map_init_w_params$handle() {
        return ecs_map_init_w_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params(ecs_map_t *map, ecs_map_params_t *params)
     * }
     */
    public static MemorySegment ecs_map_init_w_params$address() {
        return ecs_map_init_w_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init_w_params(ecs_map_t *map, ecs_map_params_t *params)
     * }
     */
    public static void ecs_map_init_w_params(MemorySegment map, MemorySegment params) {
        var mh$ = ecs_map_init_w_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init_w_params", map, params);
            }
            mh$.invokeExact(map, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_init_if {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_init_if");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor ecs_map_init_if$descriptor() {
        return ecs_map_init_if.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle ecs_map_init_if$handle() {
        return ecs_map_init_if.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment ecs_map_init_if$address() {
        return ecs_map_init_if.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init_if(ecs_map_t *map, struct ecs_allocator_t *allocator)
     * }
     */
    public static void ecs_map_init_if(MemorySegment map, MemorySegment allocator) {
        var mh$ = ecs_map_init_if.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init_if", map, allocator);
            }
            mh$.invokeExact(map, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_init_w_params_if {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_init_w_params_if");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params_if(ecs_map_t *result, ecs_map_params_t *params)
     * }
     */
    public static FunctionDescriptor ecs_map_init_w_params_if$descriptor() {
        return ecs_map_init_w_params_if.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params_if(ecs_map_t *result, ecs_map_params_t *params)
     * }
     */
    public static MethodHandle ecs_map_init_w_params_if$handle() {
        return ecs_map_init_w_params_if.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_init_w_params_if(ecs_map_t *result, ecs_map_params_t *params)
     * }
     */
    public static MemorySegment ecs_map_init_w_params_if$address() {
        return ecs_map_init_w_params_if.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_init_w_params_if(ecs_map_t *result, ecs_map_params_t *params)
     * }
     */
    public static void ecs_map_init_w_params_if(MemorySegment result, MemorySegment params) {
        var mh$ = ecs_map_init_w_params_if.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_init_w_params_if", result, params);
            }
            mh$.invokeExact(result, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_fini$descriptor() {
        return ecs_map_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_fini$handle() {
        return ecs_map_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_fini$address() {
        return ecs_map_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_fini(ecs_map_t *map)
     * }
     */
    public static void ecs_map_fini(MemorySegment map) {
        var mh$ = ecs_map_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_fini", map);
            }
            mh$.invokeExact(map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_get$descriptor() {
        return ecs_map_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_get$handle() {
        return ecs_map_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get$address() {
        return ecs_map_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_get(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get(MemorySegment map, long key) {
        var mh$ = ecs_map_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_get", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_get_deref_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_get_deref_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_get_deref_$descriptor() {
        return ecs_map_get_deref_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_get_deref_$handle() {
        return ecs_map_get_deref_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get_deref_$address() {
        return ecs_map_get_deref_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_get_deref_(const ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_get_deref_(MemorySegment map, long key) {
        var mh$ = ecs_map_get_deref_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_get_deref_", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_ensure$descriptor() {
        return ecs_map_ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_ensure$handle() {
        return ecs_map_ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure$address() {
        return ecs_map_ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t *ecs_map_ensure(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure(MemorySegment map, long key) {
        var mh$ = ecs_map_ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_ensure", map, key);
            }
            return (MemorySegment)mh$.invokeExact(map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_ensure_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_ensure_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_ensure_alloc$descriptor() {
        return ecs_map_ensure_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_ensure_alloc$handle() {
        return ecs_map_ensure_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure_alloc$address() {
        return ecs_map_ensure_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_ensure_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_ensure_alloc(MemorySegment map, int elem_size, long key) {
        var mh$ = ecs_map_ensure_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_ensure_alloc", map, elem_size, key);
            }
            return (MemorySegment)mh$.invokeExact(map, elem_size, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static FunctionDescriptor ecs_map_insert$descriptor() {
        return ecs_map_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static MethodHandle ecs_map_insert$handle() {
        return ecs_map_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static MemorySegment ecs_map_insert$address() {
        return ecs_map_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_insert(ecs_map_t *map, ecs_map_key_t key, ecs_map_val_t value)
     * }
     */
    public static void ecs_map_insert(MemorySegment map, long key, long value) {
        var mh$ = ecs_map_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_insert", map, key, value);
            }
            mh$.invokeExact(map, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_insert_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_insert_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_insert_alloc$descriptor() {
        return ecs_map_insert_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_insert_alloc$handle() {
        return ecs_map_insert_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_insert_alloc$address() {
        return ecs_map_insert_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_map_insert_alloc(ecs_map_t *map, ecs_size_t elem_size, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_insert_alloc(MemorySegment map, int elem_size, long key) {
        var mh$ = ecs_map_insert_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_insert_alloc", map, elem_size, key);
            }
            return (MemorySegment)mh$.invokeExact(map, elem_size, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_remove$descriptor() {
        return ecs_map_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_remove$handle() {
        return ecs_map_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_remove$address() {
        return ecs_map_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_val_t ecs_map_remove(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static long ecs_map_remove(MemorySegment map, long key) {
        var mh$ = ecs_map_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_remove", map, key);
            }
            return (long)mh$.invokeExact(map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_remove_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_remove_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static FunctionDescriptor ecs_map_remove_free$descriptor() {
        return ecs_map_remove_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MethodHandle ecs_map_remove_free$handle() {
        return ecs_map_remove_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static MemorySegment ecs_map_remove_free$address() {
        return ecs_map_remove_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_remove_free(ecs_map_t *map, ecs_map_key_t key)
     * }
     */
    public static void ecs_map_remove_free(MemorySegment map, long key) {
        var mh$ = ecs_map_remove_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_remove_free", map, key);
            }
            mh$.invokeExact(map, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_clear$descriptor() {
        return ecs_map_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_clear$handle() {
        return ecs_map_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_clear$address() {
        return ecs_map_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_clear(ecs_map_t *map)
     * }
     */
    public static void ecs_map_clear(MemorySegment map) {
        var mh$ = ecs_map_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_clear", map);
            }
            mh$.invokeExact(map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_map_iter_t.layout(),
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static FunctionDescriptor ecs_map_iter$descriptor() {
        return ecs_map_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MethodHandle ecs_map_iter$handle() {
        return ecs_map_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_iter$address() {
        return ecs_map_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_iter_t ecs_map_iter(const ecs_map_t *map)
     * }
     */
    public static MemorySegment ecs_map_iter(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = ecs_map_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_iter", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static FunctionDescriptor ecs_map_next$descriptor() {
        return ecs_map_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static MethodHandle ecs_map_next$handle() {
        return ecs_map_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static MemorySegment ecs_map_next$address() {
        return ecs_map_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_map_next(ecs_map_iter_t *iter)
     * }
     */
    public static boolean ecs_map_next(MemorySegment iter) {
        var mh$ = ecs_map_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_next", iter);
            }
            return (boolean)mh$.invokeExact(iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_map_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_map_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static FunctionDescriptor ecs_map_copy$descriptor() {
        return ecs_map_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static MethodHandle ecs_map_copy$handle() {
        return ecs_map_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static MemorySegment ecs_map_copy$address() {
        return ecs_map_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_map_copy(ecs_map_t *dst, const ecs_map_t *src)
     * }
     */
    public static void ecs_map_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_map_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_map_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_switch_init(ecs_switch_t *sw, ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_switch_init$descriptor() {
        return flecs_switch_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_switch_init(ecs_switch_t *sw, ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_switch_init$handle() {
        return flecs_switch_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_switch_init(ecs_switch_t *sw, ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_switch_init$address() {
        return flecs_switch_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_switch_init(ecs_switch_t *sw, ecs_allocator_t *allocator)
     * }
     */
    public static void flecs_switch_init(MemorySegment sw, MemorySegment allocator) {
        var mh$ = flecs_switch_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_init", sw, allocator);
            }
            mh$.invokeExact(sw, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_switch_fini(ecs_switch_t *sw)
     * }
     */
    public static FunctionDescriptor flecs_switch_fini$descriptor() {
        return flecs_switch_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_switch_fini(ecs_switch_t *sw)
     * }
     */
    public static MethodHandle flecs_switch_fini$handle() {
        return flecs_switch_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_switch_fini(ecs_switch_t *sw)
     * }
     */
    public static MemorySegment flecs_switch_fini$address() {
        return flecs_switch_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_switch_fini(ecs_switch_t *sw)
     * }
     */
    public static void flecs_switch_fini(MemorySegment sw) {
        var mh$ = flecs_switch_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_fini", sw);
            }
            mh$.invokeExact(sw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool flecs_switch_set(ecs_switch_t *sw, uint32_t element, uint64_t value)
     * }
     */
    public static FunctionDescriptor flecs_switch_set$descriptor() {
        return flecs_switch_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool flecs_switch_set(ecs_switch_t *sw, uint32_t element, uint64_t value)
     * }
     */
    public static MethodHandle flecs_switch_set$handle() {
        return flecs_switch_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool flecs_switch_set(ecs_switch_t *sw, uint32_t element, uint64_t value)
     * }
     */
    public static MemorySegment flecs_switch_set$address() {
        return flecs_switch_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool flecs_switch_set(ecs_switch_t *sw, uint32_t element, uint64_t value)
     * }
     */
    public static boolean flecs_switch_set(MemorySegment sw, int element, long value) {
        var mh$ = flecs_switch_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_set", sw, element, value);
            }
            return (boolean)mh$.invokeExact(sw, element, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool flecs_switch_reset(ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static FunctionDescriptor flecs_switch_reset$descriptor() {
        return flecs_switch_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool flecs_switch_reset(ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static MethodHandle flecs_switch_reset$handle() {
        return flecs_switch_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool flecs_switch_reset(ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static MemorySegment flecs_switch_reset$address() {
        return flecs_switch_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool flecs_switch_reset(ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static boolean flecs_switch_reset(MemorySegment sw, int element) {
        var mh$ = flecs_switch_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_reset", sw, element);
            }
            return (boolean)mh$.invokeExact(sw, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t flecs_switch_get(const ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static FunctionDescriptor flecs_switch_get$descriptor() {
        return flecs_switch_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t flecs_switch_get(const ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static MethodHandle flecs_switch_get$handle() {
        return flecs_switch_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t flecs_switch_get(const ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static MemorySegment flecs_switch_get$address() {
        return flecs_switch_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t flecs_switch_get(const ecs_switch_t *sw, uint32_t element)
     * }
     */
    public static long flecs_switch_get(MemorySegment sw, int element) {
        var mh$ = flecs_switch_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_get", sw, element);
            }
            return (long)mh$.invokeExact(sw, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_first(const ecs_switch_t *sw, uint64_t value)
     * }
     */
    public static FunctionDescriptor flecs_switch_first$descriptor() {
        return flecs_switch_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_first(const ecs_switch_t *sw, uint64_t value)
     * }
     */
    public static MethodHandle flecs_switch_first$handle() {
        return flecs_switch_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_first(const ecs_switch_t *sw, uint64_t value)
     * }
     */
    public static MemorySegment flecs_switch_first$address() {
        return flecs_switch_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t flecs_switch_first(const ecs_switch_t *sw, uint64_t value)
     * }
     */
    public static int flecs_switch_first(MemorySegment sw, long value) {
        var mh$ = flecs_switch_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_first", sw, value);
            }
            return (int)mh$.invokeExact(sw, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_next(const ecs_switch_t *sw, uint32_t previous)
     * }
     */
    public static FunctionDescriptor flecs_switch_next$descriptor() {
        return flecs_switch_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_next(const ecs_switch_t *sw, uint32_t previous)
     * }
     */
    public static MethodHandle flecs_switch_next$handle() {
        return flecs_switch_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t flecs_switch_next(const ecs_switch_t *sw, uint32_t previous)
     * }
     */
    public static MemorySegment flecs_switch_next$address() {
        return flecs_switch_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t flecs_switch_next(const ecs_switch_t *sw, uint32_t previous)
     * }
     */
    public static int flecs_switch_next(MemorySegment sw, int previous) {
        var mh$ = flecs_switch_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_next", sw, previous);
            }
            return (int)mh$.invokeExact(sw, previous);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_switch_targets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_map_iter_t.layout(),
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_switch_targets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_map_iter_t flecs_switch_targets(const ecs_switch_t *sw)
     * }
     */
    public static FunctionDescriptor flecs_switch_targets$descriptor() {
        return flecs_switch_targets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_map_iter_t flecs_switch_targets(const ecs_switch_t *sw)
     * }
     */
    public static MethodHandle flecs_switch_targets$handle() {
        return flecs_switch_targets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_map_iter_t flecs_switch_targets(const ecs_switch_t *sw)
     * }
     */
    public static MemorySegment flecs_switch_targets$address() {
        return flecs_switch_targets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_map_iter_t flecs_switch_targets(const ecs_switch_t *sw)
     * }
     */
    public static MemorySegment flecs_switch_targets(SegmentAllocator allocator, MemorySegment sw) {
        var mh$ = flecs_switch_targets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_switch_targets", allocator, sw);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_block_allocator_alloc_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_block_allocator_alloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static OfLong ecs_block_allocator_alloc_count$layout() {
        return ecs_block_allocator_alloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static MemorySegment ecs_block_allocator_alloc_count$segment() {
        return ecs_block_allocator_alloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static long ecs_block_allocator_alloc_count() {
        return ecs_block_allocator_alloc_count$constants.SEGMENT.get(ecs_block_allocator_alloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_alloc_count
     * }
     */
    public static void ecs_block_allocator_alloc_count(long varValue) {
        ecs_block_allocator_alloc_count$constants.SEGMENT.set(ecs_block_allocator_alloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_block_allocator_free_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_block_allocator_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static OfLong ecs_block_allocator_free_count$layout() {
        return ecs_block_allocator_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static MemorySegment ecs_block_allocator_free_count$segment() {
        return ecs_block_allocator_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static long ecs_block_allocator_free_count() {
        return ecs_block_allocator_free_count$constants.SEGMENT.get(ecs_block_allocator_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_block_allocator_free_count
     * }
     */
    public static void ecs_block_allocator_free_count(long varValue) {
        ecs_block_allocator_free_count$constants.SEGMENT.set(ecs_block_allocator_free_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_stack_allocator_alloc_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_stack_allocator_alloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static OfLong ecs_stack_allocator_alloc_count$layout() {
        return ecs_stack_allocator_alloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static MemorySegment ecs_stack_allocator_alloc_count$segment() {
        return ecs_stack_allocator_alloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static long ecs_stack_allocator_alloc_count() {
        return ecs_stack_allocator_alloc_count$constants.SEGMENT.get(ecs_stack_allocator_alloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_alloc_count
     * }
     */
    public static void ecs_stack_allocator_alloc_count(long varValue) {
        ecs_stack_allocator_alloc_count$constants.SEGMENT.set(ecs_stack_allocator_alloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_stack_allocator_free_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_stack_allocator_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static OfLong ecs_stack_allocator_free_count$layout() {
        return ecs_stack_allocator_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static MemorySegment ecs_stack_allocator_free_count$segment() {
        return ecs_stack_allocator_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static long ecs_stack_allocator_free_count() {
        return ecs_stack_allocator_free_count$constants.SEGMENT.get(ecs_stack_allocator_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_stack_allocator_free_count
     * }
     */
    public static void ecs_stack_allocator_free_count(long varValue) {
        ecs_stack_allocator_free_count$constants.SEGMENT.set(ecs_stack_allocator_free_count$constants.LAYOUT, 0L, varValue);
    }

    private static class flecs_allocator_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_allocator_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static FunctionDescriptor flecs_allocator_init$descriptor() {
        return flecs_allocator_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static MethodHandle flecs_allocator_init$handle() {
        return flecs_allocator_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static MemorySegment flecs_allocator_init$address() {
        return flecs_allocator_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_allocator_init(ecs_allocator_t *a)
     * }
     */
    public static void flecs_allocator_init(MemorySegment a) {
        var mh$ = flecs_allocator_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_init", a);
            }
            mh$.invokeExact(a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_allocator_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_allocator_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static FunctionDescriptor flecs_allocator_fini$descriptor() {
        return flecs_allocator_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static MethodHandle flecs_allocator_fini$handle() {
        return flecs_allocator_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static MemorySegment flecs_allocator_fini$address() {
        return flecs_allocator_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_allocator_fini(ecs_allocator_t *a)
     * }
     */
    public static void flecs_allocator_fini(MemorySegment a) {
        var mh$ = flecs_allocator_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_fini", a);
            }
            mh$.invokeExact(a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_allocator_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_allocator_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor flecs_allocator_get$descriptor() {
        return flecs_allocator_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MethodHandle flecs_allocator_get$handle() {
        return flecs_allocator_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_allocator_get$address() {
        return flecs_allocator_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_block_allocator_t *flecs_allocator_get(ecs_allocator_t *a, ecs_size_t size)
     * }
     */
    public static MemorySegment flecs_allocator_get(MemorySegment a, int size) {
        var mh$ = flecs_allocator_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_allocator_get", a, size);
            }
            return (MemorySegment)mh$.invokeExact(a, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static FunctionDescriptor flecs_strdup$descriptor() {
        return flecs_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MethodHandle flecs_strdup$handle() {
        return flecs_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MemorySegment flecs_strdup$address() {
        return flecs_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_strdup(ecs_allocator_t *a, const char *str)
     * }
     */
    public static MemorySegment flecs_strdup(MemorySegment a, MemorySegment str) {
        var mh$ = flecs_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_strdup", a, str);
            }
            return (MemorySegment)mh$.invokeExact(a, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_strfree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_strfree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static FunctionDescriptor flecs_strfree$descriptor() {
        return flecs_strfree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static MethodHandle flecs_strfree$handle() {
        return flecs_strfree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static MemorySegment flecs_strfree$address() {
        return flecs_strfree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_strfree(ecs_allocator_t *a, char *str)
     * }
     */
    public static void flecs_strfree(MemorySegment a, MemorySegment str) {
        var mh$ = flecs_strfree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_strfree", a, str);
            }
            mh$.invokeExact(a, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static FunctionDescriptor flecs_dup$descriptor() {
        return flecs_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MethodHandle flecs_dup$handle() {
        return flecs_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MemorySegment flecs_dup$address() {
        return flecs_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_dup(ecs_allocator_t *a, ecs_size_t size, const void *src)
     * }
     */
    public static MemorySegment flecs_dup(MemorySegment a, int size, MemorySegment src) {
        var mh$ = flecs_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_dup", a, size, src);
            }
            return (MemorySegment)mh$.invokeExact(a, size, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_strbuf_append(ecs_strbuf_t *buffer, const char *fmt, ...)
     * }
     */
    public static class ecs_strbuf_append {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_append");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_strbuf_append(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_strbuf_append(ecs_strbuf_t *buffer, const char *fmt, ...)
         * }
         */
        public static ecs_strbuf_append makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_strbuf_append(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment buffer, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_strbuf_append", buffer, fmt, x2);
                }
                spreader.invokeExact(buffer, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_strbuf_vappend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_vappend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_vappend$descriptor() {
        return ecs_strbuf_vappend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static MethodHandle ecs_strbuf_vappend$handle() {
        return ecs_strbuf_vappend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static MemorySegment ecs_strbuf_vappend$address() {
        return ecs_strbuf_vappend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_vappend(ecs_strbuf_t *buffer, const char *fmt, va_list args)
     * }
     */
    public static void ecs_strbuf_vappend(MemorySegment buffer, MemorySegment fmt, MemorySegment args) {
        var mh$ = ecs_strbuf_vappend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_vappend", buffer, fmt, args);
            }
            mh$.invokeExact(buffer, fmt, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendstr$descriptor() {
        return ecs_strbuf_appendstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MethodHandle ecs_strbuf_appendstr$handle() {
        return ecs_strbuf_appendstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MemorySegment ecs_strbuf_appendstr$address() {
        return ecs_strbuf_appendstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static void ecs_strbuf_appendstr(MemorySegment buffer, MemorySegment str) {
        var mh$ = ecs_strbuf_appendstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendstr", buffer, str);
            }
            mh$.invokeExact(buffer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendch$descriptor() {
        return ecs_strbuf_appendch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MethodHandle ecs_strbuf_appendch$handle() {
        return ecs_strbuf_appendch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MemorySegment ecs_strbuf_appendch$address() {
        return ecs_strbuf_appendch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static void ecs_strbuf_appendch(MemorySegment buffer, byte ch) {
        var mh$ = ecs_strbuf_appendch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendch", buffer, ch);
            }
            mh$.invokeExact(buffer, ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendint$descriptor() {
        return ecs_strbuf_appendint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static MethodHandle ecs_strbuf_appendint$handle() {
        return ecs_strbuf_appendint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static MemorySegment ecs_strbuf_appendint$address() {
        return ecs_strbuf_appendint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendint(ecs_strbuf_t *buffer, int64_t v)
     * }
     */
    public static void ecs_strbuf_appendint(MemorySegment buffer, long v) {
        var mh$ = ecs_strbuf_appendint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendint", buffer, v);
            }
            mh$.invokeExact(buffer, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_DOUBLE,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendflt$descriptor() {
        return ecs_strbuf_appendflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static MethodHandle ecs_strbuf_appendflt$handle() {
        return ecs_strbuf_appendflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static MemorySegment ecs_strbuf_appendflt$address() {
        return ecs_strbuf_appendflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendflt(ecs_strbuf_t *buffer, double v, char nan_delim)
     * }
     */
    public static void ecs_strbuf_appendflt(MemorySegment buffer, double v, byte nan_delim) {
        var mh$ = ecs_strbuf_appendflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendflt", buffer, v, nan_delim);
            }
            mh$.invokeExact(buffer, v, nan_delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendbool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendbool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, bool v)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendbool$descriptor() {
        return ecs_strbuf_appendbool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, bool v)
     * }
     */
    public static MethodHandle ecs_strbuf_appendbool$handle() {
        return ecs_strbuf_appendbool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, bool v)
     * }
     */
    public static MemorySegment ecs_strbuf_appendbool$address() {
        return ecs_strbuf_appendbool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendbool(ecs_strbuf_t *buffer, bool v)
     * }
     */
    public static void ecs_strbuf_appendbool(MemorySegment buffer, boolean v) {
        var mh$ = ecs_strbuf_appendbool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendbool", buffer, v);
            }
            mh$.invokeExact(buffer, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_mergebuff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_mergebuff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_mergebuff$descriptor() {
        return ecs_strbuf_mergebuff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_mergebuff$handle() {
        return ecs_strbuf_mergebuff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_mergebuff$address() {
        return ecs_strbuf_mergebuff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_mergebuff(ecs_strbuf_t *dst_buffer, ecs_strbuf_t *src_buffer)
     * }
     */
    public static void ecs_strbuf_mergebuff(MemorySegment dst_buffer, MemorySegment src_buffer) {
        var mh$ = ecs_strbuf_mergebuff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_mergebuff", dst_buffer, src_buffer);
            }
            mh$.invokeExact(dst_buffer, src_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_appendstrn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_appendstrn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_appendstrn$descriptor() {
        return ecs_strbuf_appendstrn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MethodHandle ecs_strbuf_appendstrn$handle() {
        return ecs_strbuf_appendstrn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MemorySegment ecs_strbuf_appendstrn$address() {
        return ecs_strbuf_appendstrn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static void ecs_strbuf_appendstrn(MemorySegment buffer, MemorySegment str, int n) {
        var mh$ = ecs_strbuf_appendstrn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_appendstrn", buffer, str, n);
            }
            mh$.invokeExact(buffer, str, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_get$descriptor() {
        return ecs_strbuf_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_get$handle() {
        return ecs_strbuf_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get$address() {
        return ecs_strbuf_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_strbuf_get(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get(MemorySegment buffer) {
        var mh$ = ecs_strbuf_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_get", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_get_small {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_get_small");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_get_small$descriptor() {
        return ecs_strbuf_get_small.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_get_small$handle() {
        return ecs_strbuf_get_small.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get_small$address() {
        return ecs_strbuf_get_small.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_strbuf_get_small(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_get_small(MemorySegment buffer) {
        var mh$ = ecs_strbuf_get_small.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_get_small", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_reset$descriptor() {
        return ecs_strbuf_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_reset$handle() {
        return ecs_strbuf_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_reset$address() {
        return ecs_strbuf_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_reset(ecs_strbuf_t *buffer)
     * }
     */
    public static void ecs_strbuf_reset(MemorySegment buffer) {
        var mh$ = ecs_strbuf_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_reset", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_push$descriptor() {
        return ecs_strbuf_list_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static MethodHandle ecs_strbuf_list_push$handle() {
        return ecs_strbuf_list_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static MemorySegment ecs_strbuf_list_push$address() {
        return ecs_strbuf_list_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_push(ecs_strbuf_t *buffer, const char *list_open, const char *separator)
     * }
     */
    public static void ecs_strbuf_list_push(MemorySegment buffer, MemorySegment list_open, MemorySegment separator) {
        var mh$ = ecs_strbuf_list_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_push", buffer, list_open, separator);
            }
            mh$.invokeExact(buffer, list_open, separator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_pop$descriptor() {
        return ecs_strbuf_list_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static MethodHandle ecs_strbuf_list_pop$handle() {
        return ecs_strbuf_list_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static MemorySegment ecs_strbuf_list_pop$address() {
        return ecs_strbuf_list_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_pop(ecs_strbuf_t *buffer, const char *list_close)
     * }
     */
    public static void ecs_strbuf_list_pop(MemorySegment buffer, MemorySegment list_close) {
        var mh$ = ecs_strbuf_list_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_pop", buffer, list_close);
            }
            mh$.invokeExact(buffer, list_close);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_next$descriptor() {
        return ecs_strbuf_list_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_list_next$handle() {
        return ecs_strbuf_list_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_list_next$address() {
        return ecs_strbuf_list_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_next(ecs_strbuf_t *buffer)
     * }
     */
    public static void ecs_strbuf_list_next(MemorySegment buffer) {
        var mh$ = ecs_strbuf_list_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_next", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_appendch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_appendch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendch$descriptor() {
        return ecs_strbuf_list_appendch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendch$handle() {
        return ecs_strbuf_list_appendch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendch$address() {
        return ecs_strbuf_list_appendch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendch(ecs_strbuf_t *buffer, char ch)
     * }
     */
    public static void ecs_strbuf_list_appendch(MemorySegment buffer, byte ch) {
        var mh$ = ecs_strbuf_list_appendch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendch", buffer, ch);
            }
            mh$.invokeExact(buffer, ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_append(ecs_strbuf_t *buffer, const char *fmt, ...)
     * }
     */
    public static class ecs_strbuf_list_append {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_append");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_strbuf_list_append(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_strbuf_list_append(ecs_strbuf_t *buffer, const char *fmt, ...)
         * }
         */
        public static ecs_strbuf_list_append makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_strbuf_list_append(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment buffer, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_strbuf_list_append", buffer, fmt, x2);
                }
                spreader.invokeExact(buffer, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_strbuf_list_appendstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_appendstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendstr$descriptor() {
        return ecs_strbuf_list_appendstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendstr$handle() {
        return ecs_strbuf_list_appendstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendstr$address() {
        return ecs_strbuf_list_appendstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstr(ecs_strbuf_t *buffer, const char *str)
     * }
     */
    public static void ecs_strbuf_list_appendstr(MemorySegment buffer, MemorySegment str) {
        var mh$ = ecs_strbuf_list_appendstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendstr", buffer, str);
            }
            mh$.invokeExact(buffer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_list_appendstrn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_list_appendstrn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_list_appendstrn$descriptor() {
        return ecs_strbuf_list_appendstrn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MethodHandle ecs_strbuf_list_appendstrn$handle() {
        return ecs_strbuf_list_appendstrn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static MemorySegment ecs_strbuf_list_appendstrn$address() {
        return ecs_strbuf_list_appendstrn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_strbuf_list_appendstrn(ecs_strbuf_t *buffer, const char *str, int32_t n)
     * }
     */
    public static void ecs_strbuf_list_appendstrn(MemorySegment buffer, MemorySegment str, int n) {
        var mh$ = ecs_strbuf_list_appendstrn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_list_appendstrn", buffer, str, n);
            }
            mh$.invokeExact(buffer, str, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strbuf_written {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strbuf_written");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static FunctionDescriptor ecs_strbuf_written$descriptor() {
        return ecs_strbuf_written.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static MethodHandle ecs_strbuf_written$handle() {
        return ecs_strbuf_written.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static MemorySegment ecs_strbuf_written$address() {
        return ecs_strbuf_written.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_strbuf_written(const ecs_strbuf_t *buffer)
     * }
     */
    public static int ecs_strbuf_written(MemorySegment buffer) {
        var mh$ = ecs_strbuf_written.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strbuf_written", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER    );

        public static final MemorySegment ADDR = flecs.findOrThrow("__error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static FunctionDescriptor __error$descriptor() {
        return __error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MethodHandle __error$handle() {
        return __error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error$address() {
        return __error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error() {
        var mh$ = __error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__error");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = flecs.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = flecs.C_POINTER;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = flecs.C_POINTER;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = flecs.C_POINTER;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long x3) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER    );

        public static final MemorySegment ADDR = flecs.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = flecs.C_LONG_LONG;

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_LONG,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int)spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = flecs.C_INT;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, flecs.C_POINTER);
        public static final MemorySegment SEGMENT = flecs.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_INT,
                flecs.C_LONG,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_LONG,
                flecs.C_INT,
                flecs.C_LONG,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, x1, x2, x3, x4, x5);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_INT,
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_api_malloc_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_os_api_malloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static OfLong ecs_os_api_malloc_count$layout() {
        return ecs_os_api_malloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static MemorySegment ecs_os_api_malloc_count$segment() {
        return ecs_os_api_malloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static long ecs_os_api_malloc_count() {
        return ecs_os_api_malloc_count$constants.SEGMENT.get(ecs_os_api_malloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_malloc_count
     * }
     */
    public static void ecs_os_api_malloc_count(long varValue) {
        ecs_os_api_malloc_count$constants.SEGMENT.set(ecs_os_api_malloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_realloc_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_os_api_realloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static OfLong ecs_os_api_realloc_count$layout() {
        return ecs_os_api_realloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static MemorySegment ecs_os_api_realloc_count$segment() {
        return ecs_os_api_realloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static long ecs_os_api_realloc_count() {
        return ecs_os_api_realloc_count$constants.SEGMENT.get(ecs_os_api_realloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_realloc_count
     * }
     */
    public static void ecs_os_api_realloc_count(long varValue) {
        ecs_os_api_realloc_count$constants.SEGMENT.set(ecs_os_api_realloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_calloc_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_os_api_calloc_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static OfLong ecs_os_api_calloc_count$layout() {
        return ecs_os_api_calloc_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static MemorySegment ecs_os_api_calloc_count$segment() {
        return ecs_os_api_calloc_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static long ecs_os_api_calloc_count() {
        return ecs_os_api_calloc_count$constants.SEGMENT.get(ecs_os_api_calloc_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_calloc_count
     * }
     */
    public static void ecs_os_api_calloc_count(long varValue) {
        ecs_os_api_calloc_count$constants.SEGMENT.set(ecs_os_api_calloc_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_os_api_free_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_os_api_free_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static OfLong ecs_os_api_free_count$layout() {
        return ecs_os_api_free_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static MemorySegment ecs_os_api_free_count$segment() {
        return ecs_os_api_free_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static long ecs_os_api_free_count() {
        return ecs_os_api_free_count$constants.SEGMENT.get(ecs_os_api_free_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_os_api_free_count
     * }
     */
    public static void ecs_os_api_free_count(long varValue) {
        ecs_os_api_free_count$constants.SEGMENT.set(ecs_os_api_free_count$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_thread_t
     * }
     */
    public static final OfLong ecs_os_thread_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_cond_t
     * }
     */
    public static final OfLong ecs_os_cond_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_mutex_t
     * }
     */
    public static final OfLong ecs_os_mutex_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_dl_t
     * }
     */
    public static final OfLong ecs_os_dl_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_os_sock_t
     * }
     */
    public static final OfLong ecs_os_sock_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_os_thread_id_t
     * }
     */
    public static final OfLong ecs_os_thread_id_t = flecs.C_LONG_LONG;

    private static class ecs_os_api$constants {
        public static final GroupLayout LAYOUT = ecs_os_api_t.layout();
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_os_api").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static GroupLayout ecs_os_api$layout() {
        return ecs_os_api$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static MemorySegment ecs_os_api() {
        return ecs_os_api$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_os_api_t ecs_os_api
     * }
     */
    public static void ecs_os_api(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ecs_os_api$constants.SEGMENT, 0L, ecs_os_api$constants.LAYOUT.byteSize());
    }

    private static class ecs_os_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static FunctionDescriptor ecs_os_init$descriptor() {
        return ecs_os_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static MethodHandle ecs_os_init$handle() {
        return ecs_os_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static MemorySegment ecs_os_init$address() {
        return ecs_os_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_init()
     * }
     */
    public static void ecs_os_init() {
        var mh$ = ecs_os_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_init");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static FunctionDescriptor ecs_os_fini$descriptor() {
        return ecs_os_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static MethodHandle ecs_os_fini$handle() {
        return ecs_os_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static MemorySegment ecs_os_fini$address() {
        return ecs_os_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_fini()
     * }
     */
    public static void ecs_os_fini() {
        var mh$ = ecs_os_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_fini");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_set_api {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_set_api");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static FunctionDescriptor ecs_os_set_api$descriptor() {
        return ecs_os_set_api.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static MethodHandle ecs_os_set_api$handle() {
        return ecs_os_set_api.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static MemorySegment ecs_os_set_api$address() {
        return ecs_os_set_api.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_set_api(ecs_os_api_t *os_api)
     * }
     */
    public static void ecs_os_set_api(MemorySegment os_api) {
        var mh$ = ecs_os_set_api.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_set_api", os_api);
            }
            mh$.invokeExact(os_api);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_get_api {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_os_api_t.layout()    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_get_api");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static FunctionDescriptor ecs_os_get_api$descriptor() {
        return ecs_os_get_api.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MethodHandle ecs_os_get_api$handle() {
        return ecs_os_get_api.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MemorySegment ecs_os_get_api$address() {
        return ecs_os_get_api.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_os_api_t ecs_os_get_api()
     * }
     */
    public static MemorySegment ecs_os_get_api(SegmentAllocator allocator) {
        var mh$ = ecs_os_get_api.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_get_api", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_set_api_defaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_set_api_defaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static FunctionDescriptor ecs_os_set_api_defaults$descriptor() {
        return ecs_os_set_api_defaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static MethodHandle ecs_os_set_api_defaults$handle() {
        return ecs_os_set_api_defaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static MemorySegment ecs_os_set_api_defaults$address() {
        return ecs_os_set_api_defaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_set_api_defaults()
     * }
     */
    public static void ecs_os_set_api_defaults() {
        var mh$ = ecs_os_set_api_defaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_set_api_defaults");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_dbg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_dbg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_dbg$descriptor() {
        return ecs_os_dbg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_dbg$handle() {
        return ecs_os_dbg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_dbg$address() {
        return ecs_os_dbg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_dbg(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_dbg(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_dbg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_dbg", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_trace$descriptor() {
        return ecs_os_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_trace$handle() {
        return ecs_os_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_trace$address() {
        return ecs_os_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_trace(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_trace(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_trace", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_warn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_warn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_warn$descriptor() {
        return ecs_os_warn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_warn$handle() {
        return ecs_os_warn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_warn$address() {
        return ecs_os_warn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_warn(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_warn(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_warn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_warn", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_err {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_err");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_err$descriptor() {
        return ecs_os_err.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_err$handle() {
        return ecs_os_err.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_err$address() {
        return ecs_os_err.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_err(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_err(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_err.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_err", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_fatal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_fatal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_os_fatal$descriptor() {
        return ecs_os_fatal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_os_fatal$handle() {
        return ecs_os_fatal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_os_fatal$address() {
        return ecs_os_fatal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_fatal(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_os_fatal(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_os_fatal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_fatal", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static FunctionDescriptor ecs_os_strerror$descriptor() {
        return ecs_os_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MethodHandle ecs_os_strerror$handle() {
        return ecs_os_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MemorySegment ecs_os_strerror$address() {
        return ecs_os_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_os_strerror(int err)
     * }
     */
    public static MemorySegment ecs_os_strerror(int err) {
        var mh$ = ecs_os_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_strerror", err);
            }
            return (MemorySegment)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static FunctionDescriptor ecs_os_strset$descriptor() {
        return ecs_os_strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static MethodHandle ecs_os_strset$handle() {
        return ecs_os_strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static MemorySegment ecs_os_strset$address() {
        return ecs_os_strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_strset(char **str, const char *value)
     * }
     */
    public static void ecs_os_strset(MemorySegment str, MemorySegment value) {
        var mh$ = ecs_os_strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_strset", str, value);
            }
            mh$.invokeExact(str, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_perf_trace_push_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_perf_trace_push_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_os_perf_trace_push_$descriptor() {
        return ecs_os_perf_trace_push_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static MethodHandle ecs_os_perf_trace_push_$handle() {
        return ecs_os_perf_trace_push_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static MemorySegment ecs_os_perf_trace_push_$address() {
        return ecs_os_perf_trace_push_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_perf_trace_push_(const char *file, size_t line, const char *name)
     * }
     */
    public static void ecs_os_perf_trace_push_(MemorySegment file, long line, MemorySegment name) {
        var mh$ = ecs_os_perf_trace_push_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_perf_trace_push_", file, line, name);
            }
            mh$.invokeExact(file, line, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_perf_trace_pop_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_perf_trace_pop_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_os_perf_trace_pop_$descriptor() {
        return ecs_os_perf_trace_pop_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static MethodHandle ecs_os_perf_trace_pop_$handle() {
        return ecs_os_perf_trace_pop_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static MemorySegment ecs_os_perf_trace_pop_$address() {
        return ecs_os_perf_trace_pop_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_os_perf_trace_pop_(const char *file, size_t line, const char *name)
     * }
     */
    public static void ecs_os_perf_trace_pop_(MemorySegment file, long line, MemorySegment name) {
        var mh$ = ecs_os_perf_trace_pop_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_perf_trace_pop_", file, line, name);
            }
            mh$.invokeExact(file, line, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_sleepf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_sleepf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static FunctionDescriptor ecs_sleepf$descriptor() {
        return ecs_sleepf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static MethodHandle ecs_sleepf$handle() {
        return ecs_sleepf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static MemorySegment ecs_sleepf$address() {
        return ecs_sleepf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_sleepf(double t)
     * }
     */
    public static void ecs_sleepf(double t) {
        var mh$ = ecs_sleepf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_sleepf", t);
            }
            mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_measure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_time_measure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static FunctionDescriptor ecs_time_measure$descriptor() {
        return ecs_time_measure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static MethodHandle ecs_time_measure$handle() {
        return ecs_time_measure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static MemorySegment ecs_time_measure$address() {
        return ecs_time_measure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_time_measure(ecs_time_t *start)
     * }
     */
    public static double ecs_time_measure(MemorySegment start) {
        var mh$ = ecs_time_measure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_measure", start);
            }
            return (double)mh$.invokeExact(start);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_time_t.layout(),
            ecs_time_t.layout(),
            ecs_time_t.layout()
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_time_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static FunctionDescriptor ecs_time_sub$descriptor() {
        return ecs_time_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MethodHandle ecs_time_sub$handle() {
        return ecs_time_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MemorySegment ecs_time_sub$address() {
        return ecs_time_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_time_t ecs_time_sub(ecs_time_t t1, ecs_time_t t2)
     * }
     */
    public static MemorySegment ecs_time_sub(SegmentAllocator allocator, MemorySegment t1, MemorySegment t2) {
        var mh$ = ecs_time_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_sub", allocator, t1, t2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, t1, t2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_time_to_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            ecs_time_t.layout()
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_time_to_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static FunctionDescriptor ecs_time_to_double$descriptor() {
        return ecs_time_to_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static MethodHandle ecs_time_to_double$handle() {
        return ecs_time_to_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static MemorySegment ecs_time_to_double$address() {
        return ecs_time_to_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_time_to_double(ecs_time_t t)
     * }
     */
    public static double ecs_time_to_double(MemorySegment t) {
        var mh$ = ecs_time_to_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_time_to_double", t);
            }
            return (double)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static FunctionDescriptor ecs_os_memdup$descriptor() {
        return ecs_os_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MethodHandle ecs_os_memdup$handle() {
        return ecs_os_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_os_memdup$address() {
        return ecs_os_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_os_memdup(const void *src, ecs_size_t size)
     * }
     */
    public static MemorySegment ecs_os_memdup(MemorySegment src, int size) {
        var mh$ = ecs_os_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_memdup", src, size);
            }
            return (MemorySegment)mh$.invokeExact(src, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_heap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_heap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_heap()
     * }
     */
    public static FunctionDescriptor ecs_os_has_heap$descriptor() {
        return ecs_os_has_heap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_heap()
     * }
     */
    public static MethodHandle ecs_os_has_heap$handle() {
        return ecs_os_has_heap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_heap()
     * }
     */
    public static MemorySegment ecs_os_has_heap$address() {
        return ecs_os_has_heap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_heap()
     * }
     */
    public static boolean ecs_os_has_heap() {
        var mh$ = ecs_os_has_heap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_heap");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_threading {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_threading");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_threading()
     * }
     */
    public static FunctionDescriptor ecs_os_has_threading$descriptor() {
        return ecs_os_has_threading.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_threading()
     * }
     */
    public static MethodHandle ecs_os_has_threading$handle() {
        return ecs_os_has_threading.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_threading()
     * }
     */
    public static MemorySegment ecs_os_has_threading$address() {
        return ecs_os_has_threading.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_threading()
     * }
     */
    public static boolean ecs_os_has_threading() {
        var mh$ = ecs_os_has_threading.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_threading");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_task_support {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_task_support");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_task_support()
     * }
     */
    public static FunctionDescriptor ecs_os_has_task_support$descriptor() {
        return ecs_os_has_task_support.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_task_support()
     * }
     */
    public static MethodHandle ecs_os_has_task_support$handle() {
        return ecs_os_has_task_support.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_task_support()
     * }
     */
    public static MemorySegment ecs_os_has_task_support$address() {
        return ecs_os_has_task_support.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_task_support()
     * }
     */
    public static boolean ecs_os_has_task_support() {
        var mh$ = ecs_os_has_task_support.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_task_support");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_time()
     * }
     */
    public static FunctionDescriptor ecs_os_has_time$descriptor() {
        return ecs_os_has_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_time()
     * }
     */
    public static MethodHandle ecs_os_has_time$handle() {
        return ecs_os_has_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_time()
     * }
     */
    public static MemorySegment ecs_os_has_time$address() {
        return ecs_os_has_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_time()
     * }
     */
    public static boolean ecs_os_has_time() {
        var mh$ = ecs_os_has_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_time");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_logging {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_logging");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_logging()
     * }
     */
    public static FunctionDescriptor ecs_os_has_logging$descriptor() {
        return ecs_os_has_logging.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_logging()
     * }
     */
    public static MethodHandle ecs_os_has_logging$handle() {
        return ecs_os_has_logging.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_logging()
     * }
     */
    public static MemorySegment ecs_os_has_logging$address() {
        return ecs_os_has_logging.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_logging()
     * }
     */
    public static boolean ecs_os_has_logging() {
        var mh$ = ecs_os_has_logging.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_logging");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_dl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_dl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_dl()
     * }
     */
    public static FunctionDescriptor ecs_os_has_dl$descriptor() {
        return ecs_os_has_dl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_dl()
     * }
     */
    public static MethodHandle ecs_os_has_dl$handle() {
        return ecs_os_has_dl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_dl()
     * }
     */
    public static MemorySegment ecs_os_has_dl$address() {
        return ecs_os_has_dl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_dl()
     * }
     */
    public static boolean ecs_os_has_dl() {
        var mh$ = ecs_os_has_dl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_dl");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_os_has_modules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_os_has_modules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_os_has_modules()
     * }
     */
    public static FunctionDescriptor ecs_os_has_modules$descriptor() {
        return ecs_os_has_modules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_os_has_modules()
     * }
     */
    public static MethodHandle ecs_os_has_modules$handle() {
        return ecs_os_has_modules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_os_has_modules()
     * }
     */
    public static MemorySegment ecs_os_has_modules$address() {
        return ecs_os_has_modules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_os_has_modules()
     * }
     */
    public static boolean ecs_os_has_modules() {
        var mh$ = ecs_os_has_modules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_os_has_modules");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_id_t
     * }
     */
    public static final OfLong ecs_id_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ecs_id_t ecs_entity_t
     * }
     */
    public static final OfLong ecs_entity_t = flecs.C_LONG_LONG;
    private static final int EcsInOutDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutDefault = 0
     * }
     */
    public static int EcsInOutDefault() {
        return EcsInOutDefault;
    }
    private static final int EcsInOutNone = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutNone = 1
     * }
     */
    public static int EcsInOutNone() {
        return EcsInOutNone;
    }
    private static final int EcsInOutFilter = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOutFilter = 2
     * }
     */
    public static int EcsInOutFilter() {
        return EcsInOutFilter;
    }
    private static final int EcsInOut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsInOut = 3
     * }
     */
    public static int EcsInOut() {
        return EcsInOut;
    }
    private static final int EcsIn = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsIn = 4
     * }
     */
    public static int EcsIn() {
        return EcsIn;
    }
    private static final int EcsOut = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_inout_kind_t.EcsOut = 5
     * }
     */
    public static int EcsOut() {
        return EcsOut;
    }
    private static final int EcsAnd = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsAnd = 0
     * }
     */
    public static int EcsAnd() {
        return EcsAnd;
    }
    private static final int EcsOr = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOr = 1
     * }
     */
    public static int EcsOr() {
        return EcsOr;
    }
    private static final int EcsNot = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsNot = 2
     * }
     */
    public static int EcsNot() {
        return EcsNot;
    }
    private static final int EcsOptional = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOptional = 3
     * }
     */
    public static int EcsOptional() {
        return EcsOptional;
    }
    private static final int EcsAndFrom = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsAndFrom = 4
     * }
     */
    public static int EcsAndFrom() {
        return EcsAndFrom;
    }
    private static final int EcsOrFrom = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsOrFrom = 5
     * }
     */
    public static int EcsOrFrom() {
        return EcsOrFrom;
    }
    private static final int EcsNotFrom = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_oper_kind_t.EcsNotFrom = 6
     * }
     */
    public static int EcsNotFrom() {
        return EcsNotFrom;
    }
    private static final int EcsQueryCacheDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheDefault = 0
     * }
     */
    public static int EcsQueryCacheDefault() {
        return EcsQueryCacheDefault;
    }
    private static final int EcsQueryCacheAuto = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheAuto = 1
     * }
     */
    public static int EcsQueryCacheAuto() {
        return EcsQueryCacheAuto;
    }
    private static final int EcsQueryCacheAll = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheAll = 2
     * }
     */
    public static int EcsQueryCacheAll() {
        return EcsQueryCacheAll;
    }
    private static final int EcsQueryCacheNone = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_query_cache_kind_t.EcsQueryCacheNone = 3
     * }
     */
    public static int EcsQueryCacheNone() {
        return EcsQueryCacheNone;
    }

    private static class flecs_module_path_from_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_module_path_from_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static FunctionDescriptor flecs_module_path_from_c$descriptor() {
        return flecs_module_path_from_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MethodHandle flecs_module_path_from_c$handle() {
        return flecs_module_path_from_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MemorySegment flecs_module_path_from_c$address() {
        return flecs_module_path_from_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_module_path_from_c(const char *c_name)
     * }
     */
    public static MemorySegment flecs_module_path_from_c(MemorySegment c_name) {
        var mh$ = flecs_module_path_from_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_module_path_from_c", c_name);
            }
            return (MemorySegment)mh$.invokeExact(c_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_identifier_is_0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_identifier_is_0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool flecs_identifier_is_0(const char *id)
     * }
     */
    public static FunctionDescriptor flecs_identifier_is_0$descriptor() {
        return flecs_identifier_is_0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool flecs_identifier_is_0(const char *id)
     * }
     */
    public static MethodHandle flecs_identifier_is_0$handle() {
        return flecs_identifier_is_0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool flecs_identifier_is_0(const char *id)
     * }
     */
    public static MemorySegment flecs_identifier_is_0$address() {
        return flecs_identifier_is_0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool flecs_identifier_is_0(const char *id)
     * }
     */
    public static boolean flecs_identifier_is_0(MemorySegment id) {
        var mh$ = flecs_identifier_is_0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_identifier_is_0", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_default_ctor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_default_ctor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *ctx)
     * }
     */
    public static FunctionDescriptor flecs_default_ctor$descriptor() {
        return flecs_default_ctor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *ctx)
     * }
     */
    public static MethodHandle flecs_default_ctor$handle() {
        return flecs_default_ctor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *ctx)
     * }
     */
    public static MemorySegment flecs_default_ctor$address() {
        return flecs_default_ctor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_default_ctor(void *ptr, int32_t count, const ecs_type_info_t *ctx)
     * }
     */
    public static void flecs_default_ctor(MemorySegment ptr, int count, MemorySegment ctx) {
        var mh$ = flecs_default_ctor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_default_ctor", ptr, count, ctx);
            }
            mh$.invokeExact(ptr, count, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor flecs_vasprintf$descriptor() {
        return flecs_vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MethodHandle flecs_vasprintf$handle() {
        return flecs_vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MemorySegment flecs_vasprintf$address() {
        return flecs_vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_vasprintf(const char *fmt, va_list args)
     * }
     */
    public static MemorySegment flecs_vasprintf(MemorySegment fmt, MemorySegment args) {
        var mh$ = flecs_vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_vasprintf", fmt, args);
            }
            return (MemorySegment)mh$.invokeExact(fmt, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * char *flecs_asprintf(const char *fmt, ...)
     * }
     */
    public static class flecs_asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                flecs.C_POINTER,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("flecs_asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private flecs_asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * char *flecs_asprintf(const char *fmt, ...)
         * }
         */
        public static flecs_asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new flecs_asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment fmt, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("flecs_asprintf", fmt, x1);
                }
                return (MemorySegment)spreader.invokeExact(fmt, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class flecs_chresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_CHAR,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_chresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static FunctionDescriptor flecs_chresc$descriptor() {
        return flecs_chresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MethodHandle flecs_chresc$handle() {
        return flecs_chresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MemorySegment flecs_chresc$address() {
        return flecs_chresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_chresc(char *out, char in, char delimiter)
     * }
     */
    public static MemorySegment flecs_chresc(MemorySegment out, byte in, byte delimiter) {
        var mh$ = flecs_chresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_chresc", out, in, delimiter);
            }
            return (MemorySegment)mh$.invokeExact(out, in, delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_chrparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_chrparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static FunctionDescriptor flecs_chrparse$descriptor() {
        return flecs_chrparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MethodHandle flecs_chrparse$handle() {
        return flecs_chrparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MemorySegment flecs_chrparse$address() {
        return flecs_chrparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_chrparse(const char *in, char *out)
     * }
     */
    public static MemorySegment flecs_chrparse(MemorySegment in, MemorySegment out) {
        var mh$ = flecs_chrparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_chrparse", in, out);
            }
            return (MemorySegment)mh$.invokeExact(in, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_stresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_CHAR,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_stresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static FunctionDescriptor flecs_stresc$descriptor() {
        return flecs_stresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static MethodHandle flecs_stresc$handle() {
        return flecs_stresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_stresc$address() {
        return flecs_stresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_size_t flecs_stresc(char *out, ecs_size_t size, char delimiter, const char *in)
     * }
     */
    public static int flecs_stresc(MemorySegment out, int size, byte delimiter, MemorySegment in) {
        var mh$ = flecs_stresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_stresc", out, size, delimiter, in);
            }
            return (int)mh$.invokeExact(out, size, delimiter, in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_astresc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_CHAR,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_astresc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static FunctionDescriptor flecs_astresc$descriptor() {
        return flecs_astresc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MethodHandle flecs_astresc$handle() {
        return flecs_astresc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_astresc$address() {
        return flecs_astresc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_astresc(char delimiter, const char *in)
     * }
     */
    public static MemorySegment flecs_astresc(byte delimiter, MemorySegment in) {
        var mh$ = flecs_astresc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_astresc", delimiter, in);
            }
            return (MemorySegment)mh$.invokeExact(delimiter, in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_parse_ws_eol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_parse_ws_eol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static FunctionDescriptor flecs_parse_ws_eol$descriptor() {
        return flecs_parse_ws_eol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MethodHandle flecs_parse_ws_eol$handle() {
        return flecs_parse_ws_eol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MemorySegment flecs_parse_ws_eol$address() {
        return flecs_parse_ws_eol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_parse_ws_eol(const char *ptr)
     * }
     */
    public static MemorySegment flecs_parse_ws_eol(MemorySegment ptr) {
        var mh$ = flecs_parse_ws_eol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_parse_ws_eol", ptr);
            }
            return (MemorySegment)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_parse_digit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_parse_digit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static FunctionDescriptor flecs_parse_digit$descriptor() {
        return flecs_parse_digit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MethodHandle flecs_parse_digit$handle() {
        return flecs_parse_digit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MemorySegment flecs_parse_digit$address() {
        return flecs_parse_digit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *flecs_parse_digit(const char *ptr, char *token)
     * }
     */
    public static MemorySegment flecs_parse_digit(MemorySegment ptr, MemorySegment token) {
        var mh$ = flecs_parse_digit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_parse_digit", ptr, token);
            }
            return (MemorySegment)mh$.invokeExact(ptr, token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_to_snake_case {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_to_snake_case");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static FunctionDescriptor flecs_to_snake_case$descriptor() {
        return flecs_to_snake_case.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MethodHandle flecs_to_snake_case$handle() {
        return flecs_to_snake_case.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MemorySegment flecs_to_snake_case$address() {
        return flecs_to_snake_case.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *flecs_to_snake_case(const char *str)
     * }
     */
    public static MemorySegment flecs_to_snake_case(MemorySegment str) {
        var mh$ = flecs_to_snake_case.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_to_snake_case", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_table_observed_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_table_observed_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor flecs_table_observed_count$descriptor() {
        return flecs_table_observed_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle flecs_table_observed_count$handle() {
        return flecs_table_observed_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment flecs_table_observed_count$address() {
        return flecs_table_observed_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_table_observed_count(const ecs_table_t *table)
     * }
     */
    public static int flecs_table_observed_count(MemorySegment table) {
        var mh$ = flecs_table_observed_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_table_observed_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_dump_backtrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_dump_backtrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static FunctionDescriptor flecs_dump_backtrace$descriptor() {
        return flecs_dump_backtrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static MethodHandle flecs_dump_backtrace$handle() {
        return flecs_dump_backtrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static MemorySegment flecs_dump_backtrace$address() {
        return flecs_dump_backtrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_dump_backtrace(void *stream)
     * }
     */
    public static void flecs_dump_backtrace(MemorySegment stream) {
        var mh$ = flecs_dump_backtrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_dump_backtrace", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_suspend_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_suspend_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static FunctionDescriptor flecs_suspend_readonly$descriptor() {
        return flecs_suspend_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MethodHandle flecs_suspend_readonly$handle() {
        return flecs_suspend_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_suspend_readonly$address() {
        return flecs_suspend_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *flecs_suspend_readonly(const ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_suspend_readonly(MemorySegment world, MemorySegment state) {
        var mh$ = flecs_suspend_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_suspend_readonly", world, state);
            }
            return (MemorySegment)mh$.invokeExact(world, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_resume_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_resume_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static FunctionDescriptor flecs_resume_readonly$descriptor() {
        return flecs_resume_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MethodHandle flecs_resume_readonly$handle() {
        return flecs_resume_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static MemorySegment flecs_resume_readonly$address() {
        return flecs_resume_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_resume_readonly(ecs_world_t *world, ecs_suspend_readonly_state_t *state)
     * }
     */
    public static void flecs_resume_readonly(MemorySegment world, MemorySegment state) {
        var mh$ = flecs_resume_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_resume_readonly", world, state);
            }
            mh$.invokeExact(world, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_claim_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_poly_claim_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_claim_$descriptor() {
        return flecs_poly_claim_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_claim_$handle() {
        return flecs_poly_claim_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_claim_$address() {
        return flecs_poly_claim_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_claim_(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_claim_(MemorySegment poly) {
        var mh$ = flecs_poly_claim_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_claim_", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_release_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_poly_release_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_release_$descriptor() {
        return flecs_poly_release_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_release_$handle() {
        return flecs_poly_release_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_release_$address() {
        return flecs_poly_release_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_release_(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_release_(MemorySegment poly) {
        var mh$ = flecs_poly_release_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_release_", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_refcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_poly_refcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor flecs_poly_refcount$descriptor() {
        return flecs_poly_refcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static MethodHandle flecs_poly_refcount$handle() {
        return flecs_poly_refcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static MemorySegment flecs_poly_refcount$address() {
        return flecs_poly_refcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t flecs_poly_refcount(ecs_poly_t *poly)
     * }
     */
    public static int flecs_poly_refcount(MemorySegment poly) {
        var mh$ = flecs_poly_refcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_refcount", poly);
            }
            return (int)mh$.invokeExact(poly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_init_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_init_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_init_$descriptor() {
        return flecs_hashmap_init_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static MethodHandle flecs_hashmap_init_$handle() {
        return flecs_hashmap_init_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static MemorySegment flecs_hashmap_init_$address() {
        return flecs_hashmap_init_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_init_(ecs_hashmap_t *hm, ecs_size_t key_size, ecs_size_t value_size, ecs_hash_value_action_t hash, ecs_compare_action_t compare, ecs_allocator_t *allocator)
     * }
     */
    public static void flecs_hashmap_init_(MemorySegment hm, int key_size, int value_size, MemorySegment hash, MemorySegment compare, MemorySegment allocator) {
        var mh$ = flecs_hashmap_init_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_init_", hm, key_size, value_size, hash, compare, allocator);
            }
            mh$.invokeExact(hm, key_size, value_size, hash, compare, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_fini$descriptor() {
        return flecs_hashmap_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static MethodHandle flecs_hashmap_fini$handle() {
        return flecs_hashmap_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_fini$address() {
        return flecs_hashmap_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_fini(ecs_hashmap_t *map)
     * }
     */
    public static void flecs_hashmap_fini(MemorySegment map) {
        var mh$ = flecs_hashmap_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_fini", map);
            }
            mh$.invokeExact(map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_get_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_get_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_get_$descriptor() {
        return flecs_hashmap_get_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_get_$handle() {
        return flecs_hashmap_get_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_get_$address() {
        return flecs_hashmap_get_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_hashmap_get_(const ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_get_(MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_get_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_get_", map, key_size, key, value_size);
            }
            return (MemorySegment)mh$.invokeExact(map, key_size, key, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_ensure_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_hashmap_result_t.layout(),
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_ensure_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_ensure_$descriptor() {
        return flecs_hashmap_ensure_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_ensure_$handle() {
        return flecs_hashmap_ensure_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_ensure_$address() {
        return flecs_hashmap_ensure_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * flecs_hashmap_result_t flecs_hashmap_ensure_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_ensure_(SegmentAllocator allocator, MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_ensure_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_ensure_", allocator, map, key_size, key, value_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map, key_size, key, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_set_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_set_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_set_$descriptor() {
        return flecs_hashmap_set_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static MethodHandle flecs_hashmap_set_$handle() {
        return flecs_hashmap_set_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static MemorySegment flecs_hashmap_set_$address() {
        return flecs_hashmap_set_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_set_(ecs_hashmap_t *map, ecs_size_t key_size, void *key, ecs_size_t value_size, const void *value)
     * }
     */
    public static void flecs_hashmap_set_(MemorySegment map, int key_size, MemorySegment key, int value_size, MemorySegment value) {
        var mh$ = flecs_hashmap_set_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_set_", map, key_size, key, value_size, value);
            }
            mh$.invokeExact(map, key_size, key, value_size, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_remove_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_remove_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_remove_$descriptor() {
        return flecs_hashmap_remove_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_remove_$handle() {
        return flecs_hashmap_remove_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_remove_$address() {
        return flecs_hashmap_remove_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_remove_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size)
     * }
     */
    public static void flecs_hashmap_remove_(MemorySegment map, int key_size, MemorySegment key, int value_size) {
        var mh$ = flecs_hashmap_remove_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_remove_", map, key_size, key, value_size);
            }
            mh$.invokeExact(map, key_size, key, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_remove_w_hash_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_remove_w_hash_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_remove_w_hash_$descriptor() {
        return flecs_hashmap_remove_w_hash_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static MethodHandle flecs_hashmap_remove_w_hash_$handle() {
        return flecs_hashmap_remove_w_hash_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_remove_w_hash_$address() {
        return flecs_hashmap_remove_w_hash_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_remove_w_hash_(ecs_hashmap_t *map, ecs_size_t key_size, const void *key, ecs_size_t value_size, uint64_t hash)
     * }
     */
    public static void flecs_hashmap_remove_w_hash_(MemorySegment map, int key_size, MemorySegment key, int value_size, long hash) {
        var mh$ = flecs_hashmap_remove_w_hash_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_remove_w_hash_", map, key_size, key, value_size, hash);
            }
            mh$.invokeExact(map, key_size, key, value_size, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_get_bucket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_get_bucket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_get_bucket$descriptor() {
        return flecs_hashmap_get_bucket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MethodHandle flecs_hashmap_get_bucket$handle() {
        return flecs_hashmap_get_bucket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_get_bucket$address() {
        return flecs_hashmap_get_bucket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_hm_bucket_t *flecs_hashmap_get_bucket(const ecs_hashmap_t *map, uint64_t hash)
     * }
     */
    public static MemorySegment flecs_hashmap_get_bucket(MemorySegment map, long hash) {
        var mh$ = flecs_hashmap_get_bucket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_get_bucket", map, hash);
            }
            return (MemorySegment)mh$.invokeExact(map, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hm_bucket_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hm_bucket_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static FunctionDescriptor flecs_hm_bucket_remove$descriptor() {
        return flecs_hm_bucket_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static MethodHandle flecs_hm_bucket_remove$handle() {
        return flecs_hm_bucket_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static MemorySegment flecs_hm_bucket_remove$address() {
        return flecs_hm_bucket_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hm_bucket_remove(ecs_hashmap_t *map, ecs_hm_bucket_t *bucket, uint64_t hash, int32_t index)
     * }
     */
    public static void flecs_hm_bucket_remove(MemorySegment map, MemorySegment bucket, long hash, int index) {
        var mh$ = flecs_hm_bucket_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hm_bucket_remove", map, bucket, hash, index);
            }
            mh$.invokeExact(map, bucket, hash, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_copy$descriptor() {
        return flecs_hashmap_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static MethodHandle flecs_hashmap_copy$handle() {
        return flecs_hashmap_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static MemorySegment flecs_hashmap_copy$address() {
        return flecs_hashmap_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flecs_hashmap_copy(ecs_hashmap_t *dst, const ecs_hashmap_t *src)
     * }
     */
    public static void flecs_hashmap_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = flecs_hashmap_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs_hashmap_iter_t.layout(),
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_iter$descriptor() {
        return flecs_hashmap_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MethodHandle flecs_hashmap_iter$handle() {
        return flecs_hashmap_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_iter$address() {
        return flecs_hashmap_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * flecs_hashmap_iter_t flecs_hashmap_iter(ecs_hashmap_t *map)
     * }
     */
    public static MemorySegment flecs_hashmap_iter(SegmentAllocator allocator, MemorySegment map) {
        var mh$ = flecs_hashmap_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_iter", allocator, map);
            }
            return (MemorySegment)mh$.invokeExact(allocator, map);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_hashmap_next_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_hashmap_next_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static FunctionDescriptor flecs_hashmap_next_$descriptor() {
        return flecs_hashmap_next_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MethodHandle flecs_hashmap_next_$handle() {
        return flecs_hashmap_next_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_next_$address() {
        return flecs_hashmap_next_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *flecs_hashmap_next_(flecs_hashmap_iter_t *it, ecs_size_t key_size, void *key_out, ecs_size_t value_size)
     * }
     */
    public static MemorySegment flecs_hashmap_next_(MemorySegment it, int key_size, MemorySegment key_out, int value_size) {
        var mh$ = flecs_hashmap_next_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_hashmap_next_", it, key_size, key_out, value_size);
            }
            return (MemorySegment)mh$.invokeExact(it, key_size, key_out, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ECS_PAIR$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ECS_PAIR").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static OfLong ECS_PAIR$layout() {
        return ECS_PAIR$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static MemorySegment ECS_PAIR$segment() {
        return ECS_PAIR$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static long ECS_PAIR() {
        return ECS_PAIR$constants.SEGMENT.get(ECS_PAIR$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_PAIR
     * }
     */
    public static void ECS_PAIR(long varValue) {
        ECS_PAIR$constants.SEGMENT.set(ECS_PAIR$constants.LAYOUT, 0L, varValue);
    }

    private static class ECS_AUTO_OVERRIDE$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ECS_AUTO_OVERRIDE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static OfLong ECS_AUTO_OVERRIDE$layout() {
        return ECS_AUTO_OVERRIDE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static MemorySegment ECS_AUTO_OVERRIDE$segment() {
        return ECS_AUTO_OVERRIDE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static long ECS_AUTO_OVERRIDE() {
        return ECS_AUTO_OVERRIDE$constants.SEGMENT.get(ECS_AUTO_OVERRIDE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_AUTO_OVERRIDE
     * }
     */
    public static void ECS_AUTO_OVERRIDE(long varValue) {
        ECS_AUTO_OVERRIDE$constants.SEGMENT.set(ECS_AUTO_OVERRIDE$constants.LAYOUT, 0L, varValue);
    }

    private static class ECS_TOGGLE$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ECS_TOGGLE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static OfLong ECS_TOGGLE$layout() {
        return ECS_TOGGLE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static MemorySegment ECS_TOGGLE$segment() {
        return ECS_TOGGLE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static long ECS_TOGGLE() {
        return ECS_TOGGLE$constants.SEGMENT.get(ECS_TOGGLE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_id_t ECS_TOGGLE
     * }
     */
    public static void ECS_TOGGLE(long varValue) {
        ECS_TOGGLE$constants.SEGMENT.set(ECS_TOGGLE$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsComponentID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsComponentID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static OfLong FLECS_IDEcsComponentID_$layout() {
        return FLECS_IDEcsComponentID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static MemorySegment FLECS_IDEcsComponentID_$segment() {
        return FLECS_IDEcsComponentID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static long FLECS_IDEcsComponentID_() {
        return FLECS_IDEcsComponentID_$constants.SEGMENT.get(FLECS_IDEcsComponentID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsComponentID_
     * }
     */
    public static void FLECS_IDEcsComponentID_(long varValue) {
        FLECS_IDEcsComponentID_$constants.SEGMENT.set(FLECS_IDEcsComponentID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsIdentifierID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsIdentifierID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static OfLong FLECS_IDEcsIdentifierID_$layout() {
        return FLECS_IDEcsIdentifierID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static MemorySegment FLECS_IDEcsIdentifierID_$segment() {
        return FLECS_IDEcsIdentifierID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static long FLECS_IDEcsIdentifierID_() {
        return FLECS_IDEcsIdentifierID_$constants.SEGMENT.get(FLECS_IDEcsIdentifierID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsIdentifierID_
     * }
     */
    public static void FLECS_IDEcsIdentifierID_(long varValue) {
        FLECS_IDEcsIdentifierID_$constants.SEGMENT.set(FLECS_IDEcsIdentifierID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPolyID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsPolyID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static OfLong FLECS_IDEcsPolyID_$layout() {
        return FLECS_IDEcsPolyID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPolyID_$segment() {
        return FLECS_IDEcsPolyID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static long FLECS_IDEcsPolyID_() {
        return FLECS_IDEcsPolyID_$constants.SEGMENT.get(FLECS_IDEcsPolyID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPolyID_
     * }
     */
    public static void FLECS_IDEcsPolyID_(long varValue) {
        FLECS_IDEcsPolyID_$constants.SEGMENT.set(FLECS_IDEcsPolyID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsDefaultChildComponentID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsDefaultChildComponentID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static OfLong FLECS_IDEcsDefaultChildComponentID_$layout() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static MemorySegment FLECS_IDEcsDefaultChildComponentID_$segment() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static long FLECS_IDEcsDefaultChildComponentID_() {
        return FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT.get(FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDefaultChildComponentID_
     * }
     */
    public static void FLECS_IDEcsDefaultChildComponentID_(long varValue) {
        FLECS_IDEcsDefaultChildComponentID_$constants.SEGMENT.set(FLECS_IDEcsDefaultChildComponentID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsQuery$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsQuery").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static OfLong EcsQuery$layout() {
        return EcsQuery$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static MemorySegment EcsQuery$segment() {
        return EcsQuery$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static long EcsQuery() {
        return EcsQuery$constants.SEGMENT.get(EcsQuery$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuery
     * }
     */
    public static void EcsQuery(long varValue) {
        EcsQuery$constants.SEGMENT.set(EcsQuery$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsObserver$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsObserver").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static OfLong EcsObserver$layout() {
        return EcsObserver$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static MemorySegment EcsObserver$segment() {
        return EcsObserver$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static long EcsObserver() {
        return EcsObserver$constants.SEGMENT.get(EcsObserver$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsObserver
     * }
     */
    public static void EcsObserver(long varValue) {
        EcsObserver$constants.SEGMENT.set(EcsObserver$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSystem$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSystem").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static OfLong EcsSystem$layout() {
        return EcsSystem$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static MemorySegment EcsSystem$segment() {
        return EcsSystem$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static long EcsSystem() {
        return EcsSystem$constants.SEGMENT.get(EcsSystem$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSystem
     * }
     */
    public static void EcsSystem(long varValue) {
        EcsSystem$constants.SEGMENT.set(EcsSystem$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsTickSourceID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsTickSourceID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static OfLong FLECS_IDEcsTickSourceID_$layout() {
        return FLECS_IDEcsTickSourceID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTickSourceID_$segment() {
        return FLECS_IDEcsTickSourceID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static long FLECS_IDEcsTickSourceID_() {
        return FLECS_IDEcsTickSourceID_$constants.SEGMENT.get(FLECS_IDEcsTickSourceID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTickSourceID_
     * }
     */
    public static void FLECS_IDEcsTickSourceID_(long varValue) {
        FLECS_IDEcsTickSourceID_$constants.SEGMENT.set(FLECS_IDEcsTickSourceID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPipelineQueryID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsPipelineQueryID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static OfLong FLECS_IDEcsPipelineQueryID_$layout() {
        return FLECS_IDEcsPipelineQueryID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPipelineQueryID_$segment() {
        return FLECS_IDEcsPipelineQueryID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static long FLECS_IDEcsPipelineQueryID_() {
        return FLECS_IDEcsPipelineQueryID_$constants.SEGMENT.get(FLECS_IDEcsPipelineQueryID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineQueryID_
     * }
     */
    public static void FLECS_IDEcsPipelineQueryID_(long varValue) {
        FLECS_IDEcsPipelineQueryID_$constants.SEGMENT.set(FLECS_IDEcsPipelineQueryID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsTimerID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsTimerID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static OfLong FLECS_IDEcsTimerID_$layout() {
        return FLECS_IDEcsTimerID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTimerID_$segment() {
        return FLECS_IDEcsTimerID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static long FLECS_IDEcsTimerID_() {
        return FLECS_IDEcsTimerID_$constants.SEGMENT.get(FLECS_IDEcsTimerID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTimerID_
     * }
     */
    public static void FLECS_IDEcsTimerID_(long varValue) {
        FLECS_IDEcsTimerID_$constants.SEGMENT.set(FLECS_IDEcsTimerID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsRateFilterID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsRateFilterID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static OfLong FLECS_IDEcsRateFilterID_$layout() {
        return FLECS_IDEcsRateFilterID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static MemorySegment FLECS_IDEcsRateFilterID_$segment() {
        return FLECS_IDEcsRateFilterID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static long FLECS_IDEcsRateFilterID_() {
        return FLECS_IDEcsRateFilterID_$constants.SEGMENT.get(FLECS_IDEcsRateFilterID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRateFilterID_
     * }
     */
    public static void FLECS_IDEcsRateFilterID_(long varValue) {
        FLECS_IDEcsRateFilterID_$constants.SEGMENT.set(FLECS_IDEcsRateFilterID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFlecs$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFlecs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static OfLong EcsFlecs$layout() {
        return EcsFlecs$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static MemorySegment EcsFlecs$segment() {
        return EcsFlecs$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static long EcsFlecs() {
        return EcsFlecs$constants.SEGMENT.get(EcsFlecs$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecs
     * }
     */
    public static void EcsFlecs(long varValue) {
        EcsFlecs$constants.SEGMENT.set(EcsFlecs$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFlecsCore$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFlecsCore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static OfLong EcsFlecsCore$layout() {
        return EcsFlecsCore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static MemorySegment EcsFlecsCore$segment() {
        return EcsFlecsCore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static long EcsFlecsCore() {
        return EcsFlecsCore$constants.SEGMENT.get(EcsFlecsCore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFlecsCore
     * }
     */
    public static void EcsFlecsCore(long varValue) {
        EcsFlecsCore$constants.SEGMENT.set(EcsFlecsCore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWorld$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsWorld").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static OfLong EcsWorld$layout() {
        return EcsWorld$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static MemorySegment EcsWorld$segment() {
        return EcsWorld$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static long EcsWorld() {
        return EcsWorld$constants.SEGMENT.get(EcsWorld$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWorld
     * }
     */
    public static void EcsWorld(long varValue) {
        EcsWorld$constants.SEGMENT.set(EcsWorld$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWildcard$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsWildcard").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static OfLong EcsWildcard$layout() {
        return EcsWildcard$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static MemorySegment EcsWildcard$segment() {
        return EcsWildcard$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static long EcsWildcard() {
        return EcsWildcard$constants.SEGMENT.get(EcsWildcard$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWildcard
     * }
     */
    public static void EcsWildcard(long varValue) {
        EcsWildcard$constants.SEGMENT.set(EcsWildcard$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAny$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAny").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static OfLong EcsAny$layout() {
        return EcsAny$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static MemorySegment EcsAny$segment() {
        return EcsAny$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static long EcsAny() {
        return EcsAny$constants.SEGMENT.get(EcsAny$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAny
     * }
     */
    public static void EcsAny(long varValue) {
        EcsAny$constants.SEGMENT.set(EcsAny$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsThis$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsThis").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static OfLong EcsThis$layout() {
        return EcsThis$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static MemorySegment EcsThis$segment() {
        return EcsThis$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static long EcsThis() {
        return EcsThis$constants.SEGMENT.get(EcsThis$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsThis
     * }
     */
    public static void EcsThis(long varValue) {
        EcsThis$constants.SEGMENT.set(EcsThis$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsVariable$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsVariable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static OfLong EcsVariable$layout() {
        return EcsVariable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static MemorySegment EcsVariable$segment() {
        return EcsVariable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static long EcsVariable() {
        return EcsVariable$constants.SEGMENT.get(EcsVariable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsVariable
     * }
     */
    public static void EcsVariable(long varValue) {
        EcsVariable$constants.SEGMENT.set(EcsVariable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTransitive$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTransitive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static OfLong EcsTransitive$layout() {
        return EcsTransitive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static MemorySegment EcsTransitive$segment() {
        return EcsTransitive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static long EcsTransitive() {
        return EcsTransitive$constants.SEGMENT.get(EcsTransitive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTransitive
     * }
     */
    public static void EcsTransitive(long varValue) {
        EcsTransitive$constants.SEGMENT.set(EcsTransitive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsReflexive$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsReflexive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static OfLong EcsReflexive$layout() {
        return EcsReflexive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static MemorySegment EcsReflexive$segment() {
        return EcsReflexive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static long EcsReflexive() {
        return EcsReflexive$constants.SEGMENT.get(EcsReflexive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsReflexive
     * }
     */
    public static void EcsReflexive(long varValue) {
        EcsReflexive$constants.SEGMENT.set(EcsReflexive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFinal$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFinal").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static OfLong EcsFinal$layout() {
        return EcsFinal$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static MemorySegment EcsFinal$segment() {
        return EcsFinal$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static long EcsFinal() {
        return EcsFinal$constants.SEGMENT.get(EcsFinal$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsFinal
     * }
     */
    public static void EcsFinal(long varValue) {
        EcsFinal$constants.SEGMENT.set(EcsFinal$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnInstantiate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnInstantiate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static OfLong EcsOnInstantiate$layout() {
        return EcsOnInstantiate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static MemorySegment EcsOnInstantiate$segment() {
        return EcsOnInstantiate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static long EcsOnInstantiate() {
        return EcsOnInstantiate$constants.SEGMENT.get(EcsOnInstantiate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnInstantiate
     * }
     */
    public static void EcsOnInstantiate(long varValue) {
        EcsOnInstantiate$constants.SEGMENT.set(EcsOnInstantiate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOverride$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOverride").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static OfLong EcsOverride$layout() {
        return EcsOverride$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static MemorySegment EcsOverride$segment() {
        return EcsOverride$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static long EcsOverride() {
        return EcsOverride$constants.SEGMENT.get(EcsOverride$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOverride
     * }
     */
    public static void EcsOverride(long varValue) {
        EcsOverride$constants.SEGMENT.set(EcsOverride$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsInherit$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsInherit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static OfLong EcsInherit$layout() {
        return EcsInherit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static MemorySegment EcsInherit$segment() {
        return EcsInherit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static long EcsInherit() {
        return EcsInherit$constants.SEGMENT.get(EcsInherit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsInherit
     * }
     */
    public static void EcsInherit(long varValue) {
        EcsInherit$constants.SEGMENT.set(EcsInherit$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDontInherit$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDontInherit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static OfLong EcsDontInherit$layout() {
        return EcsDontInherit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static MemorySegment EcsDontInherit$segment() {
        return EcsDontInherit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static long EcsDontInherit() {
        return EcsDontInherit$constants.SEGMENT.get(EcsDontInherit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDontInherit
     * }
     */
    public static void EcsDontInherit(long varValue) {
        EcsDontInherit$constants.SEGMENT.set(EcsDontInherit$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSymmetric$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSymmetric").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static OfLong EcsSymmetric$layout() {
        return EcsSymmetric$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static MemorySegment EcsSymmetric$segment() {
        return EcsSymmetric$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static long EcsSymmetric() {
        return EcsSymmetric$constants.SEGMENT.get(EcsSymmetric$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymmetric
     * }
     */
    public static void EcsSymmetric(long varValue) {
        EcsSymmetric$constants.SEGMENT.set(EcsSymmetric$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsExclusive$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsExclusive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static OfLong EcsExclusive$layout() {
        return EcsExclusive$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static MemorySegment EcsExclusive$segment() {
        return EcsExclusive$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static long EcsExclusive() {
        return EcsExclusive$constants.SEGMENT.get(EcsExclusive$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsExclusive
     * }
     */
    public static void EcsExclusive(long varValue) {
        EcsExclusive$constants.SEGMENT.set(EcsExclusive$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAcyclic$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAcyclic").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static OfLong EcsAcyclic$layout() {
        return EcsAcyclic$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static MemorySegment EcsAcyclic$segment() {
        return EcsAcyclic$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static long EcsAcyclic() {
        return EcsAcyclic$constants.SEGMENT.get(EcsAcyclic$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAcyclic
     * }
     */
    public static void EcsAcyclic(long varValue) {
        EcsAcyclic$constants.SEGMENT.set(EcsAcyclic$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTraversable$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTraversable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static OfLong EcsTraversable$layout() {
        return EcsTraversable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static MemorySegment EcsTraversable$segment() {
        return EcsTraversable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static long EcsTraversable() {
        return EcsTraversable$constants.SEGMENT.get(EcsTraversable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTraversable
     * }
     */
    public static void EcsTraversable(long varValue) {
        EcsTraversable$constants.SEGMENT.set(EcsTraversable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsWith$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsWith").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static OfLong EcsWith$layout() {
        return EcsWith$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static MemorySegment EcsWith$segment() {
        return EcsWith$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static long EcsWith() {
        return EcsWith$constants.SEGMENT.get(EcsWith$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsWith
     * }
     */
    public static void EcsWith(long varValue) {
        EcsWith$constants.SEGMENT.set(EcsWith$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOneOf$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOneOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static OfLong EcsOneOf$layout() {
        return EcsOneOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static MemorySegment EcsOneOf$segment() {
        return EcsOneOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static long EcsOneOf() {
        return EcsOneOf$constants.SEGMENT.get(EcsOneOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOneOf
     * }
     */
    public static void EcsOneOf(long varValue) {
        EcsOneOf$constants.SEGMENT.set(EcsOneOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCanToggle$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCanToggle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static OfLong EcsCanToggle$layout() {
        return EcsCanToggle$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static MemorySegment EcsCanToggle$segment() {
        return EcsCanToggle$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static long EcsCanToggle() {
        return EcsCanToggle$constants.SEGMENT.get(EcsCanToggle$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsCanToggle
     * }
     */
    public static void EcsCanToggle(long varValue) {
        EcsCanToggle$constants.SEGMENT.set(EcsCanToggle$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTrait$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTrait").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static OfLong EcsTrait$layout() {
        return EcsTrait$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static MemorySegment EcsTrait$segment() {
        return EcsTrait$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static long EcsTrait() {
        return EcsTrait$constants.SEGMENT.get(EcsTrait$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTrait
     * }
     */
    public static void EcsTrait(long varValue) {
        EcsTrait$constants.SEGMENT.set(EcsTrait$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsRelationship$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsRelationship").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static OfLong EcsRelationship$layout() {
        return EcsRelationship$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static MemorySegment EcsRelationship$segment() {
        return EcsRelationship$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static long EcsRelationship() {
        return EcsRelationship$constants.SEGMENT.get(EcsRelationship$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRelationship
     * }
     */
    public static void EcsRelationship(long varValue) {
        EcsRelationship$constants.SEGMENT.set(EcsRelationship$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTarget$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTarget").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static OfLong EcsTarget$layout() {
        return EcsTarget$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static MemorySegment EcsTarget$segment() {
        return EcsTarget$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static long EcsTarget() {
        return EcsTarget$constants.SEGMENT.get(EcsTarget$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsTarget
     * }
     */
    public static void EcsTarget(long varValue) {
        EcsTarget$constants.SEGMENT.set(EcsTarget$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPairIsTag$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPairIsTag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static OfLong EcsPairIsTag$layout() {
        return EcsPairIsTag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static MemorySegment EcsPairIsTag$segment() {
        return EcsPairIsTag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static long EcsPairIsTag() {
        return EcsPairIsTag$constants.SEGMENT.get(EcsPairIsTag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPairIsTag
     * }
     */
    public static void EcsPairIsTag(long varValue) {
        EcsPairIsTag$constants.SEGMENT.set(EcsPairIsTag$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsName$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsName").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static OfLong EcsName$layout() {
        return EcsName$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static MemorySegment EcsName$segment() {
        return EcsName$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static long EcsName() {
        return EcsName$constants.SEGMENT.get(EcsName$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsName
     * }
     */
    public static void EcsName(long varValue) {
        EcsName$constants.SEGMENT.set(EcsName$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSymbol$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSymbol").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static OfLong EcsSymbol$layout() {
        return EcsSymbol$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static MemorySegment EcsSymbol$segment() {
        return EcsSymbol$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static long EcsSymbol() {
        return EcsSymbol$constants.SEGMENT.get(EcsSymbol$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSymbol
     * }
     */
    public static void EcsSymbol(long varValue) {
        EcsSymbol$constants.SEGMENT.set(EcsSymbol$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlias$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAlias").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static OfLong EcsAlias$layout() {
        return EcsAlias$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static MemorySegment EcsAlias$segment() {
        return EcsAlias$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static long EcsAlias() {
        return EcsAlias$constants.SEGMENT.get(EcsAlias$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsAlias
     * }
     */
    public static void EcsAlias(long varValue) {
        EcsAlias$constants.SEGMENT.set(EcsAlias$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsChildOf$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsChildOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static OfLong EcsChildOf$layout() {
        return EcsChildOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static MemorySegment EcsChildOf$segment() {
        return EcsChildOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static long EcsChildOf() {
        return EcsChildOf$constants.SEGMENT.get(EcsChildOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsChildOf
     * }
     */
    public static void EcsChildOf(long varValue) {
        EcsChildOf$constants.SEGMENT.set(EcsChildOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsIsA$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsIsA").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static OfLong EcsIsA$layout() {
        return EcsIsA$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static MemorySegment EcsIsA$segment() {
        return EcsIsA$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static long EcsIsA() {
        return EcsIsA$constants.SEGMENT.get(EcsIsA$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsIsA
     * }
     */
    public static void EcsIsA(long varValue) {
        EcsIsA$constants.SEGMENT.set(EcsIsA$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDependsOn$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDependsOn").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static OfLong EcsDependsOn$layout() {
        return EcsDependsOn$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static MemorySegment EcsDependsOn$segment() {
        return EcsDependsOn$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static long EcsDependsOn() {
        return EcsDependsOn$constants.SEGMENT.get(EcsDependsOn$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDependsOn
     * }
     */
    public static void EcsDependsOn(long varValue) {
        EcsDependsOn$constants.SEGMENT.set(EcsDependsOn$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSlotOf$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSlotOf").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static OfLong EcsSlotOf$layout() {
        return EcsSlotOf$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static MemorySegment EcsSlotOf$segment() {
        return EcsSlotOf$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static long EcsSlotOf() {
        return EcsSlotOf$constants.SEGMENT.get(EcsSlotOf$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSlotOf
     * }
     */
    public static void EcsSlotOf(long varValue) {
        EcsSlotOf$constants.SEGMENT.set(EcsSlotOf$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsModule$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsModule").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static OfLong EcsModule$layout() {
        return EcsModule$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static MemorySegment EcsModule$segment() {
        return EcsModule$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static long EcsModule() {
        return EcsModule$constants.SEGMENT.get(EcsModule$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsModule
     * }
     */
    public static void EcsModule(long varValue) {
        EcsModule$constants.SEGMENT.set(EcsModule$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPrivate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPrivate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static OfLong EcsPrivate$layout() {
        return EcsPrivate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static MemorySegment EcsPrivate$segment() {
        return EcsPrivate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static long EcsPrivate() {
        return EcsPrivate$constants.SEGMENT.get(EcsPrivate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrivate
     * }
     */
    public static void EcsPrivate(long varValue) {
        EcsPrivate$constants.SEGMENT.set(EcsPrivate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPrefab$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPrefab").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static OfLong EcsPrefab$layout() {
        return EcsPrefab$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static MemorySegment EcsPrefab$segment() {
        return EcsPrefab$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static long EcsPrefab() {
        return EcsPrefab$constants.SEGMENT.get(EcsPrefab$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPrefab
     * }
     */
    public static void EcsPrefab(long varValue) {
        EcsPrefab$constants.SEGMENT.set(EcsPrefab$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDisabled$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDisabled").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static OfLong EcsDisabled$layout() {
        return EcsDisabled$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static MemorySegment EcsDisabled$segment() {
        return EcsDisabled$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static long EcsDisabled() {
        return EcsDisabled$constants.SEGMENT.get(EcsDisabled$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDisabled
     * }
     */
    public static void EcsDisabled(long varValue) {
        EcsDisabled$constants.SEGMENT.set(EcsDisabled$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNotQueryable$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsNotQueryable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static OfLong EcsNotQueryable$layout() {
        return EcsNotQueryable$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static MemorySegment EcsNotQueryable$segment() {
        return EcsNotQueryable$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static long EcsNotQueryable() {
        return EcsNotQueryable$constants.SEGMENT.get(EcsNotQueryable$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsNotQueryable
     * }
     */
    public static void EcsNotQueryable(long varValue) {
        EcsNotQueryable$constants.SEGMENT.set(EcsNotQueryable$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnAdd$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnAdd").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static OfLong EcsOnAdd$layout() {
        return EcsOnAdd$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static MemorySegment EcsOnAdd$segment() {
        return EcsOnAdd$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static long EcsOnAdd() {
        return EcsOnAdd$constants.SEGMENT.get(EcsOnAdd$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnAdd
     * }
     */
    public static void EcsOnAdd(long varValue) {
        EcsOnAdd$constants.SEGMENT.set(EcsOnAdd$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnRemove$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnRemove").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static OfLong EcsOnRemove$layout() {
        return EcsOnRemove$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static MemorySegment EcsOnRemove$segment() {
        return EcsOnRemove$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static long EcsOnRemove() {
        return EcsOnRemove$constants.SEGMENT.get(EcsOnRemove$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnRemove
     * }
     */
    public static void EcsOnRemove(long varValue) {
        EcsOnRemove$constants.SEGMENT.set(EcsOnRemove$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnSet$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnSet").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static OfLong EcsOnSet$layout() {
        return EcsOnSet$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static MemorySegment EcsOnSet$segment() {
        return EcsOnSet$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static long EcsOnSet() {
        return EcsOnSet$constants.SEGMENT.get(EcsOnSet$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnSet
     * }
     */
    public static void EcsOnSet(long varValue) {
        EcsOnSet$constants.SEGMENT.set(EcsOnSet$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMonitor$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMonitor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static OfLong EcsMonitor$layout() {
        return EcsMonitor$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static MemorySegment EcsMonitor$segment() {
        return EcsMonitor$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static long EcsMonitor() {
        return EcsMonitor$constants.SEGMENT.get(EcsMonitor$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsMonitor
     * }
     */
    public static void EcsMonitor(long varValue) {
        EcsMonitor$constants.SEGMENT.set(EcsMonitor$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableCreate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnTableCreate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static OfLong EcsOnTableCreate$layout() {
        return EcsOnTableCreate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static MemorySegment EcsOnTableCreate$segment() {
        return EcsOnTableCreate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static long EcsOnTableCreate() {
        return EcsOnTableCreate$constants.SEGMENT.get(EcsOnTableCreate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableCreate
     * }
     */
    public static void EcsOnTableCreate(long varValue) {
        EcsOnTableCreate$constants.SEGMENT.set(EcsOnTableCreate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableDelete$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnTableDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static OfLong EcsOnTableDelete$layout() {
        return EcsOnTableDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static MemorySegment EcsOnTableDelete$segment() {
        return EcsOnTableDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static long EcsOnTableDelete() {
        return EcsOnTableDelete$constants.SEGMENT.get(EcsOnTableDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableDelete
     * }
     */
    public static void EcsOnTableDelete(long varValue) {
        EcsOnTableDelete$constants.SEGMENT.set(EcsOnTableDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableEmpty$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnTableEmpty").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableEmpty
     * }
     */
    public static OfLong EcsOnTableEmpty$layout() {
        return EcsOnTableEmpty$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableEmpty
     * }
     */
    public static MemorySegment EcsOnTableEmpty$segment() {
        return EcsOnTableEmpty$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableEmpty
     * }
     */
    public static long EcsOnTableEmpty() {
        return EcsOnTableEmpty$constants.SEGMENT.get(EcsOnTableEmpty$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableEmpty
     * }
     */
    public static void EcsOnTableEmpty(long varValue) {
        EcsOnTableEmpty$constants.SEGMENT.set(EcsOnTableEmpty$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnTableFill$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnTableFill").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableFill
     * }
     */
    public static OfLong EcsOnTableFill$layout() {
        return EcsOnTableFill$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableFill
     * }
     */
    public static MemorySegment EcsOnTableFill$segment() {
        return EcsOnTableFill$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableFill
     * }
     */
    public static long EcsOnTableFill() {
        return EcsOnTableFill$constants.SEGMENT.get(EcsOnTableFill$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnTableFill
     * }
     */
    public static void EcsOnTableFill(long varValue) {
        EcsOnTableFill$constants.SEGMENT.set(EcsOnTableFill$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnDelete$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static OfLong EcsOnDelete$layout() {
        return EcsOnDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static MemorySegment EcsOnDelete$segment() {
        return EcsOnDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static long EcsOnDelete() {
        return EcsOnDelete$constants.SEGMENT.get(EcsOnDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDelete
     * }
     */
    public static void EcsOnDelete(long varValue) {
        EcsOnDelete$constants.SEGMENT.set(EcsOnDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnDeleteTarget$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnDeleteTarget").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static OfLong EcsOnDeleteTarget$layout() {
        return EcsOnDeleteTarget$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static MemorySegment EcsOnDeleteTarget$segment() {
        return EcsOnDeleteTarget$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static long EcsOnDeleteTarget() {
        return EcsOnDeleteTarget$constants.SEGMENT.get(EcsOnDeleteTarget$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnDeleteTarget
     * }
     */
    public static void EcsOnDeleteTarget(long varValue) {
        EcsOnDeleteTarget$constants.SEGMENT.set(EcsOnDeleteTarget$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsRemove$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsRemove").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static OfLong EcsRemove$layout() {
        return EcsRemove$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static MemorySegment EcsRemove$segment() {
        return EcsRemove$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static long EcsRemove() {
        return EcsRemove$constants.SEGMENT.get(EcsRemove$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsRemove
     * }
     */
    public static void EcsRemove(long varValue) {
        EcsRemove$constants.SEGMENT.set(EcsRemove$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDelete$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDelete").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static OfLong EcsDelete$layout() {
        return EcsDelete$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static MemorySegment EcsDelete$segment() {
        return EcsDelete$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static long EcsDelete() {
        return EcsDelete$constants.SEGMENT.get(EcsDelete$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDelete
     * }
     */
    public static void EcsDelete(long varValue) {
        EcsDelete$constants.SEGMENT.set(EcsDelete$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPanic$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPanic").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static OfLong EcsPanic$layout() {
        return EcsPanic$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static MemorySegment EcsPanic$segment() {
        return EcsPanic$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static long EcsPanic() {
        return EcsPanic$constants.SEGMENT.get(EcsPanic$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPanic
     * }
     */
    public static void EcsPanic(long varValue) {
        EcsPanic$constants.SEGMENT.set(EcsPanic$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSparse$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSparse").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static OfLong EcsSparse$layout() {
        return EcsSparse$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static MemorySegment EcsSparse$segment() {
        return EcsSparse$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static long EcsSparse() {
        return EcsSparse$constants.SEGMENT.get(EcsSparse$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsSparse
     * }
     */
    public static void EcsSparse(long varValue) {
        EcsSparse$constants.SEGMENT.set(EcsSparse$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsUnion$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUnion").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsUnion
     * }
     */
    public static OfLong EcsUnion$layout() {
        return EcsUnion$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsUnion
     * }
     */
    public static MemorySegment EcsUnion$segment() {
        return EcsUnion$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsUnion
     * }
     */
    public static long EcsUnion() {
        return EcsUnion$constants.SEGMENT.get(EcsUnion$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsUnion
     * }
     */
    public static void EcsUnion(long varValue) {
        EcsUnion$constants.SEGMENT.set(EcsUnion$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredEq$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPredEq").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static OfLong EcsPredEq$layout() {
        return EcsPredEq$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static MemorySegment EcsPredEq$segment() {
        return EcsPredEq$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static long EcsPredEq() {
        return EcsPredEq$constants.SEGMENT.get(EcsPredEq$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredEq
     * }
     */
    public static void EcsPredEq(long varValue) {
        EcsPredEq$constants.SEGMENT.set(EcsPredEq$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredMatch$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPredMatch").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static OfLong EcsPredMatch$layout() {
        return EcsPredMatch$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static MemorySegment EcsPredMatch$segment() {
        return EcsPredMatch$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static long EcsPredMatch() {
        return EcsPredMatch$constants.SEGMENT.get(EcsPredMatch$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredMatch
     * }
     */
    public static void EcsPredMatch(long varValue) {
        EcsPredMatch$constants.SEGMENT.set(EcsPredMatch$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPredLookup$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPredLookup").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static OfLong EcsPredLookup$layout() {
        return EcsPredLookup$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static MemorySegment EcsPredLookup$segment() {
        return EcsPredLookup$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static long EcsPredLookup() {
        return EcsPredLookup$constants.SEGMENT.get(EcsPredLookup$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPredLookup
     * }
     */
    public static void EcsPredLookup(long varValue) {
        EcsPredLookup$constants.SEGMENT.set(EcsPredLookup$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsScopeOpen$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsScopeOpen").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static OfLong EcsScopeOpen$layout() {
        return EcsScopeOpen$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static MemorySegment EcsScopeOpen$segment() {
        return EcsScopeOpen$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static long EcsScopeOpen() {
        return EcsScopeOpen$constants.SEGMENT.get(EcsScopeOpen$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeOpen
     * }
     */
    public static void EcsScopeOpen(long varValue) {
        EcsScopeOpen$constants.SEGMENT.set(EcsScopeOpen$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsScopeClose$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsScopeClose").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static OfLong EcsScopeClose$layout() {
        return EcsScopeClose$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static MemorySegment EcsScopeClose$segment() {
        return EcsScopeClose$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static long EcsScopeClose() {
        return EcsScopeClose$constants.SEGMENT.get(EcsScopeClose$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsScopeClose
     * }
     */
    public static void EcsScopeClose(long varValue) {
        EcsScopeClose$constants.SEGMENT.set(EcsScopeClose$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsEmpty$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsEmpty").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static OfLong EcsEmpty$layout() {
        return EcsEmpty$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static MemorySegment EcsEmpty$segment() {
        return EcsEmpty$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static long EcsEmpty() {
        return EcsEmpty$constants.SEGMENT.get(EcsEmpty$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsEmpty
     * }
     */
    public static void EcsEmpty(long varValue) {
        EcsEmpty$constants.SEGMENT.set(EcsEmpty$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPipelineID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsPipelineID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static OfLong FLECS_IDEcsPipelineID_$layout() {
        return FLECS_IDEcsPipelineID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPipelineID_$segment() {
        return FLECS_IDEcsPipelineID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static long FLECS_IDEcsPipelineID_() {
        return FLECS_IDEcsPipelineID_$constants.SEGMENT.get(FLECS_IDEcsPipelineID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPipelineID_
     * }
     */
    public static void FLECS_IDEcsPipelineID_(long varValue) {
        FLECS_IDEcsPipelineID_$constants.SEGMENT.set(FLECS_IDEcsPipelineID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnStart$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnStart").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static OfLong EcsOnStart$layout() {
        return EcsOnStart$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static MemorySegment EcsOnStart$segment() {
        return EcsOnStart$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static long EcsOnStart() {
        return EcsOnStart$constants.SEGMENT.get(EcsOnStart$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStart
     * }
     */
    public static void EcsOnStart(long varValue) {
        EcsOnStart$constants.SEGMENT.set(EcsOnStart$constants.LAYOUT, 0L, varValue);
    }
}

