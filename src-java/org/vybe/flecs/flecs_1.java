// Generated by jextract

package org.vybe.flecs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class flecs_1 extends flecs_2 {

    flecs_1() {
        // Should not be called directly
    }

    private static class EcsPreFrame$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPreFrame").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static OfLong EcsPreFrame$layout() {
        return EcsPreFrame$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static MemorySegment EcsPreFrame$segment() {
        return EcsPreFrame$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static long EcsPreFrame() {
        return EcsPreFrame$constants.SEGMENT.get(EcsPreFrame$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreFrame
     * }
     */
    public static void EcsPreFrame(long varValue) {
        EcsPreFrame$constants.SEGMENT.set(EcsPreFrame$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnLoad$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnLoad").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static OfLong EcsOnLoad$layout() {
        return EcsOnLoad$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static MemorySegment EcsOnLoad$segment() {
        return EcsOnLoad$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static long EcsOnLoad() {
        return EcsOnLoad$constants.SEGMENT.get(EcsOnLoad$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnLoad
     * }
     */
    public static void EcsOnLoad(long varValue) {
        EcsOnLoad$constants.SEGMENT.set(EcsOnLoad$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostLoad$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPostLoad").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static OfLong EcsPostLoad$layout() {
        return EcsPostLoad$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static MemorySegment EcsPostLoad$segment() {
        return EcsPostLoad$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static long EcsPostLoad() {
        return EcsPostLoad$constants.SEGMENT.get(EcsPostLoad$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostLoad
     * }
     */
    public static void EcsPostLoad(long varValue) {
        EcsPostLoad$constants.SEGMENT.set(EcsPostLoad$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPreUpdate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPreUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static OfLong EcsPreUpdate$layout() {
        return EcsPreUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static MemorySegment EcsPreUpdate$segment() {
        return EcsPreUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static long EcsPreUpdate() {
        return EcsPreUpdate$constants.SEGMENT.get(EcsPreUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreUpdate
     * }
     */
    public static void EcsPreUpdate(long varValue) {
        EcsPreUpdate$constants.SEGMENT.set(EcsPreUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnUpdate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static OfLong EcsOnUpdate$layout() {
        return EcsOnUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static MemorySegment EcsOnUpdate$segment() {
        return EcsOnUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static long EcsOnUpdate() {
        return EcsOnUpdate$constants.SEGMENT.get(EcsOnUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnUpdate
     * }
     */
    public static void EcsOnUpdate(long varValue) {
        EcsOnUpdate$constants.SEGMENT.set(EcsOnUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnValidate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnValidate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static OfLong EcsOnValidate$layout() {
        return EcsOnValidate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static MemorySegment EcsOnValidate$segment() {
        return EcsOnValidate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static long EcsOnValidate() {
        return EcsOnValidate$constants.SEGMENT.get(EcsOnValidate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnValidate
     * }
     */
    public static void EcsOnValidate(long varValue) {
        EcsOnValidate$constants.SEGMENT.set(EcsOnValidate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostUpdate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPostUpdate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static OfLong EcsPostUpdate$layout() {
        return EcsPostUpdate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static MemorySegment EcsPostUpdate$segment() {
        return EcsPostUpdate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static long EcsPostUpdate() {
        return EcsPostUpdate$constants.SEGMENT.get(EcsPostUpdate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostUpdate
     * }
     */
    public static void EcsPostUpdate(long varValue) {
        EcsPostUpdate$constants.SEGMENT.set(EcsPostUpdate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPreStore$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPreStore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static OfLong EcsPreStore$layout() {
        return EcsPreStore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static MemorySegment EcsPreStore$segment() {
        return EcsPreStore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static long EcsPreStore() {
        return EcsPreStore$constants.SEGMENT.get(EcsPreStore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPreStore
     * }
     */
    public static void EcsPreStore(long varValue) {
        EcsPreStore$constants.SEGMENT.set(EcsPreStore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsOnStore$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsOnStore").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static OfLong EcsOnStore$layout() {
        return EcsOnStore$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static MemorySegment EcsOnStore$segment() {
        return EcsOnStore$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static long EcsOnStore() {
        return EcsOnStore$constants.SEGMENT.get(EcsOnStore$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsOnStore
     * }
     */
    public static void EcsOnStore(long varValue) {
        EcsOnStore$constants.SEGMENT.set(EcsOnStore$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPostFrame$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPostFrame").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static OfLong EcsPostFrame$layout() {
        return EcsPostFrame$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static MemorySegment EcsPostFrame$segment() {
        return EcsPostFrame$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static long EcsPostFrame() {
        return EcsPostFrame$constants.SEGMENT.get(EcsPostFrame$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPostFrame
     * }
     */
    public static void EcsPostFrame(long varValue) {
        EcsPostFrame$constants.SEGMENT.set(EcsPostFrame$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPhase$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPhase").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static OfLong EcsPhase$layout() {
        return EcsPhase$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static MemorySegment EcsPhase$segment() {
        return EcsPhase$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static long EcsPhase() {
        return EcsPhase$constants.SEGMENT.get(EcsPhase$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsPhase
     * }
     */
    public static void EcsPhase(long varValue) {
        EcsPhase$constants.SEGMENT.set(EcsPhase$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static FunctionDescriptor ecs_init$descriptor() {
        return ecs_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MethodHandle ecs_init$handle() {
        return ecs_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MemorySegment ecs_init$address() {
        return ecs_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_init()
     * }
     */
    public static MemorySegment ecs_init() {
        var mh$ = ecs_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_mini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_mini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static FunctionDescriptor ecs_mini$descriptor() {
        return ecs_mini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MethodHandle ecs_mini$handle() {
        return ecs_mini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MemorySegment ecs_mini$address() {
        return ecs_mini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_mini()
     * }
     */
    public static MemorySegment ecs_mini() {
        var mh$ = ecs_mini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_mini");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_init_w_args {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_init_w_args");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static FunctionDescriptor ecs_init_w_args$descriptor() {
        return ecs_init_w_args.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MethodHandle ecs_init_w_args$handle() {
        return ecs_init_w_args.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MemorySegment ecs_init_w_args$address() {
        return ecs_init_w_args.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_init_w_args(int argc, char *argv[])
     * }
     */
    public static MemorySegment ecs_init_w_args(int argc, MemorySegment argv) {
        var mh$ = ecs_init_w_args.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_init_w_args", argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_fini$descriptor() {
        return ecs_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_fini$handle() {
        return ecs_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_fini$address() {
        return ecs_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_fini(ecs_world_t *world)
     * }
     */
    public static int ecs_fini(MemorySegment world) {
        var mh$ = ecs_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_fini", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_is_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_is_fini$descriptor() {
        return ecs_is_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_is_fini$handle() {
        return ecs_is_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_is_fini$address() {
        return ecs_is_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_is_fini(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_is_fini(MemorySegment world) {
        var mh$ = ecs_is_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_fini", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_atfini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_atfini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static FunctionDescriptor ecs_atfini$descriptor() {
        return ecs_atfini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MethodHandle ecs_atfini$handle() {
        return ecs_atfini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MemorySegment ecs_atfini$address() {
        return ecs_atfini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_atfini(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static void ecs_atfini(MemorySegment world, MemorySegment action, MemorySegment ctx) {
        var mh$ = ecs_atfini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_atfini", world, action, ctx);
            }
            mh$.invokeExact(world, action, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_entities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_entities_t.layout(),
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_entities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_entities$descriptor() {
        return ecs_get_entities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_entities$handle() {
        return ecs_get_entities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_entities$address() {
        return ecs_get_entities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entities_t ecs_get_entities(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_entities(SegmentAllocator allocator, MemorySegment world) {
        var mh$ = ecs_get_entities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_entities", allocator, world);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_world_get_flags$descriptor() {
        return ecs_world_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_world_get_flags$handle() {
        return ecs_world_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_world_get_flags$address() {
        return ecs_world_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_flags32_t ecs_world_get_flags(const ecs_world_t *world)
     * }
     */
    public static int ecs_world_get_flags(MemorySegment world) {
        var mh$ = ecs_world_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_get_flags", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_frame_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_POINTER,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_frame_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static FunctionDescriptor ecs_frame_begin$descriptor() {
        return ecs_frame_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static MethodHandle ecs_frame_begin$handle() {
        return ecs_frame_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static MemorySegment ecs_frame_begin$address() {
        return ecs_frame_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ecs_frame_begin(ecs_world_t *world, float delta_time)
     * }
     */
    public static float ecs_frame_begin(MemorySegment world, float delta_time) {
        var mh$ = ecs_frame_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_frame_begin", world, delta_time);
            }
            return (float)mh$.invokeExact(world, delta_time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_frame_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_frame_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_frame_end$descriptor() {
        return ecs_frame_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_frame_end$handle() {
        return ecs_frame_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_frame_end$address() {
        return ecs_frame_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_frame_end(ecs_world_t *world)
     * }
     */
    public static void ecs_frame_end(MemorySegment world) {
        var mh$ = ecs_frame_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_frame_end", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_post_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_run_post_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static FunctionDescriptor ecs_run_post_frame$descriptor() {
        return ecs_run_post_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MethodHandle ecs_run_post_frame$handle() {
        return ecs_run_post_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static MemorySegment ecs_run_post_frame$address() {
        return ecs_run_post_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_run_post_frame(ecs_world_t *world, ecs_fini_action_t action, void *ctx)
     * }
     */
    public static void ecs_run_post_frame(MemorySegment world, MemorySegment action, MemorySegment ctx) {
        var mh$ = ecs_run_post_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_post_frame", world, action, ctx);
            }
            mh$.invokeExact(world, action, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_quit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_quit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_quit$descriptor() {
        return ecs_quit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_quit$handle() {
        return ecs_quit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_quit$address() {
        return ecs_quit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_quit(ecs_world_t *world)
     * }
     */
    public static void ecs_quit(MemorySegment world) {
        var mh$ = ecs_quit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_quit", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_should_quit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_should_quit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_should_quit$descriptor() {
        return ecs_should_quit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_should_quit$handle() {
        return ecs_should_quit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_should_quit$address() {
        return ecs_should_quit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_should_quit(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_should_quit(MemorySegment world) {
        var mh$ = ecs_should_quit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_should_quit", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_measure_frame_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_measure_frame_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, bool enable)
     * }
     */
    public static FunctionDescriptor ecs_measure_frame_time$descriptor() {
        return ecs_measure_frame_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, bool enable)
     * }
     */
    public static MethodHandle ecs_measure_frame_time$handle() {
        return ecs_measure_frame_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, bool enable)
     * }
     */
    public static MemorySegment ecs_measure_frame_time$address() {
        return ecs_measure_frame_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_measure_frame_time(ecs_world_t *world, bool enable)
     * }
     */
    public static void ecs_measure_frame_time(MemorySegment world, boolean enable) {
        var mh$ = ecs_measure_frame_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_measure_frame_time", world, enable);
            }
            mh$.invokeExact(world, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_measure_system_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_measure_system_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, bool enable)
     * }
     */
    public static FunctionDescriptor ecs_measure_system_time$descriptor() {
        return ecs_measure_system_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, bool enable)
     * }
     */
    public static MethodHandle ecs_measure_system_time$handle() {
        return ecs_measure_system_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, bool enable)
     * }
     */
    public static MemorySegment ecs_measure_system_time$address() {
        return ecs_measure_system_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_measure_system_time(ecs_world_t *world, bool enable)
     * }
     */
    public static void ecs_measure_system_time(MemorySegment world, boolean enable) {
        var mh$ = ecs_measure_system_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_measure_system_time", world, enable);
            }
            mh$.invokeExact(world, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_target_fps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_target_fps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static FunctionDescriptor ecs_set_target_fps$descriptor() {
        return ecs_set_target_fps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static MethodHandle ecs_set_target_fps$handle() {
        return ecs_set_target_fps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static MemorySegment ecs_set_target_fps$address() {
        return ecs_set_target_fps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_target_fps(ecs_world_t *world, float fps)
     * }
     */
    public static void ecs_set_target_fps(MemorySegment world, float fps) {
        var mh$ = ecs_set_target_fps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_target_fps", world, fps);
            }
            mh$.invokeExact(world, fps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_default_query_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_default_query_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static FunctionDescriptor ecs_set_default_query_flags$descriptor() {
        return ecs_set_default_query_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MethodHandle ecs_set_default_query_flags$handle() {
        return ecs_set_default_query_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MemorySegment ecs_set_default_query_flags$address() {
        return ecs_set_default_query_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_default_query_flags(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static void ecs_set_default_query_flags(MemorySegment world, int flags) {
        var mh$ = ecs_set_default_query_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_default_query_flags", world, flags);
            }
            mh$.invokeExact(world, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_readonly_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_readonly_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_readonly_begin(ecs_world_t *world, bool multi_threaded)
     * }
     */
    public static FunctionDescriptor ecs_readonly_begin$descriptor() {
        return ecs_readonly_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_readonly_begin(ecs_world_t *world, bool multi_threaded)
     * }
     */
    public static MethodHandle ecs_readonly_begin$handle() {
        return ecs_readonly_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_readonly_begin(ecs_world_t *world, bool multi_threaded)
     * }
     */
    public static MemorySegment ecs_readonly_begin$address() {
        return ecs_readonly_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_readonly_begin(ecs_world_t *world, bool multi_threaded)
     * }
     */
    public static boolean ecs_readonly_begin(MemorySegment world, boolean multi_threaded) {
        var mh$ = ecs_readonly_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_readonly_begin", world, multi_threaded);
            }
            return (boolean)mh$.invokeExact(world, multi_threaded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_readonly_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_readonly_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_readonly_end$descriptor() {
        return ecs_readonly_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_readonly_end$handle() {
        return ecs_readonly_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_readonly_end$address() {
        return ecs_readonly_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_readonly_end(ecs_world_t *world)
     * }
     */
    public static void ecs_readonly_end(MemorySegment world) {
        var mh$ = ecs_readonly_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_readonly_end", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_merge$descriptor() {
        return ecs_merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_merge$handle() {
        return ecs_merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_merge$address() {
        return ecs_merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_merge(ecs_world_t *world)
     * }
     */
    public static void ecs_merge(MemorySegment world) {
        var mh$ = ecs_merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_merge", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_defer_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_begin$descriptor() {
        return ecs_defer_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_begin$handle() {
        return ecs_defer_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_begin$address() {
        return ecs_defer_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_defer_begin(ecs_world_t *world)
     * }
     */
    public static boolean ecs_defer_begin(MemorySegment world) {
        var mh$ = ecs_defer_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_begin", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_deferred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_is_deferred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_is_deferred$descriptor() {
        return ecs_is_deferred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_is_deferred$handle() {
        return ecs_is_deferred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_is_deferred$address() {
        return ecs_is_deferred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_is_deferred(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_is_deferred(MemorySegment world) {
        var mh$ = ecs_is_deferred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_deferred", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_defer_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_end$descriptor() {
        return ecs_defer_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_end$handle() {
        return ecs_defer_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_end$address() {
        return ecs_defer_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_defer_end(ecs_world_t *world)
     * }
     */
    public static boolean ecs_defer_end(MemorySegment world) {
        var mh$ = ecs_defer_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_end", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_suspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_defer_suspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_suspend$descriptor() {
        return ecs_defer_suspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_suspend$handle() {
        return ecs_defer_suspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_suspend$address() {
        return ecs_defer_suspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_defer_suspend(ecs_world_t *world)
     * }
     */
    public static void ecs_defer_suspend(MemorySegment world) {
        var mh$ = ecs_defer_suspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_suspend", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_defer_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_defer_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_defer_resume$descriptor() {
        return ecs_defer_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_defer_resume$handle() {
        return ecs_defer_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_defer_resume$address() {
        return ecs_defer_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_defer_resume(ecs_world_t *world)
     * }
     */
    public static void ecs_defer_resume(MemorySegment world) {
        var mh$ = ecs_defer_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_defer_resume", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_stage_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_stage_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static FunctionDescriptor ecs_set_stage_count$descriptor() {
        return ecs_set_stage_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static MethodHandle ecs_set_stage_count$handle() {
        return ecs_set_stage_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static MemorySegment ecs_set_stage_count$address() {
        return ecs_set_stage_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_stage_count(ecs_world_t *world, int32_t stages)
     * }
     */
    public static void ecs_set_stage_count(MemorySegment world, int stages) {
        var mh$ = ecs_set_stage_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_stage_count", world, stages);
            }
            mh$.invokeExact(world, stages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_stage_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_stage_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_stage_count$descriptor() {
        return ecs_get_stage_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_stage_count$handle() {
        return ecs_get_stage_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_stage_count$address() {
        return ecs_get_stage_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_get_stage_count(const ecs_world_t *world)
     * }
     */
    public static int ecs_get_stage_count(MemorySegment world) {
        var mh$ = ecs_get_stage_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_stage_count", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static FunctionDescriptor ecs_get_stage$descriptor() {
        return ecs_get_stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MethodHandle ecs_get_stage$handle() {
        return ecs_get_stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MemorySegment ecs_get_stage$address() {
        return ecs_get_stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_get_stage(const ecs_world_t *world, int32_t stage_id)
     * }
     */
    public static MemorySegment ecs_get_stage(MemorySegment world, int stage_id) {
        var mh$ = ecs_get_stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_stage", world, stage_id);
            }
            return (MemorySegment)mh$.invokeExact(world, stage_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_is_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_stage_is_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_is_readonly$descriptor() {
        return ecs_stage_is_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_is_readonly$handle() {
        return ecs_stage_is_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_is_readonly$address() {
        return ecs_stage_is_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_stage_is_readonly(const ecs_world_t *world)
     * }
     */
    public static boolean ecs_stage_is_readonly(MemorySegment world) {
        var mh$ = ecs_stage_is_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_is_readonly", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_stage_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_new$descriptor() {
        return ecs_stage_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_new$handle() {
        return ecs_stage_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_new$address() {
        return ecs_stage_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_world_t *ecs_stage_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_new(MemorySegment world) {
        var mh$ = ecs_stage_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_new", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_stage_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static FunctionDescriptor ecs_stage_free$descriptor() {
        return ecs_stage_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static MethodHandle ecs_stage_free$handle() {
        return ecs_stage_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static MemorySegment ecs_stage_free$address() {
        return ecs_stage_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_stage_free(ecs_world_t *stage)
     * }
     */
    public static void ecs_stage_free(MemorySegment stage) {
        var mh$ = ecs_stage_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_free", stage);
            }
            mh$.invokeExact(stage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stage_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_stage_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_stage_get_id$descriptor() {
        return ecs_stage_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_stage_get_id$handle() {
        return ecs_stage_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_stage_get_id$address() {
        return ecs_stage_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_stage_get_id(const ecs_world_t *world)
     * }
     */
    public static int ecs_stage_get_id(MemorySegment world) {
        var mh$ = ecs_stage_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stage_get_id", world);
            }
            return (int)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static FunctionDescriptor ecs_set_ctx$descriptor() {
        return ecs_set_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MethodHandle ecs_set_ctx$handle() {
        return ecs_set_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MemorySegment ecs_set_ctx$address() {
        return ecs_set_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static void ecs_set_ctx(MemorySegment world, MemorySegment ctx, MemorySegment ctx_free) {
        var mh$ = ecs_set_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_ctx", world, ctx, ctx_free);
            }
            mh$.invokeExact(world, ctx, ctx_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_binding_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_binding_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static FunctionDescriptor ecs_set_binding_ctx$descriptor() {
        return ecs_set_binding_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MethodHandle ecs_set_binding_ctx$handle() {
        return ecs_set_binding_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static MemorySegment ecs_set_binding_ctx$address() {
        return ecs_set_binding_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_binding_ctx(ecs_world_t *world, void *ctx, ecs_ctx_free_t ctx_free)
     * }
     */
    public static void ecs_set_binding_ctx(MemorySegment world, MemorySegment ctx, MemorySegment ctx_free) {
        var mh$ = ecs_set_binding_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_binding_ctx", world, ctx, ctx_free);
            }
            mh$.invokeExact(world, ctx, ctx_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_ctx$descriptor() {
        return ecs_get_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_ctx$handle() {
        return ecs_get_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_ctx$address() {
        return ecs_get_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_ctx(MemorySegment world) {
        var mh$ = ecs_get_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_ctx", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_binding_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_binding_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_binding_ctx$descriptor() {
        return ecs_get_binding_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_binding_ctx$handle() {
        return ecs_get_binding_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_binding_ctx$address() {
        return ecs_get_binding_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_binding_ctx(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_binding_ctx(MemorySegment world) {
        var mh$ = ecs_get_binding_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_binding_ctx", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_build_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_build_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static FunctionDescriptor ecs_get_build_info$descriptor() {
        return ecs_get_build_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MethodHandle ecs_get_build_info$handle() {
        return ecs_get_build_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MemorySegment ecs_get_build_info$address() {
        return ecs_get_build_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_build_info_t *ecs_get_build_info()
     * }
     */
    public static MemorySegment ecs_get_build_info() {
        var mh$ = ecs_get_build_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_build_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_world_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_world_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_world_info$descriptor() {
        return ecs_get_world_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_world_info$handle() {
        return ecs_get_world_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_world_info$address() {
        return ecs_get_world_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_world_info_t *ecs_get_world_info(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_world_info(MemorySegment world) {
        var mh$ = ecs_get_world_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_world_info", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_dim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_dim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static FunctionDescriptor ecs_dim$descriptor() {
        return ecs_dim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static MethodHandle ecs_dim$handle() {
        return ecs_dim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static MemorySegment ecs_dim$address() {
        return ecs_dim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_dim(ecs_world_t *world, int32_t entity_count)
     * }
     */
    public static void ecs_dim(MemorySegment world, int entity_count) {
        var mh$ = ecs_dim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_dim", world, entity_count);
            }
            mh$.invokeExact(world, entity_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_entity_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_entity_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static FunctionDescriptor ecs_set_entity_range$descriptor() {
        return ecs_set_entity_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static MethodHandle ecs_set_entity_range$handle() {
        return ecs_set_entity_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static MemorySegment ecs_set_entity_range$address() {
        return ecs_set_entity_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_entity_range(ecs_world_t *world, ecs_entity_t id_start, ecs_entity_t id_end)
     * }
     */
    public static void ecs_set_entity_range(MemorySegment world, long id_start, long id_end) {
        var mh$ = ecs_set_entity_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_entity_range", world, id_start, id_end);
            }
            mh$.invokeExact(world, id_start, id_end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable_range_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_enable_range_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_enable_range_check(ecs_world_t *world, bool enable)
     * }
     */
    public static FunctionDescriptor ecs_enable_range_check$descriptor() {
        return ecs_enable_range_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_enable_range_check(ecs_world_t *world, bool enable)
     * }
     */
    public static MethodHandle ecs_enable_range_check$handle() {
        return ecs_enable_range_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_enable_range_check(ecs_world_t *world, bool enable)
     * }
     */
    public static MemorySegment ecs_enable_range_check$address() {
        return ecs_enable_range_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_enable_range_check(ecs_world_t *world, bool enable)
     * }
     */
    public static boolean ecs_enable_range_check(MemorySegment world, boolean enable) {
        var mh$ = ecs_enable_range_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable_range_check", world, enable);
            }
            return (boolean)mh$.invokeExact(world, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_max_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_max_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_max_id$descriptor() {
        return ecs_get_max_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_max_id$handle() {
        return ecs_get_max_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_max_id$address() {
        return ecs_get_max_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_max_id(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_max_id(MemorySegment world) {
        var mh$ = ecs_get_max_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_max_id", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_aperiodic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_run_aperiodic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static FunctionDescriptor ecs_run_aperiodic$descriptor() {
        return ecs_run_aperiodic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MethodHandle ecs_run_aperiodic$handle() {
        return ecs_run_aperiodic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static MemorySegment ecs_run_aperiodic$address() {
        return ecs_run_aperiodic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_run_aperiodic(ecs_world_t *world, ecs_flags32_t flags)
     * }
     */
    public static void ecs_run_aperiodic(MemorySegment world, int flags) {
        var mh$ = ecs_run_aperiodic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_aperiodic", world, flags);
            }
            mh$.invokeExact(world, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete_empty_tables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_SHORT,
            flecs.C_SHORT,
            flecs.C_INT,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_delete_empty_tables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, ecs_id_t id, uint16_t clear_generation, uint16_t delete_generation, int32_t min_id_count, double time_budget_seconds)
     * }
     */
    public static FunctionDescriptor ecs_delete_empty_tables$descriptor() {
        return ecs_delete_empty_tables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, ecs_id_t id, uint16_t clear_generation, uint16_t delete_generation, int32_t min_id_count, double time_budget_seconds)
     * }
     */
    public static MethodHandle ecs_delete_empty_tables$handle() {
        return ecs_delete_empty_tables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, ecs_id_t id, uint16_t clear_generation, uint16_t delete_generation, int32_t min_id_count, double time_budget_seconds)
     * }
     */
    public static MemorySegment ecs_delete_empty_tables$address() {
        return ecs_delete_empty_tables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_delete_empty_tables(ecs_world_t *world, ecs_id_t id, uint16_t clear_generation, uint16_t delete_generation, int32_t min_id_count, double time_budget_seconds)
     * }
     */
    public static int ecs_delete_empty_tables(MemorySegment world, long id, short clear_generation, short delete_generation, int min_id_count, double time_budget_seconds) {
        var mh$ = ecs_delete_empty_tables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete_empty_tables", world, id, clear_generation, delete_generation, min_id_count, time_budget_seconds);
            }
            return (int)mh$.invokeExact(world, id, clear_generation, delete_generation, min_id_count, time_budget_seconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_world {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_world");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor ecs_get_world$descriptor() {
        return ecs_get_world.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MethodHandle ecs_get_world$handle() {
        return ecs_get_world.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_world$address() {
        return ecs_get_world.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_world_t *ecs_get_world(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_world(MemorySegment poly) {
        var mh$ = ecs_get_world.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_world", poly);
            }
            return (MemorySegment)mh$.invokeExact(poly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static FunctionDescriptor ecs_get_entity$descriptor() {
        return ecs_get_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static MethodHandle ecs_get_entity$handle() {
        return ecs_get_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static MemorySegment ecs_get_entity$address() {
        return ecs_get_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_entity(const ecs_poly_t *poly)
     * }
     */
    public static long ecs_get_entity(MemorySegment poly) {
        var mh$ = ecs_get_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_entity", poly);
            }
            return (long)mh$.invokeExact(poly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flecs_poly_is_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("flecs_poly_is_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static FunctionDescriptor flecs_poly_is_$descriptor() {
        return flecs_poly_is_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static MethodHandle flecs_poly_is_$handle() {
        return flecs_poly_is_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static MemorySegment flecs_poly_is_$address() {
        return flecs_poly_is_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool flecs_poly_is_(const ecs_poly_t *object, int32_t type)
     * }
     */
    public static boolean flecs_poly_is_(MemorySegment object, int type) {
        var mh$ = flecs_poly_is_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flecs_poly_is_", object, type);
            }
            return (boolean)mh$.invokeExact(object, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_pair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_make_pair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static FunctionDescriptor ecs_make_pair$descriptor() {
        return ecs_make_pair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static MethodHandle ecs_make_pair$handle() {
        return ecs_make_pair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static MemorySegment ecs_make_pair$address() {
        return ecs_make_pair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_make_pair(ecs_entity_t first, ecs_entity_t second)
     * }
     */
    public static long ecs_make_pair(long first, long second) {
        var mh$ = ecs_make_pair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_pair", first, second);
            }
            return (long)mh$.invokeExact(first, second);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_new$descriptor() {
        return ecs_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_new$handle() {
        return ecs_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_new$address() {
        return ecs_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new(ecs_world_t *world)
     * }
     */
    public static long ecs_new(MemorySegment world) {
        var mh$ = ecs_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_low_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_new_low_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_new_low_id$descriptor() {
        return ecs_new_low_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_new_low_id$handle() {
        return ecs_new_low_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_new_low_id$address() {
        return ecs_new_low_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_low_id(ecs_world_t *world)
     * }
     */
    public static long ecs_new_low_id(MemorySegment world) {
        var mh$ = ecs_new_low_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_low_id", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_w_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_new_w_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_new_w_id$descriptor() {
        return ecs_new_w_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_new_w_id$handle() {
        return ecs_new_w_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_new_w_id$address() {
        return ecs_new_w_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static long ecs_new_w_id(MemorySegment world, long id) {
        var mh$ = ecs_new_w_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_w_id", world, id);
            }
            return (long)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_w_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_new_w_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_new_w_table$descriptor() {
        return ecs_new_w_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_new_w_table$handle() {
        return ecs_new_w_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_new_w_table$address() {
        return ecs_new_w_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_w_table(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static long ecs_new_w_table(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_new_w_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_w_table", world, table);
            }
            return (long)mh$.invokeExact(world, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_entity_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_entity_init$descriptor() {
        return ecs_entity_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_entity_init$handle() {
        return ecs_entity_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_init$address() {
        return ecs_entity_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_entity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static long ecs_entity_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_entity_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_bulk_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_bulk_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_bulk_init$descriptor() {
        return ecs_bulk_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_bulk_init$handle() {
        return ecs_bulk_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_bulk_init$address() {
        return ecs_bulk_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_init(ecs_world_t *world, const ecs_bulk_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_bulk_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_bulk_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_bulk_init", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_bulk_new_w_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_bulk_new_w_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t id, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_bulk_new_w_id$descriptor() {
        return ecs_bulk_new_w_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t id, int32_t count)
     * }
     */
    public static MethodHandle ecs_bulk_new_w_id$handle() {
        return ecs_bulk_new_w_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t id, int32_t count)
     * }
     */
    public static MemorySegment ecs_bulk_new_w_id$address() {
        return ecs_bulk_new_w_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_bulk_new_w_id(ecs_world_t *world, ecs_id_t id, int32_t count)
     * }
     */
    public static MemorySegment ecs_bulk_new_w_id(MemorySegment world, long id, int count) {
        var mh$ = ecs_bulk_new_w_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_bulk_new_w_id", world, id, count);
            }
            return (MemorySegment)mh$.invokeExact(world, id, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, bool copy_value)
     * }
     */
    public static FunctionDescriptor ecs_clone$descriptor() {
        return ecs_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, bool copy_value)
     * }
     */
    public static MethodHandle ecs_clone$handle() {
        return ecs_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, bool copy_value)
     * }
     */
    public static MemorySegment ecs_clone$address() {
        return ecs_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_clone(ecs_world_t *world, ecs_entity_t dst, ecs_entity_t src, bool copy_value)
     * }
     */
    public static long ecs_clone(MemorySegment world, long dst, long src, boolean copy_value) {
        var mh$ = ecs_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_clone", world, dst, src, copy_value);
            }
            return (long)mh$.invokeExact(world, dst, src, copy_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_delete$descriptor() {
        return ecs_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_delete$handle() {
        return ecs_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_delete$address() {
        return ecs_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_delete(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_delete(MemorySegment world, long entity) {
        var mh$ = ecs_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_delete_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_delete_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_delete_with$descriptor() {
        return ecs_delete_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_delete_with$handle() {
        return ecs_delete_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_delete_with$address() {
        return ecs_delete_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_delete_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static void ecs_delete_with(MemorySegment world, long id) {
        var mh$ = ecs_delete_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_delete_with", world, id);
            }
            mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_add_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_add_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_add_id$descriptor() {
        return ecs_add_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_add_id$handle() {
        return ecs_add_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_add_id$address() {
        return ecs_add_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_add_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static void ecs_add_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_add_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_add_id", world, entity, id);
            }
            mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_remove_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_remove_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_remove_id$descriptor() {
        return ecs_remove_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_remove_id$handle() {
        return ecs_remove_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_remove_id$address() {
        return ecs_remove_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_remove_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static void ecs_remove_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_remove_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_remove_id", world, entity, id);
            }
            mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_auto_override_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_auto_override_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_auto_override_id$descriptor() {
        return ecs_auto_override_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_auto_override_id$handle() {
        return ecs_auto_override_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_auto_override_id$address() {
        return ecs_auto_override_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_auto_override_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static void ecs_auto_override_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_auto_override_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_auto_override_id", world, entity, id);
            }
            mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_clear$descriptor() {
        return ecs_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_clear$handle() {
        return ecs_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_clear$address() {
        return ecs_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_clear(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_clear(MemorySegment world, long entity) {
        var mh$ = ecs_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_clear", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_remove_all$descriptor() {
        return ecs_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_remove_all$handle() {
        return ecs_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_remove_all$address() {
        return ecs_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_remove_all(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static void ecs_remove_all(MemorySegment world, long id) {
        var mh$ = ecs_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_remove_all", world, id);
            }
            mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_set_with$descriptor() {
        return ecs_set_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_set_with$handle() {
        return ecs_set_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_set_with$address() {
        return ecs_set_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_with(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static long ecs_set_with(MemorySegment world, long id) {
        var mh$ = ecs_set_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_with", world, id);
            }
            return (long)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_with {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_with");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_with$descriptor() {
        return ecs_get_with.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_with$handle() {
        return ecs_get_with.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_with$address() {
        return ecs_get_with.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_get_with(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_with(MemorySegment world) {
        var mh$ = ecs_get_with.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_with", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, bool enabled)
     * }
     */
    public static FunctionDescriptor ecs_enable$descriptor() {
        return ecs_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, bool enabled)
     * }
     */
    public static MethodHandle ecs_enable$handle() {
        return ecs_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, bool enabled)
     * }
     */
    public static MemorySegment ecs_enable$address() {
        return ecs_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enable(ecs_world_t *world, ecs_entity_t entity, bool enabled)
     * }
     */
    public static void ecs_enable(MemorySegment world, long entity, boolean enabled) {
        var mh$ = ecs_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable", world, entity, enabled);
            }
            mh$.invokeExact(world, entity, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enable_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_enable_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool enable)
     * }
     */
    public static FunctionDescriptor ecs_enable_id$descriptor() {
        return ecs_enable_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool enable)
     * }
     */
    public static MethodHandle ecs_enable_id$handle() {
        return ecs_enable_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool enable)
     * }
     */
    public static MemorySegment ecs_enable_id$address() {
        return ecs_enable_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enable_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool enable)
     * }
     */
    public static void ecs_enable_id(MemorySegment world, long entity, long id, boolean enable) {
        var mh$ = ecs_enable_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enable_id", world, entity, id, enable);
            }
            mh$.invokeExact(world, entity, id, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_enabled_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_is_enabled_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_is_enabled_id$descriptor() {
        return ecs_is_enabled_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_is_enabled_id$handle() {
        return ecs_is_enabled_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_is_enabled_id$address() {
        return ecs_is_enabled_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_is_enabled_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static boolean ecs_is_enabled_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_is_enabled_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_enabled_id", world, entity, id);
            }
            return (boolean)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_id$descriptor() {
        return ecs_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_get_id$handle() {
        return ecs_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_id$address() {
        return ecs_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *ecs_get_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_id", world, entity, id);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_mut_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_mut_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_mut_id$descriptor() {
        return ecs_get_mut_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_get_mut_id$handle() {
        return ecs_get_mut_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_mut_id$address() {
        return ecs_get_mut_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_get_mut_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_mut_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_get_mut_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_mut_id", world, entity, id);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ensure_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ensure_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_ensure_id$descriptor() {
        return ecs_ensure_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_ensure_id$handle() {
        return ecs_ensure_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ensure_id$address() {
        return ecs_ensure_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_ensure_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ensure_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_ensure_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ensure_id", world, entity, id);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ensure_modified_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ensure_modified_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_ensure_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_ensure_modified_id$descriptor() {
        return ecs_ensure_modified_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_ensure_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_ensure_modified_id$handle() {
        return ecs_ensure_modified_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_ensure_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ensure_modified_id$address() {
        return ecs_ensure_modified_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_ensure_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ensure_modified_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_ensure_modified_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ensure_modified_id", world, entity, id);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_init_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_ref_t.layout(),
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ref_init_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_ref_init_id$descriptor() {
        return ecs_ref_init_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_ref_init_id$handle() {
        return ecs_ref_init_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ref_init_id$address() {
        return ecs_ref_init_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_ref_t ecs_ref_init_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ref_init_id(SegmentAllocator allocator, MemorySegment world, long entity, long id) {
        var mh$ = ecs_ref_init_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_init_id", allocator, world, entity, id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ref_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_ref_get_id$descriptor() {
        return ecs_ref_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_ref_get_id$handle() {
        return ecs_ref_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ref_get_id$address() {
        return ecs_ref_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_ref_get_id(const ecs_world_t *world, ecs_ref_t *ref, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_ref_get_id(MemorySegment world, MemorySegment ref, long id) {
        var mh$ = ecs_ref_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_get_id", world, ref, id);
            }
            return (MemorySegment)mh$.invokeExact(world, ref, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ref_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ref_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static FunctionDescriptor ecs_ref_update$descriptor() {
        return ecs_ref_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static MethodHandle ecs_ref_update$handle() {
        return ecs_ref_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static MemorySegment ecs_ref_update$address() {
        return ecs_ref_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_ref_update(const ecs_world_t *world, ecs_ref_t *ref)
     * }
     */
    public static void ecs_ref_update(MemorySegment world, MemorySegment ref) {
        var mh$ = ecs_ref_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ref_update", world, ref);
            }
            mh$.invokeExact(world, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_record_find$descriptor() {
        return ecs_record_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_record_find$handle() {
        return ecs_record_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_record_find$address() {
        return ecs_record_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_record_t *ecs_record_find(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_record_find(MemorySegment world, long entity) {
        var mh$ = ecs_record_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_find", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_write_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_write_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_write_begin$descriptor() {
        return ecs_write_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_write_begin$handle() {
        return ecs_write_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_write_begin$address() {
        return ecs_write_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_record_t *ecs_write_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_write_begin(MemorySegment world, long entity) {
        var mh$ = ecs_write_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_write_begin", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_write_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_write_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_write_end$descriptor() {
        return ecs_write_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_write_end$handle() {
        return ecs_write_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_write_end$address() {
        return ecs_write_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_write_end(ecs_record_t *record)
     * }
     */
    public static void ecs_write_end(MemorySegment record_) {
        var mh$ = ecs_write_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_write_end", record_);
            }
            mh$.invokeExact(record_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_read_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_read_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_read_begin$descriptor() {
        return ecs_read_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_read_begin$handle() {
        return ecs_read_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_read_begin$address() {
        return ecs_read_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_record_t *ecs_read_begin(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_read_begin(MemorySegment world, long entity) {
        var mh$ = ecs_read_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_read_begin", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_read_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_read_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_read_end$descriptor() {
        return ecs_read_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_read_end$handle() {
        return ecs_read_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_read_end$address() {
        return ecs_read_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_read_end(const ecs_record_t *record)
     * }
     */
    public static void ecs_read_end(MemorySegment record_) {
        var mh$ = ecs_read_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_read_end", record_);
            }
            mh$.invokeExact(record_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_get_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static FunctionDescriptor ecs_record_get_entity$descriptor() {
        return ecs_record_get_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static MethodHandle ecs_record_get_entity$handle() {
        return ecs_record_get_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static MemorySegment ecs_record_get_entity$address() {
        return ecs_record_get_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_record_get_entity(const ecs_record_t *record)
     * }
     */
    public static long ecs_record_get_entity(MemorySegment record_) {
        var mh$ = ecs_record_get_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_entity", record_);
            }
            return (long)mh$.invokeExact(record_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_get_id$descriptor() {
        return ecs_record_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_get_id$handle() {
        return ecs_record_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_get_id$address() {
        return ecs_record_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *ecs_record_get_id(const ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_get_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_id", world, record_, id);
            }
            return (MemorySegment)mh$.invokeExact(world, record_, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_ensure_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_ensure_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_ensure_id$descriptor() {
        return ecs_record_ensure_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_ensure_id$handle() {
        return ecs_record_ensure_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_ensure_id$address() {
        return ecs_record_ensure_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_record_ensure_id(ecs_world_t *world, ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_ensure_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_ensure_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_ensure_id", world, record_, id);
            }
            return (MemorySegment)mh$.invokeExact(world, record_, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_record_has_id$descriptor() {
        return ecs_record_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_record_has_id$handle() {
        return ecs_record_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_record_has_id$address() {
        return ecs_record_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_record_has_id(ecs_world_t *world, const ecs_record_t *record, ecs_id_t id)
     * }
     */
    public static boolean ecs_record_has_id(MemorySegment world, MemorySegment record_, long id) {
        var mh$ = ecs_record_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_has_id", world, record_, id);
            }
            return (boolean)mh$.invokeExact(world, record_, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_record_get_by_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_record_get_by_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static FunctionDescriptor ecs_record_get_by_column$descriptor() {
        return ecs_record_get_by_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MethodHandle ecs_record_get_by_column$handle() {
        return ecs_record_get_by_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MemorySegment ecs_record_get_by_column$address() {
        return ecs_record_get_by_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_record_get_by_column(const ecs_record_t *record, int32_t column, size_t size)
     * }
     */
    public static MemorySegment ecs_record_get_by_column(MemorySegment record_, int column, long size) {
        var mh$ = ecs_record_get_by_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_record_get_by_column", record_, column, size);
            }
            return (MemorySegment)mh$.invokeExact(record_, column, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_emplace_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_emplace_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool *is_new)
     * }
     */
    public static FunctionDescriptor ecs_emplace_id$descriptor() {
        return ecs_emplace_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool *is_new)
     * }
     */
    public static MethodHandle ecs_emplace_id$handle() {
        return ecs_emplace_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool *is_new)
     * }
     */
    public static MemorySegment ecs_emplace_id$address() {
        return ecs_emplace_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_emplace_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, bool *is_new)
     * }
     */
    public static MemorySegment ecs_emplace_id(MemorySegment world, long entity, long id, MemorySegment is_new) {
        var mh$ = ecs_emplace_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_emplace_id", world, entity, id, is_new);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, id, is_new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_modified_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_modified_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_modified_id$descriptor() {
        return ecs_modified_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_modified_id$handle() {
        return ecs_modified_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_modified_id$address() {
        return ecs_modified_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_modified_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static void ecs_modified_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_modified_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_modified_id", world, entity, id);
            }
            mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_set_id$descriptor() {
        return ecs_set_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)
     * }
     */
    public static MethodHandle ecs_set_id$handle() {
        return ecs_set_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)
     * }
     */
    public static MemorySegment ecs_set_id$address() {
        return ecs_set_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_id(ecs_world_t *world, ecs_entity_t entity, ecs_id_t id, size_t size, const void *ptr)
     * }
     */
    public static void ecs_set_id(MemorySegment world, long entity, long id, long size, MemorySegment ptr) {
        var mh$ = ecs_set_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_id", world, entity, id, size, ptr);
            }
            mh$.invokeExact(world, entity, id, size, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_is_valid$descriptor() {
        return ecs_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_is_valid$handle() {
        return ecs_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_is_valid$address() {
        return ecs_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_is_valid(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static boolean ecs_is_valid(MemorySegment world, long e) {
        var mh$ = ecs_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_valid", world, e);
            }
            return (boolean)mh$.invokeExact(world, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_is_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_is_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_is_alive$descriptor() {
        return ecs_is_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_is_alive$handle() {
        return ecs_is_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_is_alive$address() {
        return ecs_is_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_is_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static boolean ecs_is_alive(MemorySegment world, long e) {
        var mh$ = ecs_is_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_is_alive", world, e);
            }
            return (boolean)mh$.invokeExact(world, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strip_generation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strip_generation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_strip_generation$descriptor() {
        return ecs_strip_generation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_strip_generation$handle() {
        return ecs_strip_generation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_strip_generation$address() {
        return ecs_strip_generation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_strip_generation(ecs_entity_t e)
     * }
     */
    public static long ecs_strip_generation(long e) {
        var mh$ = ecs_strip_generation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strip_generation", e);
            }
            return (long)mh$.invokeExact(e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static FunctionDescriptor ecs_get_alive$descriptor() {
        return ecs_get_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MethodHandle ecs_get_alive$handle() {
        return ecs_get_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static MemorySegment ecs_get_alive$address() {
        return ecs_get_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alive(const ecs_world_t *world, ecs_entity_t e)
     * }
     */
    public static long ecs_get_alive(MemorySegment world, long e) {
        var mh$ = ecs_get_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_alive", world, e);
            }
            return (long)mh$.invokeExact(world, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_alive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_make_alive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_make_alive$descriptor() {
        return ecs_make_alive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_make_alive$handle() {
        return ecs_make_alive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_make_alive$address() {
        return ecs_make_alive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_make_alive(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_make_alive(MemorySegment world, long entity) {
        var mh$ = ecs_make_alive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_alive", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_make_alive_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_make_alive_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_make_alive_id$descriptor() {
        return ecs_make_alive_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_make_alive_id$handle() {
        return ecs_make_alive_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_make_alive_id$address() {
        return ecs_make_alive_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_make_alive_id(ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static void ecs_make_alive_id(MemorySegment world, long id) {
        var mh$ = ecs_make_alive_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_make_alive_id", world, id);
            }
            mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_exists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_exists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_exists$descriptor() {
        return ecs_exists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_exists$handle() {
        return ecs_exists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_exists$address() {
        return ecs_exists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_exists(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static boolean ecs_exists(MemorySegment world, long entity) {
        var mh$ = ecs_exists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_exists", world, entity);
            }
            return (boolean)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_set_version$descriptor() {
        return ecs_set_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_set_version$handle() {
        return ecs_set_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_set_version$address() {
        return ecs_set_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_version(ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static void ecs_set_version(MemorySegment world, long entity) {
        var mh$ = ecs_set_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_version", world, entity);
            }
            mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_type$descriptor() {
        return ecs_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_type$handle() {
        return ecs_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_type$address() {
        return ecs_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_t *ecs_get_type(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_type(MemorySegment world, long entity) {
        var mh$ = ecs_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_type", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_table$descriptor() {
        return ecs_get_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_table$handle() {
        return ecs_get_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_table$address() {
        return ecs_get_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_get_table(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_table(MemorySegment world, long entity) {
        var mh$ = ecs_get_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_table", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_type_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_type_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static FunctionDescriptor ecs_type_str$descriptor() {
        return ecs_type_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MethodHandle ecs_type_str$handle() {
        return ecs_type_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MemorySegment ecs_type_str$address() {
        return ecs_type_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_type_str(const ecs_world_t *world, const ecs_type_t *type)
     * }
     */
    public static MemorySegment ecs_type_str(MemorySegment world, MemorySegment type) {
        var mh$ = ecs_type_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_type_str", world, type);
            }
            return (MemorySegment)mh$.invokeExact(world, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_str$descriptor() {
        return ecs_table_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_str$handle() {
        return ecs_table_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_str$address() {
        return ecs_table_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_table_str(const ecs_world_t *world, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_str(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_table_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_str", world, table);
            }
            return (MemorySegment)mh$.invokeExact(world, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_entity_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_entity_str$descriptor() {
        return ecs_entity_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_entity_str$handle() {
        return ecs_entity_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_entity_str$address() {
        return ecs_entity_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_entity_str(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_entity_str(MemorySegment world, long entity) {
        var mh$ = ecs_entity_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_str", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_has_id$descriptor() {
        return ecs_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_has_id$handle() {
        return ecs_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_has_id$address() {
        return ecs_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_has_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static boolean ecs_has_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_has_id", world, entity, id);
            }
            return (boolean)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_owns_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_owns_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_owns_id$descriptor() {
        return ecs_owns_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_owns_id$handle() {
        return ecs_owns_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_owns_id$address() {
        return ecs_owns_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_owns_id(const ecs_world_t *world, ecs_entity_t entity, ecs_id_t id)
     * }
     */
    public static boolean ecs_owns_id(MemorySegment world, long entity, long id) {
        var mh$ = ecs_owns_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_owns_id", world, entity, id);
            }
            return (boolean)mh$.invokeExact(world, entity, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_get_target$descriptor() {
        return ecs_get_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static MethodHandle ecs_get_target$handle() {
        return ecs_get_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static MemorySegment ecs_get_target$address() {
        return ecs_get_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, int32_t index)
     * }
     */
    public static long ecs_get_target(MemorySegment world, long entity, long rel, int index) {
        var mh$ = ecs_get_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_target", world, entity, rel, index);
            }
            return (long)mh$.invokeExact(world, entity, rel, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_parent$descriptor() {
        return ecs_get_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_parent$handle() {
        return ecs_get_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_parent$address() {
        return ecs_get_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_parent(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static long ecs_get_parent(MemorySegment world, long entity) {
        var mh$ = ecs_get_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_parent", world, entity);
            }
            return (long)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_target_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_target_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_target_for_id$descriptor() {
        return ecs_get_target_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_get_target_for_id$handle() {
        return ecs_get_target_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_target_for_id$address() {
        return ecs_get_target_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_target_for_id(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel, ecs_id_t id)
     * }
     */
    public static long ecs_get_target_for_id(MemorySegment world, long entity, long rel, long id) {
        var mh$ = ecs_get_target_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_target_for_id", world, entity, rel, id);
            }
            return (long)mh$.invokeExact(world, entity, rel, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static FunctionDescriptor ecs_get_depth$descriptor() {
        return ecs_get_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static MethodHandle ecs_get_depth$handle() {
        return ecs_get_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static MemorySegment ecs_get_depth$address() {
        return ecs_get_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_get_depth(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t rel)
     * }
     */
    public static int ecs_get_depth(MemorySegment world, long entity, long rel) {
        var mh$ = ecs_get_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_depth", world, entity, rel);
            }
            return (int)mh$.invokeExact(world, entity, rel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_count_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_count_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static FunctionDescriptor ecs_count_id$descriptor() {
        return ecs_count_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static MethodHandle ecs_count_id$handle() {
        return ecs_count_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static MemorySegment ecs_count_id$address() {
        return ecs_count_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_count_id(const ecs_world_t *world, ecs_id_t entity)
     * }
     */
    public static int ecs_count_id(MemorySegment world, long entity) {
        var mh$ = ecs_count_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_count_id", world, entity);
            }
            return (int)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_name$descriptor() {
        return ecs_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_name$handle() {
        return ecs_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_name$address() {
        return ecs_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_name(MemorySegment world, long entity) {
        var mh$ = ecs_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_name", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_get_symbol$descriptor() {
        return ecs_get_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_get_symbol$handle() {
        return ecs_get_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_symbol$address() {
        return ecs_get_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_get_symbol(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_get_symbol(MemorySegment world, long entity) {
        var mh$ = ecs_get_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_symbol", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_set_name$descriptor() {
        return ecs_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MethodHandle ecs_set_name$handle() {
        return ecs_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MemorySegment ecs_set_name$address() {
        return ecs_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static long ecs_set_name(MemorySegment world, long entity, MemorySegment name) {
        var mh$ = ecs_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_name", world, entity, name);
            }
            return (long)mh$.invokeExact(world, entity, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static FunctionDescriptor ecs_set_symbol$descriptor() {
        return ecs_set_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static MethodHandle ecs_set_symbol$handle() {
        return ecs_set_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static MemorySegment ecs_set_symbol$address() {
        return ecs_set_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_symbol(ecs_world_t *world, ecs_entity_t entity, const char *symbol)
     * }
     */
    public static long ecs_set_symbol(MemorySegment world, long entity, MemorySegment symbol) {
        var mh$ = ecs_set_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_symbol", world, entity, symbol);
            }
            return (long)mh$.invokeExact(world, entity, symbol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_alias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_alias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static FunctionDescriptor ecs_set_alias$descriptor() {
        return ecs_set_alias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static MethodHandle ecs_set_alias$handle() {
        return ecs_set_alias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static MemorySegment ecs_set_alias$address() {
        return ecs_set_alias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_alias(ecs_world_t *world, ecs_entity_t entity, const char *alias)
     * }
     */
    public static void ecs_set_alias(MemorySegment world, long entity, MemorySegment alias) {
        var mh$ = ecs_set_alias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_alias", world, entity, alias);
            }
            mh$.invokeExact(world, entity, alias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static FunctionDescriptor ecs_lookup$descriptor() {
        return ecs_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static MethodHandle ecs_lookup$handle() {
        return ecs_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static MemorySegment ecs_lookup$address() {
        return ecs_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup(const ecs_world_t *world, const char *path)
     * }
     */
    public static long ecs_lookup(MemorySegment world, MemorySegment path) {
        var mh$ = ecs_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup", world, path);
            }
            return (long)mh$.invokeExact(world, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_lookup_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_lookup_child$descriptor() {
        return ecs_lookup_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static MethodHandle ecs_lookup_child$handle() {
        return ecs_lookup_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static MemorySegment ecs_lookup_child$address() {
        return ecs_lookup_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_child(const ecs_world_t *world, ecs_entity_t parent, const char *name)
     * }
     */
    public static long ecs_lookup_child(MemorySegment world, long parent, MemorySegment name) {
        var mh$ = ecs_lookup_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_child", world, parent, name);
            }
            return (long)mh$.invokeExact(world, parent, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_lookup_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)
     * }
     */
    public static FunctionDescriptor ecs_lookup_path_w_sep$descriptor() {
        return ecs_lookup_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)
     * }
     */
    public static MethodHandle ecs_lookup_path_w_sep$handle() {
        return ecs_lookup_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)
     * }
     */
    public static MemorySegment ecs_lookup_path_w_sep$address() {
        return ecs_lookup_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix, bool recursive)
     * }
     */
    public static long ecs_lookup_path_w_sep(MemorySegment world, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix, boolean recursive) {
        var mh$ = ecs_lookup_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_path_w_sep", world, parent, path, sep, prefix, recursive);
            }
            return (long)mh$.invokeExact(world, parent, path, sep, prefix, recursive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_lookup_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_BOOL,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_lookup_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, bool lookup_as_path, bool recursive)
     * }
     */
    public static FunctionDescriptor ecs_lookup_symbol$descriptor() {
        return ecs_lookup_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, bool lookup_as_path, bool recursive)
     * }
     */
    public static MethodHandle ecs_lookup_symbol$handle() {
        return ecs_lookup_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, bool lookup_as_path, bool recursive)
     * }
     */
    public static MemorySegment ecs_lookup_symbol$address() {
        return ecs_lookup_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_lookup_symbol(const ecs_world_t *world, const char *symbol, bool lookup_as_path, bool recursive)
     * }
     */
    public static long ecs_lookup_symbol(MemorySegment world, MemorySegment symbol, boolean lookup_as_path, boolean recursive) {
        var mh$ = ecs_lookup_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_lookup_symbol", world, symbol, lookup_as_path, recursive);
            }
            return (long)mh$.invokeExact(world, symbol, lookup_as_path, recursive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_get_path_w_sep$descriptor() {
        return ecs_get_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_get_path_w_sep$handle() {
        return ecs_get_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep$address() {
        return ecs_get_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_get_path_w_sep(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep(MemorySegment world, long parent, long child, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_get_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_path_w_sep", world, parent, child, sep, prefix);
            }
            return (MemorySegment)mh$.invokeExact(world, parent, child, sep, prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_path_w_sep_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_path_w_sep_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_get_path_w_sep_buf$descriptor() {
        return ecs_get_path_w_sep_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_get_path_w_sep_buf$handle() {
        return ecs_get_path_w_sep_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_get_path_w_sep_buf$address() {
        return ecs_get_path_w_sep_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_get_path_w_sep_buf(const ecs_world_t *world, ecs_entity_t parent, ecs_entity_t child, const char *sep, const char *prefix, ecs_strbuf_t *buf)
     * }
     */
    public static void ecs_get_path_w_sep_buf(MemorySegment world, long parent, long child, MemorySegment sep, MemorySegment prefix, MemorySegment buf) {
        var mh$ = ecs_get_path_w_sep_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_path_w_sep_buf", world, parent, child, sep, prefix, buf);
            }
            mh$.invokeExact(world, parent, child, sep, prefix, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_new_from_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_new_from_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_new_from_path_w_sep$descriptor() {
        return ecs_new_from_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_new_from_path_w_sep$handle() {
        return ecs_new_from_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_new_from_path_w_sep$address() {
        return ecs_new_from_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_new_from_path_w_sep(ecs_world_t *world, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static long ecs_new_from_path_w_sep(MemorySegment world, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_new_from_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_new_from_path_w_sep", world, parent, path, sep, prefix);
            }
            return (long)mh$.invokeExact(world, parent, path, sep, prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_add_path_w_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_add_path_w_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_add_path_w_sep$descriptor() {
        return ecs_add_path_w_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MethodHandle ecs_add_path_w_sep$handle() {
        return ecs_add_path_w_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static MemorySegment ecs_add_path_w_sep$address() {
        return ecs_add_path_w_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_add_path_w_sep(ecs_world_t *world, ecs_entity_t entity, ecs_entity_t parent, const char *path, const char *sep, const char *prefix)
     * }
     */
    public static long ecs_add_path_w_sep(MemorySegment world, long entity, long parent, MemorySegment path, MemorySegment sep, MemorySegment prefix) {
        var mh$ = ecs_add_path_w_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_add_path_w_sep", world, entity, parent, path, sep, prefix);
            }
            return (long)mh$.invokeExact(world, entity, parent, path, sep, prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static FunctionDescriptor ecs_set_scope$descriptor() {
        return ecs_set_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static MethodHandle ecs_set_scope$handle() {
        return ecs_set_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static MemorySegment ecs_set_scope$address() {
        return ecs_set_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_scope(ecs_world_t *world, ecs_entity_t scope)
     * }
     */
    public static long ecs_set_scope(MemorySegment world, long scope) {
        var mh$ = ecs_set_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_scope", world, scope);
            }
            return (long)mh$.invokeExact(world, scope);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_scope$descriptor() {
        return ecs_get_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_scope$handle() {
        return ecs_get_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_scope$address() {
        return ecs_get_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_scope(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_scope(MemorySegment world) {
        var mh$ = ecs_get_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_scope", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_name_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_name_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static FunctionDescriptor ecs_set_name_prefix$descriptor() {
        return ecs_set_name_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MethodHandle ecs_set_name_prefix$handle() {
        return ecs_set_name_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MemorySegment ecs_set_name_prefix$address() {
        return ecs_set_name_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_set_name_prefix(ecs_world_t *world, const char *prefix)
     * }
     */
    public static MemorySegment ecs_set_name_prefix(MemorySegment world, MemorySegment prefix) {
        var mh$ = ecs_set_name_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_name_prefix", world, prefix);
            }
            return (MemorySegment)mh$.invokeExact(world, prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_lookup_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_lookup_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static FunctionDescriptor ecs_set_lookup_path$descriptor() {
        return ecs_set_lookup_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MethodHandle ecs_set_lookup_path$handle() {
        return ecs_set_lookup_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MemorySegment ecs_set_lookup_path$address() {
        return ecs_set_lookup_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t *ecs_set_lookup_path(ecs_world_t *world, const ecs_entity_t *lookup_path)
     * }
     */
    public static MemorySegment ecs_set_lookup_path(MemorySegment world, MemorySegment lookup_path) {
        var mh$ = ecs_set_lookup_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_lookup_path", world, lookup_path);
            }
            return (MemorySegment)mh$.invokeExact(world, lookup_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_lookup_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_lookup_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_lookup_path$descriptor() {
        return ecs_get_lookup_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_lookup_path$handle() {
        return ecs_get_lookup_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_lookup_path$address() {
        return ecs_get_lookup_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t *ecs_get_lookup_path(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_lookup_path(MemorySegment world) {
        var mh$ = ecs_get_lookup_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_lookup_path", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_component_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_component_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_component_init$descriptor() {
        return ecs_component_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_component_init$handle() {
        return ecs_component_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_component_init$address() {
        return ecs_component_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_component_init(ecs_world_t *world, const ecs_component_desc_t *desc)
     * }
     */
    public static long ecs_component_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_component_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_component_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_type_info$descriptor() {
        return ecs_get_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_get_type_info$handle() {
        return ecs_get_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_type_info$address() {
        return ecs_get_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_info_t *ecs_get_type_info(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_type_info(MemorySegment world, long id) {
        var mh$ = ecs_get_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_type_info", world, id);
            }
            return (MemorySegment)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_hooks_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_hooks_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t id, const ecs_type_hooks_t *hooks)
     * }
     */
    public static FunctionDescriptor ecs_set_hooks_id$descriptor() {
        return ecs_set_hooks_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t id, const ecs_type_hooks_t *hooks)
     * }
     */
    public static MethodHandle ecs_set_hooks_id$handle() {
        return ecs_set_hooks_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t id, const ecs_type_hooks_t *hooks)
     * }
     */
    public static MemorySegment ecs_set_hooks_id$address() {
        return ecs_set_hooks_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_hooks_id(ecs_world_t *world, ecs_entity_t id, const ecs_type_hooks_t *hooks)
     * }
     */
    public static void ecs_set_hooks_id(MemorySegment world, long id, MemorySegment hooks) {
        var mh$ = ecs_set_hooks_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_hooks_id", world, id, hooks);
            }
            mh$.invokeExact(world, id, hooks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_hooks_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_hooks_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_hooks_id$descriptor() {
        return ecs_get_hooks_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static MethodHandle ecs_get_hooks_id$handle() {
        return ecs_get_hooks_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static MemorySegment ecs_get_hooks_id$address() {
        return ecs_get_hooks_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_hooks_t *ecs_get_hooks_id(const ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static MemorySegment ecs_get_hooks_id(MemorySegment world, long id) {
        var mh$ = ecs_get_hooks_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_hooks_id", world, id);
            }
            return (MemorySegment)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_is_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_is_tag$descriptor() {
        return ecs_id_is_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_is_tag$handle() {
        return ecs_id_is_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_is_tag$address() {
        return ecs_id_is_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_is_tag(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static boolean ecs_id_is_tag(MemorySegment world, long id) {
        var mh$ = ecs_id_is_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_tag", world, id);
            }
            return (boolean)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_in_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_in_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_in_use$descriptor() {
        return ecs_id_in_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_in_use$handle() {
        return ecs_id_in_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_in_use$address() {
        return ecs_id_in_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_in_use(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static boolean ecs_id_in_use(MemorySegment world, long id) {
        var mh$ = ecs_id_in_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_in_use", world, id);
            }
            return (boolean)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_typeid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_typeid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_get_typeid$descriptor() {
        return ecs_get_typeid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_get_typeid$handle() {
        return ecs_get_typeid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_get_typeid$address() {
        return ecs_get_typeid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_typeid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static long ecs_get_typeid(MemorySegment world, long id) {
        var mh$ = ecs_get_typeid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_typeid", world, id);
            }
            return (long)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_match(ecs_id_t id, ecs_id_t pattern)
     * }
     */
    public static FunctionDescriptor ecs_id_match$descriptor() {
        return ecs_id_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_match(ecs_id_t id, ecs_id_t pattern)
     * }
     */
    public static MethodHandle ecs_id_match$handle() {
        return ecs_id_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_match(ecs_id_t id, ecs_id_t pattern)
     * }
     */
    public static MemorySegment ecs_id_match$address() {
        return ecs_id_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_match(ecs_id_t id, ecs_id_t pattern)
     * }
     */
    public static boolean ecs_id_match(long id, long pattern) {
        var mh$ = ecs_id_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_match", id, pattern);
            }
            return (boolean)mh$.invokeExact(id, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_pair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_is_pair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_is_pair(ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_is_pair$descriptor() {
        return ecs_id_is_pair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_is_pair(ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_is_pair$handle() {
        return ecs_id_is_pair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_is_pair(ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_is_pair$address() {
        return ecs_id_is_pair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_is_pair(ecs_id_t id)
     * }
     */
    public static boolean ecs_id_is_pair(long id) {
        var mh$ = ecs_id_is_pair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_pair", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_wildcard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_is_wildcard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_is_wildcard(ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_is_wildcard$descriptor() {
        return ecs_id_is_wildcard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_is_wildcard(ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_is_wildcard$handle() {
        return ecs_id_is_wildcard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_is_wildcard(ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_is_wildcard$address() {
        return ecs_id_is_wildcard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_is_wildcard(ecs_id_t id)
     * }
     */
    public static boolean ecs_id_is_wildcard(long id) {
        var mh$ = ecs_id_is_wildcard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_wildcard", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_is_valid$descriptor() {
        return ecs_id_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_is_valid$handle() {
        return ecs_id_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_is_valid$address() {
        return ecs_id_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_id_is_valid(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static boolean ecs_id_is_valid(MemorySegment world, long id) {
        var mh$ = ecs_id_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_is_valid", world, id);
            }
            return (boolean)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_get_flags$descriptor() {
        return ecs_id_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_get_flags$handle() {
        return ecs_id_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_get_flags$address() {
        return ecs_id_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_flags32_t ecs_id_get_flags(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static int ecs_id_get_flags(MemorySegment world, long id) {
        var mh$ = ecs_id_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_get_flags", world, id);
            }
            return (int)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_flag_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_flag_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t id_flags)
     * }
     */
    public static FunctionDescriptor ecs_id_flag_str$descriptor() {
        return ecs_id_flag_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t id_flags)
     * }
     */
    public static MethodHandle ecs_id_flag_str$handle() {
        return ecs_id_flag_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t id_flags)
     * }
     */
    public static MemorySegment ecs_id_flag_str$address() {
        return ecs_id_flag_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_id_flag_str(ecs_id_t id_flags)
     * }
     */
    public static MemorySegment ecs_id_flag_str(long id_flags) {
        var mh$ = ecs_id_flag_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_flag_str", id_flags);
            }
            return (MemorySegment)mh$.invokeExact(id_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_id_str$descriptor() {
        return ecs_id_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_id_str$handle() {
        return ecs_id_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_str$address() {
        return ecs_id_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_id_str(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_id_str(MemorySegment world, long id) {
        var mh$ = ecs_id_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_str", world, id);
            }
            return (MemorySegment)mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_str_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_str_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t id, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_id_str_buf$descriptor() {
        return ecs_id_str_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t id, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_id_str_buf$handle() {
        return ecs_id_str_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t id, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_id_str_buf$address() {
        return ecs_id_str_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_id_str_buf(const ecs_world_t *world, ecs_id_t id, ecs_strbuf_t *buf)
     * }
     */
    public static void ecs_id_str_buf(MemorySegment world, long id, MemorySegment buf) {
        var mh$ = ecs_id_str_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_str_buf", world, id, buf);
            }
            mh$.invokeExact(world, id, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_id_from_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_id_from_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static FunctionDescriptor ecs_id_from_str$descriptor() {
        return ecs_id_from_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static MethodHandle ecs_id_from_str$handle() {
        return ecs_id_from_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static MemorySegment ecs_id_from_str$address() {
        return ecs_id_from_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_id_from_str(const ecs_world_t *world, const char *expr)
     * }
     */
    public static long ecs_id_from_str(MemorySegment world, MemorySegment expr) {
        var mh$ = ecs_id_from_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_id_from_str", world, expr);
            }
            return (long)mh$.invokeExact(world, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_ref_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_term_ref_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_term_ref_is_set(const ecs_term_ref_t *id)
     * }
     */
    public static FunctionDescriptor ecs_term_ref_is_set$descriptor() {
        return ecs_term_ref_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_term_ref_is_set(const ecs_term_ref_t *id)
     * }
     */
    public static MethodHandle ecs_term_ref_is_set$handle() {
        return ecs_term_ref_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_term_ref_is_set(const ecs_term_ref_t *id)
     * }
     */
    public static MemorySegment ecs_term_ref_is_set$address() {
        return ecs_term_ref_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_term_ref_is_set(const ecs_term_ref_t *id)
     * }
     */
    public static boolean ecs_term_ref_is_set(MemorySegment id) {
        var mh$ = ecs_term_ref_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_ref_is_set", id);
            }
            return (boolean)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_is_initialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_term_is_initialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_is_initialized$descriptor() {
        return ecs_term_is_initialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_is_initialized$handle() {
        return ecs_term_is_initialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_is_initialized$address() {
        return ecs_term_is_initialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_term_is_initialized(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_is_initialized(MemorySegment term) {
        var mh$ = ecs_term_is_initialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_is_initialized", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_match_this {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_term_match_this");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_match_this$descriptor() {
        return ecs_term_match_this.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_match_this$handle() {
        return ecs_term_match_this.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_match_this$address() {
        return ecs_term_match_this.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_term_match_this(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_match_this(MemorySegment term) {
        var mh$ = ecs_term_match_this.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_match_this", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_match_0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_term_match_0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_match_0$descriptor() {
        return ecs_term_match_0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_match_0$handle() {
        return ecs_term_match_0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_match_0$address() {
        return ecs_term_match_0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_term_match_0(const ecs_term_t *term)
     * }
     */
    public static boolean ecs_term_match_0(MemorySegment term) {
        var mh$ = ecs_term_match_0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_match_0", term);
            }
            return (boolean)mh$.invokeExact(term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_term_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_term_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static FunctionDescriptor ecs_term_str$descriptor() {
        return ecs_term_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MethodHandle ecs_term_str$handle() {
        return ecs_term_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_str$address() {
        return ecs_term_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_term_str(const ecs_world_t *world, const ecs_term_t *term)
     * }
     */
    public static MemorySegment ecs_term_str(MemorySegment world, MemorySegment term) {
        var mh$ = ecs_term_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_term_str", world, term);
            }
            return (MemorySegment)mh$.invokeExact(world, term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_str$descriptor() {
        return ecs_query_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_str$handle() {
        return ecs_query_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_str$address() {
        return ecs_query_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_str(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_str(MemorySegment query) {
        var mh$ = ecs_query_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_str", query);
            }
            return (MemorySegment)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_each_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_each_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_each_id$descriptor() {
        return ecs_each_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_each_id$handle() {
        return ecs_each_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_each_id$address() {
        return ecs_each_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_each_id(const ecs_world_t *world, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_each_id(SegmentAllocator allocator, MemorySegment world, long id) {
        var mh$ = ecs_each_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_each_id", allocator, world, id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_each_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_each_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_each_next$descriptor() {
        return ecs_each_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_each_next$handle() {
        return ecs_each_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_each_next$address() {
        return ecs_each_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_each_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_each_next(MemorySegment it) {
        var mh$ = ecs_each_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_each_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static FunctionDescriptor ecs_children$descriptor() {
        return ecs_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MethodHandle ecs_children$handle() {
        return ecs_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children$address() {
        return ecs_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_children(const ecs_world_t *world, ecs_entity_t parent)
     * }
     */
    public static MemorySegment ecs_children(SegmentAllocator allocator, MemorySegment world, long parent) {
        var mh$ = ecs_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_children", allocator, world, parent);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, parent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_children_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_children_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_children_next$descriptor() {
        return ecs_children_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_children_next$handle() {
        return ecs_children_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_children_next$address() {
        return ecs_children_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_children_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_children_next(MemorySegment it) {
        var mh$ = ecs_children_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_children_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_query_init$descriptor() {
        return ecs_query_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_query_init$handle() {
        return ecs_query_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_query_init$address() {
        return ecs_query_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_query_t *ecs_query_init(ecs_world_t *world, const ecs_query_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_query_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_query_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_init", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_fini$descriptor() {
        return ecs_query_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_fini$handle() {
        return ecs_query_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_fini$address() {
        return ecs_query_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_fini(ecs_query_t *query)
     * }
     */
    public static void ecs_query_fini(MemorySegment query) {
        var mh$ = ecs_query_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_fini", query);
            }
            mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_find_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_find_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_query_find_var$descriptor() {
        return ecs_query_find_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static MethodHandle ecs_query_find_var$handle() {
        return ecs_query_find_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static MemorySegment ecs_query_find_var$address() {
        return ecs_query_find_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_query_find_var(const ecs_query_t *query, const char *name)
     * }
     */
    public static int ecs_query_find_var(MemorySegment query, MemorySegment name) {
        var mh$ = ecs_query_find_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_find_var", query, name);
            }
            return (int)mh$.invokeExact(query, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_var_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_var_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_query_var_name$descriptor() {
        return ecs_query_var_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_query_var_name$handle() {
        return ecs_query_var_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_name$address() {
        return ecs_query_var_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_query_var_name(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_name(MemorySegment query, int var_id) {
        var mh$ = ecs_query_var_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_var_name", query, var_id);
            }
            return (MemorySegment)mh$.invokeExact(query, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_var_is_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_var_is_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_query_var_is_entity$descriptor() {
        return ecs_query_var_is_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_query_var_is_entity$handle() {
        return ecs_query_var_is_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_query_var_is_entity$address() {
        return ecs_query_var_is_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_var_is_entity(const ecs_query_t *query, int32_t var_id)
     * }
     */
    public static boolean ecs_query_var_is_entity(MemorySegment query, int var_id) {
        var mh$ = ecs_query_var_is_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_var_is_entity", query, var_id);
            }
            return (boolean)mh$.invokeExact(query, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_iter$descriptor() {
        return ecs_query_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_iter$handle() {
        return ecs_query_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_iter$address() {
        return ecs_query_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_query_iter(const ecs_world_t *world, const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_iter(SegmentAllocator allocator, MemorySegment world, MemorySegment query) {
        var mh$ = ecs_query_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_iter", allocator, world, query);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_next$descriptor() {
        return ecs_query_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_next$handle() {
        return ecs_query_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_next$address() {
        return ecs_query_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_next(MemorySegment it) {
        var mh$ = ecs_query_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_has");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has$descriptor() {
        return ecs_query_has.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has$handle() {
        return ecs_query_has.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has$address() {
        return ecs_query_has.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_has(ecs_query_t *query, ecs_entity_t entity, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has(MemorySegment query, long entity, MemorySegment it) {
        var mh$ = ecs_query_has.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has", query, entity, it);
            }
            return (boolean)mh$.invokeExact(query, entity, it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_has_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has_table$descriptor() {
        return ecs_query_has_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has_table$handle() {
        return ecs_query_has_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has_table$address() {
        return ecs_query_has_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_has_table(ecs_query_t *query, ecs_table_t *table, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has_table(MemorySegment query, MemorySegment table, MemorySegment it) {
        var mh$ = ecs_query_has_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has_table", query, table, it);
            }
            return (boolean)mh$.invokeExact(query, table, it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_has_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_has_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_has_range$descriptor() {
        return ecs_query_has_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_has_range$handle() {
        return ecs_query_has_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_has_range$address() {
        return ecs_query_has_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_has_range(ecs_query_t *query, ecs_table_range_t *range, ecs_iter_t *it)
     * }
     */
    public static boolean ecs_query_has_range(MemorySegment query, MemorySegment range, MemorySegment it) {
        var mh$ = ecs_query_has_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_has_range", query, range, it);
            }
            return (boolean)mh$.invokeExact(query, range, it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_match_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_match_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_match_count$descriptor() {
        return ecs_query_match_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_match_count$handle() {
        return ecs_query_match_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_match_count$address() {
        return ecs_query_match_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_query_match_count(const ecs_query_t *query)
     * }
     */
    public static int ecs_query_match_count(MemorySegment query) {
        var mh$ = ecs_query_match_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_match_count", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_plan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_plan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_plan$descriptor() {
        return ecs_query_plan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_plan$handle() {
        return ecs_query_plan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_plan$address() {
        return ecs_query_plan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_plan(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_plan(MemorySegment query) {
        var mh$ = ecs_query_plan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_plan", query);
            }
            return (MemorySegment)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_plan_w_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_plan_w_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_query_plan_w_profile$descriptor() {
        return ecs_query_plan_w_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_query_plan_w_profile$handle() {
        return ecs_query_plan_w_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_plan_w_profile$address() {
        return ecs_query_plan_w_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_query_plan_w_profile(const ecs_query_t *query, const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_query_plan_w_profile(MemorySegment query, MemorySegment it) {
        var mh$ = ecs_query_plan_w_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_plan_w_profile", query, it);
            }
            return (MemorySegment)mh$.invokeExact(query, it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_args_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_args_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static FunctionDescriptor ecs_query_args_parse$descriptor() {
        return ecs_query_args_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MethodHandle ecs_query_args_parse$handle() {
        return ecs_query_args_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MemorySegment ecs_query_args_parse$address() {
        return ecs_query_args_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_query_args_parse(ecs_query_t *query, ecs_iter_t *it, const char *expr)
     * }
     */
    public static MemorySegment ecs_query_args_parse(MemorySegment query, MemorySegment it, MemorySegment expr) {
        var mh$ = ecs_query_args_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_args_parse", query, it, expr);
            }
            return (MemorySegment)mh$.invokeExact(query, it, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_changed$descriptor() {
        return ecs_query_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_changed$handle() {
        return ecs_query_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_changed$address() {
        return ecs_query_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_changed(ecs_query_t *query)
     * }
     */
    public static boolean ecs_query_changed(MemorySegment query) {
        var mh$ = ecs_query_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_changed", query);
            }
            return (boolean)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_skip$descriptor() {
        return ecs_iter_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_skip$handle() {
        return ecs_iter_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_skip$address() {
        return ecs_iter_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_skip(ecs_iter_t *it)
     * }
     */
    public static void ecs_iter_skip(MemorySegment it) {
        var mh$ = ecs_iter_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_skip", it);
            }
            mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_set_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_group$descriptor() {
        return ecs_iter_set_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_iter_set_group$handle() {
        return ecs_iter_set_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_iter_set_group$address() {
        return ecs_iter_set_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_group(ecs_iter_t *it, uint64_t group_id)
     * }
     */
    public static void ecs_iter_set_group(MemorySegment it, long group_id) {
        var mh$ = ecs_iter_set_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_group", it, group_id);
            }
            mh$.invokeExact(it, group_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get_group_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_get_group_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_query_get_group_ctx$descriptor() {
        return ecs_query_get_group_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_query_get_group_ctx$handle() {
        return ecs_query_get_group_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_ctx$address() {
        return ecs_query_get_group_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_query_get_group_ctx(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_ctx(MemorySegment query, long group_id) {
        var mh$ = ecs_query_get_group_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get_group_ctx", query, group_id);
            }
            return (MemorySegment)mh$.invokeExact(query, group_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_get_group_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_get_group_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static FunctionDescriptor ecs_query_get_group_info$descriptor() {
        return ecs_query_get_group_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MethodHandle ecs_query_get_group_info$handle() {
        return ecs_query_get_group_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_info$address() {
        return ecs_query_get_group_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_query_group_info_t *ecs_query_get_group_info(const ecs_query_t *query, uint64_t group_id)
     * }
     */
    public static MemorySegment ecs_query_get_group_info(MemorySegment query, long group_id) {
        var mh$ = ecs_query_get_group_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_get_group_info", query, group_id);
            }
            return (MemorySegment)mh$.invokeExact(query, group_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_query_count_t.layout(),
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_count$descriptor() {
        return ecs_query_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_count$handle() {
        return ecs_query_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_count$address() {
        return ecs_query_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_query_count_t ecs_query_count(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_count(SegmentAllocator allocator, MemorySegment query) {
        var mh$ = ecs_query_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_count", allocator, query);
            }
            return (MemorySegment)mh$.invokeExact(allocator, query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_is_true {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_is_true");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static FunctionDescriptor ecs_query_is_true$descriptor() {
        return ecs_query_is_true.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static MethodHandle ecs_query_is_true$handle() {
        return ecs_query_is_true.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static MemorySegment ecs_query_is_true$address() {
        return ecs_query_is_true.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_query_is_true(const ecs_query_t *query)
     * }
     */
    public static boolean ecs_query_is_true(MemorySegment query) {
        var mh$ = ecs_query_is_true.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_is_true", query);
            }
            return (boolean)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_emit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_emit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_emit$descriptor() {
        return ecs_emit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_emit$handle() {
        return ecs_emit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_emit$address() {
        return ecs_emit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_emit(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static void ecs_emit(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_emit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_emit", world, desc);
            }
            mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_enqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_enqueue$descriptor() {
        return ecs_enqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_enqueue$handle() {
        return ecs_enqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_enqueue$address() {
        return ecs_enqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_enqueue(ecs_world_t *world, ecs_event_desc_t *desc)
     * }
     */
    public static void ecs_enqueue(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_enqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enqueue", world, desc);
            }
            mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_observer_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_observer_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_observer_init$descriptor() {
        return ecs_observer_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_observer_init$handle() {
        return ecs_observer_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_observer_init$address() {
        return ecs_observer_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_observer_init(ecs_world_t *world, const ecs_observer_desc_t *desc)
     * }
     */
    public static long ecs_observer_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_observer_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_observer_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_observer_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_observer_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static FunctionDescriptor ecs_observer_get$descriptor() {
        return ecs_observer_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MethodHandle ecs_observer_get$handle() {
        return ecs_observer_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MemorySegment ecs_observer_get$address() {
        return ecs_observer_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_observer_t *ecs_observer_get(const ecs_world_t *world, ecs_entity_t observer)
     * }
     */
    public static MemorySegment ecs_observer_get(MemorySegment world, long observer) {
        var mh$ = ecs_observer_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_observer_get", world, observer);
            }
            return (MemorySegment)mh$.invokeExact(world, observer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_next$descriptor() {
        return ecs_iter_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_next$handle() {
        return ecs_iter_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_next$address() {
        return ecs_iter_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_iter_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_next(MemorySegment it) {
        var mh$ = ecs_iter_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_fini$descriptor() {
        return ecs_iter_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_fini$handle() {
        return ecs_iter_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_fini$address() {
        return ecs_iter_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_fini(ecs_iter_t *it)
     * }
     */
    public static void ecs_iter_fini(MemorySegment it) {
        var mh$ = ecs_iter_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_fini", it);
            }
            mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_count$descriptor() {
        return ecs_iter_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_count$handle() {
        return ecs_iter_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_count$address() {
        return ecs_iter_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_iter_count(ecs_iter_t *it)
     * }
     */
    public static int ecs_iter_count(MemorySegment it) {
        var mh$ = ecs_iter_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_count", it);
            }
            return (int)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_is_true {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_is_true");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_is_true$descriptor() {
        return ecs_iter_is_true.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_is_true$handle() {
        return ecs_iter_is_true.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_is_true$address() {
        return ecs_iter_is_true.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_iter_is_true(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_is_true(MemorySegment it) {
        var mh$ = ecs_iter_is_true.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_is_true", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_first$descriptor() {
        return ecs_iter_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_first$handle() {
        return ecs_iter_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_first$address() {
        return ecs_iter_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_first(ecs_iter_t *it)
     * }
     */
    public static long ecs_iter_first(MemorySegment it) {
        var mh$ = ecs_iter_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_first", it);
            }
            return (long)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_set_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var$descriptor() {
        return ecs_iter_set_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_iter_set_var$handle() {
        return ecs_iter_set_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_iter_set_var$address() {
        return ecs_iter_set_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var(ecs_iter_t *it, int32_t var_id, ecs_entity_t entity)
     * }
     */
    public static void ecs_iter_set_var(MemorySegment it, int var_id, long entity) {
        var mh$ = ecs_iter_set_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var", it, var_id, entity);
            }
            mh$.invokeExact(it, var_id, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var_as_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_set_var_as_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var_as_table$descriptor() {
        return ecs_iter_set_var_as_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_iter_set_var_as_table$handle() {
        return ecs_iter_set_var_as_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_iter_set_var_as_table$address() {
        return ecs_iter_set_var_as_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_table(ecs_iter_t *it, int32_t var_id, const ecs_table_t *table)
     * }
     */
    public static void ecs_iter_set_var_as_table(MemorySegment it, int var_id, MemorySegment table) {
        var mh$ = ecs_iter_set_var_as_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var_as_table", it, var_id, table);
            }
            mh$.invokeExact(it, var_id, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_set_var_as_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_set_var_as_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static FunctionDescriptor ecs_iter_set_var_as_range$descriptor() {
        return ecs_iter_set_var_as_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static MethodHandle ecs_iter_set_var_as_range$handle() {
        return ecs_iter_set_var_as_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static MemorySegment ecs_iter_set_var_as_range$address() {
        return ecs_iter_set_var_as_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_iter_set_var_as_range(ecs_iter_t *it, int32_t var_id, const ecs_table_range_t *range)
     * }
     */
    public static void ecs_iter_set_var_as_range(MemorySegment it, int var_id, MemorySegment range) {
        var mh$ = ecs_iter_set_var_as_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_set_var_as_range", it, var_id, range);
            }
            mh$.invokeExact(it, var_id, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_get_var");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var$descriptor() {
        return ecs_iter_get_var.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var$handle() {
        return ecs_iter_get_var.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var$address() {
        return ecs_iter_get_var.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_iter_get_var(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static long ecs_iter_get_var(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var", it, var_id);
            }
            return (long)mh$.invokeExact(it, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_as_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_get_var_as_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_as_table$descriptor() {
        return ecs_iter_get_var_as_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var_as_table$handle() {
        return ecs_iter_get_var_as_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_table$address() {
        return ecs_iter_get_var_as_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_iter_get_var_as_table(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_table(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var_as_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_as_table", it, var_id);
            }
            return (MemorySegment)mh$.invokeExact(it, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_get_var_as_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_table_range_t.layout(),
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_get_var_as_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_get_var_as_range$descriptor() {
        return ecs_iter_get_var_as_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_get_var_as_range$handle() {
        return ecs_iter_get_var_as_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_range$address() {
        return ecs_iter_get_var_as_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_range_t ecs_iter_get_var_as_range(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_get_var_as_range(SegmentAllocator allocator, MemorySegment it, int var_id) {
        var mh$ = ecs_iter_get_var_as_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_get_var_as_range", allocator, it, var_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_var_is_constrained {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_var_is_constrained");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static FunctionDescriptor ecs_iter_var_is_constrained$descriptor() {
        return ecs_iter_var_is_constrained.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MethodHandle ecs_iter_var_is_constrained$handle() {
        return ecs_iter_var_is_constrained.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static MemorySegment ecs_iter_var_is_constrained$address() {
        return ecs_iter_var_is_constrained.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_iter_var_is_constrained(ecs_iter_t *it, int32_t var_id)
     * }
     */
    public static boolean ecs_iter_var_is_constrained(MemorySegment it, int var_id) {
        var mh$ = ecs_iter_var_is_constrained.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_var_is_constrained", it, var_id);
            }
            return (boolean)mh$.invokeExact(it, var_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_changed$descriptor() {
        return ecs_iter_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_changed$handle() {
        return ecs_iter_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_changed$address() {
        return ecs_iter_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_iter_changed(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_iter_changed(MemorySegment it) {
        var mh$ = ecs_iter_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_changed", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_iter_str$descriptor() {
        return ecs_iter_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_iter_str$handle() {
        return ecs_iter_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_str$address() {
        return ecs_iter_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_iter_str(const ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_iter_str(MemorySegment it) {
        var mh$ = ecs_iter_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_str", it);
            }
            return (MemorySegment)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_page_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_page_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static FunctionDescriptor ecs_page_iter$descriptor() {
        return ecs_page_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MethodHandle ecs_page_iter$handle() {
        return ecs_page_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MemorySegment ecs_page_iter$address() {
        return ecs_page_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_page_iter(const ecs_iter_t *it, int32_t offset, int32_t limit)
     * }
     */
    public static MemorySegment ecs_page_iter(SegmentAllocator allocator, MemorySegment it, int offset, int limit) {
        var mh$ = ecs_page_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_page_iter", allocator, it, offset, limit);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, offset, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_page_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_page_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_page_next$descriptor() {
        return ecs_page_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_page_next$handle() {
        return ecs_page_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_page_next$address() {
        return ecs_page_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_page_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_page_next(MemorySegment it) {
        var mh$ = ecs_page_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_page_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_worker_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_iter_t.layout(),
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_worker_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_worker_iter$descriptor() {
        return ecs_worker_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MethodHandle ecs_worker_iter$handle() {
        return ecs_worker_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MemorySegment ecs_worker_iter$address() {
        return ecs_worker_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_iter_t ecs_worker_iter(const ecs_iter_t *it, int32_t index, int32_t count)
     * }
     */
    public static MemorySegment ecs_worker_iter(SegmentAllocator allocator, MemorySegment it, int index, int count) {
        var mh$ = ecs_worker_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_worker_iter", allocator, it, index, count);
            }
            return (MemorySegment)mh$.invokeExact(allocator, it, index, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_worker_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_worker_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor ecs_worker_next$descriptor() {
        return ecs_worker_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static MethodHandle ecs_worker_next$handle() {
        return ecs_worker_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static MemorySegment ecs_worker_next$address() {
        return ecs_worker_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_worker_next(ecs_iter_t *it)
     * }
     */
    public static boolean ecs_worker_next(MemorySegment it) {
        var mh$ = ecs_worker_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_worker_next", it);
            }
            return (boolean)mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_w_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_w_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_w_size$descriptor() {
        return ecs_field_w_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_w_size$handle() {
        return ecs_field_w_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_w_size$address() {
        return ecs_field_w_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_field_w_size(const ecs_iter_t *it, size_t size, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_w_size(MemorySegment it, long size, byte index) {
        var mh$ = ecs_field_w_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_w_size", it, size, index);
            }
            return (MemorySegment)mh$.invokeExact(it, size, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_at_w_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_CHAR,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_at_w_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static FunctionDescriptor ecs_field_at_w_size$descriptor() {
        return ecs_field_at_w_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MethodHandle ecs_field_at_w_size$handle() {
        return ecs_field_at_w_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MemorySegment ecs_field_at_w_size$address() {
        return ecs_field_at_w_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_field_at_w_size(const ecs_iter_t *it, size_t size, int8_t index, int32_t row)
     * }
     */
    public static MemorySegment ecs_field_at_w_size(MemorySegment it, long size, byte index, int row) {
        var mh$ = ecs_field_at_w_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_at_w_size", it, size, index, row);
            }
            return (MemorySegment)mh$.invokeExact(it, size, index, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_is_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_readonly$descriptor() {
        return ecs_field_is_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_readonly$handle() {
        return ecs_field_is_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_readonly$address() {
        return ecs_field_is_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_field_is_readonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_readonly(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_readonly", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_writeonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_is_writeonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_writeonly$descriptor() {
        return ecs_field_is_writeonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_writeonly$handle() {
        return ecs_field_is_writeonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_writeonly$address() {
        return ecs_field_is_writeonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_field_is_writeonly(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_writeonly(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_writeonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_writeonly", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_set$descriptor() {
        return ecs_field_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_set$handle() {
        return ecs_field_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_set$address() {
        return ecs_field_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_field_is_set(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_set(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_set", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_id$descriptor() {
        return ecs_field_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_id$handle() {
        return ecs_field_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_id$address() {
        return ecs_field_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_field_id(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_id(MemorySegment it, byte index) {
        var mh$ = ecs_field_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_id", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_column$descriptor() {
        return ecs_field_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_column$handle() {
        return ecs_field_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_column$address() {
        return ecs_field_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_field_column(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static int ecs_field_column(MemorySegment it, byte index) {
        var mh$ = ecs_field_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_column", it, index);
            }
            return (int)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_src {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_src");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_src$descriptor() {
        return ecs_field_src.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_src$handle() {
        return ecs_field_src.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_src$address() {
        return ecs_field_src.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_field_src(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_src(MemorySegment it, byte index) {
        var mh$ = ecs_field_src.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_src", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_size$descriptor() {
        return ecs_field_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_size$handle() {
        return ecs_field_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_size$address() {
        return ecs_field_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t ecs_field_size(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static long ecs_field_size(MemorySegment it, byte index) {
        var mh$ = ecs_field_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_size", it, index);
            }
            return (long)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_field_is_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_field_is_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static FunctionDescriptor ecs_field_is_self$descriptor() {
        return ecs_field_is_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MethodHandle ecs_field_is_self$handle() {
        return ecs_field_is_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static MemorySegment ecs_field_is_self$address() {
        return ecs_field_is_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_field_is_self(const ecs_iter_t *it, int8_t index)
     * }
     */
    public static boolean ecs_field_is_self(MemorySegment it, byte index) {
        var mh$ = ecs_field_is_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_field_is_self", it, index);
            }
            return (boolean)mh$.invokeExact(it, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_get_type$descriptor() {
        return ecs_table_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_get_type$handle() {
        return ecs_table_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_get_type$address() {
        return ecs_table_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_type_t *ecs_table_get_type(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_get_type(MemorySegment table) {
        var mh$ = ecs_table_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_type", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_type_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_type_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_table_get_type_index$descriptor() {
        return ecs_table_get_type_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_table_get_type_index$handle() {
        return ecs_table_get_type_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_get_type_index$address() {
        return ecs_table_get_type_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_type_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static int ecs_table_get_type_index(MemorySegment world, MemorySegment table, long id) {
        var mh$ = ecs_table_get_type_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_type_index", world, table, id);
            }
            return (int)mh$.invokeExact(world, table, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_column_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column_index$descriptor() {
        return ecs_table_get_column_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_table_get_column_index$handle() {
        return ecs_table_get_column_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_get_column_index$address() {
        return ecs_table_get_column_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_column_index(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static int ecs_table_get_column_index(MemorySegment world, MemorySegment table, long id) {
        var mh$ = ecs_table_get_column_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column_index", world, table, id);
            }
            return (int)mh$.invokeExact(world, table, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_column_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_column_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_column_count$descriptor() {
        return ecs_table_column_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_column_count$handle() {
        return ecs_table_column_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_column_count$address() {
        return ecs_table_column_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_column_count(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_column_count(MemorySegment table) {
        var mh$ = ecs_table_column_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_column_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_type_to_column_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_type_to_column_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_type_to_column_index$descriptor() {
        return ecs_table_type_to_column_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_type_to_column_index$handle() {
        return ecs_table_type_to_column_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_type_to_column_index$address() {
        return ecs_table_type_to_column_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_type_to_column_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static int ecs_table_type_to_column_index(MemorySegment table, int index) {
        var mh$ = ecs_table_type_to_column_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_type_to_column_index", table, index);
            }
            return (int)mh$.invokeExact(table, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_column_to_type_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_column_to_type_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_column_to_type_index$descriptor() {
        return ecs_table_column_to_type_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_column_to_type_index$handle() {
        return ecs_table_column_to_type_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_column_to_type_index$address() {
        return ecs_table_column_to_type_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_column_to_type_index(const ecs_table_t *table, int32_t index)
     * }
     */
    public static int ecs_table_column_to_type_index(MemorySegment table, int index) {
        var mh$ = ecs_table_column_to_type_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_column_to_type_index", table, index);
            }
            return (int)mh$.invokeExact(table, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_column");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column$descriptor() {
        return ecs_table_get_column.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MethodHandle ecs_table_get_column$handle() {
        return ecs_table_get_column.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_column$address() {
        return ecs_table_get_column.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_table_get_column(const ecs_table_t *table, int32_t index, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_column(MemorySegment table, int index, int offset) {
        var mh$ = ecs_table_get_column.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column", table, index, offset);
            }
            return (MemorySegment)mh$.invokeExact(table, index, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, int32_t offset)
     * }
     */
    public static FunctionDescriptor ecs_table_get_id$descriptor() {
        return ecs_table_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, int32_t offset)
     * }
     */
    public static MethodHandle ecs_table_get_id$handle() {
        return ecs_table_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_id$address() {
        return ecs_table_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_table_get_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, int32_t offset)
     * }
     */
    public static MemorySegment ecs_table_get_id(MemorySegment world, MemorySegment table, long id, int offset) {
        var mh$ = ecs_table_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_id", world, table, id, offset);
            }
            return (MemorySegment)mh$.invokeExact(world, table, id, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_column_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_column_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static FunctionDescriptor ecs_table_get_column_size$descriptor() {
        return ecs_table_get_column_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MethodHandle ecs_table_get_column_size$handle() {
        return ecs_table_get_column_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static MemorySegment ecs_table_get_column_size$address() {
        return ecs_table_get_column_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t ecs_table_get_column_size(const ecs_table_t *table, int32_t index)
     * }
     */
    public static long ecs_table_get_column_size(MemorySegment table, int index) {
        var mh$ = ecs_table_get_column_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_column_size", table, index);
            }
            return (long)mh$.invokeExact(table, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_count$descriptor() {
        return ecs_table_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_count$handle() {
        return ecs_table_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_count$address() {
        return ecs_table_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_count(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_count(MemorySegment table) {
        var mh$ = ecs_table_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_count", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_size$descriptor() {
        return ecs_table_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_size$handle() {
        return ecs_table_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_size$address() {
        return ecs_table_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_size(const ecs_table_t *table)
     * }
     */
    public static int ecs_table_size(MemorySegment table) {
        var mh$ = ecs_table_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_size", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_entities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_entities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_entities$descriptor() {
        return ecs_table_entities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_entities$handle() {
        return ecs_table_entities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_entities$address() {
        return ecs_table_entities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_entity_t *ecs_table_entities(const ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_entities(MemorySegment table) {
        var mh$ = ecs_table_entities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_entities", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_has_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_has_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_table_has_id$descriptor() {
        return ecs_table_has_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_table_has_id$handle() {
        return ecs_table_has_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_has_id$address() {
        return ecs_table_has_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_table_has_id(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static boolean ecs_table_has_id(MemorySegment world, MemorySegment table, long id) {
        var mh$ = ecs_table_has_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_has_id", world, table, id);
            }
            return (boolean)mh$.invokeExact(world, table, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_get_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_get_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static FunctionDescriptor ecs_table_get_depth$descriptor() {
        return ecs_table_get_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static MethodHandle ecs_table_get_depth$handle() {
        return ecs_table_get_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static MemorySegment ecs_table_get_depth$address() {
        return ecs_table_get_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_table_get_depth(const ecs_world_t *world, const ecs_table_t *table, ecs_entity_t rel)
     * }
     */
    public static int ecs_table_get_depth(MemorySegment world, MemorySegment table, long rel) {
        var mh$ = ecs_table_get_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_get_depth", world, table, rel);
            }
            return (int)mh$.invokeExact(world, table, rel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_add_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_add_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_table_add_id$descriptor() {
        return ecs_table_add_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_table_add_id$handle() {
        return ecs_table_add_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_add_id$address() {
        return ecs_table_add_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_add_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_add_id(MemorySegment world, MemorySegment table, long id) {
        var mh$ = ecs_table_add_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_add_id", world, table, id);
            }
            return (MemorySegment)mh$.invokeExact(world, table, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static FunctionDescriptor ecs_table_find$descriptor() {
        return ecs_table_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MethodHandle ecs_table_find$handle() {
        return ecs_table_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MemorySegment ecs_table_find$address() {
        return ecs_table_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_find(ecs_world_t *world, const ecs_id_t *ids, int32_t id_count)
     * }
     */
    public static MemorySegment ecs_table_find(MemorySegment world, MemorySegment ids, int id_count) {
        var mh$ = ecs_table_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_find", world, ids, id_count);
            }
            return (MemorySegment)mh$.invokeExact(world, ids, id_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_remove_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_remove_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static FunctionDescriptor ecs_table_remove_id$descriptor() {
        return ecs_table_remove_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MethodHandle ecs_table_remove_id$handle() {
        return ecs_table_remove_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_remove_id$address() {
        return ecs_table_remove_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_table_t *ecs_table_remove_id(ecs_world_t *world, ecs_table_t *table, ecs_id_t id)
     * }
     */
    public static MemorySegment ecs_table_remove_id(MemorySegment world, MemorySegment table, long id) {
        var mh$ = ecs_table_remove_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_remove_id", world, table, id);
            }
            return (MemorySegment)mh$.invokeExact(world, table, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_lock$descriptor() {
        return ecs_table_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_lock$handle() {
        return ecs_table_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_lock$address() {
        return ecs_table_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_table_lock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static void ecs_table_lock(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_table_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_lock", world, table);
            }
            mh$.invokeExact(world, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_table_unlock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static FunctionDescriptor ecs_table_unlock$descriptor() {
        return ecs_table_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_table_unlock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MethodHandle ecs_table_unlock$handle() {
        return ecs_table_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_table_unlock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static MemorySegment ecs_table_unlock$address() {
        return ecs_table_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_table_unlock(ecs_world_t *world, ecs_table_t *table)
     * }
     */
    public static void ecs_table_unlock(MemorySegment world, MemorySegment table) {
        var mh$ = ecs_table_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_unlock", world, table);
            }
            mh$.invokeExact(world, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_has_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_has_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_table_has_flags(ecs_table_t *table, ecs_flags32_t flags)
     * }
     */
    public static FunctionDescriptor ecs_table_has_flags$descriptor() {
        return ecs_table_has_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_table_has_flags(ecs_table_t *table, ecs_flags32_t flags)
     * }
     */
    public static MethodHandle ecs_table_has_flags$handle() {
        return ecs_table_has_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_table_has_flags(ecs_table_t *table, ecs_flags32_t flags)
     * }
     */
    public static MemorySegment ecs_table_has_flags$address() {
        return ecs_table_has_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_table_has_flags(ecs_table_t *table, ecs_flags32_t flags)
     * }
     */
    public static boolean ecs_table_has_flags(MemorySegment table, int flags) {
        var mh$ = ecs_table_has_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_has_flags", table, flags);
            }
            return (boolean)mh$.invokeExact(table, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_table_swap_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_table_swap_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_table_swap_rows(ecs_world_t *world, ecs_table_t *table, int32_t row_1, int32_t row_2)
     * }
     */
    public static FunctionDescriptor ecs_table_swap_rows$descriptor() {
        return ecs_table_swap_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_table_swap_rows(ecs_world_t *world, ecs_table_t *table, int32_t row_1, int32_t row_2)
     * }
     */
    public static MethodHandle ecs_table_swap_rows$handle() {
        return ecs_table_swap_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_table_swap_rows(ecs_world_t *world, ecs_table_t *table, int32_t row_1, int32_t row_2)
     * }
     */
    public static MemorySegment ecs_table_swap_rows$address() {
        return ecs_table_swap_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_table_swap_rows(ecs_world_t *world, ecs_table_t *table, int32_t row_1, int32_t row_2)
     * }
     */
    public static void ecs_table_swap_rows(MemorySegment world, MemorySegment table, int row_1, int row_2) {
        var mh$ = ecs_table_swap_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_table_swap_rows", world, table, row_1, row_2);
            }
            mh$.invokeExact(world, table, row_1, row_2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_commit(ecs_world_t *world, ecs_entity_t entity, ecs_record_t *record, ecs_table_t *table, const ecs_type_t *added, const ecs_type_t *removed)
     * }
     */
    public static FunctionDescriptor ecs_commit$descriptor() {
        return ecs_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_commit(ecs_world_t *world, ecs_entity_t entity, ecs_record_t *record, ecs_table_t *table, const ecs_type_t *added, const ecs_type_t *removed)
     * }
     */
    public static MethodHandle ecs_commit$handle() {
        return ecs_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_commit(ecs_world_t *world, ecs_entity_t entity, ecs_record_t *record, ecs_table_t *table, const ecs_type_t *added, const ecs_type_t *removed)
     * }
     */
    public static MemorySegment ecs_commit$address() {
        return ecs_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_commit(ecs_world_t *world, ecs_entity_t entity, ecs_record_t *record, ecs_table_t *table, const ecs_type_t *added, const ecs_type_t *removed)
     * }
     */
    public static boolean ecs_commit(MemorySegment world, long entity, MemorySegment record_, MemorySegment table, MemorySegment added, MemorySegment removed) {
        var mh$ = ecs_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_commit", world, entity, record_, table, added, removed);
            }
            return (boolean)mh$.invokeExact(world, entity, record_, table, added, removed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_search {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_search");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_search(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static FunctionDescriptor ecs_search$descriptor() {
        return ecs_search.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_search(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static MethodHandle ecs_search$handle() {
        return ecs_search.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_search(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static MemorySegment ecs_search$address() {
        return ecs_search.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_search(const ecs_world_t *world, const ecs_table_t *table, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static int ecs_search(MemorySegment world, MemorySegment table, long id, MemorySegment id_out) {
        var mh$ = ecs_search.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_search", world, table, id, id_out);
            }
            return (int)mh$.invokeExact(world, table, id, id_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_search_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_search_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_search_offset(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static FunctionDescriptor ecs_search_offset$descriptor() {
        return ecs_search_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_search_offset(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static MethodHandle ecs_search_offset$handle() {
        return ecs_search_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_search_offset(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static MemorySegment ecs_search_offset$address() {
        return ecs_search_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_search_offset(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_id_t *id_out)
     * }
     */
    public static int ecs_search_offset(MemorySegment world, MemorySegment table, int offset, long id, MemorySegment id_out) {
        var mh$ = ecs_search_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_search_offset", world, table, offset, id, id_out);
            }
            return (int)mh$.invokeExact(world, table, offset, id, id_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_search_relation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_search_relation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_search_relation(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_entity_t rel, ecs_flags64_t flags, ecs_entity_t *subject_out, ecs_id_t *id_out, struct ecs_table_record_t **tr_out)
     * }
     */
    public static FunctionDescriptor ecs_search_relation$descriptor() {
        return ecs_search_relation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_search_relation(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_entity_t rel, ecs_flags64_t flags, ecs_entity_t *subject_out, ecs_id_t *id_out, struct ecs_table_record_t **tr_out)
     * }
     */
    public static MethodHandle ecs_search_relation$handle() {
        return ecs_search_relation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_search_relation(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_entity_t rel, ecs_flags64_t flags, ecs_entity_t *subject_out, ecs_id_t *id_out, struct ecs_table_record_t **tr_out)
     * }
     */
    public static MemorySegment ecs_search_relation$address() {
        return ecs_search_relation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_search_relation(const ecs_world_t *world, const ecs_table_t *table, int32_t offset, ecs_id_t id, ecs_entity_t rel, ecs_flags64_t flags, ecs_entity_t *subject_out, ecs_id_t *id_out, struct ecs_table_record_t **tr_out)
     * }
     */
    public static int ecs_search_relation(MemorySegment world, MemorySegment table, int offset, long id, long rel, long flags, MemorySegment subject_out, MemorySegment id_out, MemorySegment tr_out) {
        var mh$ = ecs_search_relation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_search_relation", world, table, offset, id, rel, flags, subject_out, id_out, tr_out);
            }
            return (int)mh$.invokeExact(world, table, offset, id, rel, flags, subject_out, id_out, tr_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_init(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_value_init$descriptor() {
        return ecs_value_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_init(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MethodHandle ecs_value_init$handle() {
        return ecs_value_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_init(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MemorySegment ecs_value_init$address() {
        return ecs_value_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_init(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static int ecs_value_init(MemorySegment world, long type, MemorySegment ptr) {
        var mh$ = ecs_value_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_init", world, type, ptr);
            }
            return (int)mh$.invokeExact(world, type, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_init_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_init_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_init_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_value_init_w_type_info$descriptor() {
        return ecs_value_init_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_init_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static MethodHandle ecs_value_init_w_type_info$handle() {
        return ecs_value_init_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_init_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static MemorySegment ecs_value_init_w_type_info$address() {
        return ecs_value_init_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_init_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static int ecs_value_init_w_type_info(MemorySegment world, MemorySegment ti, MemorySegment ptr) {
        var mh$ = ecs_value_init_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_init_w_type_info", world, ti, ptr);
            }
            return (int)mh$.invokeExact(world, ti, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_value_new(ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static FunctionDescriptor ecs_value_new$descriptor() {
        return ecs_value_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_value_new(ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MethodHandle ecs_value_new$handle() {
        return ecs_value_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_value_new(ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_value_new$address() {
        return ecs_value_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_value_new(ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_value_new(MemorySegment world, long type) {
        var mh$ = ecs_value_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_new", world, type);
            }
            return (MemorySegment)mh$.invokeExact(world, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_new_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_new_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_value_new_w_type_info(ecs_world_t *world, const ecs_type_info_t *ti)
     * }
     */
    public static FunctionDescriptor ecs_value_new_w_type_info$descriptor() {
        return ecs_value_new_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_value_new_w_type_info(ecs_world_t *world, const ecs_type_info_t *ti)
     * }
     */
    public static MethodHandle ecs_value_new_w_type_info$handle() {
        return ecs_value_new_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_value_new_w_type_info(ecs_world_t *world, const ecs_type_info_t *ti)
     * }
     */
    public static MemorySegment ecs_value_new_w_type_info$address() {
        return ecs_value_new_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_value_new_w_type_info(ecs_world_t *world, const ecs_type_info_t *ti)
     * }
     */
    public static MemorySegment ecs_value_new_w_type_info(MemorySegment world, MemorySegment ti) {
        var mh$ = ecs_value_new_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_new_w_type_info", world, ti);
            }
            return (MemorySegment)mh$.invokeExact(world, ti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_fini_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_fini_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_fini_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_value_fini_w_type_info$descriptor() {
        return ecs_value_fini_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_fini_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static MethodHandle ecs_value_fini_w_type_info$handle() {
        return ecs_value_fini_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_fini_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static MemorySegment ecs_value_fini_w_type_info$address() {
        return ecs_value_fini_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_fini_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *ptr)
     * }
     */
    public static int ecs_value_fini_w_type_info(MemorySegment world, MemorySegment ti, MemorySegment ptr) {
        var mh$ = ecs_value_fini_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_fini_w_type_info", world, ti, ptr);
            }
            return (int)mh$.invokeExact(world, ti, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_fini(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_value_fini$descriptor() {
        return ecs_value_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_fini(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MethodHandle ecs_value_fini$handle() {
        return ecs_value_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_fini(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MemorySegment ecs_value_fini$address() {
        return ecs_value_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_fini(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static int ecs_value_fini(MemorySegment world, long type, MemorySegment ptr) {
        var mh$ = ecs_value_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_fini", world, type, ptr);
            }
            return (int)mh$.invokeExact(world, type, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_free(ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_value_free$descriptor() {
        return ecs_value_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_free(ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MethodHandle ecs_value_free$handle() {
        return ecs_value_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_free(ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MemorySegment ecs_value_free$address() {
        return ecs_value_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_free(ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static int ecs_value_free(MemorySegment world, long type, MemorySegment ptr) {
        var mh$ = ecs_value_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_free", world, type, ptr);
            }
            return (int)mh$.invokeExact(world, type, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_copy_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_copy_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_copy_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, const void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_copy_w_type_info$descriptor() {
        return ecs_value_copy_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_copy_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, const void *src)
     * }
     */
    public static MethodHandle ecs_value_copy_w_type_info$handle() {
        return ecs_value_copy_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_copy_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, const void *src)
     * }
     */
    public static MemorySegment ecs_value_copy_w_type_info$address() {
        return ecs_value_copy_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_copy_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, const void *src)
     * }
     */
    public static int ecs_value_copy_w_type_info(MemorySegment world, MemorySegment ti, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_copy_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_copy_w_type_info", world, ti, dst, src);
            }
            return (int)mh$.invokeExact(world, ti, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_copy(const ecs_world_t *world, ecs_entity_t type, void *dst, const void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_copy$descriptor() {
        return ecs_value_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_copy(const ecs_world_t *world, ecs_entity_t type, void *dst, const void *src)
     * }
     */
    public static MethodHandle ecs_value_copy$handle() {
        return ecs_value_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_copy(const ecs_world_t *world, ecs_entity_t type, void *dst, const void *src)
     * }
     */
    public static MemorySegment ecs_value_copy$address() {
        return ecs_value_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_copy(const ecs_world_t *world, ecs_entity_t type, void *dst, const void *src)
     * }
     */
    public static int ecs_value_copy(MemorySegment world, long type, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_copy", world, type, dst, src);
            }
            return (int)mh$.invokeExact(world, type, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_move_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_move_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_move_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_move_w_type_info$descriptor() {
        return ecs_value_move_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_move_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static MethodHandle ecs_value_move_w_type_info$handle() {
        return ecs_value_move_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_move_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static MemorySegment ecs_value_move_w_type_info$address() {
        return ecs_value_move_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_move_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static int ecs_value_move_w_type_info(MemorySegment world, MemorySegment ti, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_move_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_move_w_type_info", world, ti, dst, src);
            }
            return (int)mh$.invokeExact(world, ti, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_move(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_move$descriptor() {
        return ecs_value_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_move(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static MethodHandle ecs_value_move$handle() {
        return ecs_value_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_move(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static MemorySegment ecs_value_move$address() {
        return ecs_value_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_move(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static int ecs_value_move(MemorySegment world, long type, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_move", world, type, dst, src);
            }
            return (int)mh$.invokeExact(world, type, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_move_ctor_w_type_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_move_ctor_w_type_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_move_ctor_w_type_info$descriptor() {
        return ecs_value_move_ctor_w_type_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static MethodHandle ecs_value_move_ctor_w_type_info$handle() {
        return ecs_value_move_ctor_w_type_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static MemorySegment ecs_value_move_ctor_w_type_info$address() {
        return ecs_value_move_ctor_w_type_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_move_ctor_w_type_info(const ecs_world_t *world, const ecs_type_info_t *ti, void *dst, void *src)
     * }
     */
    public static int ecs_value_move_ctor_w_type_info(MemorySegment world, MemorySegment ti, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_move_ctor_w_type_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_move_ctor_w_type_info", world, ti, dst, src);
            }
            return (int)mh$.invokeExact(world, ti, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_value_move_ctor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_value_move_ctor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static FunctionDescriptor ecs_value_move_ctor$descriptor() {
        return ecs_value_move_ctor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static MethodHandle ecs_value_move_ctor$handle() {
        return ecs_value_move_ctor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_value_move_ctor(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static MemorySegment ecs_value_move_ctor$address() {
        return ecs_value_move_ctor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_value_move_ctor(const ecs_world_t *world, ecs_entity_t type, void *dst, void *src)
     * }
     */
    public static int ecs_value_move_ctor(MemorySegment world, long type, MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_value_move_ctor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_value_move_ctor", world, type, dst, src);
            }
            return (int)mh$.invokeExact(world, type, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_deprecated_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_deprecated_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_deprecated_(const char *file, int32_t line, const char *msg)
     * }
     */
    public static FunctionDescriptor ecs_deprecated_$descriptor() {
        return ecs_deprecated_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_deprecated_(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MethodHandle ecs_deprecated_$handle() {
        return ecs_deprecated_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_deprecated_(const char *file, int32_t line, const char *msg)
     * }
     */
    public static MemorySegment ecs_deprecated_$address() {
        return ecs_deprecated_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_deprecated_(const char *file, int32_t line, const char *msg)
     * }
     */
    public static void ecs_deprecated_(MemorySegment file, int line, MemorySegment msg) {
        var mh$ = ecs_deprecated_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_deprecated_", file, line, msg);
            }
            mh$.invokeExact(file, line, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_push_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_push_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_log_push_(int32_t level)
     * }
     */
    public static FunctionDescriptor ecs_log_push_$descriptor() {
        return ecs_log_push_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_log_push_(int32_t level)
     * }
     */
    public static MethodHandle ecs_log_push_$handle() {
        return ecs_log_push_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_log_push_(int32_t level)
     * }
     */
    public static MemorySegment ecs_log_push_$address() {
        return ecs_log_push_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_log_push_(int32_t level)
     * }
     */
    public static void ecs_log_push_(int level) {
        var mh$ = ecs_log_push_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_push_", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_pop_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_pop_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_log_pop_(int32_t level)
     * }
     */
    public static FunctionDescriptor ecs_log_pop_$descriptor() {
        return ecs_log_pop_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_log_pop_(int32_t level)
     * }
     */
    public static MethodHandle ecs_log_pop_$handle() {
        return ecs_log_pop_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_log_pop_(int32_t level)
     * }
     */
    public static MemorySegment ecs_log_pop_$address() {
        return ecs_log_pop_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_log_pop_(int32_t level)
     * }
     */
    public static void ecs_log_pop_(int level) {
        var mh$ = ecs_log_pop_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_pop_", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_should_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_should_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_should_log(int32_t level)
     * }
     */
    public static FunctionDescriptor ecs_should_log$descriptor() {
        return ecs_should_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_should_log(int32_t level)
     * }
     */
    public static MethodHandle ecs_should_log$handle() {
        return ecs_should_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_should_log(int32_t level)
     * }
     */
    public static MemorySegment ecs_should_log$address() {
        return ecs_should_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_should_log(int32_t level)
     * }
     */
    public static boolean ecs_should_log(int level) {
        var mh$ = ecs_should_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_should_log", level);
            }
            return (boolean)mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_strerror(int32_t error_code)
     * }
     */
    public static FunctionDescriptor ecs_strerror$descriptor() {
        return ecs_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_strerror(int32_t error_code)
     * }
     */
    public static MethodHandle ecs_strerror$handle() {
        return ecs_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_strerror(int32_t error_code)
     * }
     */
    public static MemorySegment ecs_strerror$address() {
        return ecs_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_strerror(int32_t error_code)
     * }
     */
    public static MemorySegment ecs_strerror(int error_code) {
        var mh$ = ecs_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_strerror", error_code);
            }
            return (MemorySegment)mh$.invokeExact(error_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_print_(int32_t level, const char *file, int32_t line, const char *fmt, ...)
     * }
     */
    public static class ecs_print_ {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_print_");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_print_(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_print_(int32_t level, const char *file, int32_t line, const char *fmt, ...)
         * }
         */
        public static ecs_print_ makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_print_(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int level, MemorySegment file, int line, MemorySegment fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_print_", level, file, line, fmt, x4);
                }
                spreader.invokeExact(level, file, line, fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_printv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_printv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_printv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor ecs_printv_$descriptor() {
        return ecs_printv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_printv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static MethodHandle ecs_printv_$handle() {
        return ecs_printv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_printv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static MemorySegment ecs_printv_$address() {
        return ecs_printv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_printv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static void ecs_printv_(int level, MemorySegment file, int line, MemorySegment fmt, MemorySegment args) {
        var mh$ = ecs_printv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_printv_", level, file, line, fmt, args);
            }
            mh$.invokeExact(level, file, line, fmt, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_log_(int32_t level, const char *file, int32_t line, const char *fmt, ...)
     * }
     */
    public static class ecs_log_ {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_log_(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_log_(int32_t level, const char *file, int32_t line, const char *fmt, ...)
         * }
         */
        public static ecs_log_ makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_log_(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int level, MemorySegment file, int line, MemorySegment fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_log_", level, file, line, fmt, x4);
                }
                spreader.invokeExact(level, file, line, fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_logv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_logv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_logv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor ecs_logv_$descriptor() {
        return ecs_logv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_logv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static MethodHandle ecs_logv_$handle() {
        return ecs_logv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_logv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static MemorySegment ecs_logv_$address() {
        return ecs_logv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_logv_(int level, const char *file, int32_t line, const char *fmt, va_list args)
     * }
     */
    public static void ecs_logv_(int level, MemorySegment file, int line, MemorySegment fmt, MemorySegment args) {
        var mh$ = ecs_logv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_logv_", level, file, line, fmt, args);
            }
            mh$.invokeExact(level, file, line, fmt, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_abort_(int32_t error_code, const char *file, int32_t line, const char *fmt, ...)
     * }
     */
    public static class ecs_abort_ {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_abort_");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_abort_(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_abort_(int32_t error_code, const char *file, int32_t line, const char *fmt, ...)
         * }
         */
        public static ecs_abort_ makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_abort_(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int error_code, MemorySegment file, int line, MemorySegment fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_abort_", error_code, file, line, fmt, x4);
                }
                spreader.invokeExact(error_code, file, line, fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_assert_log_(int32_t error_code, const char *condition_str, const char *file, int32_t line, const char *fmt, ...)
     * }
     */
    public static class ecs_assert_log_ {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_INT,
                flecs.C_POINTER,
                flecs.C_POINTER,
                flecs.C_INT,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_assert_log_");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_assert_log_(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_assert_log_(int32_t error_code, const char *condition_str, const char *file, int32_t line, const char *fmt, ...)
         * }
         */
        public static ecs_assert_log_ makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_assert_log_(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int error_code, MemorySegment condition_str, MemorySegment file, int line, MemorySegment fmt, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_assert_log_", error_code, condition_str, file, line, fmt, x5);
                }
                spreader.invokeExact(error_code, condition_str, file, line, fmt, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void ecs_parser_error_(const char *name, const char *expr, int64_t column, const char *fmt, ...)
     * }
     */
    public static class ecs_parser_error_ {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                flecs.C_POINTER,
                flecs.C_POINTER,
                flecs.C_LONG_LONG,
                flecs.C_POINTER
            );
        private static final MemorySegment ADDR = flecs.findOrThrow("ecs_parser_error_");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ecs_parser_error_(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void ecs_parser_error_(const char *name, const char *expr, int64_t column, const char *fmt, ...)
         * }
         */
        public static ecs_parser_error_ makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ecs_parser_error_(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment name, MemorySegment expr, long column, MemorySegment fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ecs_parser_error_", name, expr, column, fmt, x4);
                }
                spreader.invokeExact(name, expr, column, fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ecs_parser_errorv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_parser_errorv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_parser_errorv_(const char *name, const char *expr, int64_t column, const char *fmt, va_list args)
     * }
     */
    public static FunctionDescriptor ecs_parser_errorv_$descriptor() {
        return ecs_parser_errorv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_parser_errorv_(const char *name, const char *expr, int64_t column, const char *fmt, va_list args)
     * }
     */
    public static MethodHandle ecs_parser_errorv_$handle() {
        return ecs_parser_errorv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_parser_errorv_(const char *name, const char *expr, int64_t column, const char *fmt, va_list args)
     * }
     */
    public static MemorySegment ecs_parser_errorv_$address() {
        return ecs_parser_errorv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_parser_errorv_(const char *name, const char *expr, int64_t column, const char *fmt, va_list args)
     * }
     */
    public static void ecs_parser_errorv_(MemorySegment name, MemorySegment expr, long column, MemorySegment fmt, MemorySegment args) {
        var mh$ = ecs_parser_errorv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_parser_errorv_", name, expr, column, fmt, args);
            }
            mh$.invokeExact(name, expr, column, fmt, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_set_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor ecs_log_set_level$descriptor() {
        return ecs_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_log_set_level(int level)
     * }
     */
    public static MethodHandle ecs_log_set_level$handle() {
        return ecs_log_set_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_log_set_level(int level)
     * }
     */
    public static MemorySegment ecs_log_set_level$address() {
        return ecs_log_set_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_log_set_level(int level)
     * }
     */
    public static int ecs_log_set_level(int level) {
        var mh$ = ecs_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_set_level", level);
            }
            return (int)mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_get_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_log_get_level()
     * }
     */
    public static FunctionDescriptor ecs_log_get_level$descriptor() {
        return ecs_log_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_log_get_level()
     * }
     */
    public static MethodHandle ecs_log_get_level$handle() {
        return ecs_log_get_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_log_get_level()
     * }
     */
    public static MemorySegment ecs_log_get_level$address() {
        return ecs_log_get_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_log_get_level()
     * }
     */
    public static int ecs_log_get_level() {
        var mh$ = ecs_log_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_get_level");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_enable_colors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_enable_colors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_log_enable_colors(bool enabled)
     * }
     */
    public static FunctionDescriptor ecs_log_enable_colors$descriptor() {
        return ecs_log_enable_colors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_log_enable_colors(bool enabled)
     * }
     */
    public static MethodHandle ecs_log_enable_colors$handle() {
        return ecs_log_enable_colors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_log_enable_colors(bool enabled)
     * }
     */
    public static MemorySegment ecs_log_enable_colors$address() {
        return ecs_log_enable_colors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_log_enable_colors(bool enabled)
     * }
     */
    public static boolean ecs_log_enable_colors(boolean enabled) {
        var mh$ = ecs_log_enable_colors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_enable_colors", enabled);
            }
            return (boolean)mh$.invokeExact(enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_enable_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_enable_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timestamp(bool enabled)
     * }
     */
    public static FunctionDescriptor ecs_log_enable_timestamp$descriptor() {
        return ecs_log_enable_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timestamp(bool enabled)
     * }
     */
    public static MethodHandle ecs_log_enable_timestamp$handle() {
        return ecs_log_enable_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timestamp(bool enabled)
     * }
     */
    public static MemorySegment ecs_log_enable_timestamp$address() {
        return ecs_log_enable_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_log_enable_timestamp(bool enabled)
     * }
     */
    public static boolean ecs_log_enable_timestamp(boolean enabled) {
        var mh$ = ecs_log_enable_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_enable_timestamp", enabled);
            }
            return (boolean)mh$.invokeExact(enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_enable_timedelta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_enable_timedelta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timedelta(bool enabled)
     * }
     */
    public static FunctionDescriptor ecs_log_enable_timedelta$descriptor() {
        return ecs_log_enable_timedelta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timedelta(bool enabled)
     * }
     */
    public static MethodHandle ecs_log_enable_timedelta$handle() {
        return ecs_log_enable_timedelta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_log_enable_timedelta(bool enabled)
     * }
     */
    public static MemorySegment ecs_log_enable_timedelta$address() {
        return ecs_log_enable_timedelta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_log_enable_timedelta(bool enabled)
     * }
     */
    public static boolean ecs_log_enable_timedelta(boolean enabled) {
        var mh$ = ecs_log_enable_timedelta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_enable_timedelta", enabled);
            }
            return (boolean)mh$.invokeExact(enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_log_last_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_log_last_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_log_last_error()
     * }
     */
    public static FunctionDescriptor ecs_log_last_error$descriptor() {
        return ecs_log_last_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_log_last_error()
     * }
     */
    public static MethodHandle ecs_log_last_error$handle() {
        return ecs_log_last_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_log_last_error()
     * }
     */
    public static MemorySegment ecs_log_last_error$address() {
        return ecs_log_last_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_log_last_error()
     * }
     */
    public static int ecs_log_last_error() {
        var mh$ = ecs_log_last_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_log_last_error");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_app_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_app_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_app_run(ecs_world_t *world, ecs_app_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_app_run$descriptor() {
        return ecs_app_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_app_run(ecs_world_t *world, ecs_app_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_app_run$handle() {
        return ecs_app_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_app_run(ecs_world_t *world, ecs_app_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_app_run$address() {
        return ecs_app_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_app_run(ecs_world_t *world, ecs_app_desc_t *desc)
     * }
     */
    public static int ecs_app_run(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_app_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_app_run", world, desc);
            }
            return (int)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_app_run_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_app_run_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_app_run_frame(ecs_world_t *world, const ecs_app_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_app_run_frame$descriptor() {
        return ecs_app_run_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_app_run_frame(ecs_world_t *world, const ecs_app_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_app_run_frame$handle() {
        return ecs_app_run_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_app_run_frame(ecs_world_t *world, const ecs_app_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_app_run_frame$address() {
        return ecs_app_run_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_app_run_frame(ecs_world_t *world, const ecs_app_desc_t *desc)
     * }
     */
    public static int ecs_app_run_frame(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_app_run_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_app_run_frame", world, desc);
            }
            return (int)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_app_set_run_action {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_app_set_run_action");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_app_set_run_action(ecs_app_run_action_t callback)
     * }
     */
    public static FunctionDescriptor ecs_app_set_run_action$descriptor() {
        return ecs_app_set_run_action.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_app_set_run_action(ecs_app_run_action_t callback)
     * }
     */
    public static MethodHandle ecs_app_set_run_action$handle() {
        return ecs_app_set_run_action.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_app_set_run_action(ecs_app_run_action_t callback)
     * }
     */
    public static MemorySegment ecs_app_set_run_action$address() {
        return ecs_app_set_run_action.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_app_set_run_action(ecs_app_run_action_t callback)
     * }
     */
    public static int ecs_app_set_run_action(MemorySegment callback) {
        var mh$ = ecs_app_set_run_action.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_app_set_run_action", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_app_set_frame_action {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_app_set_frame_action");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_app_set_frame_action(ecs_app_frame_action_t callback)
     * }
     */
    public static FunctionDescriptor ecs_app_set_frame_action$descriptor() {
        return ecs_app_set_frame_action.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_app_set_frame_action(ecs_app_frame_action_t callback)
     * }
     */
    public static MethodHandle ecs_app_set_frame_action$handle() {
        return ecs_app_set_frame_action.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_app_set_frame_action(ecs_app_frame_action_t callback)
     * }
     */
    public static MemorySegment ecs_app_set_frame_action$address() {
        return ecs_app_set_frame_action.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_app_set_frame_action(ecs_app_frame_action_t callback)
     * }
     */
    public static int ecs_app_set_frame_action(MemorySegment callback) {
        var mh$ = ecs_app_set_frame_action.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_app_set_frame_action", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int EcsHttpGet = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpGet = 0
     * }
     */
    public static int EcsHttpGet() {
        return EcsHttpGet;
    }
    private static final int EcsHttpPost = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpPost = 1
     * }
     */
    public static int EcsHttpPost() {
        return EcsHttpPost;
    }
    private static final int EcsHttpPut = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpPut = 2
     * }
     */
    public static int EcsHttpPut() {
        return EcsHttpPut;
    }
    private static final int EcsHttpDelete = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpDelete = 3
     * }
     */
    public static int EcsHttpDelete() {
        return EcsHttpDelete;
    }
    private static final int EcsHttpOptions = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpOptions = 4
     * }
     */
    public static int EcsHttpOptions() {
        return EcsHttpOptions;
    }
    private static final int EcsHttpMethodUnsupported = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EcsHttpMethodUnsupported = 5
     * }
     */
    public static int EcsHttpMethodUnsupported() {
        return EcsHttpMethodUnsupported;
    }

    private static class ecs_http_request_received_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_received_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_received_count
     * }
     */
    public static OfLong ecs_http_request_received_count$layout() {
        return ecs_http_request_received_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_received_count
     * }
     */
    public static MemorySegment ecs_http_request_received_count$segment() {
        return ecs_http_request_received_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_received_count
     * }
     */
    public static long ecs_http_request_received_count() {
        return ecs_http_request_received_count$constants.SEGMENT.get(ecs_http_request_received_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_received_count
     * }
     */
    public static void ecs_http_request_received_count(long varValue) {
        ecs_http_request_received_count$constants.SEGMENT.set(ecs_http_request_received_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_request_invalid_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_invalid_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_invalid_count
     * }
     */
    public static OfLong ecs_http_request_invalid_count$layout() {
        return ecs_http_request_invalid_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_invalid_count
     * }
     */
    public static MemorySegment ecs_http_request_invalid_count$segment() {
        return ecs_http_request_invalid_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_invalid_count
     * }
     */
    public static long ecs_http_request_invalid_count() {
        return ecs_http_request_invalid_count$constants.SEGMENT.get(ecs_http_request_invalid_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_invalid_count
     * }
     */
    public static void ecs_http_request_invalid_count(long varValue) {
        ecs_http_request_invalid_count$constants.SEGMENT.set(ecs_http_request_invalid_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_request_handled_ok_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_handled_ok_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_ok_count
     * }
     */
    public static OfLong ecs_http_request_handled_ok_count$layout() {
        return ecs_http_request_handled_ok_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_ok_count
     * }
     */
    public static MemorySegment ecs_http_request_handled_ok_count$segment() {
        return ecs_http_request_handled_ok_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_ok_count
     * }
     */
    public static long ecs_http_request_handled_ok_count() {
        return ecs_http_request_handled_ok_count$constants.SEGMENT.get(ecs_http_request_handled_ok_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_ok_count
     * }
     */
    public static void ecs_http_request_handled_ok_count(long varValue) {
        ecs_http_request_handled_ok_count$constants.SEGMENT.set(ecs_http_request_handled_ok_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_request_handled_error_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_handled_error_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_error_count
     * }
     */
    public static OfLong ecs_http_request_handled_error_count$layout() {
        return ecs_http_request_handled_error_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_error_count
     * }
     */
    public static MemorySegment ecs_http_request_handled_error_count$segment() {
        return ecs_http_request_handled_error_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_error_count
     * }
     */
    public static long ecs_http_request_handled_error_count() {
        return ecs_http_request_handled_error_count$constants.SEGMENT.get(ecs_http_request_handled_error_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_handled_error_count
     * }
     */
    public static void ecs_http_request_handled_error_count(long varValue) {
        ecs_http_request_handled_error_count$constants.SEGMENT.set(ecs_http_request_handled_error_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_request_not_handled_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_not_handled_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_not_handled_count
     * }
     */
    public static OfLong ecs_http_request_not_handled_count$layout() {
        return ecs_http_request_not_handled_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_not_handled_count
     * }
     */
    public static MemorySegment ecs_http_request_not_handled_count$segment() {
        return ecs_http_request_not_handled_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_not_handled_count
     * }
     */
    public static long ecs_http_request_not_handled_count() {
        return ecs_http_request_not_handled_count$constants.SEGMENT.get(ecs_http_request_not_handled_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_not_handled_count
     * }
     */
    public static void ecs_http_request_not_handled_count(long varValue) {
        ecs_http_request_not_handled_count$constants.SEGMENT.set(ecs_http_request_not_handled_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_request_preflight_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_request_preflight_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_preflight_count
     * }
     */
    public static OfLong ecs_http_request_preflight_count$layout() {
        return ecs_http_request_preflight_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_preflight_count
     * }
     */
    public static MemorySegment ecs_http_request_preflight_count$segment() {
        return ecs_http_request_preflight_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_preflight_count
     * }
     */
    public static long ecs_http_request_preflight_count() {
        return ecs_http_request_preflight_count$constants.SEGMENT.get(ecs_http_request_preflight_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_request_preflight_count
     * }
     */
    public static void ecs_http_request_preflight_count(long varValue) {
        ecs_http_request_preflight_count$constants.SEGMENT.set(ecs_http_request_preflight_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_send_ok_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_send_ok_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_ok_count
     * }
     */
    public static OfLong ecs_http_send_ok_count$layout() {
        return ecs_http_send_ok_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_ok_count
     * }
     */
    public static MemorySegment ecs_http_send_ok_count$segment() {
        return ecs_http_send_ok_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_ok_count
     * }
     */
    public static long ecs_http_send_ok_count() {
        return ecs_http_send_ok_count$constants.SEGMENT.get(ecs_http_send_ok_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_ok_count
     * }
     */
    public static void ecs_http_send_ok_count(long varValue) {
        ecs_http_send_ok_count$constants.SEGMENT.set(ecs_http_send_ok_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_send_error_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_send_error_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_error_count
     * }
     */
    public static OfLong ecs_http_send_error_count$layout() {
        return ecs_http_send_error_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_error_count
     * }
     */
    public static MemorySegment ecs_http_send_error_count$segment() {
        return ecs_http_send_error_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_error_count
     * }
     */
    public static long ecs_http_send_error_count() {
        return ecs_http_send_error_count$constants.SEGMENT.get(ecs_http_send_error_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_send_error_count
     * }
     */
    public static void ecs_http_send_error_count(long varValue) {
        ecs_http_send_error_count$constants.SEGMENT.set(ecs_http_send_error_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_busy_count$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("ecs_http_busy_count").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_busy_count
     * }
     */
    public static OfLong ecs_http_busy_count$layout() {
        return ecs_http_busy_count$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_busy_count
     * }
     */
    public static MemorySegment ecs_http_busy_count$segment() {
        return ecs_http_busy_count$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_busy_count
     * }
     */
    public static long ecs_http_busy_count() {
        return ecs_http_busy_count$constants.SEGMENT.get(ecs_http_busy_count$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int64_t ecs_http_busy_count
     * }
     */
    public static void ecs_http_busy_count(long varValue) {
        ecs_http_busy_count$constants.SEGMENT.set(ecs_http_busy_count$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_http_server_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_http_server_init(const ecs_http_server_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_http_server_init$descriptor() {
        return ecs_http_server_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_http_server_init(const ecs_http_server_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_http_server_init$handle() {
        return ecs_http_server_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_http_server_init(const ecs_http_server_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_http_server_init$address() {
        return ecs_http_server_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_http_server_init(const ecs_http_server_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_http_server_init(MemorySegment desc) {
        var mh$ = ecs_http_server_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_init", desc);
            }
            return (MemorySegment)mh$.invokeExact(desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_http_server_fini(ecs_http_server_t *server)
     * }
     */
    public static FunctionDescriptor ecs_http_server_fini$descriptor() {
        return ecs_http_server_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_http_server_fini(ecs_http_server_t *server)
     * }
     */
    public static MethodHandle ecs_http_server_fini$handle() {
        return ecs_http_server_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_http_server_fini(ecs_http_server_t *server)
     * }
     */
    public static MemorySegment ecs_http_server_fini$address() {
        return ecs_http_server_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_http_server_fini(ecs_http_server_t *server)
     * }
     */
    public static void ecs_http_server_fini(MemorySegment server) {
        var mh$ = ecs_http_server_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_fini", server);
            }
            mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_http_server_start(ecs_http_server_t *server)
     * }
     */
    public static FunctionDescriptor ecs_http_server_start$descriptor() {
        return ecs_http_server_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_http_server_start(ecs_http_server_t *server)
     * }
     */
    public static MethodHandle ecs_http_server_start$handle() {
        return ecs_http_server_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_http_server_start(ecs_http_server_t *server)
     * }
     */
    public static MemorySegment ecs_http_server_start$address() {
        return ecs_http_server_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_http_server_start(ecs_http_server_t *server)
     * }
     */
    public static int ecs_http_server_start(MemorySegment server) {
        var mh$ = ecs_http_server_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_start", server);
            }
            return (int)mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_dequeue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_dequeue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_http_server_dequeue(ecs_http_server_t *server, float delta_time)
     * }
     */
    public static FunctionDescriptor ecs_http_server_dequeue$descriptor() {
        return ecs_http_server_dequeue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_http_server_dequeue(ecs_http_server_t *server, float delta_time)
     * }
     */
    public static MethodHandle ecs_http_server_dequeue$handle() {
        return ecs_http_server_dequeue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_http_server_dequeue(ecs_http_server_t *server, float delta_time)
     * }
     */
    public static MemorySegment ecs_http_server_dequeue$address() {
        return ecs_http_server_dequeue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_http_server_dequeue(ecs_http_server_t *server, float delta_time)
     * }
     */
    public static void ecs_http_server_dequeue(MemorySegment server, float delta_time) {
        var mh$ = ecs_http_server_dequeue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_dequeue", server, delta_time);
            }
            mh$.invokeExact(server, delta_time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_http_server_stop(ecs_http_server_t *server)
     * }
     */
    public static FunctionDescriptor ecs_http_server_stop$descriptor() {
        return ecs_http_server_stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_http_server_stop(ecs_http_server_t *server)
     * }
     */
    public static MethodHandle ecs_http_server_stop$handle() {
        return ecs_http_server_stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_http_server_stop(ecs_http_server_t *server)
     * }
     */
    public static MemorySegment ecs_http_server_stop$address() {
        return ecs_http_server_stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_http_server_stop(ecs_http_server_t *server)
     * }
     */
    public static void ecs_http_server_stop(MemorySegment server) {
        var mh$ = ecs_http_server_stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_stop", server);
            }
            mh$.invokeExact(server);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_http_request {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_http_request");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_http_server_http_request(ecs_http_server_t *srv, const char *req, ecs_size_t len, ecs_http_reply_t *reply_out)
     * }
     */
    public static FunctionDescriptor ecs_http_server_http_request$descriptor() {
        return ecs_http_server_http_request.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_http_server_http_request(ecs_http_server_t *srv, const char *req, ecs_size_t len, ecs_http_reply_t *reply_out)
     * }
     */
    public static MethodHandle ecs_http_server_http_request$handle() {
        return ecs_http_server_http_request.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_http_server_http_request(ecs_http_server_t *srv, const char *req, ecs_size_t len, ecs_http_reply_t *reply_out)
     * }
     */
    public static MemorySegment ecs_http_server_http_request$address() {
        return ecs_http_server_http_request.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_http_server_http_request(ecs_http_server_t *srv, const char *req, ecs_size_t len, ecs_http_reply_t *reply_out)
     * }
     */
    public static int ecs_http_server_http_request(MemorySegment srv, MemorySegment req, int len, MemorySegment reply_out) {
        var mh$ = ecs_http_server_http_request.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_http_request", srv, req, len, reply_out);
            }
            return (int)mh$.invokeExact(srv, req, len, reply_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_request {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_request");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_http_server_request(ecs_http_server_t *srv, const char *method, const char *req, ecs_http_reply_t *reply_out)
     * }
     */
    public static FunctionDescriptor ecs_http_server_request$descriptor() {
        return ecs_http_server_request.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_http_server_request(ecs_http_server_t *srv, const char *method, const char *req, ecs_http_reply_t *reply_out)
     * }
     */
    public static MethodHandle ecs_http_server_request$handle() {
        return ecs_http_server_request.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_http_server_request(ecs_http_server_t *srv, const char *method, const char *req, ecs_http_reply_t *reply_out)
     * }
     */
    public static MemorySegment ecs_http_server_request$address() {
        return ecs_http_server_request.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_http_server_request(ecs_http_server_t *srv, const char *method, const char *req, ecs_http_reply_t *reply_out)
     * }
     */
    public static int ecs_http_server_request(MemorySegment srv, MemorySegment method, MemorySegment req, MemorySegment reply_out) {
        var mh$ = ecs_http_server_request.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_request", srv, method, req, reply_out);
            }
            return (int)mh$.invokeExact(srv, method, req, reply_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_server_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_server_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_http_server_ctx(ecs_http_server_t *srv)
     * }
     */
    public static FunctionDescriptor ecs_http_server_ctx$descriptor() {
        return ecs_http_server_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_http_server_ctx(ecs_http_server_t *srv)
     * }
     */
    public static MethodHandle ecs_http_server_ctx$handle() {
        return ecs_http_server_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_http_server_ctx(ecs_http_server_t *srv)
     * }
     */
    public static MemorySegment ecs_http_server_ctx$address() {
        return ecs_http_server_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_http_server_ctx(ecs_http_server_t *srv)
     * }
     */
    public static MemorySegment ecs_http_server_ctx(MemorySegment srv) {
        var mh$ = ecs_http_server_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_server_ctx", srv);
            }
            return (MemorySegment)mh$.invokeExact(srv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_get_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_get_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_http_get_header(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_http_get_header$descriptor() {
        return ecs_http_get_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_http_get_header(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MethodHandle ecs_http_get_header$handle() {
        return ecs_http_get_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_http_get_header(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MemorySegment ecs_http_get_header$address() {
        return ecs_http_get_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_http_get_header(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MemorySegment ecs_http_get_header(MemorySegment req, MemorySegment name) {
        var mh$ = ecs_http_get_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_get_header", req, name);
            }
            return (MemorySegment)mh$.invokeExact(req, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_http_get_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_http_get_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_http_get_param(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_http_get_param$descriptor() {
        return ecs_http_get_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_http_get_param(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MethodHandle ecs_http_get_param$handle() {
        return ecs_http_get_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_http_get_param(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MemorySegment ecs_http_get_param$address() {
        return ecs_http_get_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_http_get_param(const ecs_http_request_t *req, const char *name)
     * }
     */
    public static MemorySegment ecs_http_get_param(MemorySegment req, MemorySegment name) {
        var mh$ = ecs_http_get_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_http_get_param", req, name);
            }
            return (MemorySegment)mh$.invokeExact(req, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDEcsRestID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsRestID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRestID_
     * }
     */
    public static OfLong FLECS_IDEcsRestID_$layout() {
        return FLECS_IDEcsRestID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRestID_
     * }
     */
    public static MemorySegment FLECS_IDEcsRestID_$segment() {
        return FLECS_IDEcsRestID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRestID_
     * }
     */
    public static long FLECS_IDEcsRestID_() {
        return FLECS_IDEcsRestID_$constants.SEGMENT.get(FLECS_IDEcsRestID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsRestID_
     * }
     */
    public static void FLECS_IDEcsRestID_(long varValue) {
        FLECS_IDEcsRestID_$constants.SEGMENT.set(FLECS_IDEcsRestID_$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_rest_server_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_rest_server_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_rest_server_init(ecs_world_t *world, const ecs_http_server_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_rest_server_init$descriptor() {
        return ecs_rest_server_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_rest_server_init(ecs_world_t *world, const ecs_http_server_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_rest_server_init$handle() {
        return ecs_rest_server_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_rest_server_init(ecs_world_t *world, const ecs_http_server_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_rest_server_init$address() {
        return ecs_rest_server_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_http_server_t *ecs_rest_server_init(ecs_world_t *world, const ecs_http_server_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_rest_server_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_rest_server_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_rest_server_init", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_rest_server_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_rest_server_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_rest_server_fini(ecs_http_server_t *srv)
     * }
     */
    public static FunctionDescriptor ecs_rest_server_fini$descriptor() {
        return ecs_rest_server_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_rest_server_fini(ecs_http_server_t *srv)
     * }
     */
    public static MethodHandle ecs_rest_server_fini$handle() {
        return ecs_rest_server_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_rest_server_fini(ecs_http_server_t *srv)
     * }
     */
    public static MemorySegment ecs_rest_server_fini$address() {
        return ecs_rest_server_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_rest_server_fini(ecs_http_server_t *srv)
     * }
     */
    public static void ecs_rest_server_fini(MemorySegment srv) {
        var mh$ = ecs_rest_server_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_rest_server_fini", srv);
            }
            mh$.invokeExact(srv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsRestImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsRestImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsRestImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsRestImport$descriptor() {
        return FlecsRestImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsRestImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsRestImport$handle() {
        return FlecsRestImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsRestImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsRestImport$address() {
        return FlecsRestImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsRestImport(ecs_world_t *world)
     * }
     */
    public static void FlecsRestImport(MemorySegment world) {
        var mh$ = FlecsRestImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsRestImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_timeout(ecs_world_t *world, ecs_entity_t tick_source, float timeout)
     * }
     */
    public static FunctionDescriptor ecs_set_timeout$descriptor() {
        return ecs_set_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_timeout(ecs_world_t *world, ecs_entity_t tick_source, float timeout)
     * }
     */
    public static MethodHandle ecs_set_timeout$handle() {
        return ecs_set_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_timeout(ecs_world_t *world, ecs_entity_t tick_source, float timeout)
     * }
     */
    public static MemorySegment ecs_set_timeout$address() {
        return ecs_set_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_timeout(ecs_world_t *world, ecs_entity_t tick_source, float timeout)
     * }
     */
    public static long ecs_set_timeout(MemorySegment world, long tick_source, float timeout) {
        var mh$ = ecs_set_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_timeout", world, tick_source, timeout);
            }
            return (long)mh$.invokeExact(world, tick_source, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ecs_get_timeout(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_get_timeout$descriptor() {
        return ecs_get_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ecs_get_timeout(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_get_timeout$handle() {
        return ecs_get_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ecs_get_timeout(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_get_timeout$address() {
        return ecs_get_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ecs_get_timeout(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static float ecs_get_timeout(MemorySegment world, long tick_source) {
        var mh$ = ecs_get_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_timeout", world, tick_source);
            }
            return (float)mh$.invokeExact(world, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_interval(ecs_world_t *world, ecs_entity_t tick_source, float interval)
     * }
     */
    public static FunctionDescriptor ecs_set_interval$descriptor() {
        return ecs_set_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_interval(ecs_world_t *world, ecs_entity_t tick_source, float interval)
     * }
     */
    public static MethodHandle ecs_set_interval$handle() {
        return ecs_set_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_interval(ecs_world_t *world, ecs_entity_t tick_source, float interval)
     * }
     */
    public static MemorySegment ecs_set_interval$address() {
        return ecs_set_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_interval(ecs_world_t *world, ecs_entity_t tick_source, float interval)
     * }
     */
    public static long ecs_set_interval(MemorySegment world, long tick_source, float interval) {
        var mh$ = ecs_set_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_interval", world, tick_source, interval);
            }
            return (long)mh$.invokeExact(world, tick_source, interval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ecs_get_interval(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_get_interval$descriptor() {
        return ecs_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ecs_get_interval(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_get_interval$handle() {
        return ecs_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ecs_get_interval(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_get_interval$address() {
        return ecs_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ecs_get_interval(const ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static float ecs_get_interval(MemorySegment world, long tick_source) {
        var mh$ = ecs_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_interval", world, tick_source);
            }
            return (float)mh$.invokeExact(world, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_start_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_start_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_start_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_start_timer$descriptor() {
        return ecs_start_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_start_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_start_timer$handle() {
        return ecs_start_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_start_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_start_timer$address() {
        return ecs_start_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_start_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static void ecs_start_timer(MemorySegment world, long tick_source) {
        var mh$ = ecs_start_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_start_timer", world, tick_source);
            }
            mh$.invokeExact(world, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_stop_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_stop_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_stop_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_stop_timer$descriptor() {
        return ecs_stop_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_stop_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_stop_timer$handle() {
        return ecs_stop_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_stop_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_stop_timer$address() {
        return ecs_stop_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_stop_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static void ecs_stop_timer(MemorySegment world, long tick_source) {
        var mh$ = ecs_stop_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_stop_timer", world, tick_source);
            }
            mh$.invokeExact(world, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_reset_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_reset_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_reset_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_reset_timer$descriptor() {
        return ecs_reset_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_reset_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_reset_timer$handle() {
        return ecs_reset_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_reset_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_reset_timer$address() {
        return ecs_reset_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_reset_timer(ecs_world_t *world, ecs_entity_t tick_source)
     * }
     */
    public static void ecs_reset_timer(MemorySegment world, long tick_source) {
        var mh$ = ecs_reset_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_reset_timer", world, tick_source);
            }
            mh$.invokeExact(world, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_randomize_timers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_randomize_timers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_randomize_timers(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_randomize_timers$descriptor() {
        return ecs_randomize_timers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_randomize_timers(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_randomize_timers$handle() {
        return ecs_randomize_timers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_randomize_timers(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_randomize_timers$address() {
        return ecs_randomize_timers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_randomize_timers(ecs_world_t *world)
     * }
     */
    public static void ecs_randomize_timers(MemorySegment world) {
        var mh$ = ecs_randomize_timers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_randomize_timers", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_rate(ecs_world_t *world, ecs_entity_t tick_source, int32_t rate, ecs_entity_t source)
     * }
     */
    public static FunctionDescriptor ecs_set_rate$descriptor() {
        return ecs_set_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_rate(ecs_world_t *world, ecs_entity_t tick_source, int32_t rate, ecs_entity_t source)
     * }
     */
    public static MethodHandle ecs_set_rate$handle() {
        return ecs_set_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_rate(ecs_world_t *world, ecs_entity_t tick_source, int32_t rate, ecs_entity_t source)
     * }
     */
    public static MemorySegment ecs_set_rate$address() {
        return ecs_set_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_set_rate(ecs_world_t *world, ecs_entity_t tick_source, int32_t rate, ecs_entity_t source)
     * }
     */
    public static long ecs_set_rate(MemorySegment world, long tick_source, int rate, long source) {
        var mh$ = ecs_set_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_rate", world, tick_source, rate, source);
            }
            return (long)mh$.invokeExact(world, tick_source, rate, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_tick_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_tick_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_tick_source(ecs_world_t *world, ecs_entity_t system, ecs_entity_t tick_source)
     * }
     */
    public static FunctionDescriptor ecs_set_tick_source$descriptor() {
        return ecs_set_tick_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_tick_source(ecs_world_t *world, ecs_entity_t system, ecs_entity_t tick_source)
     * }
     */
    public static MethodHandle ecs_set_tick_source$handle() {
        return ecs_set_tick_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_tick_source(ecs_world_t *world, ecs_entity_t system, ecs_entity_t tick_source)
     * }
     */
    public static MemorySegment ecs_set_tick_source$address() {
        return ecs_set_tick_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_tick_source(ecs_world_t *world, ecs_entity_t system, ecs_entity_t tick_source)
     * }
     */
    public static void ecs_set_tick_source(MemorySegment world, long system, long tick_source) {
        var mh$ = ecs_set_tick_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_tick_source", world, system, tick_source);
            }
            mh$.invokeExact(world, system, tick_source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsTimerImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsTimerImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsTimerImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsTimerImport$descriptor() {
        return FlecsTimerImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsTimerImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsTimerImport$handle() {
        return FlecsTimerImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsTimerImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsTimerImport$address() {
        return FlecsTimerImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsTimerImport(ecs_world_t *world)
     * }
     */
    public static void FlecsTimerImport(MemorySegment world) {
        var mh$ = FlecsTimerImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsTimerImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_pipeline_init(ecs_world_t *world, const ecs_pipeline_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_init$descriptor() {
        return ecs_pipeline_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_pipeline_init(ecs_world_t *world, const ecs_pipeline_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_pipeline_init$handle() {
        return ecs_pipeline_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_pipeline_init(ecs_world_t *world, const ecs_pipeline_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_pipeline_init$address() {
        return ecs_pipeline_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_pipeline_init(ecs_world_t *world, const ecs_pipeline_desc_t *desc)
     * }
     */
    public static long ecs_pipeline_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_pipeline_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_pipeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_pipeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_pipeline(ecs_world_t *world, ecs_entity_t pipeline)
     * }
     */
    public static FunctionDescriptor ecs_set_pipeline$descriptor() {
        return ecs_set_pipeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_pipeline(ecs_world_t *world, ecs_entity_t pipeline)
     * }
     */
    public static MethodHandle ecs_set_pipeline$handle() {
        return ecs_set_pipeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_pipeline(ecs_world_t *world, ecs_entity_t pipeline)
     * }
     */
    public static MemorySegment ecs_set_pipeline$address() {
        return ecs_set_pipeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_pipeline(ecs_world_t *world, ecs_entity_t pipeline)
     * }
     */
    public static void ecs_set_pipeline(MemorySegment world, long pipeline) {
        var mh$ = ecs_set_pipeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_pipeline", world, pipeline);
            }
            mh$.invokeExact(world, pipeline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_pipeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_pipeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_pipeline(const ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_get_pipeline$descriptor() {
        return ecs_get_pipeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_pipeline(const ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_get_pipeline$handle() {
        return ecs_get_pipeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_pipeline(const ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_get_pipeline$address() {
        return ecs_get_pipeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_pipeline(const ecs_world_t *world)
     * }
     */
    public static long ecs_get_pipeline(MemorySegment world) {
        var mh$ = ecs_get_pipeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_pipeline", world);
            }
            return (long)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_progress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_progress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_progress(ecs_world_t *world, float delta_time)
     * }
     */
    public static FunctionDescriptor ecs_progress$descriptor() {
        return ecs_progress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_progress(ecs_world_t *world, float delta_time)
     * }
     */
    public static MethodHandle ecs_progress$handle() {
        return ecs_progress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_progress(ecs_world_t *world, float delta_time)
     * }
     */
    public static MemorySegment ecs_progress$address() {
        return ecs_progress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_progress(ecs_world_t *world, float delta_time)
     * }
     */
    public static boolean ecs_progress(MemorySegment world, float delta_time) {
        var mh$ = ecs_progress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_progress", world, delta_time);
            }
            return (boolean)mh$.invokeExact(world, delta_time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_time_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_time_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_time_scale(ecs_world_t *world, float scale)
     * }
     */
    public static FunctionDescriptor ecs_set_time_scale$descriptor() {
        return ecs_set_time_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_time_scale(ecs_world_t *world, float scale)
     * }
     */
    public static MethodHandle ecs_set_time_scale$handle() {
        return ecs_set_time_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_time_scale(ecs_world_t *world, float scale)
     * }
     */
    public static MemorySegment ecs_set_time_scale$address() {
        return ecs_set_time_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_time_scale(ecs_world_t *world, float scale)
     * }
     */
    public static void ecs_set_time_scale(MemorySegment world, float scale) {
        var mh$ = ecs_set_time_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_time_scale", world, scale);
            }
            mh$.invokeExact(world, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_reset_clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_reset_clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_reset_clock(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_reset_clock$descriptor() {
        return ecs_reset_clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_reset_clock(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_reset_clock$handle() {
        return ecs_reset_clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_reset_clock(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_reset_clock$address() {
        return ecs_reset_clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_reset_clock(ecs_world_t *world)
     * }
     */
    public static void ecs_reset_clock(MemorySegment world) {
        var mh$ = ecs_reset_clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_reset_clock", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_pipeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_run_pipeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_run_pipeline(ecs_world_t *world, ecs_entity_t pipeline, float delta_time)
     * }
     */
    public static FunctionDescriptor ecs_run_pipeline$descriptor() {
        return ecs_run_pipeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_run_pipeline(ecs_world_t *world, ecs_entity_t pipeline, float delta_time)
     * }
     */
    public static MethodHandle ecs_run_pipeline$handle() {
        return ecs_run_pipeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_run_pipeline(ecs_world_t *world, ecs_entity_t pipeline, float delta_time)
     * }
     */
    public static MemorySegment ecs_run_pipeline$address() {
        return ecs_run_pipeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_run_pipeline(ecs_world_t *world, ecs_entity_t pipeline, float delta_time)
     * }
     */
    public static void ecs_run_pipeline(MemorySegment world, long pipeline, float delta_time) {
        var mh$ = ecs_run_pipeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_pipeline", world, pipeline, delta_time);
            }
            mh$.invokeExact(world, pipeline, delta_time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_threads(ecs_world_t *world, int32_t threads)
     * }
     */
    public static FunctionDescriptor ecs_set_threads$descriptor() {
        return ecs_set_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_threads(ecs_world_t *world, int32_t threads)
     * }
     */
    public static MethodHandle ecs_set_threads$handle() {
        return ecs_set_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_threads(ecs_world_t *world, int32_t threads)
     * }
     */
    public static MemorySegment ecs_set_threads$address() {
        return ecs_set_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_threads(ecs_world_t *world, int32_t threads)
     * }
     */
    public static void ecs_set_threads(MemorySegment world, int threads) {
        var mh$ = ecs_set_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_threads", world, threads);
            }
            mh$.invokeExact(world, threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_task_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_task_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_task_threads(ecs_world_t *world, int32_t task_threads)
     * }
     */
    public static FunctionDescriptor ecs_set_task_threads$descriptor() {
        return ecs_set_task_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_task_threads(ecs_world_t *world, int32_t task_threads)
     * }
     */
    public static MethodHandle ecs_set_task_threads$handle() {
        return ecs_set_task_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_task_threads(ecs_world_t *world, int32_t task_threads)
     * }
     */
    public static MemorySegment ecs_set_task_threads$address() {
        return ecs_set_task_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_task_threads(ecs_world_t *world, int32_t task_threads)
     * }
     */
    public static void ecs_set_task_threads(MemorySegment world, int task_threads) {
        var mh$ = ecs_set_task_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_task_threads", world, task_threads);
            }
            mh$.invokeExact(world, task_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_using_task_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_using_task_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_using_task_threads(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_using_task_threads$descriptor() {
        return ecs_using_task_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_using_task_threads(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_using_task_threads$handle() {
        return ecs_using_task_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_using_task_threads(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_using_task_threads$address() {
        return ecs_using_task_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_using_task_threads(ecs_world_t *world)
     * }
     */
    public static boolean ecs_using_task_threads(MemorySegment world) {
        var mh$ = ecs_using_task_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_using_task_threads", world);
            }
            return (boolean)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsPipelineImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsPipelineImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsPipelineImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsPipelineImport$descriptor() {
        return FlecsPipelineImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsPipelineImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsPipelineImport$handle() {
        return FlecsPipelineImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsPipelineImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsPipelineImport$address() {
        return FlecsPipelineImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsPipelineImport(ecs_world_t *world)
     * }
     */
    public static void FlecsPipelineImport(MemorySegment world) {
        var mh$ = FlecsPipelineImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsPipelineImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_system_init(ecs_world_t *world, const ecs_system_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_system_init$descriptor() {
        return ecs_system_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_system_init(ecs_world_t *world, const ecs_system_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_system_init$handle() {
        return ecs_system_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_system_init(ecs_world_t *world, const ecs_system_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_system_init$address() {
        return ecs_system_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_system_init(ecs_world_t *world, const ecs_system_desc_t *desc)
     * }
     */
    public static long ecs_system_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_system_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_system_t *ecs_system_get(const ecs_world_t *world, ecs_entity_t system)
     * }
     */
    public static FunctionDescriptor ecs_system_get$descriptor() {
        return ecs_system_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_system_t *ecs_system_get(const ecs_world_t *world, ecs_entity_t system)
     * }
     */
    public static MethodHandle ecs_system_get$handle() {
        return ecs_system_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_system_t *ecs_system_get(const ecs_world_t *world, ecs_entity_t system)
     * }
     */
    public static MemorySegment ecs_system_get$address() {
        return ecs_system_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_system_t *ecs_system_get(const ecs_world_t *world, ecs_entity_t system)
     * }
     */
    public static MemorySegment ecs_system_get(MemorySegment world, long system) {
        var mh$ = ecs_system_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_get", world, system);
            }
            return (MemorySegment)mh$.invokeExact(world, system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run(ecs_world_t *world, ecs_entity_t system, float delta_time, void *param)
     * }
     */
    public static FunctionDescriptor ecs_run$descriptor() {
        return ecs_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run(ecs_world_t *world, ecs_entity_t system, float delta_time, void *param)
     * }
     */
    public static MethodHandle ecs_run$handle() {
        return ecs_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run(ecs_world_t *world, ecs_entity_t system, float delta_time, void *param)
     * }
     */
    public static MemorySegment ecs_run$address() {
        return ecs_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_run(ecs_world_t *world, ecs_entity_t system, float delta_time, void *param)
     * }
     */
    public static long ecs_run(MemorySegment world, long system, float delta_time, MemorySegment param) {
        var mh$ = ecs_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run", world, system, delta_time, param);
            }
            return (long)mh$.invokeExact(world, system, delta_time, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_run_worker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_run_worker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run_worker(ecs_world_t *world, ecs_entity_t system, int32_t stage_current, int32_t stage_count, float delta_time, void *param)
     * }
     */
    public static FunctionDescriptor ecs_run_worker$descriptor() {
        return ecs_run_worker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run_worker(ecs_world_t *world, ecs_entity_t system, int32_t stage_current, int32_t stage_count, float delta_time, void *param)
     * }
     */
    public static MethodHandle ecs_run_worker$handle() {
        return ecs_run_worker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_run_worker(ecs_world_t *world, ecs_entity_t system, int32_t stage_current, int32_t stage_count, float delta_time, void *param)
     * }
     */
    public static MemorySegment ecs_run_worker$address() {
        return ecs_run_worker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_run_worker(ecs_world_t *world, ecs_entity_t system, int32_t stage_current, int32_t stage_count, float delta_time, void *param)
     * }
     */
    public static long ecs_run_worker(MemorySegment world, long system, int stage_current, int stage_count, float delta_time, MemorySegment param) {
        var mh$ = ecs_run_worker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_run_worker", world, system, stage_current, stage_count, delta_time, param);
            }
            return (long)mh$.invokeExact(world, system, stage_current, stage_count, delta_time, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsSystemImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsSystemImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsSystemImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsSystemImport$descriptor() {
        return FlecsSystemImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsSystemImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsSystemImport$handle() {
        return FlecsSystemImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsSystemImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsSystemImport$address() {
        return FlecsSystemImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsSystemImport(ecs_world_t *world)
     * }
     */
    public static void FlecsSystemImport(MemorySegment world) {
        var mh$ = FlecsSystemImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsSystemImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_get(const ecs_world_t *world, ecs_world_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_get$descriptor() {
        return ecs_world_stats_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_get(const ecs_world_t *world, ecs_world_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_world_stats_get$handle() {
        return ecs_world_stats_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_get(const ecs_world_t *world, ecs_world_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_world_stats_get$address() {
        return ecs_world_stats_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_get(const ecs_world_t *world, ecs_world_stats_t *stats)
     * }
     */
    public static void ecs_world_stats_get(MemorySegment world, MemorySegment stats) {
        var mh$ = ecs_world_stats_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_get", world, stats);
            }
            mh$.invokeExact(world, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_reduce$descriptor() {
        return ecs_world_stats_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static MethodHandle ecs_world_stats_reduce$handle() {
        return ecs_world_stats_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static MemorySegment ecs_world_stats_reduce$address() {
        return ecs_world_stats_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_reduce(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static void ecs_world_stats_reduce(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_world_stats_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_reduce", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_reduce_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_reduce_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce_last(ecs_world_stats_t *stats, const ecs_world_stats_t *old, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_reduce_last$descriptor() {
        return ecs_world_stats_reduce_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce_last(ecs_world_stats_t *stats, const ecs_world_stats_t *old, int32_t count)
     * }
     */
    public static MethodHandle ecs_world_stats_reduce_last$handle() {
        return ecs_world_stats_reduce_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_reduce_last(ecs_world_stats_t *stats, const ecs_world_stats_t *old, int32_t count)
     * }
     */
    public static MemorySegment ecs_world_stats_reduce_last$address() {
        return ecs_world_stats_reduce_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_reduce_last(ecs_world_stats_t *stats, const ecs_world_stats_t *old, int32_t count)
     * }
     */
    public static void ecs_world_stats_reduce_last(MemorySegment stats, MemorySegment old, int count) {
        var mh$ = ecs_world_stats_reduce_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_reduce_last", stats, old, count);
            }
            mh$.invokeExact(stats, old, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_repeat_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_repeat_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_repeat_last(ecs_world_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_repeat_last$descriptor() {
        return ecs_world_stats_repeat_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_repeat_last(ecs_world_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_world_stats_repeat_last$handle() {
        return ecs_world_stats_repeat_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_repeat_last(ecs_world_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_world_stats_repeat_last$address() {
        return ecs_world_stats_repeat_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_repeat_last(ecs_world_stats_t *stats)
     * }
     */
    public static void ecs_world_stats_repeat_last(MemorySegment stats) {
        var mh$ = ecs_world_stats_repeat_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_repeat_last", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_copy_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_copy_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_copy_last(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_copy_last$descriptor() {
        return ecs_world_stats_copy_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_copy_last(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static MethodHandle ecs_world_stats_copy_last$handle() {
        return ecs_world_stats_copy_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_copy_last(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static MemorySegment ecs_world_stats_copy_last$address() {
        return ecs_world_stats_copy_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_copy_last(ecs_world_stats_t *dst, const ecs_world_stats_t *src)
     * }
     */
    public static void ecs_world_stats_copy_last(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_world_stats_copy_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_copy_last", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_stats_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_stats_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_world_stats_log(const ecs_world_t *world, const ecs_world_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_world_stats_log$descriptor() {
        return ecs_world_stats_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_world_stats_log(const ecs_world_t *world, const ecs_world_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_world_stats_log$handle() {
        return ecs_world_stats_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_world_stats_log(const ecs_world_t *world, const ecs_world_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_world_stats_log$address() {
        return ecs_world_stats_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_world_stats_log(const ecs_world_t *world, const ecs_world_stats_t *stats)
     * }
     */
    public static void ecs_world_stats_log(MemorySegment world, MemorySegment stats) {
        var mh$ = ecs_world_stats_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_stats_log", world, stats);
            }
            mh$.invokeExact(world, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_stats_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_stats_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_stats_get(const ecs_world_t *world, const ecs_query_t *query, ecs_query_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_query_stats_get$descriptor() {
        return ecs_query_stats_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_stats_get(const ecs_world_t *world, const ecs_query_t *query, ecs_query_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_query_stats_get$handle() {
        return ecs_query_stats_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_stats_get(const ecs_world_t *world, const ecs_query_t *query, ecs_query_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_query_stats_get$address() {
        return ecs_query_stats_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_stats_get(const ecs_world_t *world, const ecs_query_t *query, ecs_query_stats_t *stats)
     * }
     */
    public static void ecs_query_stats_get(MemorySegment world, MemorySegment query, MemorySegment stats) {
        var mh$ = ecs_query_stats_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_stats_get", world, query, stats);
            }
            mh$.invokeExact(world, query, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_cache_stats_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_cache_stats_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_query_cache_stats_reduce$descriptor() {
        return ecs_query_cache_stats_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static MethodHandle ecs_query_cache_stats_reduce$handle() {
        return ecs_query_cache_stats_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static MemorySegment ecs_query_cache_stats_reduce$address() {
        return ecs_query_cache_stats_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static void ecs_query_cache_stats_reduce(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_query_cache_stats_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_cache_stats_reduce", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_cache_stats_reduce_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_cache_stats_reduce_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce_last(ecs_query_stats_t *stats, const ecs_query_stats_t *old, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_query_cache_stats_reduce_last$descriptor() {
        return ecs_query_cache_stats_reduce_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce_last(ecs_query_stats_t *stats, const ecs_query_stats_t *old, int32_t count)
     * }
     */
    public static MethodHandle ecs_query_cache_stats_reduce_last$handle() {
        return ecs_query_cache_stats_reduce_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce_last(ecs_query_stats_t *stats, const ecs_query_stats_t *old, int32_t count)
     * }
     */
    public static MemorySegment ecs_query_cache_stats_reduce_last$address() {
        return ecs_query_cache_stats_reduce_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_cache_stats_reduce_last(ecs_query_stats_t *stats, const ecs_query_stats_t *old, int32_t count)
     * }
     */
    public static void ecs_query_cache_stats_reduce_last(MemorySegment stats, MemorySegment old, int count) {
        var mh$ = ecs_query_cache_stats_reduce_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_cache_stats_reduce_last", stats, old, count);
            }
            mh$.invokeExact(stats, old, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_cache_stats_repeat_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_cache_stats_repeat_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_repeat_last(ecs_query_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_query_cache_stats_repeat_last$descriptor() {
        return ecs_query_cache_stats_repeat_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_repeat_last(ecs_query_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_query_cache_stats_repeat_last$handle() {
        return ecs_query_cache_stats_repeat_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_repeat_last(ecs_query_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_query_cache_stats_repeat_last$address() {
        return ecs_query_cache_stats_repeat_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_cache_stats_repeat_last(ecs_query_stats_t *stats)
     * }
     */
    public static void ecs_query_cache_stats_repeat_last(MemorySegment stats) {
        var mh$ = ecs_query_cache_stats_repeat_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_cache_stats_repeat_last", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_query_cache_stats_copy_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_query_cache_stats_copy_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_copy_last(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_query_cache_stats_copy_last$descriptor() {
        return ecs_query_cache_stats_copy_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_copy_last(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static MethodHandle ecs_query_cache_stats_copy_last$handle() {
        return ecs_query_cache_stats_copy_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_query_cache_stats_copy_last(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static MemorySegment ecs_query_cache_stats_copy_last$address() {
        return ecs_query_cache_stats_copy_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_query_cache_stats_copy_last(ecs_query_stats_t *dst, const ecs_query_stats_t *src)
     * }
     */
    public static void ecs_query_cache_stats_copy_last(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_query_cache_stats_copy_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_query_cache_stats_copy_last", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_stats_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_stats_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_system_stats_get(const ecs_world_t *world, ecs_entity_t system, ecs_system_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_system_stats_get$descriptor() {
        return ecs_system_stats_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_system_stats_get(const ecs_world_t *world, ecs_entity_t system, ecs_system_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_system_stats_get$handle() {
        return ecs_system_stats_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_system_stats_get(const ecs_world_t *world, ecs_entity_t system, ecs_system_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_system_stats_get$address() {
        return ecs_system_stats_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_system_stats_get(const ecs_world_t *world, ecs_entity_t system, ecs_system_stats_t *stats)
     * }
     */
    public static boolean ecs_system_stats_get(MemorySegment world, long system, MemorySegment stats) {
        var mh$ = ecs_system_stats_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_stats_get", world, system, stats);
            }
            return (boolean)mh$.invokeExact(world, system, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_stats_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_stats_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_system_stats_reduce$descriptor() {
        return ecs_system_stats_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static MethodHandle ecs_system_stats_reduce$handle() {
        return ecs_system_stats_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static MemorySegment ecs_system_stats_reduce$address() {
        return ecs_system_stats_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_system_stats_reduce(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static void ecs_system_stats_reduce(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_system_stats_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_stats_reduce", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_stats_reduce_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_stats_reduce_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce_last(ecs_system_stats_t *stats, const ecs_system_stats_t *old, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_system_stats_reduce_last$descriptor() {
        return ecs_system_stats_reduce_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce_last(ecs_system_stats_t *stats, const ecs_system_stats_t *old, int32_t count)
     * }
     */
    public static MethodHandle ecs_system_stats_reduce_last$handle() {
        return ecs_system_stats_reduce_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_system_stats_reduce_last(ecs_system_stats_t *stats, const ecs_system_stats_t *old, int32_t count)
     * }
     */
    public static MemorySegment ecs_system_stats_reduce_last$address() {
        return ecs_system_stats_reduce_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_system_stats_reduce_last(ecs_system_stats_t *stats, const ecs_system_stats_t *old, int32_t count)
     * }
     */
    public static void ecs_system_stats_reduce_last(MemorySegment stats, MemorySegment old, int count) {
        var mh$ = ecs_system_stats_reduce_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_stats_reduce_last", stats, old, count);
            }
            mh$.invokeExact(stats, old, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_stats_repeat_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_stats_repeat_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_system_stats_repeat_last(ecs_system_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_system_stats_repeat_last$descriptor() {
        return ecs_system_stats_repeat_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_system_stats_repeat_last(ecs_system_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_system_stats_repeat_last$handle() {
        return ecs_system_stats_repeat_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_system_stats_repeat_last(ecs_system_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_system_stats_repeat_last$address() {
        return ecs_system_stats_repeat_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_system_stats_repeat_last(ecs_system_stats_t *stats)
     * }
     */
    public static void ecs_system_stats_repeat_last(MemorySegment stats) {
        var mh$ = ecs_system_stats_repeat_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_stats_repeat_last", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_system_stats_copy_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_system_stats_copy_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_system_stats_copy_last(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_system_stats_copy_last$descriptor() {
        return ecs_system_stats_copy_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_system_stats_copy_last(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static MethodHandle ecs_system_stats_copy_last$handle() {
        return ecs_system_stats_copy_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_system_stats_copy_last(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static MemorySegment ecs_system_stats_copy_last$address() {
        return ecs_system_stats_copy_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_system_stats_copy_last(ecs_system_stats_t *dst, const ecs_system_stats_t *src)
     * }
     */
    public static void ecs_system_stats_copy_last(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_system_stats_copy_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_system_stats_copy_last", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_pipeline_stats_get(ecs_world_t *world, ecs_entity_t pipeline, ecs_pipeline_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_get$descriptor() {
        return ecs_pipeline_stats_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_pipeline_stats_get(ecs_world_t *world, ecs_entity_t pipeline, ecs_pipeline_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_get$handle() {
        return ecs_pipeline_stats_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_pipeline_stats_get(ecs_world_t *world, ecs_entity_t pipeline, ecs_pipeline_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_get$address() {
        return ecs_pipeline_stats_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_pipeline_stats_get(ecs_world_t *world, ecs_entity_t pipeline, ecs_pipeline_stats_t *stats)
     * }
     */
    public static boolean ecs_pipeline_stats_get(MemorySegment world, long pipeline, MemorySegment stats) {
        var mh$ = ecs_pipeline_stats_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_get", world, pipeline, stats);
            }
            return (boolean)mh$.invokeExact(world, pipeline, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_fini(ecs_pipeline_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_fini$descriptor() {
        return ecs_pipeline_stats_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_fini(ecs_pipeline_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_fini$handle() {
        return ecs_pipeline_stats_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_fini(ecs_pipeline_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_fini$address() {
        return ecs_pipeline_stats_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_pipeline_stats_fini(ecs_pipeline_stats_t *stats)
     * }
     */
    public static void ecs_pipeline_stats_fini(MemorySegment stats) {
        var mh$ = ecs_pipeline_stats_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_fini", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_reduce$descriptor() {
        return ecs_pipeline_stats_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_reduce$handle() {
        return ecs_pipeline_stats_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_reduce$address() {
        return ecs_pipeline_stats_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static void ecs_pipeline_stats_reduce(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_pipeline_stats_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_reduce", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_reduce_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_reduce_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce_last(ecs_pipeline_stats_t *stats, const ecs_pipeline_stats_t *old, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_reduce_last$descriptor() {
        return ecs_pipeline_stats_reduce_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce_last(ecs_pipeline_stats_t *stats, const ecs_pipeline_stats_t *old, int32_t count)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_reduce_last$handle() {
        return ecs_pipeline_stats_reduce_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce_last(ecs_pipeline_stats_t *stats, const ecs_pipeline_stats_t *old, int32_t count)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_reduce_last$address() {
        return ecs_pipeline_stats_reduce_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_pipeline_stats_reduce_last(ecs_pipeline_stats_t *stats, const ecs_pipeline_stats_t *old, int32_t count)
     * }
     */
    public static void ecs_pipeline_stats_reduce_last(MemorySegment stats, MemorySegment old, int count) {
        var mh$ = ecs_pipeline_stats_reduce_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_reduce_last", stats, old, count);
            }
            mh$.invokeExact(stats, old, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_repeat_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_repeat_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_repeat_last(ecs_pipeline_stats_t *stats)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_repeat_last$descriptor() {
        return ecs_pipeline_stats_repeat_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_repeat_last(ecs_pipeline_stats_t *stats)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_repeat_last$handle() {
        return ecs_pipeline_stats_repeat_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_repeat_last(ecs_pipeline_stats_t *stats)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_repeat_last$address() {
        return ecs_pipeline_stats_repeat_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_pipeline_stats_repeat_last(ecs_pipeline_stats_t *stats)
     * }
     */
    public static void ecs_pipeline_stats_repeat_last(MemorySegment stats) {
        var mh$ = ecs_pipeline_stats_repeat_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_repeat_last", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_pipeline_stats_copy_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_pipeline_stats_copy_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_copy_last(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static FunctionDescriptor ecs_pipeline_stats_copy_last$descriptor() {
        return ecs_pipeline_stats_copy_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_copy_last(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static MethodHandle ecs_pipeline_stats_copy_last$handle() {
        return ecs_pipeline_stats_copy_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_pipeline_stats_copy_last(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static MemorySegment ecs_pipeline_stats_copy_last$address() {
        return ecs_pipeline_stats_copy_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_pipeline_stats_copy_last(ecs_pipeline_stats_t *dst, const ecs_pipeline_stats_t *src)
     * }
     */
    public static void ecs_pipeline_stats_copy_last(MemorySegment dst, MemorySegment src) {
        var mh$ = ecs_pipeline_stats_copy_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_pipeline_stats_copy_last", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_metric_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_metric_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_metric_reduce(ecs_metric_t *dst, const ecs_metric_t *src, int32_t t_dst, int32_t t_src)
     * }
     */
    public static FunctionDescriptor ecs_metric_reduce$descriptor() {
        return ecs_metric_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_metric_reduce(ecs_metric_t *dst, const ecs_metric_t *src, int32_t t_dst, int32_t t_src)
     * }
     */
    public static MethodHandle ecs_metric_reduce$handle() {
        return ecs_metric_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_metric_reduce(ecs_metric_t *dst, const ecs_metric_t *src, int32_t t_dst, int32_t t_src)
     * }
     */
    public static MemorySegment ecs_metric_reduce$address() {
        return ecs_metric_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_metric_reduce(ecs_metric_t *dst, const ecs_metric_t *src, int32_t t_dst, int32_t t_src)
     * }
     */
    public static void ecs_metric_reduce(MemorySegment dst, MemorySegment src, int t_dst, int t_src) {
        var mh$ = ecs_metric_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_metric_reduce", dst, src, t_dst, t_src);
            }
            mh$.invokeExact(dst, src, t_dst, t_src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_metric_reduce_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_metric_reduce_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_metric_reduce_last(ecs_metric_t *m, int32_t t, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_metric_reduce_last$descriptor() {
        return ecs_metric_reduce_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_metric_reduce_last(ecs_metric_t *m, int32_t t, int32_t count)
     * }
     */
    public static MethodHandle ecs_metric_reduce_last$handle() {
        return ecs_metric_reduce_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_metric_reduce_last(ecs_metric_t *m, int32_t t, int32_t count)
     * }
     */
    public static MemorySegment ecs_metric_reduce_last$address() {
        return ecs_metric_reduce_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_metric_reduce_last(ecs_metric_t *m, int32_t t, int32_t count)
     * }
     */
    public static void ecs_metric_reduce_last(MemorySegment m, int t, int count) {
        var mh$ = ecs_metric_reduce_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_metric_reduce_last", m, t, count);
            }
            mh$.invokeExact(m, t, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_metric_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_metric_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_metric_copy(ecs_metric_t *m, int32_t dst, int32_t src)
     * }
     */
    public static FunctionDescriptor ecs_metric_copy$descriptor() {
        return ecs_metric_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_metric_copy(ecs_metric_t *m, int32_t dst, int32_t src)
     * }
     */
    public static MethodHandle ecs_metric_copy$handle() {
        return ecs_metric_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_metric_copy(ecs_metric_t *m, int32_t dst, int32_t src)
     * }
     */
    public static MemorySegment ecs_metric_copy$address() {
        return ecs_metric_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_metric_copy(ecs_metric_t *m, int32_t dst, int32_t src)
     * }
     */
    public static void ecs_metric_copy(MemorySegment m, int dst, int src) {
        var mh$ = ecs_metric_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_metric_copy", m, dst, src);
            }
            mh$.invokeExact(m, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDFlecsStatsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDFlecsStatsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsStatsID_
     * }
     */
    public static OfLong FLECS_IDFlecsStatsID_$layout() {
        return FLECS_IDFlecsStatsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsStatsID_
     * }
     */
    public static MemorySegment FLECS_IDFlecsStatsID_$segment() {
        return FLECS_IDFlecsStatsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsStatsID_
     * }
     */
    public static long FLECS_IDFlecsStatsID_() {
        return FLECS_IDFlecsStatsID_$constants.SEGMENT.get(FLECS_IDFlecsStatsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsStatsID_
     * }
     */
    public static void FLECS_IDFlecsStatsID_(long varValue) {
        FLECS_IDFlecsStatsID_$constants.SEGMENT.set(FLECS_IDFlecsStatsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsWorldStatsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsWorldStatsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldStatsID_
     * }
     */
    public static OfLong FLECS_IDEcsWorldStatsID_$layout() {
        return FLECS_IDEcsWorldStatsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldStatsID_
     * }
     */
    public static MemorySegment FLECS_IDEcsWorldStatsID_$segment() {
        return FLECS_IDEcsWorldStatsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldStatsID_
     * }
     */
    public static long FLECS_IDEcsWorldStatsID_() {
        return FLECS_IDEcsWorldStatsID_$constants.SEGMENT.get(FLECS_IDEcsWorldStatsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldStatsID_
     * }
     */
    public static void FLECS_IDEcsWorldStatsID_(long varValue) {
        FLECS_IDEcsWorldStatsID_$constants.SEGMENT.set(FLECS_IDEcsWorldStatsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsWorldSummaryID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsWorldSummaryID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldSummaryID_
     * }
     */
    public static OfLong FLECS_IDEcsWorldSummaryID_$layout() {
        return FLECS_IDEcsWorldSummaryID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldSummaryID_
     * }
     */
    public static MemorySegment FLECS_IDEcsWorldSummaryID_$segment() {
        return FLECS_IDEcsWorldSummaryID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldSummaryID_
     * }
     */
    public static long FLECS_IDEcsWorldSummaryID_() {
        return FLECS_IDEcsWorldSummaryID_$constants.SEGMENT.get(FLECS_IDEcsWorldSummaryID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsWorldSummaryID_
     * }
     */
    public static void FLECS_IDEcsWorldSummaryID_(long varValue) {
        FLECS_IDEcsWorldSummaryID_$constants.SEGMENT.set(FLECS_IDEcsWorldSummaryID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsSystemStatsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsSystemStatsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsSystemStatsID_
     * }
     */
    public static OfLong FLECS_IDEcsSystemStatsID_$layout() {
        return FLECS_IDEcsSystemStatsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsSystemStatsID_
     * }
     */
    public static MemorySegment FLECS_IDEcsSystemStatsID_$segment() {
        return FLECS_IDEcsSystemStatsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsSystemStatsID_
     * }
     */
    public static long FLECS_IDEcsSystemStatsID_() {
        return FLECS_IDEcsSystemStatsID_$constants.SEGMENT.get(FLECS_IDEcsSystemStatsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsSystemStatsID_
     * }
     */
    public static void FLECS_IDEcsSystemStatsID_(long varValue) {
        FLECS_IDEcsSystemStatsID_$constants.SEGMENT.set(FLECS_IDEcsSystemStatsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPipelineStatsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsPipelineStatsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsPipelineStatsID_
     * }
     */
    public static OfLong FLECS_IDEcsPipelineStatsID_$layout() {
        return FLECS_IDEcsPipelineStatsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsPipelineStatsID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPipelineStatsID_$segment() {
        return FLECS_IDEcsPipelineStatsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsPipelineStatsID_
     * }
     */
    public static long FLECS_IDEcsPipelineStatsID_() {
        return FLECS_IDEcsPipelineStatsID_$constants.SEGMENT.get(FLECS_IDEcsPipelineStatsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsPipelineStatsID_
     * }
     */
    public static void FLECS_IDEcsPipelineStatsID_(long varValue) {
        FLECS_IDEcsPipelineStatsID_$constants.SEGMENT.set(FLECS_IDEcsPipelineStatsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeriod1s$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeriod1s").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1s
     * }
     */
    public static OfLong EcsPeriod1s$layout() {
        return EcsPeriod1s$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1s
     * }
     */
    public static MemorySegment EcsPeriod1s$segment() {
        return EcsPeriod1s$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1s
     * }
     */
    public static long EcsPeriod1s() {
        return EcsPeriod1s$constants.SEGMENT.get(EcsPeriod1s$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1s
     * }
     */
    public static void EcsPeriod1s(long varValue) {
        EcsPeriod1s$constants.SEGMENT.set(EcsPeriod1s$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeriod1m$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeriod1m").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1m
     * }
     */
    public static OfLong EcsPeriod1m$layout() {
        return EcsPeriod1m$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1m
     * }
     */
    public static MemorySegment EcsPeriod1m$segment() {
        return EcsPeriod1m$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1m
     * }
     */
    public static long EcsPeriod1m() {
        return EcsPeriod1m$constants.SEGMENT.get(EcsPeriod1m$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1m
     * }
     */
    public static void EcsPeriod1m(long varValue) {
        EcsPeriod1m$constants.SEGMENT.set(EcsPeriod1m$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeriod1h$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeriod1h").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1h
     * }
     */
    public static OfLong EcsPeriod1h$layout() {
        return EcsPeriod1h$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1h
     * }
     */
    public static MemorySegment EcsPeriod1h$segment() {
        return EcsPeriod1h$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1h
     * }
     */
    public static long EcsPeriod1h() {
        return EcsPeriod1h$constants.SEGMENT.get(EcsPeriod1h$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1h
     * }
     */
    public static void EcsPeriod1h(long varValue) {
        EcsPeriod1h$constants.SEGMENT.set(EcsPeriod1h$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeriod1d$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeriod1d").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1d
     * }
     */
    public static OfLong EcsPeriod1d$layout() {
        return EcsPeriod1d$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1d
     * }
     */
    public static MemorySegment EcsPeriod1d$segment() {
        return EcsPeriod1d$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1d
     * }
     */
    public static long EcsPeriod1d() {
        return EcsPeriod1d$constants.SEGMENT.get(EcsPeriod1d$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1d
     * }
     */
    public static void EcsPeriod1d(long varValue) {
        EcsPeriod1d$constants.SEGMENT.set(EcsPeriod1d$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeriod1w$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeriod1w").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1w
     * }
     */
    public static OfLong EcsPeriod1w$layout() {
        return EcsPeriod1w$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1w
     * }
     */
    public static MemorySegment EcsPeriod1w$segment() {
        return EcsPeriod1w$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1w
     * }
     */
    public static long EcsPeriod1w() {
        return EcsPeriod1w$constants.SEGMENT.get(EcsPeriod1w$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeriod1w
     * }
     */
    public static void EcsPeriod1w(long varValue) {
        EcsPeriod1w$constants.SEGMENT.set(EcsPeriod1w$constants.LAYOUT, 0L, varValue);
    }

    private static class FlecsStatsImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsStatsImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsStatsImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsStatsImport$descriptor() {
        return FlecsStatsImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsStatsImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsStatsImport$handle() {
        return FlecsStatsImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsStatsImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsStatsImport$address() {
        return FlecsStatsImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsStatsImport(ecs_world_t *world)
     * }
     */
    public static void FlecsStatsImport(MemorySegment world) {
        var mh$ = FlecsStatsImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsStatsImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDFlecsMetricsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDFlecsMetricsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsMetricsID_
     * }
     */
    public static OfLong FLECS_IDFlecsMetricsID_$layout() {
        return FLECS_IDFlecsMetricsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsMetricsID_
     * }
     */
    public static MemorySegment FLECS_IDFlecsMetricsID_$segment() {
        return FLECS_IDFlecsMetricsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsMetricsID_
     * }
     */
    public static long FLECS_IDFlecsMetricsID_() {
        return FLECS_IDFlecsMetricsID_$constants.SEGMENT.get(FLECS_IDFlecsMetricsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsMetricsID_
     * }
     */
    public static void FLECS_IDFlecsMetricsID_(long varValue) {
        FLECS_IDFlecsMetricsID_$constants.SEGMENT.set(FLECS_IDFlecsMetricsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMetric$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMetric").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetric
     * }
     */
    public static OfLong EcsMetric$layout() {
        return EcsMetric$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetric
     * }
     */
    public static MemorySegment EcsMetric$segment() {
        return EcsMetric$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetric
     * }
     */
    public static long EcsMetric() {
        return EcsMetric$constants.SEGMENT.get(EcsMetric$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetric
     * }
     */
    public static void EcsMetric(long varValue) {
        EcsMetric$constants.SEGMENT.set(EcsMetric$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMetricID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMetricID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricID_
     * }
     */
    public static OfLong FLECS_IDEcsMetricID_$layout() {
        return FLECS_IDEcsMetricID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMetricID_$segment() {
        return FLECS_IDEcsMetricID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricID_
     * }
     */
    public static long FLECS_IDEcsMetricID_() {
        return FLECS_IDEcsMetricID_$constants.SEGMENT.get(FLECS_IDEcsMetricID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricID_
     * }
     */
    public static void FLECS_IDEcsMetricID_(long varValue) {
        FLECS_IDEcsMetricID_$constants.SEGMENT.set(FLECS_IDEcsMetricID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCounter$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCounter").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounter
     * }
     */
    public static OfLong EcsCounter$layout() {
        return EcsCounter$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounter
     * }
     */
    public static MemorySegment EcsCounter$segment() {
        return EcsCounter$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounter
     * }
     */
    public static long EcsCounter() {
        return EcsCounter$constants.SEGMENT.get(EcsCounter$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounter
     * }
     */
    public static void EcsCounter(long varValue) {
        EcsCounter$constants.SEGMENT.set(EcsCounter$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsCounterID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsCounterID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterID_
     * }
     */
    public static OfLong FLECS_IDEcsCounterID_$layout() {
        return FLECS_IDEcsCounterID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterID_
     * }
     */
    public static MemorySegment FLECS_IDEcsCounterID_$segment() {
        return FLECS_IDEcsCounterID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterID_
     * }
     */
    public static long FLECS_IDEcsCounterID_() {
        return FLECS_IDEcsCounterID_$constants.SEGMENT.get(FLECS_IDEcsCounterID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterID_
     * }
     */
    public static void FLECS_IDEcsCounterID_(long varValue) {
        FLECS_IDEcsCounterID_$constants.SEGMENT.set(FLECS_IDEcsCounterID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCounterIncrement$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCounterIncrement").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterIncrement
     * }
     */
    public static OfLong EcsCounterIncrement$layout() {
        return EcsCounterIncrement$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterIncrement
     * }
     */
    public static MemorySegment EcsCounterIncrement$segment() {
        return EcsCounterIncrement$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterIncrement
     * }
     */
    public static long EcsCounterIncrement() {
        return EcsCounterIncrement$constants.SEGMENT.get(EcsCounterIncrement$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterIncrement
     * }
     */
    public static void EcsCounterIncrement(long varValue) {
        EcsCounterIncrement$constants.SEGMENT.set(EcsCounterIncrement$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsCounterIncrementID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsCounterIncrementID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIncrementID_
     * }
     */
    public static OfLong FLECS_IDEcsCounterIncrementID_$layout() {
        return FLECS_IDEcsCounterIncrementID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIncrementID_
     * }
     */
    public static MemorySegment FLECS_IDEcsCounterIncrementID_$segment() {
        return FLECS_IDEcsCounterIncrementID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIncrementID_
     * }
     */
    public static long FLECS_IDEcsCounterIncrementID_() {
        return FLECS_IDEcsCounterIncrementID_$constants.SEGMENT.get(FLECS_IDEcsCounterIncrementID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIncrementID_
     * }
     */
    public static void FLECS_IDEcsCounterIncrementID_(long varValue) {
        FLECS_IDEcsCounterIncrementID_$constants.SEGMENT.set(FLECS_IDEcsCounterIncrementID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCounterId$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCounterId").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterId
     * }
     */
    public static OfLong EcsCounterId$layout() {
        return EcsCounterId$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterId
     * }
     */
    public static MemorySegment EcsCounterId$segment() {
        return EcsCounterId$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterId
     * }
     */
    public static long EcsCounterId() {
        return EcsCounterId$constants.SEGMENT.get(EcsCounterId$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCounterId
     * }
     */
    public static void EcsCounterId(long varValue) {
        EcsCounterId$constants.SEGMENT.set(EcsCounterId$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsCounterIdID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsCounterIdID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIdID_
     * }
     */
    public static OfLong FLECS_IDEcsCounterIdID_$layout() {
        return FLECS_IDEcsCounterIdID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIdID_
     * }
     */
    public static MemorySegment FLECS_IDEcsCounterIdID_$segment() {
        return FLECS_IDEcsCounterIdID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIdID_
     * }
     */
    public static long FLECS_IDEcsCounterIdID_() {
        return FLECS_IDEcsCounterIdID_$constants.SEGMENT.get(FLECS_IDEcsCounterIdID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsCounterIdID_
     * }
     */
    public static void FLECS_IDEcsCounterIdID_(long varValue) {
        FLECS_IDEcsCounterIdID_$constants.SEGMENT.set(FLECS_IDEcsCounterIdID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGauge$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGauge").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGauge
     * }
     */
    public static OfLong EcsGauge$layout() {
        return EcsGauge$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGauge
     * }
     */
    public static MemorySegment EcsGauge$segment() {
        return EcsGauge$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGauge
     * }
     */
    public static long EcsGauge() {
        return EcsGauge$constants.SEGMENT.get(EcsGauge$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGauge
     * }
     */
    public static void EcsGauge(long varValue) {
        EcsGauge$constants.SEGMENT.set(EcsGauge$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsGaugeID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsGaugeID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsGaugeID_
     * }
     */
    public static OfLong FLECS_IDEcsGaugeID_$layout() {
        return FLECS_IDEcsGaugeID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsGaugeID_
     * }
     */
    public static MemorySegment FLECS_IDEcsGaugeID_$segment() {
        return FLECS_IDEcsGaugeID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsGaugeID_
     * }
     */
    public static long FLECS_IDEcsGaugeID_() {
        return FLECS_IDEcsGaugeID_$constants.SEGMENT.get(FLECS_IDEcsGaugeID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsGaugeID_
     * }
     */
    public static void FLECS_IDEcsGaugeID_(long varValue) {
        FLECS_IDEcsGaugeID_$constants.SEGMENT.set(FLECS_IDEcsGaugeID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMetricInstance$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMetricInstance").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetricInstance
     * }
     */
    public static OfLong EcsMetricInstance$layout() {
        return EcsMetricInstance$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetricInstance
     * }
     */
    public static MemorySegment EcsMetricInstance$segment() {
        return EcsMetricInstance$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetricInstance
     * }
     */
    public static long EcsMetricInstance() {
        return EcsMetricInstance$constants.SEGMENT.get(EcsMetricInstance$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetricInstance
     * }
     */
    public static void EcsMetricInstance(long varValue) {
        EcsMetricInstance$constants.SEGMENT.set(EcsMetricInstance$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMetricInstanceID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMetricInstanceID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricInstanceID_
     * }
     */
    public static OfLong FLECS_IDEcsMetricInstanceID_$layout() {
        return FLECS_IDEcsMetricInstanceID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricInstanceID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMetricInstanceID_$segment() {
        return FLECS_IDEcsMetricInstanceID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricInstanceID_
     * }
     */
    public static long FLECS_IDEcsMetricInstanceID_() {
        return FLECS_IDEcsMetricInstanceID_$constants.SEGMENT.get(FLECS_IDEcsMetricInstanceID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricInstanceID_
     * }
     */
    public static void FLECS_IDEcsMetricInstanceID_(long varValue) {
        FLECS_IDEcsMetricInstanceID_$constants.SEGMENT.set(FLECS_IDEcsMetricInstanceID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMetricValueID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMetricValueID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricValueID_
     * }
     */
    public static OfLong FLECS_IDEcsMetricValueID_$layout() {
        return FLECS_IDEcsMetricValueID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricValueID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMetricValueID_$segment() {
        return FLECS_IDEcsMetricValueID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricValueID_
     * }
     */
    public static long FLECS_IDEcsMetricValueID_() {
        return FLECS_IDEcsMetricValueID_$constants.SEGMENT.get(FLECS_IDEcsMetricValueID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricValueID_
     * }
     */
    public static void FLECS_IDEcsMetricValueID_(long varValue) {
        FLECS_IDEcsMetricValueID_$constants.SEGMENT.set(FLECS_IDEcsMetricValueID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMetricSourceID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMetricSourceID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricSourceID_
     * }
     */
    public static OfLong FLECS_IDEcsMetricSourceID_$layout() {
        return FLECS_IDEcsMetricSourceID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricSourceID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMetricSourceID_$segment() {
        return FLECS_IDEcsMetricSourceID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricSourceID_
     * }
     */
    public static long FLECS_IDEcsMetricSourceID_() {
        return FLECS_IDEcsMetricSourceID_$constants.SEGMENT.get(FLECS_IDEcsMetricSourceID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsMetricSourceID_
     * }
     */
    public static void FLECS_IDEcsMetricSourceID_(long varValue) {
        FLECS_IDEcsMetricSourceID_$constants.SEGMENT.set(FLECS_IDEcsMetricSourceID_$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_metric_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_metric_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_metric_init(ecs_world_t *world, const ecs_metric_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_metric_init$descriptor() {
        return ecs_metric_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_metric_init(ecs_world_t *world, const ecs_metric_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_metric_init$handle() {
        return ecs_metric_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_metric_init(ecs_world_t *world, const ecs_metric_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_metric_init$address() {
        return ecs_metric_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_metric_init(ecs_world_t *world, const ecs_metric_desc_t *desc)
     * }
     */
    public static long ecs_metric_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_metric_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_metric_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsMetricsImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsMetricsImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsMetricsImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsMetricsImport$descriptor() {
        return FlecsMetricsImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsMetricsImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsMetricsImport$handle() {
        return FlecsMetricsImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsMetricsImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsMetricsImport$address() {
        return FlecsMetricsImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsMetricsImport(ecs_world_t *world)
     * }
     */
    public static void FlecsMetricsImport(MemorySegment world) {
        var mh$ = FlecsMetricsImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsMetricsImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDFlecsAlertsID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDFlecsAlertsID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsAlertsID_
     * }
     */
    public static OfLong FLECS_IDFlecsAlertsID_$layout() {
        return FLECS_IDFlecsAlertsID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsAlertsID_
     * }
     */
    public static MemorySegment FLECS_IDFlecsAlertsID_$segment() {
        return FLECS_IDFlecsAlertsID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsAlertsID_
     * }
     */
    public static long FLECS_IDFlecsAlertsID_() {
        return FLECS_IDFlecsAlertsID_$constants.SEGMENT.get(FLECS_IDFlecsAlertsID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDFlecsAlertsID_
     * }
     */
    public static void FLECS_IDFlecsAlertsID_(long varValue) {
        FLECS_IDFlecsAlertsID_$constants.SEGMENT.set(FLECS_IDFlecsAlertsID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertID_$layout() {
        return FLECS_IDEcsAlertID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertID_$segment() {
        return FLECS_IDEcsAlertID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertID_
     * }
     */
    public static long FLECS_IDEcsAlertID_() {
        return FLECS_IDEcsAlertID_$constants.SEGMENT.get(FLECS_IDEcsAlertID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertID_
     * }
     */
    public static void FLECS_IDEcsAlertID_(long varValue) {
        FLECS_IDEcsAlertID_$constants.SEGMENT.set(FLECS_IDEcsAlertID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertInstanceID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertInstanceID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInstanceID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertInstanceID_$layout() {
        return FLECS_IDEcsAlertInstanceID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInstanceID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertInstanceID_$segment() {
        return FLECS_IDEcsAlertInstanceID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInstanceID_
     * }
     */
    public static long FLECS_IDEcsAlertInstanceID_() {
        return FLECS_IDEcsAlertInstanceID_$constants.SEGMENT.get(FLECS_IDEcsAlertInstanceID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInstanceID_
     * }
     */
    public static void FLECS_IDEcsAlertInstanceID_(long varValue) {
        FLECS_IDEcsAlertInstanceID_$constants.SEGMENT.set(FLECS_IDEcsAlertInstanceID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertsActiveID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertsActiveID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertsActiveID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertsActiveID_$layout() {
        return FLECS_IDEcsAlertsActiveID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertsActiveID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertsActiveID_$segment() {
        return FLECS_IDEcsAlertsActiveID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertsActiveID_
     * }
     */
    public static long FLECS_IDEcsAlertsActiveID_() {
        return FLECS_IDEcsAlertsActiveID_$constants.SEGMENT.get(FLECS_IDEcsAlertsActiveID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertsActiveID_
     * }
     */
    public static void FLECS_IDEcsAlertsActiveID_(long varValue) {
        FLECS_IDEcsAlertsActiveID_$constants.SEGMENT.set(FLECS_IDEcsAlertsActiveID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertTimeoutID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertTimeoutID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertTimeoutID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertTimeoutID_$layout() {
        return FLECS_IDEcsAlertTimeoutID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertTimeoutID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertTimeoutID_$segment() {
        return FLECS_IDEcsAlertTimeoutID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertTimeoutID_
     * }
     */
    public static long FLECS_IDEcsAlertTimeoutID_() {
        return FLECS_IDEcsAlertTimeoutID_$constants.SEGMENT.get(FLECS_IDEcsAlertTimeoutID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertTimeoutID_
     * }
     */
    public static void FLECS_IDEcsAlertTimeoutID_(long varValue) {
        FLECS_IDEcsAlertTimeoutID_$constants.SEGMENT.set(FLECS_IDEcsAlertTimeoutID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlertInfo$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAlertInfo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertInfo
     * }
     */
    public static OfLong EcsAlertInfo$layout() {
        return EcsAlertInfo$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertInfo
     * }
     */
    public static MemorySegment EcsAlertInfo$segment() {
        return EcsAlertInfo$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertInfo
     * }
     */
    public static long EcsAlertInfo() {
        return EcsAlertInfo$constants.SEGMENT.get(EcsAlertInfo$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertInfo
     * }
     */
    public static void EcsAlertInfo(long varValue) {
        EcsAlertInfo$constants.SEGMENT.set(EcsAlertInfo$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertInfoID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertInfoID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInfoID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertInfoID_$layout() {
        return FLECS_IDEcsAlertInfoID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInfoID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertInfoID_$segment() {
        return FLECS_IDEcsAlertInfoID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInfoID_
     * }
     */
    public static long FLECS_IDEcsAlertInfoID_() {
        return FLECS_IDEcsAlertInfoID_$constants.SEGMENT.get(FLECS_IDEcsAlertInfoID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertInfoID_
     * }
     */
    public static void FLECS_IDEcsAlertInfoID_(long varValue) {
        FLECS_IDEcsAlertInfoID_$constants.SEGMENT.set(FLECS_IDEcsAlertInfoID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlertWarning$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAlertWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertWarning
     * }
     */
    public static OfLong EcsAlertWarning$layout() {
        return EcsAlertWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertWarning
     * }
     */
    public static MemorySegment EcsAlertWarning$segment() {
        return EcsAlertWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertWarning
     * }
     */
    public static long EcsAlertWarning() {
        return EcsAlertWarning$constants.SEGMENT.get(EcsAlertWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertWarning
     * }
     */
    public static void EcsAlertWarning(long varValue) {
        EcsAlertWarning$constants.SEGMENT.set(EcsAlertWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertWarningID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertWarningID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertWarningID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertWarningID_$layout() {
        return FLECS_IDEcsAlertWarningID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertWarningID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertWarningID_$segment() {
        return FLECS_IDEcsAlertWarningID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertWarningID_
     * }
     */
    public static long FLECS_IDEcsAlertWarningID_() {
        return FLECS_IDEcsAlertWarningID_$constants.SEGMENT.get(FLECS_IDEcsAlertWarningID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertWarningID_
     * }
     */
    public static void FLECS_IDEcsAlertWarningID_(long varValue) {
        FLECS_IDEcsAlertWarningID_$constants.SEGMENT.set(FLECS_IDEcsAlertWarningID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlertError$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAlertError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertError
     * }
     */
    public static OfLong EcsAlertError$layout() {
        return EcsAlertError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertError
     * }
     */
    public static MemorySegment EcsAlertError$segment() {
        return EcsAlertError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertError
     * }
     */
    public static long EcsAlertError() {
        return EcsAlertError$constants.SEGMENT.get(EcsAlertError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertError
     * }
     */
    public static void EcsAlertError(long varValue) {
        EcsAlertError$constants.SEGMENT.set(EcsAlertError$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertErrorID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertErrorID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertErrorID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertErrorID_$layout() {
        return FLECS_IDEcsAlertErrorID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertErrorID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertErrorID_$segment() {
        return FLECS_IDEcsAlertErrorID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertErrorID_
     * }
     */
    public static long FLECS_IDEcsAlertErrorID_() {
        return FLECS_IDEcsAlertErrorID_$constants.SEGMENT.get(FLECS_IDEcsAlertErrorID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertErrorID_
     * }
     */
    public static void FLECS_IDEcsAlertErrorID_(long varValue) {
        FLECS_IDEcsAlertErrorID_$constants.SEGMENT.set(FLECS_IDEcsAlertErrorID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAlertCritical$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAlertCritical").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertCritical
     * }
     */
    public static OfLong EcsAlertCritical$layout() {
        return EcsAlertCritical$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertCritical
     * }
     */
    public static MemorySegment EcsAlertCritical$segment() {
        return EcsAlertCritical$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertCritical
     * }
     */
    public static long EcsAlertCritical() {
        return EcsAlertCritical$constants.SEGMENT.get(EcsAlertCritical$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAlertCritical
     * }
     */
    public static void EcsAlertCritical(long varValue) {
        EcsAlertCritical$constants.SEGMENT.set(EcsAlertCritical$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsAlertCriticalID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsAlertCriticalID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertCriticalID_
     * }
     */
    public static OfLong FLECS_IDEcsAlertCriticalID_$layout() {
        return FLECS_IDEcsAlertCriticalID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertCriticalID_
     * }
     */
    public static MemorySegment FLECS_IDEcsAlertCriticalID_$segment() {
        return FLECS_IDEcsAlertCriticalID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertCriticalID_
     * }
     */
    public static long FLECS_IDEcsAlertCriticalID_() {
        return FLECS_IDEcsAlertCriticalID_$constants.SEGMENT.get(FLECS_IDEcsAlertCriticalID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsAlertCriticalID_
     * }
     */
    public static void FLECS_IDEcsAlertCriticalID_(long varValue) {
        FLECS_IDEcsAlertCriticalID_$constants.SEGMENT.set(FLECS_IDEcsAlertCriticalID_$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_alert_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_alert_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_alert_init(ecs_world_t *world, const ecs_alert_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_alert_init$descriptor() {
        return ecs_alert_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_alert_init(ecs_world_t *world, const ecs_alert_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_alert_init$handle() {
        return ecs_alert_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_alert_init(ecs_world_t *world, const ecs_alert_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_alert_init$address() {
        return ecs_alert_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_alert_init(ecs_world_t *world, const ecs_alert_desc_t *desc)
     * }
     */
    public static long ecs_alert_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_alert_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_alert_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_alert_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_alert_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_get_alert_count(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static FunctionDescriptor ecs_get_alert_count$descriptor() {
        return ecs_get_alert_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_get_alert_count(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static MethodHandle ecs_get_alert_count$handle() {
        return ecs_get_alert_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_get_alert_count(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static MemorySegment ecs_get_alert_count$address() {
        return ecs_get_alert_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_get_alert_count(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static int ecs_get_alert_count(MemorySegment world, long entity, long alert) {
        var mh$ = ecs_get_alert_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_alert_count", world, entity, alert);
            }
            return (int)mh$.invokeExact(world, entity, alert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_get_alert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_get_alert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alert(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static FunctionDescriptor ecs_get_alert$descriptor() {
        return ecs_get_alert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alert(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static MethodHandle ecs_get_alert$handle() {
        return ecs_get_alert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alert(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static MemorySegment ecs_get_alert$address() {
        return ecs_get_alert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_get_alert(const ecs_world_t *world, ecs_entity_t entity, ecs_entity_t alert)
     * }
     */
    public static long ecs_get_alert(MemorySegment world, long entity, long alert) {
        var mh$ = ecs_get_alert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_get_alert", world, entity, alert);
            }
            return (long)mh$.invokeExact(world, entity, alert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsAlertsImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsAlertsImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsAlertsImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsAlertsImport$descriptor() {
        return FlecsAlertsImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsAlertsImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsAlertsImport$handle() {
        return FlecsAlertsImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsAlertsImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsAlertsImport$address() {
        return FlecsAlertsImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsAlertsImport(ecs_world_t *world)
     * }
     */
    public static void FlecsAlertsImport(MemorySegment world) {
        var mh$ = FlecsAlertsImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsAlertsImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_from_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_from_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_ptr_from_json(const ecs_world_t *world, ecs_entity_t type, void *ptr, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_ptr_from_json$descriptor() {
        return ecs_ptr_from_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_ptr_from_json(const ecs_world_t *world, ecs_entity_t type, void *ptr, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_ptr_from_json$handle() {
        return ecs_ptr_from_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_ptr_from_json(const ecs_world_t *world, ecs_entity_t type, void *ptr, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_ptr_from_json$address() {
        return ecs_ptr_from_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_ptr_from_json(const ecs_world_t *world, ecs_entity_t type, void *ptr, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_ptr_from_json(MemorySegment world, long type, MemorySegment ptr, MemorySegment json, MemorySegment desc) {
        var mh$ = ecs_ptr_from_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_from_json", world, type, ptr, json, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, type, ptr, json, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_from_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_entity_from_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_entity_from_json(ecs_world_t *world, ecs_entity_t entity, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_entity_from_json$descriptor() {
        return ecs_entity_from_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_entity_from_json(ecs_world_t *world, ecs_entity_t entity, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_entity_from_json$handle() {
        return ecs_entity_from_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_entity_from_json(ecs_world_t *world, ecs_entity_t entity, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_from_json$address() {
        return ecs_entity_from_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_entity_from_json(ecs_world_t *world, ecs_entity_t entity, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_from_json(MemorySegment world, long entity, MemorySegment json, MemorySegment desc) {
        var mh$ = ecs_entity_from_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_from_json", world, entity, json, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, json, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_from_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_from_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json(ecs_world_t *world, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_world_from_json$descriptor() {
        return ecs_world_from_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json(ecs_world_t *world, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_world_from_json$handle() {
        return ecs_world_from_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json(ecs_world_t *world, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_from_json$address() {
        return ecs_world_from_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_world_from_json(ecs_world_t *world, const char *json, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_from_json(MemorySegment world, MemorySegment json, MemorySegment desc) {
        var mh$ = ecs_world_from_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_from_json", world, json, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, json, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_from_json_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_from_json_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json_file(ecs_world_t *world, const char *filename, const ecs_from_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_world_from_json_file$descriptor() {
        return ecs_world_from_json_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json_file(ecs_world_t *world, const char *filename, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_world_from_json_file$handle() {
        return ecs_world_from_json_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_world_from_json_file(ecs_world_t *world, const char *filename, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_from_json_file$address() {
        return ecs_world_from_json_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_world_from_json_file(ecs_world_t *world, const char *filename, const ecs_from_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_from_json_file(MemorySegment world, MemorySegment filename, MemorySegment desc) {
        var mh$ = ecs_world_from_json_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_from_json_file", world, filename, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, filename, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_array_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_array_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_array_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count)
     * }
     */
    public static FunctionDescriptor ecs_array_to_json$descriptor() {
        return ecs_array_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_array_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count)
     * }
     */
    public static MethodHandle ecs_array_to_json$handle() {
        return ecs_array_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_array_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count)
     * }
     */
    public static MemorySegment ecs_array_to_json$address() {
        return ecs_array_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_array_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count)
     * }
     */
    public static MemorySegment ecs_array_to_json(MemorySegment world, long type, MemorySegment data, int count) {
        var mh$ = ecs_array_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_array_to_json", world, type, data, count);
            }
            return (MemorySegment)mh$.invokeExact(world, type, data, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_array_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_array_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_array_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count, ecs_strbuf_t *buf_out)
     * }
     */
    public static FunctionDescriptor ecs_array_to_json_buf$descriptor() {
        return ecs_array_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_array_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count, ecs_strbuf_t *buf_out)
     * }
     */
    public static MethodHandle ecs_array_to_json_buf$handle() {
        return ecs_array_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_array_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count, ecs_strbuf_t *buf_out)
     * }
     */
    public static MemorySegment ecs_array_to_json_buf$address() {
        return ecs_array_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_array_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, int32_t count, ecs_strbuf_t *buf_out)
     * }
     */
    public static int ecs_array_to_json_buf(MemorySegment world, long type, MemorySegment data, int count, MemorySegment buf_out) {
        var mh$ = ecs_array_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_array_to_json_buf", world, type, data, count, buf_out);
            }
            return (int)mh$.invokeExact(world, type, data, count, buf_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_json$descriptor() {
        return ecs_ptr_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MethodHandle ecs_ptr_to_json$handle() {
        return ecs_ptr_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_json$address() {
        return ecs_ptr_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_ptr_to_json(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_json(MemorySegment world, long type, MemorySegment data) {
        var mh$ = ecs_ptr_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_json", world, type, data);
            }
            return (MemorySegment)mh$.invokeExact(world, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_ptr_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf_out)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_json_buf$descriptor() {
        return ecs_ptr_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_ptr_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf_out)
     * }
     */
    public static MethodHandle ecs_ptr_to_json_buf$handle() {
        return ecs_ptr_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_ptr_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf_out)
     * }
     */
    public static MemorySegment ecs_ptr_to_json_buf$address() {
        return ecs_ptr_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_ptr_to_json_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf_out)
     * }
     */
    public static int ecs_ptr_to_json_buf(MemorySegment world, long type, MemorySegment data, MemorySegment buf_out) {
        var mh$ = ecs_ptr_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_json_buf", world, type, data, buf_out);
            }
            return (int)mh$.invokeExact(world, type, data, buf_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_type_info_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_type_info_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_type_info_to_json(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static FunctionDescriptor ecs_type_info_to_json$descriptor() {
        return ecs_type_info_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_type_info_to_json(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MethodHandle ecs_type_info_to_json$handle() {
        return ecs_type_info_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_type_info_to_json(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_type_info_to_json$address() {
        return ecs_type_info_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_type_info_to_json(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_type_info_to_json(MemorySegment world, long type) {
        var mh$ = ecs_type_info_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_type_info_to_json", world, type);
            }
            return (MemorySegment)mh$.invokeExact(world, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_type_info_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_type_info_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_type_info_to_json_buf(const ecs_world_t *world, ecs_entity_t type, ecs_strbuf_t *buf_out)
     * }
     */
    public static FunctionDescriptor ecs_type_info_to_json_buf$descriptor() {
        return ecs_type_info_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_type_info_to_json_buf(const ecs_world_t *world, ecs_entity_t type, ecs_strbuf_t *buf_out)
     * }
     */
    public static MethodHandle ecs_type_info_to_json_buf$handle() {
        return ecs_type_info_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_type_info_to_json_buf(const ecs_world_t *world, ecs_entity_t type, ecs_strbuf_t *buf_out)
     * }
     */
    public static MemorySegment ecs_type_info_to_json_buf$address() {
        return ecs_type_info_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_type_info_to_json_buf(const ecs_world_t *world, ecs_entity_t type, ecs_strbuf_t *buf_out)
     * }
     */
    public static int ecs_type_info_to_json_buf(MemorySegment world, long type, MemorySegment buf_out) {
        var mh$ = ecs_type_info_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_type_info_to_json_buf", world, type, buf_out);
            }
            return (int)mh$.invokeExact(world, type, buf_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_entity_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_entity_to_json(const ecs_world_t *world, ecs_entity_t entity, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_entity_to_json$descriptor() {
        return ecs_entity_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_entity_to_json(const ecs_world_t *world, ecs_entity_t entity, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_entity_to_json$handle() {
        return ecs_entity_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_entity_to_json(const ecs_world_t *world, ecs_entity_t entity, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_to_json$address() {
        return ecs_entity_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_entity_to_json(const ecs_world_t *world, ecs_entity_t entity, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_to_json(MemorySegment world, long entity, MemorySegment desc) {
        var mh$ = ecs_entity_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_to_json", world, entity, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, entity, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_entity_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_entity_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_entity_to_json_buf(const ecs_world_t *world, ecs_entity_t entity, ecs_strbuf_t *buf_out, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_entity_to_json_buf$descriptor() {
        return ecs_entity_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_entity_to_json_buf(const ecs_world_t *world, ecs_entity_t entity, ecs_strbuf_t *buf_out, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_entity_to_json_buf$handle() {
        return ecs_entity_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_entity_to_json_buf(const ecs_world_t *world, ecs_entity_t entity, ecs_strbuf_t *buf_out, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_entity_to_json_buf$address() {
        return ecs_entity_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_entity_to_json_buf(const ecs_world_t *world, ecs_entity_t entity, ecs_strbuf_t *buf_out, const ecs_entity_to_json_desc_t *desc)
     * }
     */
    public static int ecs_entity_to_json_buf(MemorySegment world, long entity, MemorySegment buf_out, MemorySegment desc) {
        var mh$ = ecs_entity_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_entity_to_json_buf", world, entity, buf_out, desc);
            }
            return (int)mh$.invokeExact(world, entity, buf_out, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_iter_to_json(ecs_iter_t *iter, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_iter_to_json$descriptor() {
        return ecs_iter_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_iter_to_json(ecs_iter_t *iter, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_iter_to_json$handle() {
        return ecs_iter_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_iter_to_json(ecs_iter_t *iter, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_iter_to_json$address() {
        return ecs_iter_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_iter_to_json(ecs_iter_t *iter, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_iter_to_json(MemorySegment iter, MemorySegment desc) {
        var mh$ = ecs_iter_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_to_json", iter, desc);
            }
            return (MemorySegment)mh$.invokeExact(iter, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_iter_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_iter_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_iter_to_json_buf(ecs_iter_t *iter, ecs_strbuf_t *buf_out, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_iter_to_json_buf$descriptor() {
        return ecs_iter_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_iter_to_json_buf(ecs_iter_t *iter, ecs_strbuf_t *buf_out, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_iter_to_json_buf$handle() {
        return ecs_iter_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_iter_to_json_buf(ecs_iter_t *iter, ecs_strbuf_t *buf_out, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_iter_to_json_buf$address() {
        return ecs_iter_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_iter_to_json_buf(ecs_iter_t *iter, ecs_strbuf_t *buf_out, const ecs_iter_to_json_desc_t *desc)
     * }
     */
    public static int ecs_iter_to_json_buf(MemorySegment iter, MemorySegment buf_out, MemorySegment desc) {
        var mh$ = ecs_iter_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_iter_to_json_buf", iter, buf_out, desc);
            }
            return (int)mh$.invokeExact(iter, buf_out, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_to_json {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_to_json");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_world_to_json(ecs_world_t *world, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_world_to_json$descriptor() {
        return ecs_world_to_json.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_world_to_json(ecs_world_t *world, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_world_to_json$handle() {
        return ecs_world_to_json.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_world_to_json(ecs_world_t *world, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_to_json$address() {
        return ecs_world_to_json.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_world_to_json(ecs_world_t *world, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_to_json(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_world_to_json.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_to_json", world, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_world_to_json_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_world_to_json_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_world_to_json_buf(ecs_world_t *world, ecs_strbuf_t *buf_out, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_world_to_json_buf$descriptor() {
        return ecs_world_to_json_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_world_to_json_buf(ecs_world_t *world, ecs_strbuf_t *buf_out, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_world_to_json_buf$handle() {
        return ecs_world_to_json_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_world_to_json_buf(ecs_world_t *world, ecs_strbuf_t *buf_out, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_world_to_json_buf$address() {
        return ecs_world_to_json_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_world_to_json_buf(ecs_world_t *world, ecs_strbuf_t *buf_out, const ecs_world_to_json_desc_t *desc)
     * }
     */
    public static int ecs_world_to_json_buf(MemorySegment world, MemorySegment buf_out, MemorySegment desc) {
        var mh$ = ecs_world_to_json_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_world_to_json_buf", world, buf_out, desc);
            }
            return (int)mh$.invokeExact(world, buf_out, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EcsUnitPrefixes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUnitPrefixes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUnitPrefixes
     * }
     */
    public static OfLong EcsUnitPrefixes$layout() {
        return EcsUnitPrefixes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUnitPrefixes
     * }
     */
    public static MemorySegment EcsUnitPrefixes$segment() {
        return EcsUnitPrefixes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUnitPrefixes
     * }
     */
    public static long EcsUnitPrefixes() {
        return EcsUnitPrefixes$constants.SEGMENT.get(EcsUnitPrefixes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUnitPrefixes
     * }
     */
    public static void EcsUnitPrefixes(long varValue) {
        EcsUnitPrefixes$constants.SEGMENT.set(EcsUnitPrefixes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsYocto$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsYocto").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYocto
     * }
     */
    public static OfLong EcsYocto$layout() {
        return EcsYocto$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYocto
     * }
     */
    public static MemorySegment EcsYocto$segment() {
        return EcsYocto$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYocto
     * }
     */
    public static long EcsYocto() {
        return EcsYocto$constants.SEGMENT.get(EcsYocto$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYocto
     * }
     */
    public static void EcsYocto(long varValue) {
        EcsYocto$constants.SEGMENT.set(EcsYocto$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsZepto$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsZepto").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZepto
     * }
     */
    public static OfLong EcsZepto$layout() {
        return EcsZepto$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZepto
     * }
     */
    public static MemorySegment EcsZepto$segment() {
        return EcsZepto$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZepto
     * }
     */
    public static long EcsZepto() {
        return EcsZepto$constants.SEGMENT.get(EcsZepto$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZepto
     * }
     */
    public static void EcsZepto(long varValue) {
        EcsZepto$constants.SEGMENT.set(EcsZepto$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAtto$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAtto").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAtto
     * }
     */
    public static OfLong EcsAtto$layout() {
        return EcsAtto$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAtto
     * }
     */
    public static MemorySegment EcsAtto$segment() {
        return EcsAtto$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAtto
     * }
     */
    public static long EcsAtto() {
        return EcsAtto$constants.SEGMENT.get(EcsAtto$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAtto
     * }
     */
    public static void EcsAtto(long varValue) {
        EcsAtto$constants.SEGMENT.set(EcsAtto$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFemto$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFemto").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFemto
     * }
     */
    public static OfLong EcsFemto$layout() {
        return EcsFemto$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFemto
     * }
     */
    public static MemorySegment EcsFemto$segment() {
        return EcsFemto$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFemto
     * }
     */
    public static long EcsFemto() {
        return EcsFemto$constants.SEGMENT.get(EcsFemto$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFemto
     * }
     */
    public static void EcsFemto(long varValue) {
        EcsFemto$constants.SEGMENT.set(EcsFemto$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPico$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPico").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPico
     * }
     */
    public static OfLong EcsPico$layout() {
        return EcsPico$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPico
     * }
     */
    public static MemorySegment EcsPico$segment() {
        return EcsPico$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPico
     * }
     */
    public static long EcsPico() {
        return EcsPico$constants.SEGMENT.get(EcsPico$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPico
     * }
     */
    public static void EcsPico(long varValue) {
        EcsPico$constants.SEGMENT.set(EcsPico$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNano$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsNano").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNano
     * }
     */
    public static OfLong EcsNano$layout() {
        return EcsNano$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNano
     * }
     */
    public static MemorySegment EcsNano$segment() {
        return EcsNano$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNano
     * }
     */
    public static long EcsNano() {
        return EcsNano$constants.SEGMENT.get(EcsNano$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNano
     * }
     */
    public static void EcsNano(long varValue) {
        EcsNano$constants.SEGMENT.set(EcsNano$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMicro$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMicro").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicro
     * }
     */
    public static OfLong EcsMicro$layout() {
        return EcsMicro$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicro
     * }
     */
    public static MemorySegment EcsMicro$segment() {
        return EcsMicro$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicro
     * }
     */
    public static long EcsMicro() {
        return EcsMicro$constants.SEGMENT.get(EcsMicro$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicro
     * }
     */
    public static void EcsMicro(long varValue) {
        EcsMicro$constants.SEGMENT.set(EcsMicro$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMilli$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMilli").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilli
     * }
     */
    public static OfLong EcsMilli$layout() {
        return EcsMilli$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilli
     * }
     */
    public static MemorySegment EcsMilli$segment() {
        return EcsMilli$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilli
     * }
     */
    public static long EcsMilli() {
        return EcsMilli$constants.SEGMENT.get(EcsMilli$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilli
     * }
     */
    public static void EcsMilli(long varValue) {
        EcsMilli$constants.SEGMENT.set(EcsMilli$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCenti$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCenti").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCenti
     * }
     */
    public static OfLong EcsCenti$layout() {
        return EcsCenti$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCenti
     * }
     */
    public static MemorySegment EcsCenti$segment() {
        return EcsCenti$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCenti
     * }
     */
    public static long EcsCenti() {
        return EcsCenti$constants.SEGMENT.get(EcsCenti$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCenti
     * }
     */
    public static void EcsCenti(long varValue) {
        EcsCenti$constants.SEGMENT.set(EcsCenti$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDeci$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDeci").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeci
     * }
     */
    public static OfLong EcsDeci$layout() {
        return EcsDeci$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeci
     * }
     */
    public static MemorySegment EcsDeci$segment() {
        return EcsDeci$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeci
     * }
     */
    public static long EcsDeci() {
        return EcsDeci$constants.SEGMENT.get(EcsDeci$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeci
     * }
     */
    public static void EcsDeci(long varValue) {
        EcsDeci$constants.SEGMENT.set(EcsDeci$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDeca$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDeca").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeca
     * }
     */
    public static OfLong EcsDeca$layout() {
        return EcsDeca$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeca
     * }
     */
    public static MemorySegment EcsDeca$segment() {
        return EcsDeca$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeca
     * }
     */
    public static long EcsDeca() {
        return EcsDeca$constants.SEGMENT.get(EcsDeca$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeca
     * }
     */
    public static void EcsDeca(long varValue) {
        EcsDeca$constants.SEGMENT.set(EcsDeca$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsHecto$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsHecto").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHecto
     * }
     */
    public static OfLong EcsHecto$layout() {
        return EcsHecto$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHecto
     * }
     */
    public static MemorySegment EcsHecto$segment() {
        return EcsHecto$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHecto
     * }
     */
    public static long EcsHecto() {
        return EcsHecto$constants.SEGMENT.get(EcsHecto$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHecto
     * }
     */
    public static void EcsHecto(long varValue) {
        EcsHecto$constants.SEGMENT.set(EcsHecto$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKilo$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKilo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKilo
     * }
     */
    public static OfLong EcsKilo$layout() {
        return EcsKilo$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKilo
     * }
     */
    public static MemorySegment EcsKilo$segment() {
        return EcsKilo$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKilo
     * }
     */
    public static long EcsKilo() {
        return EcsKilo$constants.SEGMENT.get(EcsKilo$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKilo
     * }
     */
    public static void EcsKilo(long varValue) {
        EcsKilo$constants.SEGMENT.set(EcsKilo$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMega$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMega").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMega
     * }
     */
    public static OfLong EcsMega$layout() {
        return EcsMega$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMega
     * }
     */
    public static MemorySegment EcsMega$segment() {
        return EcsMega$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMega
     * }
     */
    public static long EcsMega() {
        return EcsMega$constants.SEGMENT.get(EcsMega$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMega
     * }
     */
    public static void EcsMega(long varValue) {
        EcsMega$constants.SEGMENT.set(EcsMega$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGiga$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGiga").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGiga
     * }
     */
    public static OfLong EcsGiga$layout() {
        return EcsGiga$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGiga
     * }
     */
    public static MemorySegment EcsGiga$segment() {
        return EcsGiga$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGiga
     * }
     */
    public static long EcsGiga() {
        return EcsGiga$constants.SEGMENT.get(EcsGiga$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGiga
     * }
     */
    public static void EcsGiga(long varValue) {
        EcsGiga$constants.SEGMENT.set(EcsGiga$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTera$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTera").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTera
     * }
     */
    public static OfLong EcsTera$layout() {
        return EcsTera$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTera
     * }
     */
    public static MemorySegment EcsTera$segment() {
        return EcsTera$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTera
     * }
     */
    public static long EcsTera() {
        return EcsTera$constants.SEGMENT.get(EcsTera$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTera
     * }
     */
    public static void EcsTera(long varValue) {
        EcsTera$constants.SEGMENT.set(EcsTera$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPeta$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPeta").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeta
     * }
     */
    public static OfLong EcsPeta$layout() {
        return EcsPeta$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeta
     * }
     */
    public static MemorySegment EcsPeta$segment() {
        return EcsPeta$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeta
     * }
     */
    public static long EcsPeta() {
        return EcsPeta$constants.SEGMENT.get(EcsPeta$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPeta
     * }
     */
    public static void EcsPeta(long varValue) {
        EcsPeta$constants.SEGMENT.set(EcsPeta$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsExa$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsExa").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExa
     * }
     */
    public static OfLong EcsExa$layout() {
        return EcsExa$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExa
     * }
     */
    public static MemorySegment EcsExa$segment() {
        return EcsExa$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExa
     * }
     */
    public static long EcsExa() {
        return EcsExa$constants.SEGMENT.get(EcsExa$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExa
     * }
     */
    public static void EcsExa(long varValue) {
        EcsExa$constants.SEGMENT.set(EcsExa$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsZetta$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsZetta").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZetta
     * }
     */
    public static OfLong EcsZetta$layout() {
        return EcsZetta$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZetta
     * }
     */
    public static MemorySegment EcsZetta$segment() {
        return EcsZetta$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZetta
     * }
     */
    public static long EcsZetta() {
        return EcsZetta$constants.SEGMENT.get(EcsZetta$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZetta
     * }
     */
    public static void EcsZetta(long varValue) {
        EcsZetta$constants.SEGMENT.set(EcsZetta$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsYotta$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsYotta").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYotta
     * }
     */
    public static OfLong EcsYotta$layout() {
        return EcsYotta$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYotta
     * }
     */
    public static MemorySegment EcsYotta$segment() {
        return EcsYotta$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYotta
     * }
     */
    public static long EcsYotta() {
        return EcsYotta$constants.SEGMENT.get(EcsYotta$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYotta
     * }
     */
    public static void EcsYotta(long varValue) {
        EcsYotta$constants.SEGMENT.set(EcsYotta$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKibi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKibi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibi
     * }
     */
    public static OfLong EcsKibi$layout() {
        return EcsKibi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibi
     * }
     */
    public static MemorySegment EcsKibi$segment() {
        return EcsKibi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibi
     * }
     */
    public static long EcsKibi() {
        return EcsKibi$constants.SEGMENT.get(EcsKibi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibi
     * }
     */
    public static void EcsKibi(long varValue) {
        EcsKibi$constants.SEGMENT.set(EcsKibi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMebi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMebi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebi
     * }
     */
    public static OfLong EcsMebi$layout() {
        return EcsMebi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebi
     * }
     */
    public static MemorySegment EcsMebi$segment() {
        return EcsMebi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebi
     * }
     */
    public static long EcsMebi() {
        return EcsMebi$constants.SEGMENT.get(EcsMebi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebi
     * }
     */
    public static void EcsMebi(long varValue) {
        EcsMebi$constants.SEGMENT.set(EcsMebi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGibi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGibi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibi
     * }
     */
    public static OfLong EcsGibi$layout() {
        return EcsGibi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibi
     * }
     */
    public static MemorySegment EcsGibi$segment() {
        return EcsGibi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibi
     * }
     */
    public static long EcsGibi() {
        return EcsGibi$constants.SEGMENT.get(EcsGibi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibi
     * }
     */
    public static void EcsGibi(long varValue) {
        EcsGibi$constants.SEGMENT.set(EcsGibi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTebi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTebi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTebi
     * }
     */
    public static OfLong EcsTebi$layout() {
        return EcsTebi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTebi
     * }
     */
    public static MemorySegment EcsTebi$segment() {
        return EcsTebi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTebi
     * }
     */
    public static long EcsTebi() {
        return EcsTebi$constants.SEGMENT.get(EcsTebi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTebi
     * }
     */
    public static void EcsTebi(long varValue) {
        EcsTebi$constants.SEGMENT.set(EcsTebi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPebi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPebi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPebi
     * }
     */
    public static OfLong EcsPebi$layout() {
        return EcsPebi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPebi
     * }
     */
    public static MemorySegment EcsPebi$segment() {
        return EcsPebi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPebi
     * }
     */
    public static long EcsPebi() {
        return EcsPebi$constants.SEGMENT.get(EcsPebi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPebi
     * }
     */
    public static void EcsPebi(long varValue) {
        EcsPebi$constants.SEGMENT.set(EcsPebi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsExbi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsExbi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExbi
     * }
     */
    public static OfLong EcsExbi$layout() {
        return EcsExbi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExbi
     * }
     */
    public static MemorySegment EcsExbi$segment() {
        return EcsExbi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExbi
     * }
     */
    public static long EcsExbi() {
        return EcsExbi$constants.SEGMENT.get(EcsExbi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsExbi
     * }
     */
    public static void EcsExbi(long varValue) {
        EcsExbi$constants.SEGMENT.set(EcsExbi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsZebi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsZebi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZebi
     * }
     */
    public static OfLong EcsZebi$layout() {
        return EcsZebi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZebi
     * }
     */
    public static MemorySegment EcsZebi$segment() {
        return EcsZebi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZebi
     * }
     */
    public static long EcsZebi() {
        return EcsZebi$constants.SEGMENT.get(EcsZebi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsZebi
     * }
     */
    public static void EcsZebi(long varValue) {
        EcsZebi$constants.SEGMENT.set(EcsZebi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsYobi$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsYobi").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYobi
     * }
     */
    public static OfLong EcsYobi$layout() {
        return EcsYobi$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYobi
     * }
     */
    public static MemorySegment EcsYobi$segment() {
        return EcsYobi$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYobi
     * }
     */
    public static long EcsYobi() {
        return EcsYobi$constants.SEGMENT.get(EcsYobi$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsYobi
     * }
     */
    public static void EcsYobi(long varValue) {
        EcsYobi$constants.SEGMENT.set(EcsYobi$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDuration$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDuration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDuration
     * }
     */
    public static OfLong EcsDuration$layout() {
        return EcsDuration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDuration
     * }
     */
    public static MemorySegment EcsDuration$segment() {
        return EcsDuration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDuration
     * }
     */
    public static long EcsDuration() {
        return EcsDuration$constants.SEGMENT.get(EcsDuration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDuration
     * }
     */
    public static void EcsDuration(long varValue) {
        EcsDuration$constants.SEGMENT.set(EcsDuration$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPicoSeconds$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPicoSeconds").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoSeconds
     * }
     */
    public static OfLong EcsPicoSeconds$layout() {
        return EcsPicoSeconds$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoSeconds
     * }
     */
    public static MemorySegment EcsPicoSeconds$segment() {
        return EcsPicoSeconds$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoSeconds
     * }
     */
    public static long EcsPicoSeconds() {
        return EcsPicoSeconds$constants.SEGMENT.get(EcsPicoSeconds$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoSeconds
     * }
     */
    public static void EcsPicoSeconds(long varValue) {
        EcsPicoSeconds$constants.SEGMENT.set(EcsPicoSeconds$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNanoSeconds$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsNanoSeconds").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoSeconds
     * }
     */
    public static OfLong EcsNanoSeconds$layout() {
        return EcsNanoSeconds$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoSeconds
     * }
     */
    public static MemorySegment EcsNanoSeconds$segment() {
        return EcsNanoSeconds$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoSeconds
     * }
     */
    public static long EcsNanoSeconds() {
        return EcsNanoSeconds$constants.SEGMENT.get(EcsNanoSeconds$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoSeconds
     * }
     */
    public static void EcsNanoSeconds(long varValue) {
        EcsNanoSeconds$constants.SEGMENT.set(EcsNanoSeconds$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMicroSeconds$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMicroSeconds").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroSeconds
     * }
     */
    public static OfLong EcsMicroSeconds$layout() {
        return EcsMicroSeconds$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroSeconds
     * }
     */
    public static MemorySegment EcsMicroSeconds$segment() {
        return EcsMicroSeconds$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroSeconds
     * }
     */
    public static long EcsMicroSeconds() {
        return EcsMicroSeconds$constants.SEGMENT.get(EcsMicroSeconds$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroSeconds
     * }
     */
    public static void EcsMicroSeconds(long varValue) {
        EcsMicroSeconds$constants.SEGMENT.set(EcsMicroSeconds$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMilliSeconds$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMilliSeconds").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliSeconds
     * }
     */
    public static OfLong EcsMilliSeconds$layout() {
        return EcsMilliSeconds$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliSeconds
     * }
     */
    public static MemorySegment EcsMilliSeconds$segment() {
        return EcsMilliSeconds$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliSeconds
     * }
     */
    public static long EcsMilliSeconds() {
        return EcsMilliSeconds$constants.SEGMENT.get(EcsMilliSeconds$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliSeconds
     * }
     */
    public static void EcsMilliSeconds(long varValue) {
        EcsMilliSeconds$constants.SEGMENT.set(EcsMilliSeconds$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSeconds$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSeconds").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSeconds
     * }
     */
    public static OfLong EcsSeconds$layout() {
        return EcsSeconds$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSeconds
     * }
     */
    public static MemorySegment EcsSeconds$segment() {
        return EcsSeconds$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSeconds
     * }
     */
    public static long EcsSeconds() {
        return EcsSeconds$constants.SEGMENT.get(EcsSeconds$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSeconds
     * }
     */
    public static void EcsSeconds(long varValue) {
        EcsSeconds$constants.SEGMENT.set(EcsSeconds$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMinutes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMinutes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMinutes
     * }
     */
    public static OfLong EcsMinutes$layout() {
        return EcsMinutes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMinutes
     * }
     */
    public static MemorySegment EcsMinutes$segment() {
        return EcsMinutes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMinutes
     * }
     */
    public static long EcsMinutes() {
        return EcsMinutes$constants.SEGMENT.get(EcsMinutes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMinutes
     * }
     */
    public static void EcsMinutes(long varValue) {
        EcsMinutes$constants.SEGMENT.set(EcsMinutes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsHours$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsHours").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHours
     * }
     */
    public static OfLong EcsHours$layout() {
        return EcsHours$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHours
     * }
     */
    public static MemorySegment EcsHours$segment() {
        return EcsHours$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHours
     * }
     */
    public static long EcsHours() {
        return EcsHours$constants.SEGMENT.get(EcsHours$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHours
     * }
     */
    public static void EcsHours(long varValue) {
        EcsHours$constants.SEGMENT.set(EcsHours$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDays$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDays").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDays
     * }
     */
    public static OfLong EcsDays$layout() {
        return EcsDays$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDays
     * }
     */
    public static MemorySegment EcsDays$segment() {
        return EcsDays$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDays
     * }
     */
    public static long EcsDays() {
        return EcsDays$constants.SEGMENT.get(EcsDays$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDays
     * }
     */
    public static void EcsDays(long varValue) {
        EcsDays$constants.SEGMENT.set(EcsDays$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTime$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTime
     * }
     */
    public static OfLong EcsTime$layout() {
        return EcsTime$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTime
     * }
     */
    public static MemorySegment EcsTime$segment() {
        return EcsTime$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTime
     * }
     */
    public static long EcsTime() {
        return EcsTime$constants.SEGMENT.get(EcsTime$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTime
     * }
     */
    public static void EcsTime(long varValue) {
        EcsTime$constants.SEGMENT.set(EcsTime$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDate
     * }
     */
    public static OfLong EcsDate$layout() {
        return EcsDate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDate
     * }
     */
    public static MemorySegment EcsDate$segment() {
        return EcsDate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDate
     * }
     */
    public static long EcsDate() {
        return EcsDate$constants.SEGMENT.get(EcsDate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDate
     * }
     */
    public static void EcsDate(long varValue) {
        EcsDate$constants.SEGMENT.set(EcsDate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMass$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMass").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMass
     * }
     */
    public static OfLong EcsMass$layout() {
        return EcsMass$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMass
     * }
     */
    public static MemorySegment EcsMass$segment() {
        return EcsMass$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMass
     * }
     */
    public static long EcsMass() {
        return EcsMass$constants.SEGMENT.get(EcsMass$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMass
     * }
     */
    public static void EcsMass(long varValue) {
        EcsMass$constants.SEGMENT.set(EcsMass$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGrams$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGrams").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGrams
     * }
     */
    public static OfLong EcsGrams$layout() {
        return EcsGrams$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGrams
     * }
     */
    public static MemorySegment EcsGrams$segment() {
        return EcsGrams$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGrams
     * }
     */
    public static long EcsGrams() {
        return EcsGrams$constants.SEGMENT.get(EcsGrams$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGrams
     * }
     */
    public static void EcsGrams(long varValue) {
        EcsGrams$constants.SEGMENT.set(EcsGrams$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloGrams$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloGrams").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloGrams
     * }
     */
    public static OfLong EcsKiloGrams$layout() {
        return EcsKiloGrams$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloGrams
     * }
     */
    public static MemorySegment EcsKiloGrams$segment() {
        return EcsKiloGrams$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloGrams
     * }
     */
    public static long EcsKiloGrams() {
        return EcsKiloGrams$constants.SEGMENT.get(EcsKiloGrams$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloGrams
     * }
     */
    public static void EcsKiloGrams(long varValue) {
        EcsKiloGrams$constants.SEGMENT.set(EcsKiloGrams$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsElectricCurrent$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsElectricCurrent").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsElectricCurrent
     * }
     */
    public static OfLong EcsElectricCurrent$layout() {
        return EcsElectricCurrent$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsElectricCurrent
     * }
     */
    public static MemorySegment EcsElectricCurrent$segment() {
        return EcsElectricCurrent$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsElectricCurrent
     * }
     */
    public static long EcsElectricCurrent() {
        return EcsElectricCurrent$constants.SEGMENT.get(EcsElectricCurrent$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsElectricCurrent
     * }
     */
    public static void EcsElectricCurrent(long varValue) {
        EcsElectricCurrent$constants.SEGMENT.set(EcsElectricCurrent$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAmpere$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAmpere").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmpere
     * }
     */
    public static OfLong EcsAmpere$layout() {
        return EcsAmpere$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmpere
     * }
     */
    public static MemorySegment EcsAmpere$segment() {
        return EcsAmpere$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmpere
     * }
     */
    public static long EcsAmpere() {
        return EcsAmpere$constants.SEGMENT.get(EcsAmpere$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmpere
     * }
     */
    public static void EcsAmpere(long varValue) {
        EcsAmpere$constants.SEGMENT.set(EcsAmpere$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAmount$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAmount").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmount
     * }
     */
    public static OfLong EcsAmount$layout() {
        return EcsAmount$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmount
     * }
     */
    public static MemorySegment EcsAmount$segment() {
        return EcsAmount$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmount
     * }
     */
    public static long EcsAmount() {
        return EcsAmount$constants.SEGMENT.get(EcsAmount$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAmount
     * }
     */
    public static void EcsAmount(long varValue) {
        EcsAmount$constants.SEGMENT.set(EcsAmount$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMole$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMole").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMole
     * }
     */
    public static OfLong EcsMole$layout() {
        return EcsMole$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMole
     * }
     */
    public static MemorySegment EcsMole$segment() {
        return EcsMole$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMole
     * }
     */
    public static long EcsMole() {
        return EcsMole$constants.SEGMENT.get(EcsMole$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMole
     * }
     */
    public static void EcsMole(long varValue) {
        EcsMole$constants.SEGMENT.set(EcsMole$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsLuminousIntensity$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsLuminousIntensity").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLuminousIntensity
     * }
     */
    public static OfLong EcsLuminousIntensity$layout() {
        return EcsLuminousIntensity$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLuminousIntensity
     * }
     */
    public static MemorySegment EcsLuminousIntensity$segment() {
        return EcsLuminousIntensity$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLuminousIntensity
     * }
     */
    public static long EcsLuminousIntensity() {
        return EcsLuminousIntensity$constants.SEGMENT.get(EcsLuminousIntensity$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLuminousIntensity
     * }
     */
    public static void EcsLuminousIntensity(long varValue) {
        EcsLuminousIntensity$constants.SEGMENT.set(EcsLuminousIntensity$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCandela$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCandela").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCandela
     * }
     */
    public static OfLong EcsCandela$layout() {
        return EcsCandela$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCandela
     * }
     */
    public static MemorySegment EcsCandela$segment() {
        return EcsCandela$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCandela
     * }
     */
    public static long EcsCandela() {
        return EcsCandela$constants.SEGMENT.get(EcsCandela$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCandela
     * }
     */
    public static void EcsCandela(long varValue) {
        EcsCandela$constants.SEGMENT.set(EcsCandela$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsForce$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsForce").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsForce
     * }
     */
    public static OfLong EcsForce$layout() {
        return EcsForce$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsForce
     * }
     */
    public static MemorySegment EcsForce$segment() {
        return EcsForce$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsForce
     * }
     */
    public static long EcsForce() {
        return EcsForce$constants.SEGMENT.get(EcsForce$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsForce
     * }
     */
    public static void EcsForce(long varValue) {
        EcsForce$constants.SEGMENT.set(EcsForce$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNewton$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsNewton").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNewton
     * }
     */
    public static OfLong EcsNewton$layout() {
        return EcsNewton$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNewton
     * }
     */
    public static MemorySegment EcsNewton$segment() {
        return EcsNewton$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNewton
     * }
     */
    public static long EcsNewton() {
        return EcsNewton$constants.SEGMENT.get(EcsNewton$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNewton
     * }
     */
    public static void EcsNewton(long varValue) {
        EcsNewton$constants.SEGMENT.set(EcsNewton$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsLength$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsLength").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLength
     * }
     */
    public static OfLong EcsLength$layout() {
        return EcsLength$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLength
     * }
     */
    public static MemorySegment EcsLength$segment() {
        return EcsLength$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLength
     * }
     */
    public static long EcsLength() {
        return EcsLength$constants.SEGMENT.get(EcsLength$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsLength
     * }
     */
    public static void EcsLength(long varValue) {
        EcsLength$constants.SEGMENT.set(EcsLength$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMeters
     * }
     */
    public static OfLong EcsMeters$layout() {
        return EcsMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMeters
     * }
     */
    public static MemorySegment EcsMeters$segment() {
        return EcsMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMeters
     * }
     */
    public static long EcsMeters() {
        return EcsMeters$constants.SEGMENT.get(EcsMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMeters
     * }
     */
    public static void EcsMeters(long varValue) {
        EcsMeters$constants.SEGMENT.set(EcsMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPicoMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPicoMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoMeters
     * }
     */
    public static OfLong EcsPicoMeters$layout() {
        return EcsPicoMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoMeters
     * }
     */
    public static MemorySegment EcsPicoMeters$segment() {
        return EcsPicoMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoMeters
     * }
     */
    public static long EcsPicoMeters() {
        return EcsPicoMeters$constants.SEGMENT.get(EcsPicoMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPicoMeters
     * }
     */
    public static void EcsPicoMeters(long varValue) {
        EcsPicoMeters$constants.SEGMENT.set(EcsPicoMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsNanoMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsNanoMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoMeters
     * }
     */
    public static OfLong EcsNanoMeters$layout() {
        return EcsNanoMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoMeters
     * }
     */
    public static MemorySegment EcsNanoMeters$segment() {
        return EcsNanoMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoMeters
     * }
     */
    public static long EcsNanoMeters() {
        return EcsNanoMeters$constants.SEGMENT.get(EcsNanoMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsNanoMeters
     * }
     */
    public static void EcsNanoMeters(long varValue) {
        EcsNanoMeters$constants.SEGMENT.set(EcsNanoMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMicroMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMicroMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroMeters
     * }
     */
    public static OfLong EcsMicroMeters$layout() {
        return EcsMicroMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroMeters
     * }
     */
    public static MemorySegment EcsMicroMeters$segment() {
        return EcsMicroMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroMeters
     * }
     */
    public static long EcsMicroMeters() {
        return EcsMicroMeters$constants.SEGMENT.get(EcsMicroMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMicroMeters
     * }
     */
    public static void EcsMicroMeters(long varValue) {
        EcsMicroMeters$constants.SEGMENT.set(EcsMicroMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMilliMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMilliMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliMeters
     * }
     */
    public static OfLong EcsMilliMeters$layout() {
        return EcsMilliMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliMeters
     * }
     */
    public static MemorySegment EcsMilliMeters$segment() {
        return EcsMilliMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliMeters
     * }
     */
    public static long EcsMilliMeters() {
        return EcsMilliMeters$constants.SEGMENT.get(EcsMilliMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilliMeters
     * }
     */
    public static void EcsMilliMeters(long varValue) {
        EcsMilliMeters$constants.SEGMENT.set(EcsMilliMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCentiMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCentiMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCentiMeters
     * }
     */
    public static OfLong EcsCentiMeters$layout() {
        return EcsCentiMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCentiMeters
     * }
     */
    public static MemorySegment EcsCentiMeters$segment() {
        return EcsCentiMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCentiMeters
     * }
     */
    public static long EcsCentiMeters() {
        return EcsCentiMeters$constants.SEGMENT.get(EcsCentiMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCentiMeters
     * }
     */
    public static void EcsCentiMeters(long varValue) {
        EcsCentiMeters$constants.SEGMENT.set(EcsCentiMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloMeters$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloMeters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMeters
     * }
     */
    public static OfLong EcsKiloMeters$layout() {
        return EcsKiloMeters$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMeters
     * }
     */
    public static MemorySegment EcsKiloMeters$segment() {
        return EcsKiloMeters$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMeters
     * }
     */
    public static long EcsKiloMeters() {
        return EcsKiloMeters$constants.SEGMENT.get(EcsKiloMeters$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMeters
     * }
     */
    public static void EcsKiloMeters(long varValue) {
        EcsKiloMeters$constants.SEGMENT.set(EcsKiloMeters$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMiles$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMiles").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMiles
     * }
     */
    public static OfLong EcsMiles$layout() {
        return EcsMiles$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMiles
     * }
     */
    public static MemorySegment EcsMiles$segment() {
        return EcsMiles$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMiles
     * }
     */
    public static long EcsMiles() {
        return EcsMiles$constants.SEGMENT.get(EcsMiles$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMiles
     * }
     */
    public static void EcsMiles(long varValue) {
        EcsMiles$constants.SEGMENT.set(EcsMiles$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPixels$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPixels").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPixels
     * }
     */
    public static OfLong EcsPixels$layout() {
        return EcsPixels$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPixels
     * }
     */
    public static MemorySegment EcsPixels$segment() {
        return EcsPixels$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPixels
     * }
     */
    public static long EcsPixels() {
        return EcsPixels$constants.SEGMENT.get(EcsPixels$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPixels
     * }
     */
    public static void EcsPixels(long varValue) {
        EcsPixels$constants.SEGMENT.set(EcsPixels$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPressure$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPressure
     * }
     */
    public static OfLong EcsPressure$layout() {
        return EcsPressure$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPressure
     * }
     */
    public static MemorySegment EcsPressure$segment() {
        return EcsPressure$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPressure
     * }
     */
    public static long EcsPressure() {
        return EcsPressure$constants.SEGMENT.get(EcsPressure$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPressure
     * }
     */
    public static void EcsPressure(long varValue) {
        EcsPressure$constants.SEGMENT.set(EcsPressure$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPascal$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPascal").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPascal
     * }
     */
    public static OfLong EcsPascal$layout() {
        return EcsPascal$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPascal
     * }
     */
    public static MemorySegment EcsPascal$segment() {
        return EcsPascal$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPascal
     * }
     */
    public static long EcsPascal() {
        return EcsPascal$constants.SEGMENT.get(EcsPascal$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPascal
     * }
     */
    public static void EcsPascal(long varValue) {
        EcsPascal$constants.SEGMENT.set(EcsPascal$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBar$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBar").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBar
     * }
     */
    public static OfLong EcsBar$layout() {
        return EcsBar$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBar
     * }
     */
    public static MemorySegment EcsBar$segment() {
        return EcsBar$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBar
     * }
     */
    public static long EcsBar() {
        return EcsBar$constants.SEGMENT.get(EcsBar$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBar
     * }
     */
    public static void EcsBar(long varValue) {
        EcsBar$constants.SEGMENT.set(EcsBar$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsSpeed$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsSpeed").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSpeed
     * }
     */
    public static OfLong EcsSpeed$layout() {
        return EcsSpeed$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSpeed
     * }
     */
    public static MemorySegment EcsSpeed$segment() {
        return EcsSpeed$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSpeed
     * }
     */
    public static long EcsSpeed() {
        return EcsSpeed$constants.SEGMENT.get(EcsSpeed$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsSpeed
     * }
     */
    public static void EcsSpeed(long varValue) {
        EcsSpeed$constants.SEGMENT.set(EcsSpeed$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMetersPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMetersPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetersPerSecond
     * }
     */
    public static OfLong EcsMetersPerSecond$layout() {
        return EcsMetersPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetersPerSecond
     * }
     */
    public static MemorySegment EcsMetersPerSecond$segment() {
        return EcsMetersPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetersPerSecond
     * }
     */
    public static long EcsMetersPerSecond() {
        return EcsMetersPerSecond$constants.SEGMENT.get(EcsMetersPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMetersPerSecond
     * }
     */
    public static void EcsMetersPerSecond(long varValue) {
        EcsMetersPerSecond$constants.SEGMENT.set(EcsMetersPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloMetersPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloMetersPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerSecond
     * }
     */
    public static OfLong EcsKiloMetersPerSecond$layout() {
        return EcsKiloMetersPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerSecond
     * }
     */
    public static MemorySegment EcsKiloMetersPerSecond$segment() {
        return EcsKiloMetersPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerSecond
     * }
     */
    public static long EcsKiloMetersPerSecond() {
        return EcsKiloMetersPerSecond$constants.SEGMENT.get(EcsKiloMetersPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerSecond
     * }
     */
    public static void EcsKiloMetersPerSecond(long varValue) {
        EcsKiloMetersPerSecond$constants.SEGMENT.set(EcsKiloMetersPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloMetersPerHour$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloMetersPerHour").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerHour
     * }
     */
    public static OfLong EcsKiloMetersPerHour$layout() {
        return EcsKiloMetersPerHour$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerHour
     * }
     */
    public static MemorySegment EcsKiloMetersPerHour$segment() {
        return EcsKiloMetersPerHour$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerHour
     * }
     */
    public static long EcsKiloMetersPerHour() {
        return EcsKiloMetersPerHour$constants.SEGMENT.get(EcsKiloMetersPerHour$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloMetersPerHour
     * }
     */
    public static void EcsKiloMetersPerHour(long varValue) {
        EcsKiloMetersPerHour$constants.SEGMENT.set(EcsKiloMetersPerHour$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMilesPerHour$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMilesPerHour").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilesPerHour
     * }
     */
    public static OfLong EcsMilesPerHour$layout() {
        return EcsMilesPerHour$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilesPerHour
     * }
     */
    public static MemorySegment EcsMilesPerHour$segment() {
        return EcsMilesPerHour$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilesPerHour
     * }
     */
    public static long EcsMilesPerHour() {
        return EcsMilesPerHour$constants.SEGMENT.get(EcsMilesPerHour$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMilesPerHour
     * }
     */
    public static void EcsMilesPerHour(long varValue) {
        EcsMilesPerHour$constants.SEGMENT.set(EcsMilesPerHour$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsTemperature$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsTemperature").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTemperature
     * }
     */
    public static OfLong EcsTemperature$layout() {
        return EcsTemperature$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTemperature
     * }
     */
    public static MemorySegment EcsTemperature$segment() {
        return EcsTemperature$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTemperature
     * }
     */
    public static long EcsTemperature() {
        return EcsTemperature$constants.SEGMENT.get(EcsTemperature$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsTemperature
     * }
     */
    public static void EcsTemperature(long varValue) {
        EcsTemperature$constants.SEGMENT.set(EcsTemperature$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKelvin$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKelvin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKelvin
     * }
     */
    public static OfLong EcsKelvin$layout() {
        return EcsKelvin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKelvin
     * }
     */
    public static MemorySegment EcsKelvin$segment() {
        return EcsKelvin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKelvin
     * }
     */
    public static long EcsKelvin() {
        return EcsKelvin$constants.SEGMENT.get(EcsKelvin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKelvin
     * }
     */
    public static void EcsKelvin(long varValue) {
        EcsKelvin$constants.SEGMENT.set(EcsKelvin$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsCelsius$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsCelsius").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCelsius
     * }
     */
    public static OfLong EcsCelsius$layout() {
        return EcsCelsius$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCelsius
     * }
     */
    public static MemorySegment EcsCelsius$segment() {
        return EcsCelsius$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCelsius
     * }
     */
    public static long EcsCelsius() {
        return EcsCelsius$constants.SEGMENT.get(EcsCelsius$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsCelsius
     * }
     */
    public static void EcsCelsius(long varValue) {
        EcsCelsius$constants.SEGMENT.set(EcsCelsius$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFahrenheit$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFahrenheit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFahrenheit
     * }
     */
    public static OfLong EcsFahrenheit$layout() {
        return EcsFahrenheit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFahrenheit
     * }
     */
    public static MemorySegment EcsFahrenheit$segment() {
        return EcsFahrenheit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFahrenheit
     * }
     */
    public static long EcsFahrenheit() {
        return EcsFahrenheit$constants.SEGMENT.get(EcsFahrenheit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFahrenheit
     * }
     */
    public static void EcsFahrenheit(long varValue) {
        EcsFahrenheit$constants.SEGMENT.set(EcsFahrenheit$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsData$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsData").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsData
     * }
     */
    public static OfLong EcsData$layout() {
        return EcsData$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsData
     * }
     */
    public static MemorySegment EcsData$segment() {
        return EcsData$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsData
     * }
     */
    public static long EcsData() {
        return EcsData$constants.SEGMENT.get(EcsData$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsData
     * }
     */
    public static void EcsData(long varValue) {
        EcsData$constants.SEGMENT.set(EcsData$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBits$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBits
     * }
     */
    public static OfLong EcsBits$layout() {
        return EcsBits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBits
     * }
     */
    public static MemorySegment EcsBits$segment() {
        return EcsBits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBits
     * }
     */
    public static long EcsBits() {
        return EcsBits$constants.SEGMENT.get(EcsBits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBits
     * }
     */
    public static void EcsBits(long varValue) {
        EcsBits$constants.SEGMENT.set(EcsBits$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloBits$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloBits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBits
     * }
     */
    public static OfLong EcsKiloBits$layout() {
        return EcsKiloBits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBits
     * }
     */
    public static MemorySegment EcsKiloBits$segment() {
        return EcsKiloBits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBits
     * }
     */
    public static long EcsKiloBits() {
        return EcsKiloBits$constants.SEGMENT.get(EcsKiloBits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBits
     * }
     */
    public static void EcsKiloBits(long varValue) {
        EcsKiloBits$constants.SEGMENT.set(EcsKiloBits$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMegaBits$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMegaBits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBits
     * }
     */
    public static OfLong EcsMegaBits$layout() {
        return EcsMegaBits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBits
     * }
     */
    public static MemorySegment EcsMegaBits$segment() {
        return EcsMegaBits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBits
     * }
     */
    public static long EcsMegaBits() {
        return EcsMegaBits$constants.SEGMENT.get(EcsMegaBits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBits
     * }
     */
    public static void EcsMegaBits(long varValue) {
        EcsMegaBits$constants.SEGMENT.set(EcsMegaBits$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGigaBits$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGigaBits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBits
     * }
     */
    public static OfLong EcsGigaBits$layout() {
        return EcsGigaBits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBits
     * }
     */
    public static MemorySegment EcsGigaBits$segment() {
        return EcsGigaBits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBits
     * }
     */
    public static long EcsGigaBits() {
        return EcsGigaBits$constants.SEGMENT.get(EcsGigaBits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBits
     * }
     */
    public static void EcsGigaBits(long varValue) {
        EcsGigaBits$constants.SEGMENT.set(EcsGigaBits$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytes
     * }
     */
    public static OfLong EcsBytes$layout() {
        return EcsBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytes
     * }
     */
    public static MemorySegment EcsBytes$segment() {
        return EcsBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytes
     * }
     */
    public static long EcsBytes() {
        return EcsBytes$constants.SEGMENT.get(EcsBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytes
     * }
     */
    public static void EcsBytes(long varValue) {
        EcsBytes$constants.SEGMENT.set(EcsBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytes
     * }
     */
    public static OfLong EcsKiloBytes$layout() {
        return EcsKiloBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytes
     * }
     */
    public static MemorySegment EcsKiloBytes$segment() {
        return EcsKiloBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytes
     * }
     */
    public static long EcsKiloBytes() {
        return EcsKiloBytes$constants.SEGMENT.get(EcsKiloBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytes
     * }
     */
    public static void EcsKiloBytes(long varValue) {
        EcsKiloBytes$constants.SEGMENT.set(EcsKiloBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMegaBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMegaBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytes
     * }
     */
    public static OfLong EcsMegaBytes$layout() {
        return EcsMegaBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytes
     * }
     */
    public static MemorySegment EcsMegaBytes$segment() {
        return EcsMegaBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytes
     * }
     */
    public static long EcsMegaBytes() {
        return EcsMegaBytes$constants.SEGMENT.get(EcsMegaBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytes
     * }
     */
    public static void EcsMegaBytes(long varValue) {
        EcsMegaBytes$constants.SEGMENT.set(EcsMegaBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGigaBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGigaBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytes
     * }
     */
    public static OfLong EcsGigaBytes$layout() {
        return EcsGigaBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytes
     * }
     */
    public static MemorySegment EcsGigaBytes$segment() {
        return EcsGigaBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytes
     * }
     */
    public static long EcsGigaBytes() {
        return EcsGigaBytes$constants.SEGMENT.get(EcsGigaBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytes
     * }
     */
    public static void EcsGigaBytes(long varValue) {
        EcsGigaBytes$constants.SEGMENT.set(EcsGigaBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKibiBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKibiBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibiBytes
     * }
     */
    public static OfLong EcsKibiBytes$layout() {
        return EcsKibiBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibiBytes
     * }
     */
    public static MemorySegment EcsKibiBytes$segment() {
        return EcsKibiBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibiBytes
     * }
     */
    public static long EcsKibiBytes() {
        return EcsKibiBytes$constants.SEGMENT.get(EcsKibiBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKibiBytes
     * }
     */
    public static void EcsKibiBytes(long varValue) {
        EcsKibiBytes$constants.SEGMENT.set(EcsKibiBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMebiBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMebiBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebiBytes
     * }
     */
    public static OfLong EcsMebiBytes$layout() {
        return EcsMebiBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebiBytes
     * }
     */
    public static MemorySegment EcsMebiBytes$segment() {
        return EcsMebiBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebiBytes
     * }
     */
    public static long EcsMebiBytes() {
        return EcsMebiBytes$constants.SEGMENT.get(EcsMebiBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMebiBytes
     * }
     */
    public static void EcsMebiBytes(long varValue) {
        EcsMebiBytes$constants.SEGMENT.set(EcsMebiBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGibiBytes$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGibiBytes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibiBytes
     * }
     */
    public static OfLong EcsGibiBytes$layout() {
        return EcsGibiBytes$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibiBytes
     * }
     */
    public static MemorySegment EcsGibiBytes$segment() {
        return EcsGibiBytes$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibiBytes
     * }
     */
    public static long EcsGibiBytes() {
        return EcsGibiBytes$constants.SEGMENT.get(EcsGibiBytes$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGibiBytes
     * }
     */
    public static void EcsGibiBytes(long varValue) {
        EcsGibiBytes$constants.SEGMENT.set(EcsGibiBytes$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDataRate$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDataRate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDataRate
     * }
     */
    public static OfLong EcsDataRate$layout() {
        return EcsDataRate$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDataRate
     * }
     */
    public static MemorySegment EcsDataRate$segment() {
        return EcsDataRate$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDataRate
     * }
     */
    public static long EcsDataRate() {
        return EcsDataRate$constants.SEGMENT.get(EcsDataRate$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDataRate
     * }
     */
    public static void EcsDataRate(long varValue) {
        EcsDataRate$constants.SEGMENT.set(EcsDataRate$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBitsPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBitsPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBitsPerSecond
     * }
     */
    public static OfLong EcsBitsPerSecond$layout() {
        return EcsBitsPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBitsPerSecond
     * }
     */
    public static MemorySegment EcsBitsPerSecond$segment() {
        return EcsBitsPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBitsPerSecond
     * }
     */
    public static long EcsBitsPerSecond() {
        return EcsBitsPerSecond$constants.SEGMENT.get(EcsBitsPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBitsPerSecond
     * }
     */
    public static void EcsBitsPerSecond(long varValue) {
        EcsBitsPerSecond$constants.SEGMENT.set(EcsBitsPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloBitsPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloBitsPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBitsPerSecond
     * }
     */
    public static OfLong EcsKiloBitsPerSecond$layout() {
        return EcsKiloBitsPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBitsPerSecond
     * }
     */
    public static MemorySegment EcsKiloBitsPerSecond$segment() {
        return EcsKiloBitsPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBitsPerSecond
     * }
     */
    public static long EcsKiloBitsPerSecond() {
        return EcsKiloBitsPerSecond$constants.SEGMENT.get(EcsKiloBitsPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBitsPerSecond
     * }
     */
    public static void EcsKiloBitsPerSecond(long varValue) {
        EcsKiloBitsPerSecond$constants.SEGMENT.set(EcsKiloBitsPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMegaBitsPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMegaBitsPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBitsPerSecond
     * }
     */
    public static OfLong EcsMegaBitsPerSecond$layout() {
        return EcsMegaBitsPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBitsPerSecond
     * }
     */
    public static MemorySegment EcsMegaBitsPerSecond$segment() {
        return EcsMegaBitsPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBitsPerSecond
     * }
     */
    public static long EcsMegaBitsPerSecond() {
        return EcsMegaBitsPerSecond$constants.SEGMENT.get(EcsMegaBitsPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBitsPerSecond
     * }
     */
    public static void EcsMegaBitsPerSecond(long varValue) {
        EcsMegaBitsPerSecond$constants.SEGMENT.set(EcsMegaBitsPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGigaBitsPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGigaBitsPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBitsPerSecond
     * }
     */
    public static OfLong EcsGigaBitsPerSecond$layout() {
        return EcsGigaBitsPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBitsPerSecond
     * }
     */
    public static MemorySegment EcsGigaBitsPerSecond$segment() {
        return EcsGigaBitsPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBitsPerSecond
     * }
     */
    public static long EcsGigaBitsPerSecond() {
        return EcsGigaBitsPerSecond$constants.SEGMENT.get(EcsGigaBitsPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBitsPerSecond
     * }
     */
    public static void EcsGigaBitsPerSecond(long varValue) {
        EcsGigaBitsPerSecond$constants.SEGMENT.set(EcsGigaBitsPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBytesPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBytesPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytesPerSecond
     * }
     */
    public static OfLong EcsBytesPerSecond$layout() {
        return EcsBytesPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytesPerSecond
     * }
     */
    public static MemorySegment EcsBytesPerSecond$segment() {
        return EcsBytesPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytesPerSecond
     * }
     */
    public static long EcsBytesPerSecond() {
        return EcsBytesPerSecond$constants.SEGMENT.get(EcsBytesPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBytesPerSecond
     * }
     */
    public static void EcsBytesPerSecond(long varValue) {
        EcsBytesPerSecond$constants.SEGMENT.set(EcsBytesPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloBytesPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloBytesPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytesPerSecond
     * }
     */
    public static OfLong EcsKiloBytesPerSecond$layout() {
        return EcsKiloBytesPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytesPerSecond
     * }
     */
    public static MemorySegment EcsKiloBytesPerSecond$segment() {
        return EcsKiloBytesPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytesPerSecond
     * }
     */
    public static long EcsKiloBytesPerSecond() {
        return EcsKiloBytesPerSecond$constants.SEGMENT.get(EcsKiloBytesPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloBytesPerSecond
     * }
     */
    public static void EcsKiloBytesPerSecond(long varValue) {
        EcsKiloBytesPerSecond$constants.SEGMENT.set(EcsKiloBytesPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMegaBytesPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMegaBytesPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytesPerSecond
     * }
     */
    public static OfLong EcsMegaBytesPerSecond$layout() {
        return EcsMegaBytesPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytesPerSecond
     * }
     */
    public static MemorySegment EcsMegaBytesPerSecond$segment() {
        return EcsMegaBytesPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytesPerSecond
     * }
     */
    public static long EcsMegaBytesPerSecond() {
        return EcsMegaBytesPerSecond$constants.SEGMENT.get(EcsMegaBytesPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaBytesPerSecond
     * }
     */
    public static void EcsMegaBytesPerSecond(long varValue) {
        EcsMegaBytesPerSecond$constants.SEGMENT.set(EcsMegaBytesPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGigaBytesPerSecond$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGigaBytesPerSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytesPerSecond
     * }
     */
    public static OfLong EcsGigaBytesPerSecond$layout() {
        return EcsGigaBytesPerSecond$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytesPerSecond
     * }
     */
    public static MemorySegment EcsGigaBytesPerSecond$segment() {
        return EcsGigaBytesPerSecond$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytesPerSecond
     * }
     */
    public static long EcsGigaBytesPerSecond() {
        return EcsGigaBytesPerSecond$constants.SEGMENT.get(EcsGigaBytesPerSecond$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaBytesPerSecond
     * }
     */
    public static void EcsGigaBytesPerSecond(long varValue) {
        EcsGigaBytesPerSecond$constants.SEGMENT.set(EcsGigaBytesPerSecond$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAngle$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAngle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAngle
     * }
     */
    public static OfLong EcsAngle$layout() {
        return EcsAngle$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAngle
     * }
     */
    public static MemorySegment EcsAngle$segment() {
        return EcsAngle$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAngle
     * }
     */
    public static long EcsAngle() {
        return EcsAngle$constants.SEGMENT.get(EcsAngle$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAngle
     * }
     */
    public static void EcsAngle(long varValue) {
        EcsAngle$constants.SEGMENT.set(EcsAngle$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsRadians$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsRadians").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsRadians
     * }
     */
    public static OfLong EcsRadians$layout() {
        return EcsRadians$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsRadians
     * }
     */
    public static MemorySegment EcsRadians$segment() {
        return EcsRadians$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsRadians
     * }
     */
    public static long EcsRadians() {
        return EcsRadians$constants.SEGMENT.get(EcsRadians$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsRadians
     * }
     */
    public static void EcsRadians(long varValue) {
        EcsRadians$constants.SEGMENT.set(EcsRadians$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDegrees$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDegrees").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDegrees
     * }
     */
    public static OfLong EcsDegrees$layout() {
        return EcsDegrees$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDegrees
     * }
     */
    public static MemorySegment EcsDegrees$segment() {
        return EcsDegrees$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDegrees
     * }
     */
    public static long EcsDegrees() {
        return EcsDegrees$constants.SEGMENT.get(EcsDegrees$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDegrees
     * }
     */
    public static void EcsDegrees(long varValue) {
        EcsDegrees$constants.SEGMENT.set(EcsDegrees$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsFrequency$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsFrequency").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFrequency
     * }
     */
    public static OfLong EcsFrequency$layout() {
        return EcsFrequency$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFrequency
     * }
     */
    public static MemorySegment EcsFrequency$segment() {
        return EcsFrequency$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFrequency
     * }
     */
    public static long EcsFrequency() {
        return EcsFrequency$constants.SEGMENT.get(EcsFrequency$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsFrequency
     * }
     */
    public static void EcsFrequency(long varValue) {
        EcsFrequency$constants.SEGMENT.set(EcsFrequency$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsHertz$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsHertz").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHertz
     * }
     */
    public static OfLong EcsHertz$layout() {
        return EcsHertz$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHertz
     * }
     */
    public static MemorySegment EcsHertz$segment() {
        return EcsHertz$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHertz
     * }
     */
    public static long EcsHertz() {
        return EcsHertz$constants.SEGMENT.get(EcsHertz$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsHertz
     * }
     */
    public static void EcsHertz(long varValue) {
        EcsHertz$constants.SEGMENT.set(EcsHertz$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsKiloHertz$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsKiloHertz").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloHertz
     * }
     */
    public static OfLong EcsKiloHertz$layout() {
        return EcsKiloHertz$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloHertz
     * }
     */
    public static MemorySegment EcsKiloHertz$segment() {
        return EcsKiloHertz$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloHertz
     * }
     */
    public static long EcsKiloHertz() {
        return EcsKiloHertz$constants.SEGMENT.get(EcsKiloHertz$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsKiloHertz
     * }
     */
    public static void EcsKiloHertz(long varValue) {
        EcsKiloHertz$constants.SEGMENT.set(EcsKiloHertz$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsMegaHertz$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsMegaHertz").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaHertz
     * }
     */
    public static OfLong EcsMegaHertz$layout() {
        return EcsMegaHertz$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaHertz
     * }
     */
    public static MemorySegment EcsMegaHertz$segment() {
        return EcsMegaHertz$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaHertz
     * }
     */
    public static long EcsMegaHertz() {
        return EcsMegaHertz$constants.SEGMENT.get(EcsMegaHertz$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsMegaHertz
     * }
     */
    public static void EcsMegaHertz(long varValue) {
        EcsMegaHertz$constants.SEGMENT.set(EcsMegaHertz$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsGigaHertz$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsGigaHertz").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaHertz
     * }
     */
    public static OfLong EcsGigaHertz$layout() {
        return EcsGigaHertz$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaHertz
     * }
     */
    public static MemorySegment EcsGigaHertz$segment() {
        return EcsGigaHertz$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaHertz
     * }
     */
    public static long EcsGigaHertz() {
        return EcsGigaHertz$constants.SEGMENT.get(EcsGigaHertz$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsGigaHertz
     * }
     */
    public static void EcsGigaHertz(long varValue) {
        EcsGigaHertz$constants.SEGMENT.set(EcsGigaHertz$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsUri$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUri").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUri
     * }
     */
    public static OfLong EcsUri$layout() {
        return EcsUri$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUri
     * }
     */
    public static MemorySegment EcsUri$segment() {
        return EcsUri$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUri
     * }
     */
    public static long EcsUri() {
        return EcsUri$constants.SEGMENT.get(EcsUri$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUri
     * }
     */
    public static void EcsUri(long varValue) {
        EcsUri$constants.SEGMENT.set(EcsUri$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsUriHyperlink$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUriHyperlink").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriHyperlink
     * }
     */
    public static OfLong EcsUriHyperlink$layout() {
        return EcsUriHyperlink$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriHyperlink
     * }
     */
    public static MemorySegment EcsUriHyperlink$segment() {
        return EcsUriHyperlink$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriHyperlink
     * }
     */
    public static long EcsUriHyperlink() {
        return EcsUriHyperlink$constants.SEGMENT.get(EcsUriHyperlink$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriHyperlink
     * }
     */
    public static void EcsUriHyperlink(long varValue) {
        EcsUriHyperlink$constants.SEGMENT.set(EcsUriHyperlink$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsUriImage$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUriImage").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriImage
     * }
     */
    public static OfLong EcsUriImage$layout() {
        return EcsUriImage$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriImage
     * }
     */
    public static MemorySegment EcsUriImage$segment() {
        return EcsUriImage$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriImage
     * }
     */
    public static long EcsUriImage() {
        return EcsUriImage$constants.SEGMENT.get(EcsUriImage$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriImage
     * }
     */
    public static void EcsUriImage(long varValue) {
        EcsUriImage$constants.SEGMENT.set(EcsUriImage$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsUriFile$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsUriFile").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriFile
     * }
     */
    public static OfLong EcsUriFile$layout() {
        return EcsUriFile$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriFile
     * }
     */
    public static MemorySegment EcsUriFile$segment() {
        return EcsUriFile$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriFile
     * }
     */
    public static long EcsUriFile() {
        return EcsUriFile$constants.SEGMENT.get(EcsUriFile$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsUriFile
     * }
     */
    public static void EcsUriFile(long varValue) {
        EcsUriFile$constants.SEGMENT.set(EcsUriFile$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsColor$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsColor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColor
     * }
     */
    public static OfLong EcsColor$layout() {
        return EcsColor$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColor
     * }
     */
    public static MemorySegment EcsColor$segment() {
        return EcsColor$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColor
     * }
     */
    public static long EcsColor() {
        return EcsColor$constants.SEGMENT.get(EcsColor$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColor
     * }
     */
    public static void EcsColor(long varValue) {
        EcsColor$constants.SEGMENT.set(EcsColor$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsColorRgb$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsColorRgb").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorRgb
     * }
     */
    public static OfLong EcsColorRgb$layout() {
        return EcsColorRgb$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorRgb
     * }
     */
    public static MemorySegment EcsColorRgb$segment() {
        return EcsColorRgb$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorRgb
     * }
     */
    public static long EcsColorRgb() {
        return EcsColorRgb$constants.SEGMENT.get(EcsColorRgb$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorRgb
     * }
     */
    public static void EcsColorRgb(long varValue) {
        EcsColorRgb$constants.SEGMENT.set(EcsColorRgb$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsColorHsl$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsColorHsl").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorHsl
     * }
     */
    public static OfLong EcsColorHsl$layout() {
        return EcsColorHsl$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorHsl
     * }
     */
    public static MemorySegment EcsColorHsl$segment() {
        return EcsColorHsl$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorHsl
     * }
     */
    public static long EcsColorHsl() {
        return EcsColorHsl$constants.SEGMENT.get(EcsColorHsl$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorHsl
     * }
     */
    public static void EcsColorHsl(long varValue) {
        EcsColorHsl$constants.SEGMENT.set(EcsColorHsl$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsColorCss$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsColorCss").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorCss
     * }
     */
    public static OfLong EcsColorCss$layout() {
        return EcsColorCss$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorCss
     * }
     */
    public static MemorySegment EcsColorCss$segment() {
        return EcsColorCss$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorCss
     * }
     */
    public static long EcsColorCss() {
        return EcsColorCss$constants.SEGMENT.get(EcsColorCss$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsColorCss
     * }
     */
    public static void EcsColorCss(long varValue) {
        EcsColorCss$constants.SEGMENT.set(EcsColorCss$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsAcceleration$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsAcceleration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAcceleration
     * }
     */
    public static OfLong EcsAcceleration$layout() {
        return EcsAcceleration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAcceleration
     * }
     */
    public static MemorySegment EcsAcceleration$segment() {
        return EcsAcceleration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAcceleration
     * }
     */
    public static long EcsAcceleration() {
        return EcsAcceleration$constants.SEGMENT.get(EcsAcceleration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsAcceleration
     * }
     */
    public static void EcsAcceleration(long varValue) {
        EcsAcceleration$constants.SEGMENT.set(EcsAcceleration$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsPercentage$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsPercentage").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPercentage
     * }
     */
    public static OfLong EcsPercentage$layout() {
        return EcsPercentage$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPercentage
     * }
     */
    public static MemorySegment EcsPercentage$segment() {
        return EcsPercentage$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPercentage
     * }
     */
    public static long EcsPercentage() {
        return EcsPercentage$constants.SEGMENT.get(EcsPercentage$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsPercentage
     * }
     */
    public static void EcsPercentage(long varValue) {
        EcsPercentage$constants.SEGMENT.set(EcsPercentage$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsBel$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsBel").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBel
     * }
     */
    public static OfLong EcsBel$layout() {
        return EcsBel$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBel
     * }
     */
    public static MemorySegment EcsBel$segment() {
        return EcsBel$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBel
     * }
     */
    public static long EcsBel() {
        return EcsBel$constants.SEGMENT.get(EcsBel$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsBel
     * }
     */
    public static void EcsBel(long varValue) {
        EcsBel$constants.SEGMENT.set(EcsBel$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDeciBel$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDeciBel").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeciBel
     * }
     */
    public static OfLong EcsDeciBel$layout() {
        return EcsDeciBel$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeciBel
     * }
     */
    public static MemorySegment EcsDeciBel$segment() {
        return EcsDeciBel$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeciBel
     * }
     */
    public static long EcsDeciBel() {
        return EcsDeciBel$constants.SEGMENT.get(EcsDeciBel$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t EcsDeciBel
     * }
     */
    public static void EcsDeciBel(long varValue) {
        EcsDeciBel$constants.SEGMENT.set(EcsDeciBel$constants.LAYOUT, 0L, varValue);
    }

    private static class FlecsUnitsImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsUnitsImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsUnitsImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsUnitsImport$descriptor() {
        return FlecsUnitsImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsUnitsImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsUnitsImport$handle() {
        return FlecsUnitsImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsUnitsImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsUnitsImport$address() {
        return FlecsUnitsImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsUnitsImport(ecs_world_t *world)
     * }
     */
    public static void FlecsUnitsImport(MemorySegment world) {
        var mh$ = FlecsUnitsImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsUnitsImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDEcsScriptID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsScriptID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsScriptID_
     * }
     */
    public static OfLong FLECS_IDEcsScriptID_$layout() {
        return FLECS_IDEcsScriptID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsScriptID_
     * }
     */
    public static MemorySegment FLECS_IDEcsScriptID_$segment() {
        return FLECS_IDEcsScriptID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsScriptID_
     * }
     */
    public static long FLECS_IDEcsScriptID_() {
        return FLECS_IDEcsScriptID_$constants.SEGMENT.get(FLECS_IDEcsScriptID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern ecs_entity_t FLECS_IDEcsScriptID_
     * }
     */
    public static void FLECS_IDEcsScriptID_(long varValue) {
        FLECS_IDEcsScriptID_$constants.SEGMENT.set(FLECS_IDEcsScriptID_$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_script_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_t *ecs_script_parse(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static FunctionDescriptor ecs_script_parse$descriptor() {
        return ecs_script_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_t *ecs_script_parse(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static MethodHandle ecs_script_parse$handle() {
        return ecs_script_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_t *ecs_script_parse(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static MemorySegment ecs_script_parse$address() {
        return ecs_script_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_t *ecs_script_parse(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static MemorySegment ecs_script_parse(MemorySegment world, MemorySegment name, MemorySegment code) {
        var mh$ = ecs_script_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_parse", world, name, code);
            }
            return (MemorySegment)mh$.invokeExact(world, name, code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_script_eval(ecs_script_t *script)
     * }
     */
    public static FunctionDescriptor ecs_script_eval$descriptor() {
        return ecs_script_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_script_eval(ecs_script_t *script)
     * }
     */
    public static MethodHandle ecs_script_eval$handle() {
        return ecs_script_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_script_eval(ecs_script_t *script)
     * }
     */
    public static MemorySegment ecs_script_eval$address() {
        return ecs_script_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_script_eval(ecs_script_t *script)
     * }
     */
    public static int ecs_script_eval(MemorySegment script) {
        var mh$ = ecs_script_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_eval", script);
            }
            return (int)mh$.invokeExact(script);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_script_free(ecs_script_t *script)
     * }
     */
    public static FunctionDescriptor ecs_script_free$descriptor() {
        return ecs_script_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_script_free(ecs_script_t *script)
     * }
     */
    public static MethodHandle ecs_script_free$handle() {
        return ecs_script_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_script_free(ecs_script_t *script)
     * }
     */
    public static MemorySegment ecs_script_free$address() {
        return ecs_script_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_script_free(ecs_script_t *script)
     * }
     */
    public static void ecs_script_free(MemorySegment script) {
        var mh$ = ecs_script_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_free", script);
            }
            mh$.invokeExact(script);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_script_run(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static FunctionDescriptor ecs_script_run$descriptor() {
        return ecs_script_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_script_run(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static MethodHandle ecs_script_run$handle() {
        return ecs_script_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_script_run(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static MemorySegment ecs_script_run$address() {
        return ecs_script_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_script_run(ecs_world_t *world, const char *name, const char *code)
     * }
     */
    public static int ecs_script_run(MemorySegment world, MemorySegment name, MemorySegment code) {
        var mh$ = ecs_script_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_run", world, name, code);
            }
            return (int)mh$.invokeExact(world, name, code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_run_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_run_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_script_run_file(ecs_world_t *world, const char *filename)
     * }
     */
    public static FunctionDescriptor ecs_script_run_file$descriptor() {
        return ecs_script_run_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_script_run_file(ecs_world_t *world, const char *filename)
     * }
     */
    public static MethodHandle ecs_script_run_file$handle() {
        return ecs_script_run_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_script_run_file(ecs_world_t *world, const char *filename)
     * }
     */
    public static MemorySegment ecs_script_run_file$address() {
        return ecs_script_run_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_script_run_file(ecs_world_t *world, const char *filename)
     * }
     */
    public static int ecs_script_run_file(MemorySegment world, MemorySegment filename) {
        var mh$ = ecs_script_run_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_run_file", world, filename);
            }
            return (int)mh$.invokeExact(world, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_ast_to_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_ast_to_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_script_ast_to_buf(ecs_script_t *script, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_script_ast_to_buf$descriptor() {
        return ecs_script_ast_to_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_script_ast_to_buf(ecs_script_t *script, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_script_ast_to_buf$handle() {
        return ecs_script_ast_to_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_script_ast_to_buf(ecs_script_t *script, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_script_ast_to_buf$address() {
        return ecs_script_ast_to_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_script_ast_to_buf(ecs_script_t *script, ecs_strbuf_t *buf)
     * }
     */
    public static int ecs_script_ast_to_buf(MemorySegment script, MemorySegment buf) {
        var mh$ = ecs_script_ast_to_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_ast_to_buf", script, buf);
            }
            return (int)mh$.invokeExact(script, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_ast_to_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_ast_to_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_script_ast_to_str(ecs_script_t *script)
     * }
     */
    public static FunctionDescriptor ecs_script_ast_to_str$descriptor() {
        return ecs_script_ast_to_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_script_ast_to_str(ecs_script_t *script)
     * }
     */
    public static MethodHandle ecs_script_ast_to_str$handle() {
        return ecs_script_ast_to_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_script_ast_to_str(ecs_script_t *script)
     * }
     */
    public static MemorySegment ecs_script_ast_to_str$address() {
        return ecs_script_ast_to_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_script_ast_to_str(ecs_script_t *script)
     * }
     */
    public static MemorySegment ecs_script_ast_to_str(MemorySegment script) {
        var mh$ = ecs_script_ast_to_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_ast_to_str", script);
            }
            return (MemorySegment)mh$.invokeExact(script);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_script_init(ecs_world_t *world, const ecs_script_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_script_init$descriptor() {
        return ecs_script_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_script_init(ecs_world_t *world, const ecs_script_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_script_init$handle() {
        return ecs_script_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_script_init(ecs_world_t *world, const ecs_script_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_script_init$address() {
        return ecs_script_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_script_init(ecs_world_t *world, const ecs_script_desc_t *desc)
     * }
     */
    public static long ecs_script_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_script_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_script_update(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance, const char *code)
     * }
     */
    public static FunctionDescriptor ecs_script_update$descriptor() {
        return ecs_script_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_script_update(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance, const char *code)
     * }
     */
    public static MethodHandle ecs_script_update$handle() {
        return ecs_script_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_script_update(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance, const char *code)
     * }
     */
    public static MemorySegment ecs_script_update$address() {
        return ecs_script_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_script_update(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance, const char *code)
     * }
     */
    public static int ecs_script_update(MemorySegment world, long script, long instance, MemorySegment code) {
        var mh$ = ecs_script_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_update", world, script, instance, code);
            }
            return (int)mh$.invokeExact(world, script, instance, code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_script_clear(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance)
     * }
     */
    public static FunctionDescriptor ecs_script_clear$descriptor() {
        return ecs_script_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_script_clear(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance)
     * }
     */
    public static MethodHandle ecs_script_clear$handle() {
        return ecs_script_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_script_clear(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance)
     * }
     */
    public static MemorySegment ecs_script_clear$address() {
        return ecs_script_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_script_clear(ecs_world_t *world, ecs_entity_t script, ecs_entity_t instance)
     * }
     */
    public static void ecs_script_clear(MemorySegment world, long script, long instance) {
        var mh$ = ecs_script_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_clear", world, script, instance);
            }
            mh$.invokeExact(world, script, instance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_init(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_init$descriptor() {
        return ecs_script_vars_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_init(ecs_world_t *world)
     * }
     */
    public static MethodHandle ecs_script_vars_init$handle() {
        return ecs_script_vars_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_init(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_script_vars_init$address() {
        return ecs_script_vars_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_init(ecs_world_t *world)
     * }
     */
    public static MemorySegment ecs_script_vars_init(MemorySegment world) {
        var mh$ = ecs_script_vars_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_init", world);
            }
            return (MemorySegment)mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_script_vars_fini(ecs_script_vars_t *vars)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_fini$descriptor() {
        return ecs_script_vars_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_script_vars_fini(ecs_script_vars_t *vars)
     * }
     */
    public static MethodHandle ecs_script_vars_fini$handle() {
        return ecs_script_vars_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_script_vars_fini(ecs_script_vars_t *vars)
     * }
     */
    public static MemorySegment ecs_script_vars_fini$address() {
        return ecs_script_vars_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_script_vars_fini(ecs_script_vars_t *vars)
     * }
     */
    public static void ecs_script_vars_fini(MemorySegment vars) {
        var mh$ = ecs_script_vars_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_fini", vars);
            }
            mh$.invokeExact(vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_push(ecs_script_vars_t *parent)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_push$descriptor() {
        return ecs_script_vars_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_push(ecs_script_vars_t *parent)
     * }
     */
    public static MethodHandle ecs_script_vars_push$handle() {
        return ecs_script_vars_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_push(ecs_script_vars_t *parent)
     * }
     */
    public static MemorySegment ecs_script_vars_push$address() {
        return ecs_script_vars_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_push(ecs_script_vars_t *parent)
     * }
     */
    public static MemorySegment ecs_script_vars_push(MemorySegment parent) {
        var mh$ = ecs_script_vars_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_push", parent);
            }
            return (MemorySegment)mh$.invokeExact(parent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_pop(ecs_script_vars_t *vars)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_pop$descriptor() {
        return ecs_script_vars_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_pop(ecs_script_vars_t *vars)
     * }
     */
    public static MethodHandle ecs_script_vars_pop$handle() {
        return ecs_script_vars_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_pop(ecs_script_vars_t *vars)
     * }
     */
    public static MemorySegment ecs_script_vars_pop$address() {
        return ecs_script_vars_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_vars_t *ecs_script_vars_pop(ecs_script_vars_t *vars)
     * }
     */
    public static MemorySegment ecs_script_vars_pop(MemorySegment vars) {
        var mh$ = ecs_script_vars_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_pop", vars);
            }
            return (MemorySegment)mh$.invokeExact(vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_declare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_declare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_declare(ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_declare$descriptor() {
        return ecs_script_vars_declare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_declare(ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MethodHandle ecs_script_vars_declare$handle() {
        return ecs_script_vars_declare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_declare(ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MemorySegment ecs_script_vars_declare$address() {
        return ecs_script_vars_declare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_declare(ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MemorySegment ecs_script_vars_declare(MemorySegment vars, MemorySegment name) {
        var mh$ = ecs_script_vars_declare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_declare", vars, name);
            }
            return (MemorySegment)mh$.invokeExact(vars, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_define_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_define_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_define_id(ecs_script_vars_t *vars, const char *name, ecs_entity_t type)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_define_id$descriptor() {
        return ecs_script_vars_define_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_define_id(ecs_script_vars_t *vars, const char *name, ecs_entity_t type)
     * }
     */
    public static MethodHandle ecs_script_vars_define_id$handle() {
        return ecs_script_vars_define_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_define_id(ecs_script_vars_t *vars, const char *name, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_script_vars_define_id$address() {
        return ecs_script_vars_define_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_define_id(ecs_script_vars_t *vars, const char *name, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_script_vars_define_id(MemorySegment vars, MemorySegment name, long type) {
        var mh$ = ecs_script_vars_define_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_define_id", vars, name, type);
            }
            return (MemorySegment)mh$.invokeExact(vars, name, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_lookup(const ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_lookup$descriptor() {
        return ecs_script_vars_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_lookup(const ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MethodHandle ecs_script_vars_lookup$handle() {
        return ecs_script_vars_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_lookup(const ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MemorySegment ecs_script_vars_lookup$address() {
        return ecs_script_vars_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_script_var_t *ecs_script_vars_lookup(const ecs_script_vars_t *vars, const char *name)
     * }
     */
    public static MemorySegment ecs_script_vars_lookup(MemorySegment vars, MemorySegment name) {
        var mh$ = ecs_script_vars_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_lookup", vars, name);
            }
            return (MemorySegment)mh$.invokeExact(vars, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_vars_from_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_vars_from_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_script_vars_from_iter(const ecs_iter_t *it, ecs_script_vars_t *vars, int offset)
     * }
     */
    public static FunctionDescriptor ecs_script_vars_from_iter$descriptor() {
        return ecs_script_vars_from_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_script_vars_from_iter(const ecs_iter_t *it, ecs_script_vars_t *vars, int offset)
     * }
     */
    public static MethodHandle ecs_script_vars_from_iter$handle() {
        return ecs_script_vars_from_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_script_vars_from_iter(const ecs_iter_t *it, ecs_script_vars_t *vars, int offset)
     * }
     */
    public static MemorySegment ecs_script_vars_from_iter$address() {
        return ecs_script_vars_from_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_script_vars_from_iter(const ecs_iter_t *it, ecs_script_vars_t *vars, int offset)
     * }
     */
    public static void ecs_script_vars_from_iter(MemorySegment it, MemorySegment vars, int offset) {
        var mh$ = ecs_script_vars_from_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_vars_from_iter", it, vars, offset);
            }
            mh$.invokeExact(it, vars, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_expr_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_expr_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_script_expr_run(ecs_world_t *world, const char *ptr, ecs_value_t *value, const ecs_script_expr_run_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_script_expr_run$descriptor() {
        return ecs_script_expr_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_script_expr_run(ecs_world_t *world, const char *ptr, ecs_value_t *value, const ecs_script_expr_run_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_script_expr_run$handle() {
        return ecs_script_expr_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_script_expr_run(ecs_world_t *world, const char *ptr, ecs_value_t *value, const ecs_script_expr_run_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_script_expr_run$address() {
        return ecs_script_expr_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_script_expr_run(ecs_world_t *world, const char *ptr, ecs_value_t *value, const ecs_script_expr_run_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_script_expr_run(MemorySegment world, MemorySegment ptr, MemorySegment value, MemorySegment desc) {
        var mh$ = ecs_script_expr_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_expr_run", world, ptr, value, desc);
            }
            return (MemorySegment)mh$.invokeExact(world, ptr, value, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_script_string_interpolate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_script_string_interpolate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_script_string_interpolate(ecs_world_t *world, const char *str, const ecs_script_vars_t *vars)
     * }
     */
    public static FunctionDescriptor ecs_script_string_interpolate$descriptor() {
        return ecs_script_string_interpolate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_script_string_interpolate(ecs_world_t *world, const char *str, const ecs_script_vars_t *vars)
     * }
     */
    public static MethodHandle ecs_script_string_interpolate$handle() {
        return ecs_script_string_interpolate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_script_string_interpolate(ecs_world_t *world, const char *str, const ecs_script_vars_t *vars)
     * }
     */
    public static MemorySegment ecs_script_string_interpolate$address() {
        return ecs_script_string_interpolate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_script_string_interpolate(ecs_world_t *world, const char *str, const ecs_script_vars_t *vars)
     * }
     */
    public static MemorySegment ecs_script_string_interpolate(MemorySegment world, MemorySegment str, MemorySegment vars) {
        var mh$ = ecs_script_string_interpolate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_script_string_interpolate", world, str, vars);
            }
            return (MemorySegment)mh$.invokeExact(world, str, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_expr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_expr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_expr(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_expr$descriptor() {
        return ecs_ptr_to_expr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_expr(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MethodHandle ecs_ptr_to_expr$handle() {
        return ecs_ptr_to_expr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_expr(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_expr$address() {
        return ecs_ptr_to_expr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_ptr_to_expr(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_expr(MemorySegment world, long type, MemorySegment data) {
        var mh$ = ecs_ptr_to_expr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_expr", world, type, data);
            }
            return (MemorySegment)mh$.invokeExact(world, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_expr_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_expr_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_ptr_to_expr_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_expr_buf$descriptor() {
        return ecs_ptr_to_expr_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_ptr_to_expr_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_ptr_to_expr_buf$handle() {
        return ecs_ptr_to_expr_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_ptr_to_expr_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_ptr_to_expr_buf$address() {
        return ecs_ptr_to_expr_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_ptr_to_expr_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static int ecs_ptr_to_expr_buf(MemorySegment world, long type, MemorySegment data, MemorySegment buf) {
        var mh$ = ecs_ptr_to_expr_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_expr_buf", world, type, data, buf);
            }
            return (int)mh$.invokeExact(world, type, data, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_str(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_str$descriptor() {
        return ecs_ptr_to_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_str(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MethodHandle ecs_ptr_to_str$handle() {
        return ecs_ptr_to_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_ptr_to_str(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_str$address() {
        return ecs_ptr_to_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_ptr_to_str(const ecs_world_t *world, ecs_entity_t type, const void *data)
     * }
     */
    public static MemorySegment ecs_ptr_to_str(MemorySegment world, long type, MemorySegment data) {
        var mh$ = ecs_ptr_to_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_str", world, type, data);
            }
            return (MemorySegment)mh$.invokeExact(world, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_ptr_to_str_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_ptr_to_str_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_ptr_to_str_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static FunctionDescriptor ecs_ptr_to_str_buf$descriptor() {
        return ecs_ptr_to_str_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_ptr_to_str_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static MethodHandle ecs_ptr_to_str_buf$handle() {
        return ecs_ptr_to_str_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_ptr_to_str_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static MemorySegment ecs_ptr_to_str_buf$address() {
        return ecs_ptr_to_str_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_ptr_to_str_buf(const ecs_world_t *world, ecs_entity_t type, const void *data, ecs_strbuf_t *buf)
     * }
     */
    public static int ecs_ptr_to_str_buf(MemorySegment world, long type, MemorySegment data, MemorySegment buf) {
        var mh$ = ecs_ptr_to_str_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_ptr_to_str_buf", world, type, data, buf);
            }
            return (int)mh$.invokeExact(world, type, data, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsScriptImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsScriptImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsScriptImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsScriptImport$descriptor() {
        return FlecsScriptImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsScriptImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsScriptImport$handle() {
        return FlecsScriptImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsScriptImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsScriptImport$address() {
        return FlecsScriptImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsScriptImport(ecs_world_t *world)
     * }
     */
    public static void FlecsScriptImport(MemorySegment world) {
        var mh$ = FlecsScriptImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsScriptImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FLECS_IDEcsDocDescriptionID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsDocDescriptionID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDocDescriptionID_
     * }
     */
    public static OfLong FLECS_IDEcsDocDescriptionID_$layout() {
        return FLECS_IDEcsDocDescriptionID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDocDescriptionID_
     * }
     */
    public static MemorySegment FLECS_IDEcsDocDescriptionID_$segment() {
        return FLECS_IDEcsDocDescriptionID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDocDescriptionID_
     * }
     */
    public static long FLECS_IDEcsDocDescriptionID_() {
        return FLECS_IDEcsDocDescriptionID_$constants.SEGMENT.get(FLECS_IDEcsDocDescriptionID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsDocDescriptionID_
     * }
     */
    public static void FLECS_IDEcsDocDescriptionID_(long varValue) {
        FLECS_IDEcsDocDescriptionID_$constants.SEGMENT.set(FLECS_IDEcsDocDescriptionID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDocBrief$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDocBrief").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocBrief
     * }
     */
    public static OfLong EcsDocBrief$layout() {
        return EcsDocBrief$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocBrief
     * }
     */
    public static MemorySegment EcsDocBrief$segment() {
        return EcsDocBrief$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocBrief
     * }
     */
    public static long EcsDocBrief() {
        return EcsDocBrief$constants.SEGMENT.get(EcsDocBrief$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocBrief
     * }
     */
    public static void EcsDocBrief(long varValue) {
        EcsDocBrief$constants.SEGMENT.set(EcsDocBrief$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDocDetail$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDocDetail").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocDetail
     * }
     */
    public static OfLong EcsDocDetail$layout() {
        return EcsDocDetail$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocDetail
     * }
     */
    public static MemorySegment EcsDocDetail$segment() {
        return EcsDocDetail$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocDetail
     * }
     */
    public static long EcsDocDetail() {
        return EcsDocDetail$constants.SEGMENT.get(EcsDocDetail$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocDetail
     * }
     */
    public static void EcsDocDetail(long varValue) {
        EcsDocDetail$constants.SEGMENT.set(EcsDocDetail$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDocLink$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDocLink").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocLink
     * }
     */
    public static OfLong EcsDocLink$layout() {
        return EcsDocLink$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocLink
     * }
     */
    public static MemorySegment EcsDocLink$segment() {
        return EcsDocLink$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocLink
     * }
     */
    public static long EcsDocLink() {
        return EcsDocLink$constants.SEGMENT.get(EcsDocLink$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocLink
     * }
     */
    public static void EcsDocLink(long varValue) {
        EcsDocLink$constants.SEGMENT.set(EcsDocLink$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsDocColor$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsDocColor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocColor
     * }
     */
    public static OfLong EcsDocColor$layout() {
        return EcsDocColor$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocColor
     * }
     */
    public static MemorySegment EcsDocColor$segment() {
        return EcsDocColor$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocColor
     * }
     */
    public static long EcsDocColor() {
        return EcsDocColor$constants.SEGMENT.get(EcsDocColor$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsDocColor
     * }
     */
    public static void EcsDocColor(long varValue) {
        EcsDocColor$constants.SEGMENT.set(EcsDocColor$constants.LAYOUT, 0L, varValue);
    }

    private static class ecs_doc_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_doc_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_doc_set_name$descriptor() {
        return ecs_doc_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_doc_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MethodHandle ecs_doc_set_name$handle() {
        return ecs_doc_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_doc_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static MemorySegment ecs_doc_set_name$address() {
        return ecs_doc_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_doc_set_name(ecs_world_t *world, ecs_entity_t entity, const char *name)
     * }
     */
    public static void ecs_doc_set_name(MemorySegment world, long entity, MemorySegment name) {
        var mh$ = ecs_doc_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_set_name", world, entity, name);
            }
            mh$.invokeExact(world, entity, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_set_brief {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_set_brief");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_doc_set_brief(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static FunctionDescriptor ecs_doc_set_brief$descriptor() {
        return ecs_doc_set_brief.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_doc_set_brief(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static MethodHandle ecs_doc_set_brief$handle() {
        return ecs_doc_set_brief.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_doc_set_brief(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static MemorySegment ecs_doc_set_brief$address() {
        return ecs_doc_set_brief.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_doc_set_brief(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static void ecs_doc_set_brief(MemorySegment world, long entity, MemorySegment description) {
        var mh$ = ecs_doc_set_brief.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_set_brief", world, entity, description);
            }
            mh$.invokeExact(world, entity, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_set_detail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_set_detail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_doc_set_detail(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static FunctionDescriptor ecs_doc_set_detail$descriptor() {
        return ecs_doc_set_detail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_doc_set_detail(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static MethodHandle ecs_doc_set_detail$handle() {
        return ecs_doc_set_detail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_doc_set_detail(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static MemorySegment ecs_doc_set_detail$address() {
        return ecs_doc_set_detail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_doc_set_detail(ecs_world_t *world, ecs_entity_t entity, const char *description)
     * }
     */
    public static void ecs_doc_set_detail(MemorySegment world, long entity, MemorySegment description) {
        var mh$ = ecs_doc_set_detail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_set_detail", world, entity, description);
            }
            mh$.invokeExact(world, entity, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_set_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_set_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_doc_set_link(ecs_world_t *world, ecs_entity_t entity, const char *link)
     * }
     */
    public static FunctionDescriptor ecs_doc_set_link$descriptor() {
        return ecs_doc_set_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_doc_set_link(ecs_world_t *world, ecs_entity_t entity, const char *link)
     * }
     */
    public static MethodHandle ecs_doc_set_link$handle() {
        return ecs_doc_set_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_doc_set_link(ecs_world_t *world, ecs_entity_t entity, const char *link)
     * }
     */
    public static MemorySegment ecs_doc_set_link$address() {
        return ecs_doc_set_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_doc_set_link(ecs_world_t *world, ecs_entity_t entity, const char *link)
     * }
     */
    public static void ecs_doc_set_link(MemorySegment world, long entity, MemorySegment link) {
        var mh$ = ecs_doc_set_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_set_link", world, entity, link);
            }
            mh$.invokeExact(world, entity, link);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_set_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_set_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_doc_set_color(ecs_world_t *world, ecs_entity_t entity, const char *color)
     * }
     */
    public static FunctionDescriptor ecs_doc_set_color$descriptor() {
        return ecs_doc_set_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_doc_set_color(ecs_world_t *world, ecs_entity_t entity, const char *color)
     * }
     */
    public static MethodHandle ecs_doc_set_color$handle() {
        return ecs_doc_set_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_doc_set_color(ecs_world_t *world, ecs_entity_t entity, const char *color)
     * }
     */
    public static MemorySegment ecs_doc_set_color$address() {
        return ecs_doc_set_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_doc_set_color(ecs_world_t *world, ecs_entity_t entity, const char *color)
     * }
     */
    public static void ecs_doc_set_color(MemorySegment world, long entity, MemorySegment color) {
        var mh$ = ecs_doc_set_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_set_color", world, entity, color);
            }
            mh$.invokeExact(world, entity, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_doc_get_name$descriptor() {
        return ecs_doc_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_doc_get_name$handle() {
        return ecs_doc_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_name$address() {
        return ecs_doc_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_doc_get_name(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_name(MemorySegment world, long entity) {
        var mh$ = ecs_doc_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_get_name", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_get_brief {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_get_brief");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_brief(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_doc_get_brief$descriptor() {
        return ecs_doc_get_brief.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_brief(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_doc_get_brief$handle() {
        return ecs_doc_get_brief.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_brief(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_brief$address() {
        return ecs_doc_get_brief.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_doc_get_brief(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_brief(MemorySegment world, long entity) {
        var mh$ = ecs_doc_get_brief.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_get_brief", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_get_detail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_get_detail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_detail(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_doc_get_detail$descriptor() {
        return ecs_doc_get_detail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_detail(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_doc_get_detail$handle() {
        return ecs_doc_get_detail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_detail(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_detail$address() {
        return ecs_doc_get_detail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_doc_get_detail(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_detail(MemorySegment world, long entity) {
        var mh$ = ecs_doc_get_detail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_get_detail", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_get_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_get_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_link(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_doc_get_link$descriptor() {
        return ecs_doc_get_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_link(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_doc_get_link$handle() {
        return ecs_doc_get_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_link(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_link$address() {
        return ecs_doc_get_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_doc_get_link(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_link(MemorySegment world, long entity) {
        var mh$ = ecs_doc_get_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_get_link", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_doc_get_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_doc_get_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_color(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static FunctionDescriptor ecs_doc_get_color$descriptor() {
        return ecs_doc_get_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_color(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MethodHandle ecs_doc_get_color$handle() {
        return ecs_doc_get_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_doc_get_color(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_color$address() {
        return ecs_doc_get_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_doc_get_color(const ecs_world_t *world, ecs_entity_t entity)
     * }
     */
    public static MemorySegment ecs_doc_get_color(MemorySegment world, long entity) {
        var mh$ = ecs_doc_get_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_doc_get_color", world, entity);
            }
            return (MemorySegment)mh$.invokeExact(world, entity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsDocImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsDocImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsDocImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsDocImport$descriptor() {
        return FlecsDocImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsDocImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsDocImport$handle() {
        return FlecsDocImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsDocImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsDocImport$address() {
        return FlecsDocImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsDocImport(ecs_world_t *world)
     * }
     */
    public static void FlecsDocImport(MemorySegment world) {
        var mh$ = FlecsDocImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsDocImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef bool ecs_bool_t
     * }
     */
    public static final OfBoolean ecs_bool_t = flecs.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef char ecs_char_t
     * }
     */
    public static final OfByte ecs_char_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char ecs_byte_t
     * }
     */
    public static final OfByte ecs_byte_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t ecs_u8_t
     * }
     */
    public static final OfByte ecs_u8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t ecs_u16_t
     * }
     */
    public static final OfShort ecs_u16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t ecs_u32_t
     * }
     */
    public static final OfInt ecs_u32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ecs_u64_t
     * }
     */
    public static final OfLong ecs_u64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t ecs_uptr_t
     * }
     */
    public static final OfLong ecs_uptr_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t ecs_i8_t
     * }
     */
    public static final OfByte ecs_i8_t = flecs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t ecs_i16_t
     * }
     */
    public static final OfShort ecs_i16_t = flecs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t ecs_i32_t
     * }
     */
    public static final OfInt ecs_i32_t = flecs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t ecs_i64_t
     * }
     */
    public static final OfLong ecs_i64_t = flecs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t ecs_iptr_t
     * }
     */
    public static final OfLong ecs_iptr_t = flecs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float ecs_f32_t
     * }
     */
    public static final OfFloat ecs_f32_t = flecs.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double ecs_f64_t
     * }
     */
    public static final OfDouble ecs_f64_t = flecs.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef char *ecs_string_t
     * }
     */
    public static final AddressLayout ecs_string_t = flecs.C_POINTER;

    private static class FLECS_IDEcsTypeID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsTypeID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeID_
     * }
     */
    public static OfLong FLECS_IDEcsTypeID_$layout() {
        return FLECS_IDEcsTypeID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTypeID_$segment() {
        return FLECS_IDEcsTypeID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeID_
     * }
     */
    public static long FLECS_IDEcsTypeID_() {
        return FLECS_IDEcsTypeID_$constants.SEGMENT.get(FLECS_IDEcsTypeID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeID_
     * }
     */
    public static void FLECS_IDEcsTypeID_(long varValue) {
        FLECS_IDEcsTypeID_$constants.SEGMENT.set(FLECS_IDEcsTypeID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsTypeSerializerID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsTypeSerializerID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeSerializerID_
     * }
     */
    public static OfLong FLECS_IDEcsTypeSerializerID_$layout() {
        return FLECS_IDEcsTypeSerializerID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeSerializerID_
     * }
     */
    public static MemorySegment FLECS_IDEcsTypeSerializerID_$segment() {
        return FLECS_IDEcsTypeSerializerID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeSerializerID_
     * }
     */
    public static long FLECS_IDEcsTypeSerializerID_() {
        return FLECS_IDEcsTypeSerializerID_$constants.SEGMENT.get(FLECS_IDEcsTypeSerializerID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsTypeSerializerID_
     * }
     */
    public static void FLECS_IDEcsTypeSerializerID_(long varValue) {
        FLECS_IDEcsTypeSerializerID_$constants.SEGMENT.set(FLECS_IDEcsTypeSerializerID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsPrimitiveID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsPrimitiveID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPrimitiveID_
     * }
     */
    public static OfLong FLECS_IDEcsPrimitiveID_$layout() {
        return FLECS_IDEcsPrimitiveID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPrimitiveID_
     * }
     */
    public static MemorySegment FLECS_IDEcsPrimitiveID_$segment() {
        return FLECS_IDEcsPrimitiveID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPrimitiveID_
     * }
     */
    public static long FLECS_IDEcsPrimitiveID_() {
        return FLECS_IDEcsPrimitiveID_$constants.SEGMENT.get(FLECS_IDEcsPrimitiveID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsPrimitiveID_
     * }
     */
    public static void FLECS_IDEcsPrimitiveID_(long varValue) {
        FLECS_IDEcsPrimitiveID_$constants.SEGMENT.set(FLECS_IDEcsPrimitiveID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsEnumID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsEnumID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsEnumID_
     * }
     */
    public static OfLong FLECS_IDEcsEnumID_$layout() {
        return FLECS_IDEcsEnumID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsEnumID_
     * }
     */
    public static MemorySegment FLECS_IDEcsEnumID_$segment() {
        return FLECS_IDEcsEnumID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsEnumID_
     * }
     */
    public static long FLECS_IDEcsEnumID_() {
        return FLECS_IDEcsEnumID_$constants.SEGMENT.get(FLECS_IDEcsEnumID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsEnumID_
     * }
     */
    public static void FLECS_IDEcsEnumID_(long varValue) {
        FLECS_IDEcsEnumID_$constants.SEGMENT.set(FLECS_IDEcsEnumID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsBitmaskID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsBitmaskID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsBitmaskID_
     * }
     */
    public static OfLong FLECS_IDEcsBitmaskID_$layout() {
        return FLECS_IDEcsBitmaskID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsBitmaskID_
     * }
     */
    public static MemorySegment FLECS_IDEcsBitmaskID_$segment() {
        return FLECS_IDEcsBitmaskID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsBitmaskID_
     * }
     */
    public static long FLECS_IDEcsBitmaskID_() {
        return FLECS_IDEcsBitmaskID_$constants.SEGMENT.get(FLECS_IDEcsBitmaskID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsBitmaskID_
     * }
     */
    public static void FLECS_IDEcsBitmaskID_(long varValue) {
        FLECS_IDEcsBitmaskID_$constants.SEGMENT.set(FLECS_IDEcsBitmaskID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMemberID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMemberID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberID_
     * }
     */
    public static OfLong FLECS_IDEcsMemberID_$layout() {
        return FLECS_IDEcsMemberID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMemberID_$segment() {
        return FLECS_IDEcsMemberID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberID_
     * }
     */
    public static long FLECS_IDEcsMemberID_() {
        return FLECS_IDEcsMemberID_$constants.SEGMENT.get(FLECS_IDEcsMemberID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberID_
     * }
     */
    public static void FLECS_IDEcsMemberID_(long varValue) {
        FLECS_IDEcsMemberID_$constants.SEGMENT.set(FLECS_IDEcsMemberID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsMemberRangesID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsMemberRangesID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberRangesID_
     * }
     */
    public static OfLong FLECS_IDEcsMemberRangesID_$layout() {
        return FLECS_IDEcsMemberRangesID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberRangesID_
     * }
     */
    public static MemorySegment FLECS_IDEcsMemberRangesID_$segment() {
        return FLECS_IDEcsMemberRangesID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberRangesID_
     * }
     */
    public static long FLECS_IDEcsMemberRangesID_() {
        return FLECS_IDEcsMemberRangesID_$constants.SEGMENT.get(FLECS_IDEcsMemberRangesID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsMemberRangesID_
     * }
     */
    public static void FLECS_IDEcsMemberRangesID_(long varValue) {
        FLECS_IDEcsMemberRangesID_$constants.SEGMENT.set(FLECS_IDEcsMemberRangesID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsStructID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsStructID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsStructID_
     * }
     */
    public static OfLong FLECS_IDEcsStructID_$layout() {
        return FLECS_IDEcsStructID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsStructID_
     * }
     */
    public static MemorySegment FLECS_IDEcsStructID_$segment() {
        return FLECS_IDEcsStructID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsStructID_
     * }
     */
    public static long FLECS_IDEcsStructID_() {
        return FLECS_IDEcsStructID_$constants.SEGMENT.get(FLECS_IDEcsStructID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsStructID_
     * }
     */
    public static void FLECS_IDEcsStructID_(long varValue) {
        FLECS_IDEcsStructID_$constants.SEGMENT.set(FLECS_IDEcsStructID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsArrayID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsArrayID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsArrayID_
     * }
     */
    public static OfLong FLECS_IDEcsArrayID_$layout() {
        return FLECS_IDEcsArrayID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsArrayID_
     * }
     */
    public static MemorySegment FLECS_IDEcsArrayID_$segment() {
        return FLECS_IDEcsArrayID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsArrayID_
     * }
     */
    public static long FLECS_IDEcsArrayID_() {
        return FLECS_IDEcsArrayID_$constants.SEGMENT.get(FLECS_IDEcsArrayID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsArrayID_
     * }
     */
    public static void FLECS_IDEcsArrayID_(long varValue) {
        FLECS_IDEcsArrayID_$constants.SEGMENT.set(FLECS_IDEcsArrayID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsVectorID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsVectorID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsVectorID_
     * }
     */
    public static OfLong FLECS_IDEcsVectorID_$layout() {
        return FLECS_IDEcsVectorID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsVectorID_
     * }
     */
    public static MemorySegment FLECS_IDEcsVectorID_$segment() {
        return FLECS_IDEcsVectorID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsVectorID_
     * }
     */
    public static long FLECS_IDEcsVectorID_() {
        return FLECS_IDEcsVectorID_$constants.SEGMENT.get(FLECS_IDEcsVectorID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsVectorID_
     * }
     */
    public static void FLECS_IDEcsVectorID_(long varValue) {
        FLECS_IDEcsVectorID_$constants.SEGMENT.set(FLECS_IDEcsVectorID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsOpaqueID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsOpaqueID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsOpaqueID_
     * }
     */
    public static OfLong FLECS_IDEcsOpaqueID_$layout() {
        return FLECS_IDEcsOpaqueID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsOpaqueID_
     * }
     */
    public static MemorySegment FLECS_IDEcsOpaqueID_$segment() {
        return FLECS_IDEcsOpaqueID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsOpaqueID_
     * }
     */
    public static long FLECS_IDEcsOpaqueID_() {
        return FLECS_IDEcsOpaqueID_$constants.SEGMENT.get(FLECS_IDEcsOpaqueID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsOpaqueID_
     * }
     */
    public static void FLECS_IDEcsOpaqueID_(long varValue) {
        FLECS_IDEcsOpaqueID_$constants.SEGMENT.set(FLECS_IDEcsOpaqueID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsUnitID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsUnitID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitID_
     * }
     */
    public static OfLong FLECS_IDEcsUnitID_$layout() {
        return FLECS_IDEcsUnitID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitID_
     * }
     */
    public static MemorySegment FLECS_IDEcsUnitID_$segment() {
        return FLECS_IDEcsUnitID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitID_
     * }
     */
    public static long FLECS_IDEcsUnitID_() {
        return FLECS_IDEcsUnitID_$constants.SEGMENT.get(FLECS_IDEcsUnitID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitID_
     * }
     */
    public static void FLECS_IDEcsUnitID_(long varValue) {
        FLECS_IDEcsUnitID_$constants.SEGMENT.set(FLECS_IDEcsUnitID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDEcsUnitPrefixID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDEcsUnitPrefixID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitPrefixID_
     * }
     */
    public static OfLong FLECS_IDEcsUnitPrefixID_$layout() {
        return FLECS_IDEcsUnitPrefixID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitPrefixID_
     * }
     */
    public static MemorySegment FLECS_IDEcsUnitPrefixID_$segment() {
        return FLECS_IDEcsUnitPrefixID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitPrefixID_
     * }
     */
    public static long FLECS_IDEcsUnitPrefixID_() {
        return FLECS_IDEcsUnitPrefixID_$constants.SEGMENT.get(FLECS_IDEcsUnitPrefixID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDEcsUnitPrefixID_
     * }
     */
    public static void FLECS_IDEcsUnitPrefixID_(long varValue) {
        FLECS_IDEcsUnitPrefixID_$constants.SEGMENT.set(FLECS_IDEcsUnitPrefixID_$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsConstant$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsConstant").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static OfLong EcsConstant$layout() {
        return EcsConstant$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static MemorySegment EcsConstant$segment() {
        return EcsConstant$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static long EcsConstant() {
        return EcsConstant$constants.SEGMENT.get(EcsConstant$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsConstant
     * }
     */
    public static void EcsConstant(long varValue) {
        EcsConstant$constants.SEGMENT.set(EcsConstant$constants.LAYOUT, 0L, varValue);
    }

    private static class EcsQuantity$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("EcsQuantity").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuantity
     * }
     */
    public static OfLong EcsQuantity$layout() {
        return EcsQuantity$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuantity
     * }
     */
    public static MemorySegment EcsQuantity$segment() {
        return EcsQuantity$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuantity
     * }
     */
    public static long EcsQuantity() {
        return EcsQuantity$constants.SEGMENT.get(EcsQuantity$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t EcsQuantity
     * }
     */
    public static void EcsQuantity(long varValue) {
        EcsQuantity$constants.SEGMENT.set(EcsQuantity$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_bool_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_bool_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_bool_tID_
     * }
     */
    public static OfLong FLECS_IDecs_bool_tID_$layout() {
        return FLECS_IDecs_bool_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_bool_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_bool_tID_$segment() {
        return FLECS_IDecs_bool_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_bool_tID_
     * }
     */
    public static long FLECS_IDecs_bool_tID_() {
        return FLECS_IDecs_bool_tID_$constants.SEGMENT.get(FLECS_IDecs_bool_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_bool_tID_
     * }
     */
    public static void FLECS_IDecs_bool_tID_(long varValue) {
        FLECS_IDecs_bool_tID_$constants.SEGMENT.set(FLECS_IDecs_bool_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_char_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_char_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_char_tID_
     * }
     */
    public static OfLong FLECS_IDecs_char_tID_$layout() {
        return FLECS_IDecs_char_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_char_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_char_tID_$segment() {
        return FLECS_IDecs_char_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_char_tID_
     * }
     */
    public static long FLECS_IDecs_char_tID_() {
        return FLECS_IDecs_char_tID_$constants.SEGMENT.get(FLECS_IDecs_char_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_char_tID_
     * }
     */
    public static void FLECS_IDecs_char_tID_(long varValue) {
        FLECS_IDecs_char_tID_$constants.SEGMENT.set(FLECS_IDecs_char_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_byte_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_byte_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_byte_tID_
     * }
     */
    public static OfLong FLECS_IDecs_byte_tID_$layout() {
        return FLECS_IDecs_byte_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_byte_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_byte_tID_$segment() {
        return FLECS_IDecs_byte_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_byte_tID_
     * }
     */
    public static long FLECS_IDecs_byte_tID_() {
        return FLECS_IDecs_byte_tID_$constants.SEGMENT.get(FLECS_IDecs_byte_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_byte_tID_
     * }
     */
    public static void FLECS_IDecs_byte_tID_(long varValue) {
        FLECS_IDecs_byte_tID_$constants.SEGMENT.set(FLECS_IDecs_byte_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_u8_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_u8_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u8_tID_
     * }
     */
    public static OfLong FLECS_IDecs_u8_tID_$layout() {
        return FLECS_IDecs_u8_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u8_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_u8_tID_$segment() {
        return FLECS_IDecs_u8_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u8_tID_
     * }
     */
    public static long FLECS_IDecs_u8_tID_() {
        return FLECS_IDecs_u8_tID_$constants.SEGMENT.get(FLECS_IDecs_u8_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u8_tID_
     * }
     */
    public static void FLECS_IDecs_u8_tID_(long varValue) {
        FLECS_IDecs_u8_tID_$constants.SEGMENT.set(FLECS_IDecs_u8_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_u16_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_u16_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u16_tID_
     * }
     */
    public static OfLong FLECS_IDecs_u16_tID_$layout() {
        return FLECS_IDecs_u16_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u16_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_u16_tID_$segment() {
        return FLECS_IDecs_u16_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u16_tID_
     * }
     */
    public static long FLECS_IDecs_u16_tID_() {
        return FLECS_IDecs_u16_tID_$constants.SEGMENT.get(FLECS_IDecs_u16_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u16_tID_
     * }
     */
    public static void FLECS_IDecs_u16_tID_(long varValue) {
        FLECS_IDecs_u16_tID_$constants.SEGMENT.set(FLECS_IDecs_u16_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_u32_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_u32_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u32_tID_
     * }
     */
    public static OfLong FLECS_IDecs_u32_tID_$layout() {
        return FLECS_IDecs_u32_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u32_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_u32_tID_$segment() {
        return FLECS_IDecs_u32_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u32_tID_
     * }
     */
    public static long FLECS_IDecs_u32_tID_() {
        return FLECS_IDecs_u32_tID_$constants.SEGMENT.get(FLECS_IDecs_u32_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u32_tID_
     * }
     */
    public static void FLECS_IDecs_u32_tID_(long varValue) {
        FLECS_IDecs_u32_tID_$constants.SEGMENT.set(FLECS_IDecs_u32_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_u64_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_u64_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u64_tID_
     * }
     */
    public static OfLong FLECS_IDecs_u64_tID_$layout() {
        return FLECS_IDecs_u64_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u64_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_u64_tID_$segment() {
        return FLECS_IDecs_u64_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u64_tID_
     * }
     */
    public static long FLECS_IDecs_u64_tID_() {
        return FLECS_IDecs_u64_tID_$constants.SEGMENT.get(FLECS_IDecs_u64_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_u64_tID_
     * }
     */
    public static void FLECS_IDecs_u64_tID_(long varValue) {
        FLECS_IDecs_u64_tID_$constants.SEGMENT.set(FLECS_IDecs_u64_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_uptr_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_uptr_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_uptr_tID_
     * }
     */
    public static OfLong FLECS_IDecs_uptr_tID_$layout() {
        return FLECS_IDecs_uptr_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_uptr_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_uptr_tID_$segment() {
        return FLECS_IDecs_uptr_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_uptr_tID_
     * }
     */
    public static long FLECS_IDecs_uptr_tID_() {
        return FLECS_IDecs_uptr_tID_$constants.SEGMENT.get(FLECS_IDecs_uptr_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_uptr_tID_
     * }
     */
    public static void FLECS_IDecs_uptr_tID_(long varValue) {
        FLECS_IDecs_uptr_tID_$constants.SEGMENT.set(FLECS_IDecs_uptr_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_i8_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_i8_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i8_tID_
     * }
     */
    public static OfLong FLECS_IDecs_i8_tID_$layout() {
        return FLECS_IDecs_i8_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i8_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_i8_tID_$segment() {
        return FLECS_IDecs_i8_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i8_tID_
     * }
     */
    public static long FLECS_IDecs_i8_tID_() {
        return FLECS_IDecs_i8_tID_$constants.SEGMENT.get(FLECS_IDecs_i8_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i8_tID_
     * }
     */
    public static void FLECS_IDecs_i8_tID_(long varValue) {
        FLECS_IDecs_i8_tID_$constants.SEGMENT.set(FLECS_IDecs_i8_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_i16_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_i16_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i16_tID_
     * }
     */
    public static OfLong FLECS_IDecs_i16_tID_$layout() {
        return FLECS_IDecs_i16_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i16_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_i16_tID_$segment() {
        return FLECS_IDecs_i16_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i16_tID_
     * }
     */
    public static long FLECS_IDecs_i16_tID_() {
        return FLECS_IDecs_i16_tID_$constants.SEGMENT.get(FLECS_IDecs_i16_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i16_tID_
     * }
     */
    public static void FLECS_IDecs_i16_tID_(long varValue) {
        FLECS_IDecs_i16_tID_$constants.SEGMENT.set(FLECS_IDecs_i16_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_i32_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_i32_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i32_tID_
     * }
     */
    public static OfLong FLECS_IDecs_i32_tID_$layout() {
        return FLECS_IDecs_i32_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i32_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_i32_tID_$segment() {
        return FLECS_IDecs_i32_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i32_tID_
     * }
     */
    public static long FLECS_IDecs_i32_tID_() {
        return FLECS_IDecs_i32_tID_$constants.SEGMENT.get(FLECS_IDecs_i32_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i32_tID_
     * }
     */
    public static void FLECS_IDecs_i32_tID_(long varValue) {
        FLECS_IDecs_i32_tID_$constants.SEGMENT.set(FLECS_IDecs_i32_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_i64_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_i64_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i64_tID_
     * }
     */
    public static OfLong FLECS_IDecs_i64_tID_$layout() {
        return FLECS_IDecs_i64_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i64_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_i64_tID_$segment() {
        return FLECS_IDecs_i64_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i64_tID_
     * }
     */
    public static long FLECS_IDecs_i64_tID_() {
        return FLECS_IDecs_i64_tID_$constants.SEGMENT.get(FLECS_IDecs_i64_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_i64_tID_
     * }
     */
    public static void FLECS_IDecs_i64_tID_(long varValue) {
        FLECS_IDecs_i64_tID_$constants.SEGMENT.set(FLECS_IDecs_i64_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_iptr_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_iptr_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_iptr_tID_
     * }
     */
    public static OfLong FLECS_IDecs_iptr_tID_$layout() {
        return FLECS_IDecs_iptr_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_iptr_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_iptr_tID_$segment() {
        return FLECS_IDecs_iptr_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_iptr_tID_
     * }
     */
    public static long FLECS_IDecs_iptr_tID_() {
        return FLECS_IDecs_iptr_tID_$constants.SEGMENT.get(FLECS_IDecs_iptr_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_iptr_tID_
     * }
     */
    public static void FLECS_IDecs_iptr_tID_(long varValue) {
        FLECS_IDecs_iptr_tID_$constants.SEGMENT.set(FLECS_IDecs_iptr_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_f32_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_f32_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f32_tID_
     * }
     */
    public static OfLong FLECS_IDecs_f32_tID_$layout() {
        return FLECS_IDecs_f32_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f32_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_f32_tID_$segment() {
        return FLECS_IDecs_f32_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f32_tID_
     * }
     */
    public static long FLECS_IDecs_f32_tID_() {
        return FLECS_IDecs_f32_tID_$constants.SEGMENT.get(FLECS_IDecs_f32_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f32_tID_
     * }
     */
    public static void FLECS_IDecs_f32_tID_(long varValue) {
        FLECS_IDecs_f32_tID_$constants.SEGMENT.set(FLECS_IDecs_f32_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_f64_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_f64_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f64_tID_
     * }
     */
    public static OfLong FLECS_IDecs_f64_tID_$layout() {
        return FLECS_IDecs_f64_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f64_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_f64_tID_$segment() {
        return FLECS_IDecs_f64_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f64_tID_
     * }
     */
    public static long FLECS_IDecs_f64_tID_() {
        return FLECS_IDecs_f64_tID_$constants.SEGMENT.get(FLECS_IDecs_f64_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_f64_tID_
     * }
     */
    public static void FLECS_IDecs_f64_tID_(long varValue) {
        FLECS_IDecs_f64_tID_$constants.SEGMENT.set(FLECS_IDecs_f64_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_string_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_string_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_string_tID_
     * }
     */
    public static OfLong FLECS_IDecs_string_tID_$layout() {
        return FLECS_IDecs_string_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_string_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_string_tID_$segment() {
        return FLECS_IDecs_string_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_string_tID_
     * }
     */
    public static long FLECS_IDecs_string_tID_() {
        return FLECS_IDecs_string_tID_$constants.SEGMENT.get(FLECS_IDecs_string_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_string_tID_
     * }
     */
    public static void FLECS_IDecs_string_tID_(long varValue) {
        FLECS_IDecs_string_tID_$constants.SEGMENT.set(FLECS_IDecs_string_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_entity_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_entity_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_entity_tID_
     * }
     */
    public static OfLong FLECS_IDecs_entity_tID_$layout() {
        return FLECS_IDecs_entity_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_entity_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_entity_tID_$segment() {
        return FLECS_IDecs_entity_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_entity_tID_
     * }
     */
    public static long FLECS_IDecs_entity_tID_() {
        return FLECS_IDecs_entity_tID_$constants.SEGMENT.get(FLECS_IDecs_entity_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_entity_tID_
     * }
     */
    public static void FLECS_IDecs_entity_tID_(long varValue) {
        FLECS_IDecs_entity_tID_$constants.SEGMENT.set(FLECS_IDecs_entity_tID_$constants.LAYOUT, 0L, varValue);
    }

    private static class FLECS_IDecs_id_tID_$constants {
        public static final OfLong LAYOUT = flecs.C_LONG_LONG;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("FLECS_IDecs_id_tID_").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_id_tID_
     * }
     */
    public static OfLong FLECS_IDecs_id_tID_$layout() {
        return FLECS_IDecs_id_tID_$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_id_tID_
     * }
     */
    public static MemorySegment FLECS_IDecs_id_tID_$segment() {
        return FLECS_IDecs_id_tID_$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_id_tID_
     * }
     */
    public static long FLECS_IDecs_id_tID_() {
        return FLECS_IDecs_id_tID_$constants.SEGMENT.get(FLECS_IDecs_id_tID_$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const ecs_entity_t FLECS_IDecs_id_tID_
     * }
     */
    public static void FLECS_IDecs_id_tID_(long varValue) {
        FLECS_IDecs_id_tID_$constants.SEGMENT.set(FLECS_IDecs_id_tID_$constants.LAYOUT, 0L, varValue);
    }
    private static final int EcsPrimitiveType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsPrimitiveType = 0
     * }
     */
    public static int EcsPrimitiveType() {
        return EcsPrimitiveType;
    }
    private static final int EcsBitmaskType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsBitmaskType = 1
     * }
     */
    public static int EcsBitmaskType() {
        return EcsBitmaskType;
    }
    private static final int EcsEnumType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsEnumType = 2
     * }
     */
    public static int EcsEnumType() {
        return EcsEnumType;
    }
    private static final int EcsStructType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsStructType = 3
     * }
     */
    public static int EcsStructType() {
        return EcsStructType;
    }
    private static final int EcsArrayType = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsArrayType = 4
     * }
     */
    public static int EcsArrayType() {
        return EcsArrayType;
    }
    private static final int EcsVectorType = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsVectorType = 5
     * }
     */
    public static int EcsVectorType() {
        return EcsVectorType;
    }
    private static final int EcsOpaqueType = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsOpaqueType = 6
     * }
     */
    public static int EcsOpaqueType() {
        return EcsOpaqueType;
    }
    private static final int EcsTypeKindLast = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_type_kind_t.EcsTypeKindLast = 6
     * }
     */
    public static int EcsTypeKindLast() {
        return EcsTypeKindLast;
    }
    private static final int EcsBool = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsBool = 1
     * }
     */
    public static int EcsBool() {
        return EcsBool;
    }
    private static final int EcsChar = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsChar = 2
     * }
     */
    public static int EcsChar() {
        return EcsChar;
    }
    private static final int EcsByte = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsByte = 3
     * }
     */
    public static int EcsByte() {
        return EcsByte;
    }
    private static final int EcsU8 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsU8 = 4
     * }
     */
    public static int EcsU8() {
        return EcsU8;
    }
    private static final int EcsU16 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsU16 = 5
     * }
     */
    public static int EcsU16() {
        return EcsU16;
    }
    private static final int EcsU32 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsU32 = 6
     * }
     */
    public static int EcsU32() {
        return EcsU32;
    }
    private static final int EcsU64 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsU64 = 7
     * }
     */
    public static int EcsU64() {
        return EcsU64;
    }
    private static final int EcsI8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsI8 = 8
     * }
     */
    public static int EcsI8() {
        return EcsI8;
    }
    private static final int EcsI16 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsI16 = 9
     * }
     */
    public static int EcsI16() {
        return EcsI16;
    }
    private static final int EcsI32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsI32 = 10
     * }
     */
    public static int EcsI32() {
        return EcsI32;
    }
    private static final int EcsI64 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsI64 = 11
     * }
     */
    public static int EcsI64() {
        return EcsI64;
    }
    private static final int EcsF32 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsF32 = 12
     * }
     */
    public static int EcsF32() {
        return EcsF32;
    }
    private static final int EcsF64 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsF64 = 13
     * }
     */
    public static int EcsF64() {
        return EcsF64;
    }
    private static final int EcsUPtr = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsUPtr = 14
     * }
     */
    public static int EcsUPtr() {
        return EcsUPtr;
    }
    private static final int EcsIPtr = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsIPtr = 15
     * }
     */
    public static int EcsIPtr() {
        return EcsIPtr;
    }
    private static final int EcsString = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsString = 16
     * }
     */
    public static int EcsString() {
        return EcsString;
    }
    private static final int EcsEntity = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsEntity = 17
     * }
     */
    public static int EcsEntity() {
        return EcsEntity;
    }
    private static final int EcsId = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsId = 18
     * }
     */
    public static int EcsId() {
        return EcsId;
    }
    private static final int EcsPrimitiveKindLast = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ecs_primitive_kind_t.EcsPrimitiveKindLast = 18
     * }
     */
    public static int EcsPrimitiveKindLast() {
        return EcsPrimitiveKindLast;
    }
    private static final int EcsOpArray = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpArray = 0
     * }
     */
    public static int EcsOpArray() {
        return EcsOpArray;
    }
    private static final int EcsOpVector = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpVector = 1
     * }
     */
    public static int EcsOpVector() {
        return EcsOpVector;
    }
    private static final int EcsOpOpaque = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpOpaque = 2
     * }
     */
    public static int EcsOpOpaque() {
        return EcsOpOpaque;
    }
    private static final int EcsOpPush = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpPush = 3
     * }
     */
    public static int EcsOpPush() {
        return EcsOpPush;
    }
    private static final int EcsOpPop = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpPop = 4
     * }
     */
    public static int EcsOpPop() {
        return EcsOpPop;
    }
    private static final int EcsOpScope = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpScope = 5
     * }
     */
    public static int EcsOpScope() {
        return EcsOpScope;
    }
    private static final int EcsOpEnum = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpEnum = 6
     * }
     */
    public static int EcsOpEnum() {
        return EcsOpEnum;
    }
    private static final int EcsOpBitmask = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpBitmask = 7
     * }
     */
    public static int EcsOpBitmask() {
        return EcsOpBitmask;
    }
    private static final int EcsOpPrimitive = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpPrimitive = 8
     * }
     */
    public static int EcsOpPrimitive() {
        return EcsOpPrimitive;
    }
    private static final int EcsOpBool = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpBool = 9
     * }
     */
    public static int EcsOpBool() {
        return EcsOpBool;
    }
    private static final int EcsOpChar = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpChar = 10
     * }
     */
    public static int EcsOpChar() {
        return EcsOpChar;
    }
    private static final int EcsOpByte = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpByte = 11
     * }
     */
    public static int EcsOpByte() {
        return EcsOpByte;
    }
    private static final int EcsOpU8 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpU8 = 12
     * }
     */
    public static int EcsOpU8() {
        return EcsOpU8;
    }
    private static final int EcsOpU16 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpU16 = 13
     * }
     */
    public static int EcsOpU16() {
        return EcsOpU16;
    }
    private static final int EcsOpU32 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpU32 = 14
     * }
     */
    public static int EcsOpU32() {
        return EcsOpU32;
    }
    private static final int EcsOpU64 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpU64 = 15
     * }
     */
    public static int EcsOpU64() {
        return EcsOpU64;
    }
    private static final int EcsOpI8 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpI8 = 16
     * }
     */
    public static int EcsOpI8() {
        return EcsOpI8;
    }
    private static final int EcsOpI16 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpI16 = 17
     * }
     */
    public static int EcsOpI16() {
        return EcsOpI16;
    }
    private static final int EcsOpI32 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpI32 = 18
     * }
     */
    public static int EcsOpI32() {
        return EcsOpI32;
    }
    private static final int EcsOpI64 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpI64 = 19
     * }
     */
    public static int EcsOpI64() {
        return EcsOpI64;
    }
    private static final int EcsOpF32 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpF32 = 20
     * }
     */
    public static int EcsOpF32() {
        return EcsOpF32;
    }
    private static final int EcsOpF64 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpF64 = 21
     * }
     */
    public static int EcsOpF64() {
        return EcsOpF64;
    }
    private static final int EcsOpUPtr = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpUPtr = 22
     * }
     */
    public static int EcsOpUPtr() {
        return EcsOpUPtr;
    }
    private static final int EcsOpIPtr = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpIPtr = 23
     * }
     */
    public static int EcsOpIPtr() {
        return EcsOpIPtr;
    }
    private static final int EcsOpString = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpString = 24
     * }
     */
    public static int EcsOpString() {
        return EcsOpString;
    }
    private static final int EcsOpEntity = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpEntity = 25
     * }
     */
    public static int EcsOpEntity() {
        return EcsOpEntity;
    }
    private static final int EcsOpId = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsOpId = 26
     * }
     */
    public static int EcsOpId() {
        return EcsOpId;
    }
    private static final int EcsMetaTypeOpKindLast = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ecs_meta_type_op_kind_t.EcsMetaTypeOpKindLast = 26
     * }
     */
    public static int EcsMetaTypeOpKindLast() {
        return EcsMetaTypeOpKindLast;
    }

    private static class ecs_meta_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ecs_meta_cursor_t.layout(),
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_meta_cursor_t ecs_meta_cursor(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_meta_cursor$descriptor() {
        return ecs_meta_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_meta_cursor_t ecs_meta_cursor(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MethodHandle ecs_meta_cursor$handle() {
        return ecs_meta_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_meta_cursor_t ecs_meta_cursor(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MemorySegment ecs_meta_cursor$address() {
        return ecs_meta_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_meta_cursor_t ecs_meta_cursor(const ecs_world_t *world, ecs_entity_t type, void *ptr)
     * }
     */
    public static MemorySegment ecs_meta_cursor(SegmentAllocator allocator, MemorySegment world, long type, MemorySegment ptr) {
        var mh$ = ecs_meta_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_cursor", allocator, world, type, ptr);
            }
            return (MemorySegment)mh$.invokeExact(allocator, world, type, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ecs_meta_get_ptr(ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_ptr$descriptor() {
        return ecs_meta_get_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ecs_meta_get_ptr(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_ptr$handle() {
        return ecs_meta_get_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ecs_meta_get_ptr(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_ptr$address() {
        return ecs_meta_get_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ecs_meta_get_ptr(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_ptr(MemorySegment cursor) {
        var mh$ = ecs_meta_get_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_ptr", cursor);
            }
            return (MemorySegment)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_next(ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_next$descriptor() {
        return ecs_meta_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_next(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_next$handle() {
        return ecs_meta_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_next(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_next$address() {
        return ecs_meta_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_next(ecs_meta_cursor_t *cursor)
     * }
     */
    public static int ecs_meta_next(MemorySegment cursor) {
        var mh$ = ecs_meta_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_next", cursor);
            }
            return (int)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_elem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_elem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_elem(ecs_meta_cursor_t *cursor, int32_t elem)
     * }
     */
    public static FunctionDescriptor ecs_meta_elem$descriptor() {
        return ecs_meta_elem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_elem(ecs_meta_cursor_t *cursor, int32_t elem)
     * }
     */
    public static MethodHandle ecs_meta_elem$handle() {
        return ecs_meta_elem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_elem(ecs_meta_cursor_t *cursor, int32_t elem)
     * }
     */
    public static MemorySegment ecs_meta_elem$address() {
        return ecs_meta_elem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_elem(ecs_meta_cursor_t *cursor, int32_t elem)
     * }
     */
    public static int ecs_meta_elem(MemorySegment cursor, int elem) {
        var mh$ = ecs_meta_elem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_elem", cursor, elem);
            }
            return (int)mh$.invokeExact(cursor, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_member {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_member");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_member(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_meta_member$descriptor() {
        return ecs_meta_member.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_member(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static MethodHandle ecs_meta_member$handle() {
        return ecs_meta_member.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_member(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static MemorySegment ecs_meta_member$address() {
        return ecs_meta_member.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_member(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static int ecs_meta_member(MemorySegment cursor, MemorySegment name) {
        var mh$ = ecs_meta_member.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_member", cursor, name);
            }
            return (int)mh$.invokeExact(cursor, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_dotmember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_dotmember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_dotmember(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static FunctionDescriptor ecs_meta_dotmember$descriptor() {
        return ecs_meta_dotmember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_dotmember(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static MethodHandle ecs_meta_dotmember$handle() {
        return ecs_meta_dotmember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_dotmember(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static MemorySegment ecs_meta_dotmember$address() {
        return ecs_meta_dotmember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_dotmember(ecs_meta_cursor_t *cursor, const char *name)
     * }
     */
    public static int ecs_meta_dotmember(MemorySegment cursor, MemorySegment name) {
        var mh$ = ecs_meta_dotmember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_dotmember", cursor, name);
            }
            return (int)mh$.invokeExact(cursor, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_push(ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_push$descriptor() {
        return ecs_meta_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_push(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_push$handle() {
        return ecs_meta_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_push(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_push$address() {
        return ecs_meta_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_push(ecs_meta_cursor_t *cursor)
     * }
     */
    public static int ecs_meta_push(MemorySegment cursor) {
        var mh$ = ecs_meta_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_push", cursor);
            }
            return (int)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_pop(ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_pop$descriptor() {
        return ecs_meta_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_pop(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_pop$handle() {
        return ecs_meta_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_pop(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_pop$address() {
        return ecs_meta_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_pop(ecs_meta_cursor_t *cursor)
     * }
     */
    public static int ecs_meta_pop(MemorySegment cursor) {
        var mh$ = ecs_meta_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_pop", cursor);
            }
            return (int)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_is_collection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_is_collection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_meta_is_collection(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_is_collection$descriptor() {
        return ecs_meta_is_collection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_meta_is_collection(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_is_collection$handle() {
        return ecs_meta_is_collection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_meta_is_collection(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_is_collection$address() {
        return ecs_meta_is_collection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_meta_is_collection(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static boolean ecs_meta_is_collection(MemorySegment cursor) {
        var mh$ = ecs_meta_is_collection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_is_collection", cursor);
            }
            return (boolean)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_type(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_type$descriptor() {
        return ecs_meta_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_type(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_type$handle() {
        return ecs_meta_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_type(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_type$address() {
        return ecs_meta_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_type(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_type(MemorySegment cursor) {
        var mh$ = ecs_meta_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_type", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_unit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_unit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_unit(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_unit$descriptor() {
        return ecs_meta_get_unit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_unit(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_unit$handle() {
        return ecs_meta_get_unit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_unit(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_unit$address() {
        return ecs_meta_get_unit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_unit(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_unit(MemorySegment cursor) {
        var mh$ = ecs_meta_get_unit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_unit", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_member {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_member");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_member(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_member$descriptor() {
        return ecs_meta_get_member.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_member(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_member$handle() {
        return ecs_meta_get_member.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_member(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_member$address() {
        return ecs_meta_get_member.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_meta_get_member(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_member(MemorySegment cursor) {
        var mh$ = ecs_meta_get_member.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_member", cursor);
            }
            return (MemorySegment)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_member_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_member_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_member_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_member_id$descriptor() {
        return ecs_meta_get_member_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_member_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_member_id$handle() {
        return ecs_meta_get_member_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_member_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_member_id$address() {
        return ecs_meta_get_member_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_member_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_member_id(MemorySegment cursor) {
        var mh$ = ecs_meta_get_member_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_member_id", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_bool(ecs_meta_cursor_t *cursor, bool value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_bool$descriptor() {
        return ecs_meta_set_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_bool(ecs_meta_cursor_t *cursor, bool value)
     * }
     */
    public static MethodHandle ecs_meta_set_bool$handle() {
        return ecs_meta_set_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_bool(ecs_meta_cursor_t *cursor, bool value)
     * }
     */
    public static MemorySegment ecs_meta_set_bool$address() {
        return ecs_meta_set_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_bool(ecs_meta_cursor_t *cursor, bool value)
     * }
     */
    public static int ecs_meta_set_bool(MemorySegment cursor, boolean value) {
        var mh$ = ecs_meta_set_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_bool", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_CHAR
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_char(ecs_meta_cursor_t *cursor, char value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_char$descriptor() {
        return ecs_meta_set_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_char(ecs_meta_cursor_t *cursor, char value)
     * }
     */
    public static MethodHandle ecs_meta_set_char$handle() {
        return ecs_meta_set_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_char(ecs_meta_cursor_t *cursor, char value)
     * }
     */
    public static MemorySegment ecs_meta_set_char$address() {
        return ecs_meta_set_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_char(ecs_meta_cursor_t *cursor, char value)
     * }
     */
    public static int ecs_meta_set_char(MemorySegment cursor, byte value) {
        var mh$ = ecs_meta_set_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_char", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_int(ecs_meta_cursor_t *cursor, int64_t value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_int$descriptor() {
        return ecs_meta_set_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_int(ecs_meta_cursor_t *cursor, int64_t value)
     * }
     */
    public static MethodHandle ecs_meta_set_int$handle() {
        return ecs_meta_set_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_int(ecs_meta_cursor_t *cursor, int64_t value)
     * }
     */
    public static MemorySegment ecs_meta_set_int$address() {
        return ecs_meta_set_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_int(ecs_meta_cursor_t *cursor, int64_t value)
     * }
     */
    public static int ecs_meta_set_int(MemorySegment cursor, long value) {
        var mh$ = ecs_meta_set_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_int", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_uint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_uint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_uint(ecs_meta_cursor_t *cursor, uint64_t value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_uint$descriptor() {
        return ecs_meta_set_uint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_uint(ecs_meta_cursor_t *cursor, uint64_t value)
     * }
     */
    public static MethodHandle ecs_meta_set_uint$handle() {
        return ecs_meta_set_uint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_uint(ecs_meta_cursor_t *cursor, uint64_t value)
     * }
     */
    public static MemorySegment ecs_meta_set_uint$address() {
        return ecs_meta_set_uint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_uint(ecs_meta_cursor_t *cursor, uint64_t value)
     * }
     */
    public static int ecs_meta_set_uint(MemorySegment cursor, long value) {
        var mh$ = ecs_meta_set_uint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_uint", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_float(ecs_meta_cursor_t *cursor, double value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_float$descriptor() {
        return ecs_meta_set_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_float(ecs_meta_cursor_t *cursor, double value)
     * }
     */
    public static MethodHandle ecs_meta_set_float$handle() {
        return ecs_meta_set_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_float(ecs_meta_cursor_t *cursor, double value)
     * }
     */
    public static MemorySegment ecs_meta_set_float$address() {
        return ecs_meta_set_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_float(ecs_meta_cursor_t *cursor, double value)
     * }
     */
    public static int ecs_meta_set_float(MemorySegment cursor, double value) {
        var mh$ = ecs_meta_set_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_float", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_string(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_string$descriptor() {
        return ecs_meta_set_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_string(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static MethodHandle ecs_meta_set_string$handle() {
        return ecs_meta_set_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_string(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static MemorySegment ecs_meta_set_string$address() {
        return ecs_meta_set_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_string(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static int ecs_meta_set_string(MemorySegment cursor, MemorySegment value) {
        var mh$ = ecs_meta_set_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_string", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_string_literal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_string_literal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_string_literal(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_string_literal$descriptor() {
        return ecs_meta_set_string_literal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_string_literal(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static MethodHandle ecs_meta_set_string_literal$handle() {
        return ecs_meta_set_string_literal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_string_literal(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static MemorySegment ecs_meta_set_string_literal$address() {
        return ecs_meta_set_string_literal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_string_literal(ecs_meta_cursor_t *cursor, const char *value)
     * }
     */
    public static int ecs_meta_set_string_literal(MemorySegment cursor, MemorySegment value) {
        var mh$ = ecs_meta_set_string_literal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_string_literal", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_entity(ecs_meta_cursor_t *cursor, ecs_entity_t value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_entity$descriptor() {
        return ecs_meta_set_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_entity(ecs_meta_cursor_t *cursor, ecs_entity_t value)
     * }
     */
    public static MethodHandle ecs_meta_set_entity$handle() {
        return ecs_meta_set_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_entity(ecs_meta_cursor_t *cursor, ecs_entity_t value)
     * }
     */
    public static MemorySegment ecs_meta_set_entity$address() {
        return ecs_meta_set_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_entity(ecs_meta_cursor_t *cursor, ecs_entity_t value)
     * }
     */
    public static int ecs_meta_set_entity(MemorySegment cursor, long value) {
        var mh$ = ecs_meta_set_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_entity", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_id(ecs_meta_cursor_t *cursor, ecs_id_t value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_id$descriptor() {
        return ecs_meta_set_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_id(ecs_meta_cursor_t *cursor, ecs_id_t value)
     * }
     */
    public static MethodHandle ecs_meta_set_id$handle() {
        return ecs_meta_set_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_id(ecs_meta_cursor_t *cursor, ecs_id_t value)
     * }
     */
    public static MemorySegment ecs_meta_set_id$address() {
        return ecs_meta_set_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_id(ecs_meta_cursor_t *cursor, ecs_id_t value)
     * }
     */
    public static int ecs_meta_set_id(MemorySegment cursor, long value) {
        var mh$ = ecs_meta_set_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_id", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_null {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_null");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_null(ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_null$descriptor() {
        return ecs_meta_set_null.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_null(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_set_null$handle() {
        return ecs_meta_set_null.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_null(ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_set_null$address() {
        return ecs_meta_set_null.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_null(ecs_meta_cursor_t *cursor)
     * }
     */
    public static int ecs_meta_set_null(MemorySegment cursor) {
        var mh$ = ecs_meta_set_null.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_null", cursor);
            }
            return (int)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_set_value(ecs_meta_cursor_t *cursor, const ecs_value_t *value)
     * }
     */
    public static FunctionDescriptor ecs_meta_set_value$descriptor() {
        return ecs_meta_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_set_value(ecs_meta_cursor_t *cursor, const ecs_value_t *value)
     * }
     */
    public static MethodHandle ecs_meta_set_value$handle() {
        return ecs_meta_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_set_value(ecs_meta_cursor_t *cursor, const ecs_value_t *value)
     * }
     */
    public static MemorySegment ecs_meta_set_value$address() {
        return ecs_meta_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_set_value(ecs_meta_cursor_t *cursor, const ecs_value_t *value)
     * }
     */
    public static int ecs_meta_set_value(MemorySegment cursor, MemorySegment value) {
        var mh$ = ecs_meta_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_set_value", cursor, value);
            }
            return (int)mh$.invokeExact(cursor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool ecs_meta_get_bool(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_bool$descriptor() {
        return ecs_meta_get_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool ecs_meta_get_bool(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_bool$handle() {
        return ecs_meta_get_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool ecs_meta_get_bool(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_bool$address() {
        return ecs_meta_get_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool ecs_meta_get_bool(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static boolean ecs_meta_get_bool(MemorySegment cursor) {
        var mh$ = ecs_meta_get_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_bool", cursor);
            }
            return (boolean)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_CHAR,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ecs_meta_get_char(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_char$descriptor() {
        return ecs_meta_get_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ecs_meta_get_char(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_char$handle() {
        return ecs_meta_get_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ecs_meta_get_char(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_char$address() {
        return ecs_meta_get_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ecs_meta_get_char(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static byte ecs_meta_get_char(MemorySegment cursor) {
        var mh$ = ecs_meta_get_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_char", cursor);
            }
            return (byte)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t ecs_meta_get_int(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_int$descriptor() {
        return ecs_meta_get_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t ecs_meta_get_int(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_int$handle() {
        return ecs_meta_get_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t ecs_meta_get_int(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_int$address() {
        return ecs_meta_get_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t ecs_meta_get_int(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_int(MemorySegment cursor) {
        var mh$ = ecs_meta_get_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_int", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_uint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_uint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t ecs_meta_get_uint(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_uint$descriptor() {
        return ecs_meta_get_uint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t ecs_meta_get_uint(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_uint$handle() {
        return ecs_meta_get_uint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t ecs_meta_get_uint(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_uint$address() {
        return ecs_meta_get_uint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t ecs_meta_get_uint(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_uint(MemorySegment cursor) {
        var mh$ = ecs_meta_get_uint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_uint", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_meta_get_float(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_float$descriptor() {
        return ecs_meta_get_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_meta_get_float(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_float$handle() {
        return ecs_meta_get_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_meta_get_float(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_float$address() {
        return ecs_meta_get_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_meta_get_float(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static double ecs_meta_get_float(MemorySegment cursor) {
        var mh$ = ecs_meta_get_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_float", cursor);
            }
            return (double)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_string(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_string$descriptor() {
        return ecs_meta_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_string(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_string$handle() {
        return ecs_meta_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_meta_get_string(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_string$address() {
        return ecs_meta_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_meta_get_string(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_string(MemorySegment cursor) {
        var mh$ = ecs_meta_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_string", cursor);
            }
            return (MemorySegment)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_entity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_entity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_entity(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_entity$descriptor() {
        return ecs_meta_get_entity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_entity(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_entity$handle() {
        return ecs_meta_get_entity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_entity(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_entity$address() {
        return ecs_meta_get_entity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_meta_get_entity(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_entity(MemorySegment cursor) {
        var mh$ = ecs_meta_get_entity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_entity", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_id_t ecs_meta_get_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static FunctionDescriptor ecs_meta_get_id$descriptor() {
        return ecs_meta_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_id_t ecs_meta_get_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MethodHandle ecs_meta_get_id$handle() {
        return ecs_meta_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_id_t ecs_meta_get_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static MemorySegment ecs_meta_get_id$address() {
        return ecs_meta_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_id_t ecs_meta_get_id(const ecs_meta_cursor_t *cursor)
     * }
     */
    public static long ecs_meta_get_id(MemorySegment cursor) {
        var mh$ = ecs_meta_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_get_id", cursor);
            }
            return (long)mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_ptr_to_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_ptr_to_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ecs_meta_ptr_to_float(ecs_primitive_kind_t type_kind, const void *ptr)
     * }
     */
    public static FunctionDescriptor ecs_meta_ptr_to_float$descriptor() {
        return ecs_meta_ptr_to_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ecs_meta_ptr_to_float(ecs_primitive_kind_t type_kind, const void *ptr)
     * }
     */
    public static MethodHandle ecs_meta_ptr_to_float$handle() {
        return ecs_meta_ptr_to_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ecs_meta_ptr_to_float(ecs_primitive_kind_t type_kind, const void *ptr)
     * }
     */
    public static MemorySegment ecs_meta_ptr_to_float$address() {
        return ecs_meta_ptr_to_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ecs_meta_ptr_to_float(ecs_primitive_kind_t type_kind, const void *ptr)
     * }
     */
    public static double ecs_meta_ptr_to_float(int type_kind, MemorySegment ptr) {
        var mh$ = ecs_meta_ptr_to_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_ptr_to_float", type_kind, ptr);
            }
            return (double)mh$.invokeExact(type_kind, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_primitive_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_primitive_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_primitive_init(ecs_world_t *world, const ecs_primitive_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_primitive_init$descriptor() {
        return ecs_primitive_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_primitive_init(ecs_world_t *world, const ecs_primitive_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_primitive_init$handle() {
        return ecs_primitive_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_primitive_init(ecs_world_t *world, const ecs_primitive_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_primitive_init$address() {
        return ecs_primitive_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_primitive_init(ecs_world_t *world, const ecs_primitive_desc_t *desc)
     * }
     */
    public static long ecs_primitive_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_primitive_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_primitive_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_enum_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_enum_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_enum_init(ecs_world_t *world, const ecs_enum_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_enum_init$descriptor() {
        return ecs_enum_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_enum_init(ecs_world_t *world, const ecs_enum_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_enum_init$handle() {
        return ecs_enum_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_enum_init(ecs_world_t *world, const ecs_enum_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_enum_init$address() {
        return ecs_enum_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_enum_init(ecs_world_t *world, const ecs_enum_desc_t *desc)
     * }
     */
    public static long ecs_enum_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_enum_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_enum_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_bitmask_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_bitmask_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_bitmask_init(ecs_world_t *world, const ecs_bitmask_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_bitmask_init$descriptor() {
        return ecs_bitmask_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_bitmask_init(ecs_world_t *world, const ecs_bitmask_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_bitmask_init$handle() {
        return ecs_bitmask_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_bitmask_init(ecs_world_t *world, const ecs_bitmask_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_bitmask_init$address() {
        return ecs_bitmask_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_bitmask_init(ecs_world_t *world, const ecs_bitmask_desc_t *desc)
     * }
     */
    public static long ecs_bitmask_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_bitmask_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_bitmask_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_array_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_array_init(ecs_world_t *world, const ecs_array_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_array_init$descriptor() {
        return ecs_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_array_init(ecs_world_t *world, const ecs_array_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_array_init$handle() {
        return ecs_array_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_array_init(ecs_world_t *world, const ecs_array_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_array_init$address() {
        return ecs_array_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_array_init(ecs_world_t *world, const ecs_array_desc_t *desc)
     * }
     */
    public static long ecs_array_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_array_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_vector_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_vector_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_vector_init(ecs_world_t *world, const ecs_vector_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_vector_init$descriptor() {
        return ecs_vector_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_vector_init(ecs_world_t *world, const ecs_vector_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_vector_init$handle() {
        return ecs_vector_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_vector_init(ecs_world_t *world, const ecs_vector_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_vector_init$address() {
        return ecs_vector_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_vector_init(ecs_world_t *world, const ecs_vector_desc_t *desc)
     * }
     */
    public static long ecs_vector_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_vector_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_vector_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_struct_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_struct_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_struct_init(ecs_world_t *world, const ecs_struct_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_struct_init$descriptor() {
        return ecs_struct_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_struct_init(ecs_world_t *world, const ecs_struct_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_struct_init$handle() {
        return ecs_struct_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_struct_init(ecs_world_t *world, const ecs_struct_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_struct_init$address() {
        return ecs_struct_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_struct_init(ecs_world_t *world, const ecs_struct_desc_t *desc)
     * }
     */
    public static long ecs_struct_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_struct_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_struct_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_opaque_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_opaque_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_opaque_init(ecs_world_t *world, const ecs_opaque_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_opaque_init$descriptor() {
        return ecs_opaque_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_opaque_init(ecs_world_t *world, const ecs_opaque_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_opaque_init$handle() {
        return ecs_opaque_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_opaque_init(ecs_world_t *world, const ecs_opaque_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_opaque_init$address() {
        return ecs_opaque_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_opaque_init(ecs_world_t *world, const ecs_opaque_desc_t *desc)
     * }
     */
    public static long ecs_opaque_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_opaque_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_opaque_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_unit_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_unit_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_init(ecs_world_t *world, const ecs_unit_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_unit_init$descriptor() {
        return ecs_unit_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_init(ecs_world_t *world, const ecs_unit_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_unit_init$handle() {
        return ecs_unit_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_init(ecs_world_t *world, const ecs_unit_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_unit_init$address() {
        return ecs_unit_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_init(ecs_world_t *world, const ecs_unit_desc_t *desc)
     * }
     */
    public static long ecs_unit_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_unit_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_unit_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_unit_prefix_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_unit_prefix_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_prefix_init(ecs_world_t *world, const ecs_unit_prefix_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_unit_prefix_init$descriptor() {
        return ecs_unit_prefix_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_prefix_init(ecs_world_t *world, const ecs_unit_prefix_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_unit_prefix_init$handle() {
        return ecs_unit_prefix_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_prefix_init(ecs_world_t *world, const ecs_unit_prefix_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_unit_prefix_init$address() {
        return ecs_unit_prefix_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_unit_prefix_init(ecs_world_t *world, const ecs_unit_prefix_desc_t *desc)
     * }
     */
    public static long ecs_unit_prefix_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_unit_prefix_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_unit_prefix_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_quantity_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_quantity_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_quantity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_quantity_init$descriptor() {
        return ecs_quantity_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_quantity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_quantity_init$handle() {
        return ecs_quantity_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_quantity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_quantity_init$address() {
        return ecs_quantity_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_quantity_init(ecs_world_t *world, const ecs_entity_desc_t *desc)
     * }
     */
    public static long ecs_quantity_init(MemorySegment world, MemorySegment desc) {
        var mh$ = ecs_quantity_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_quantity_init", world, desc);
            }
            return (long)mh$.invokeExact(world, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlecsMetaImport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("FlecsMetaImport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlecsMetaImport(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor FlecsMetaImport$descriptor() {
        return FlecsMetaImport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlecsMetaImport(ecs_world_t *world)
     * }
     */
    public static MethodHandle FlecsMetaImport$handle() {
        return FlecsMetaImport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlecsMetaImport(ecs_world_t *world)
     * }
     */
    public static MemorySegment FlecsMetaImport$address() {
        return FlecsMetaImport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlecsMetaImport(ecs_world_t *world)
     * }
     */
    public static void FlecsMetaImport(MemorySegment world) {
        var mh$ = FlecsMetaImport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlecsMetaImport", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_meta_from_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_INT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_meta_from_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ecs_meta_from_desc(ecs_world_t *world, ecs_entity_t component, ecs_type_kind_t kind, const char *desc)
     * }
     */
    public static FunctionDescriptor ecs_meta_from_desc$descriptor() {
        return ecs_meta_from_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ecs_meta_from_desc(ecs_world_t *world, ecs_entity_t component, ecs_type_kind_t kind, const char *desc)
     * }
     */
    public static MethodHandle ecs_meta_from_desc$handle() {
        return ecs_meta_from_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ecs_meta_from_desc(ecs_world_t *world, ecs_entity_t component, ecs_type_kind_t kind, const char *desc)
     * }
     */
    public static MemorySegment ecs_meta_from_desc$address() {
        return ecs_meta_from_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ecs_meta_from_desc(ecs_world_t *world, ecs_entity_t component, ecs_type_kind_t kind, const char *desc)
     * }
     */
    public static int ecs_meta_from_desc(MemorySegment world, long component, int kind, MemorySegment desc) {
        var mh$ = ecs_meta_from_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_meta_from_desc", world, component, kind, desc);
            }
            return (int)mh$.invokeExact(world, component, kind, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_set_os_api_impl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_set_os_api_impl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_set_os_api_impl()
     * }
     */
    public static FunctionDescriptor ecs_set_os_api_impl$descriptor() {
        return ecs_set_os_api_impl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_set_os_api_impl()
     * }
     */
    public static MethodHandle ecs_set_os_api_impl$handle() {
        return ecs_set_os_api_impl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_set_os_api_impl()
     * }
     */
    public static MemorySegment ecs_set_os_api_impl$address() {
        return ecs_set_os_api_impl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_set_os_api_impl()
     * }
     */
    public static void ecs_set_os_api_impl() {
        var mh$ = ecs_set_os_api_impl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_set_os_api_impl");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import(ecs_world_t *world, ecs_module_action_t module, const char *module_name)
     * }
     */
    public static FunctionDescriptor ecs_import$descriptor() {
        return ecs_import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import(ecs_world_t *world, ecs_module_action_t module, const char *module_name)
     * }
     */
    public static MethodHandle ecs_import$handle() {
        return ecs_import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import(ecs_world_t *world, ecs_module_action_t module, const char *module_name)
     * }
     */
    public static MemorySegment ecs_import$address() {
        return ecs_import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_import(ecs_world_t *world, ecs_module_action_t module, const char *module_name)
     * }
     */
    public static long ecs_import(MemorySegment world, MemorySegment module, MemorySegment module_name) {
        var mh$ = ecs_import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_import", world, module, module_name);
            }
            return (long)mh$.invokeExact(world, module, module_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_import_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_import_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_c(ecs_world_t *world, ecs_module_action_t module, const char *module_name_c)
     * }
     */
    public static FunctionDescriptor ecs_import_c$descriptor() {
        return ecs_import_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_c(ecs_world_t *world, ecs_module_action_t module, const char *module_name_c)
     * }
     */
    public static MethodHandle ecs_import_c$handle() {
        return ecs_import_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_c(ecs_world_t *world, ecs_module_action_t module, const char *module_name_c)
     * }
     */
    public static MemorySegment ecs_import_c$address() {
        return ecs_import_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_c(ecs_world_t *world, ecs_module_action_t module, const char *module_name_c)
     * }
     */
    public static long ecs_import_c(MemorySegment world, MemorySegment module, MemorySegment module_name_c) {
        var mh$ = ecs_import_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_import_c", world, module, module_name_c);
            }
            return (long)mh$.invokeExact(world, module, module_name_c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_import_from_library {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_import_from_library");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_from_library(ecs_world_t *world, const char *library_name, const char *module_name)
     * }
     */
    public static FunctionDescriptor ecs_import_from_library$descriptor() {
        return ecs_import_from_library.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_from_library(ecs_world_t *world, const char *library_name, const char *module_name)
     * }
     */
    public static MethodHandle ecs_import_from_library$handle() {
        return ecs_import_from_library.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_from_library(ecs_world_t *world, const char *library_name, const char *module_name)
     * }
     */
    public static MemorySegment ecs_import_from_library$address() {
        return ecs_import_from_library.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_import_from_library(ecs_world_t *world, const char *library_name, const char *module_name)
     * }
     */
    public static long ecs_import_from_library(MemorySegment world, MemorySegment library_name, MemorySegment module_name) {
        var mh$ = ecs_import_from_library.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_import_from_library", world, library_name, module_name);
            }
            return (long)mh$.invokeExact(world, library_name, module_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_module_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_module_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_module_init(ecs_world_t *world, const char *c_name, const ecs_component_desc_t *desc)
     * }
     */
    public static FunctionDescriptor ecs_module_init$descriptor() {
        return ecs_module_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_module_init(ecs_world_t *world, const char *c_name, const ecs_component_desc_t *desc)
     * }
     */
    public static MethodHandle ecs_module_init$handle() {
        return ecs_module_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_module_init(ecs_world_t *world, const char *c_name, const ecs_component_desc_t *desc)
     * }
     */
    public static MemorySegment ecs_module_init$address() {
        return ecs_module_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_module_init(ecs_world_t *world, const char *c_name, const ecs_component_desc_t *desc)
     * }
     */
    public static long ecs_module_init(MemorySegment world, MemorySegment c_name, MemorySegment desc) {
        var mh$ = ecs_module_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_module_init", world, c_name, desc);
            }
            return (long)mh$.invokeExact(world, c_name, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_get_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_get_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_type_name(char *type_name, const char *func_name, size_t len, size_t front_len)
     * }
     */
    public static FunctionDescriptor ecs_cpp_get_type_name$descriptor() {
        return ecs_cpp_get_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_type_name(char *type_name, const char *func_name, size_t len, size_t front_len)
     * }
     */
    public static MethodHandle ecs_cpp_get_type_name$handle() {
        return ecs_cpp_get_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_type_name(char *type_name, const char *func_name, size_t len, size_t front_len)
     * }
     */
    public static MemorySegment ecs_cpp_get_type_name$address() {
        return ecs_cpp_get_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_cpp_get_type_name(char *type_name, const char *func_name, size_t len, size_t front_len)
     * }
     */
    public static MemorySegment ecs_cpp_get_type_name(MemorySegment type_name, MemorySegment func_name, long len, long front_len) {
        var mh$ = ecs_cpp_get_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_get_type_name", type_name, func_name, len, front_len);
            }
            return (MemorySegment)mh$.invokeExact(type_name, func_name, len, front_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_get_symbol_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_get_symbol_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_symbol_name(char *symbol_name, const char *type_name, size_t len)
     * }
     */
    public static FunctionDescriptor ecs_cpp_get_symbol_name$descriptor() {
        return ecs_cpp_get_symbol_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_symbol_name(char *symbol_name, const char *type_name, size_t len)
     * }
     */
    public static MethodHandle ecs_cpp_get_symbol_name$handle() {
        return ecs_cpp_get_symbol_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_symbol_name(char *symbol_name, const char *type_name, size_t len)
     * }
     */
    public static MemorySegment ecs_cpp_get_symbol_name$address() {
        return ecs_cpp_get_symbol_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_cpp_get_symbol_name(char *symbol_name, const char *type_name, size_t len)
     * }
     */
    public static MemorySegment ecs_cpp_get_symbol_name(MemorySegment symbol_name, MemorySegment type_name, long len) {
        var mh$ = ecs_cpp_get_symbol_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_get_symbol_name", symbol_name, type_name, len);
            }
            return (MemorySegment)mh$.invokeExact(symbol_name, type_name, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_get_constant_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_get_constant_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_constant_name(char *constant_name, const char *func_name, size_t len, size_t back_len)
     * }
     */
    public static FunctionDescriptor ecs_cpp_get_constant_name$descriptor() {
        return ecs_cpp_get_constant_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_constant_name(char *constant_name, const char *func_name, size_t len, size_t back_len)
     * }
     */
    public static MethodHandle ecs_cpp_get_constant_name$handle() {
        return ecs_cpp_get_constant_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecs_cpp_get_constant_name(char *constant_name, const char *func_name, size_t len, size_t back_len)
     * }
     */
    public static MemorySegment ecs_cpp_get_constant_name$address() {
        return ecs_cpp_get_constant_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecs_cpp_get_constant_name(char *constant_name, const char *func_name, size_t len, size_t back_len)
     * }
     */
    public static MemorySegment ecs_cpp_get_constant_name(MemorySegment constant_name, MemorySegment func_name, long len, long back_len) {
        var mh$ = ecs_cpp_get_constant_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_get_constant_name", constant_name, func_name, len, back_len);
            }
            return (MemorySegment)mh$.invokeExact(constant_name, func_name, len, back_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_trim_module {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_trim_module");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ecs_cpp_trim_module(ecs_world_t *world, const char *type_name)
     * }
     */
    public static FunctionDescriptor ecs_cpp_trim_module$descriptor() {
        return ecs_cpp_trim_module.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ecs_cpp_trim_module(ecs_world_t *world, const char *type_name)
     * }
     */
    public static MethodHandle ecs_cpp_trim_module$handle() {
        return ecs_cpp_trim_module.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ecs_cpp_trim_module(ecs_world_t *world, const char *type_name)
     * }
     */
    public static MemorySegment ecs_cpp_trim_module$address() {
        return ecs_cpp_trim_module.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ecs_cpp_trim_module(ecs_world_t *world, const char *type_name)
     * }
     */
    public static MemorySegment ecs_cpp_trim_module(MemorySegment world, MemorySegment type_name) {
        var mh$ = ecs_cpp_trim_module.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_trim_module", world, type_name);
            }
            return (MemorySegment)mh$.invokeExact(world, type_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_component_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_component_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_cpp_component_validate(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, size_t size, size_t alignment, bool implicit_name)
     * }
     */
    public static FunctionDescriptor ecs_cpp_component_validate$descriptor() {
        return ecs_cpp_component_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_cpp_component_validate(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, size_t size, size_t alignment, bool implicit_name)
     * }
     */
    public static MethodHandle ecs_cpp_component_validate$handle() {
        return ecs_cpp_component_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_cpp_component_validate(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, size_t size, size_t alignment, bool implicit_name)
     * }
     */
    public static MemorySegment ecs_cpp_component_validate$address() {
        return ecs_cpp_component_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_cpp_component_validate(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, size_t size, size_t alignment, bool implicit_name)
     * }
     */
    public static void ecs_cpp_component_validate(MemorySegment world, long id, MemorySegment name, MemorySegment symbol, long size, long alignment, boolean implicit_name) {
        var mh$ = ecs_cpp_component_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_component_validate", world, id, name, symbol, size, alignment, implicit_name);
            }
            mh$.invokeExact(world, id, name, symbol, size, alignment, implicit_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_component_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_INT,
            flecs.C_INT,
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_component_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, ecs_size_t size, ecs_size_t alignment, bool implicit_name, bool *existing_out)
     * }
     */
    public static FunctionDescriptor ecs_cpp_component_register$descriptor() {
        return ecs_cpp_component_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, ecs_size_t size, ecs_size_t alignment, bool implicit_name, bool *existing_out)
     * }
     */
    public static MethodHandle ecs_cpp_component_register$handle() {
        return ecs_cpp_component_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, ecs_size_t size, ecs_size_t alignment, bool implicit_name, bool *existing_out)
     * }
     */
    public static MemorySegment ecs_cpp_component_register$address() {
        return ecs_cpp_component_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register(ecs_world_t *world, ecs_entity_t id, const char *name, const char *symbol, ecs_size_t size, ecs_size_t alignment, bool implicit_name, bool *existing_out)
     * }
     */
    public static long ecs_cpp_component_register(MemorySegment world, long id, MemorySegment name, MemorySegment symbol, int size, int alignment, boolean implicit_name, MemorySegment existing_out) {
        var mh$ = ecs_cpp_component_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_component_register", world, id, name, symbol, size, alignment, implicit_name, existing_out);
            }
            return (long)mh$.invokeExact(world, id, name, symbol, size, alignment, implicit_name, existing_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_component_register_explicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG,
            flecs.C_LONG,
            flecs.C_BOOL,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_component_register_explicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register_explicit(ecs_world_t *world, ecs_entity_t s_id, ecs_entity_t id, const char *name, const char *type_name, const char *symbol, size_t size, size_t alignment, bool is_component, bool *existing_out)
     * }
     */
    public static FunctionDescriptor ecs_cpp_component_register_explicit$descriptor() {
        return ecs_cpp_component_register_explicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register_explicit(ecs_world_t *world, ecs_entity_t s_id, ecs_entity_t id, const char *name, const char *type_name, const char *symbol, size_t size, size_t alignment, bool is_component, bool *existing_out)
     * }
     */
    public static MethodHandle ecs_cpp_component_register_explicit$handle() {
        return ecs_cpp_component_register_explicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register_explicit(ecs_world_t *world, ecs_entity_t s_id, ecs_entity_t id, const char *name, const char *type_name, const char *symbol, size_t size, size_t alignment, bool is_component, bool *existing_out)
     * }
     */
    public static MemorySegment ecs_cpp_component_register_explicit$address() {
        return ecs_cpp_component_register_explicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_component_register_explicit(ecs_world_t *world, ecs_entity_t s_id, ecs_entity_t id, const char *name, const char *type_name, const char *symbol, size_t size, size_t alignment, bool is_component, bool *existing_out)
     * }
     */
    public static long ecs_cpp_component_register_explicit(MemorySegment world, long s_id, long id, MemorySegment name, MemorySegment type_name, MemorySegment symbol, long size, long alignment, boolean is_component, MemorySegment existing_out) {
        var mh$ = ecs_cpp_component_register_explicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_component_register_explicit", world, s_id, id, name, type_name, symbol, size, alignment, is_component, existing_out);
            }
            return (long)mh$.invokeExact(world, s_id, id, name, type_name, symbol, size, alignment, is_component, existing_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_enum_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_enum_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ecs_cpp_enum_init(ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static FunctionDescriptor ecs_cpp_enum_init$descriptor() {
        return ecs_cpp_enum_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ecs_cpp_enum_init(ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static MethodHandle ecs_cpp_enum_init$handle() {
        return ecs_cpp_enum_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ecs_cpp_enum_init(ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static MemorySegment ecs_cpp_enum_init$address() {
        return ecs_cpp_enum_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ecs_cpp_enum_init(ecs_world_t *world, ecs_entity_t id)
     * }
     */
    public static void ecs_cpp_enum_init(MemorySegment world, long id) {
        var mh$ = ecs_cpp_enum_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_enum_init", world, id);
            }
            mh$.invokeExact(world, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_enum_constant_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_enum_constant_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_enum_constant_register(ecs_world_t *world, ecs_entity_t parent, ecs_entity_t id, const char *name, int value)
     * }
     */
    public static FunctionDescriptor ecs_cpp_enum_constant_register$descriptor() {
        return ecs_cpp_enum_constant_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_enum_constant_register(ecs_world_t *world, ecs_entity_t parent, ecs_entity_t id, const char *name, int value)
     * }
     */
    public static MethodHandle ecs_cpp_enum_constant_register$handle() {
        return ecs_cpp_enum_constant_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_enum_constant_register(ecs_world_t *world, ecs_entity_t parent, ecs_entity_t id, const char *name, int value)
     * }
     */
    public static MemorySegment ecs_cpp_enum_constant_register$address() {
        return ecs_cpp_enum_constant_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t ecs_cpp_enum_constant_register(ecs_world_t *world, ecs_entity_t parent, ecs_entity_t id, const char *name, int value)
     * }
     */
    public static long ecs_cpp_enum_constant_register(MemorySegment world, long parent, long id, MemorySegment name, int value) {
        var mh$ = ecs_cpp_enum_constant_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_enum_constant_register", world, parent, id, name, value);
            }
            return (long)mh$.invokeExact(world, parent, id, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_reset_count_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_reset_count_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_get()
     * }
     */
    public static FunctionDescriptor ecs_cpp_reset_count_get$descriptor() {
        return ecs_cpp_reset_count_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_get()
     * }
     */
    public static MethodHandle ecs_cpp_reset_count_get$handle() {
        return ecs_cpp_reset_count_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_get()
     * }
     */
    public static MemorySegment ecs_cpp_reset_count_get$address() {
        return ecs_cpp_reset_count_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_get()
     * }
     */
    public static int ecs_cpp_reset_count_get() {
        var mh$ = ecs_cpp_reset_count_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_reset_count_get");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_reset_count_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_reset_count_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_inc()
     * }
     */
    public static FunctionDescriptor ecs_cpp_reset_count_inc$descriptor() {
        return ecs_cpp_reset_count_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_inc()
     * }
     */
    public static MethodHandle ecs_cpp_reset_count_inc$handle() {
        return ecs_cpp_reset_count_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_inc()
     * }
     */
    public static MemorySegment ecs_cpp_reset_count_inc$address() {
        return ecs_cpp_reset_count_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t ecs_cpp_reset_count_inc()
     * }
     */
    public static int ecs_cpp_reset_count_inc() {
        var mh$ = ecs_cpp_reset_count_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_reset_count_inc");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecs_cpp_last_member {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_POINTER,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ecs_cpp_last_member");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const ecs_member_t *ecs_cpp_last_member(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static FunctionDescriptor ecs_cpp_last_member$descriptor() {
        return ecs_cpp_last_member.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const ecs_member_t *ecs_cpp_last_member(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MethodHandle ecs_cpp_last_member$handle() {
        return ecs_cpp_last_member.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const ecs_member_t *ecs_cpp_last_member(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_cpp_last_member$address() {
        return ecs_cpp_last_member.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const ecs_member_t *ecs_cpp_last_member(const ecs_world_t *world, ecs_entity_t type)
     * }
     */
    public static MemorySegment ecs_cpp_last_member(MemorySegment world, long type) {
        var mh$ = ecs_cpp_last_member.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecs_cpp_last_member", world, type);
            }
            return (MemorySegment)mh$.invokeExact(world, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = flecs.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = flecs.C_DOUBLE;

    private static class __math_errhandling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT    );

        public static final MemorySegment ADDR = flecs.findOrThrow("__math_errhandling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static FunctionDescriptor __math_errhandling$descriptor() {
        return __math_errhandling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MethodHandle __math_errhandling$handle() {
        return __math_errhandling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MemorySegment __math_errhandling$address() {
        return __math_errhandling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static int __math_errhandling() {
        var mh$ = __math_errhandling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__math_errhandling");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static int __fpclassifyf(float x0) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__fpclassifyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static FunctionDescriptor __fpclassifyd$descriptor() {
        return __fpclassifyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MethodHandle __fpclassifyd$handle() {
        return __fpclassifyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MemorySegment __fpclassifyd$address() {
        return __fpclassifyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static int __fpclassifyd(double x0) {
        var mh$ = __fpclassifyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static float acosf(float x0) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static double acos(double x0) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static float asinf(float x0) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static double asin(double x0) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static float atanf(float x0) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static double atan(double x0) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static float atan2f(float x0, float x1) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static double atan2(double x0, double x1) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static float cosf(float x0) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static double cos(double x0) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static float sinf(float x0) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static double sin(double x0) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static float tanf(float x0) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static double tan(double x0) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static float acoshf(float x0) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static double acosh(double x0) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static float asinhf(float x0) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static double asinh(double x0) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static float atanhf(float x0) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static double atanh(double x0) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static float coshf(float x0) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static double cosh(double x0) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static float sinhf(float x0) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static double sinh(double x0) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static float tanhf(float x0) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static double tanh(double x0) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static float expf(float x0) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static double exp(double x0) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static float exp2f(float x0) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static double exp2(double x0) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static float expm1f(float x0) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static double expm1(double x0) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static float logf(float x0) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static double log(double x0) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static float log10f(float x0) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static double log10(double x0) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static float log2f(float x0) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static double log2(double x0) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static float log1pf(float x0) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static double log1p(double x0) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static float logbf(float x0) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static double logb(double x0) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static float modff(float x0, MemorySegment x1) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static double modf(double x0, MemorySegment x1) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static float ldexpf(float x0, int x1) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static double ldexp(double x0, int x1) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static float frexpf(float x0, MemorySegment x1) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static double frexp(double x0, MemorySegment x1) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static int ilogbf(float x0) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static int ilogb(double x0) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static float scalbnf(float x0, int x1) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_INT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static double scalbn(double x0, int x1) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static float scalblnf(float x0, long x1) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static double scalbln(double x0, long x1) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static float fabsf(float x0) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static double fabs(double x0) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static float cbrtf(float x0) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static double cbrt(double x0) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static float hypotf(float x0, float x1) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static double hypot(double x0, double x1) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static float powf(float x0, float x1) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static double pow(double x0, double x1) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static float sqrtf(float x0) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static double sqrt(double x0) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static float ceilf(float x0) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static double ceil(double x0) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static float floorf(float x0) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static double floor(double x0) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static float nearbyintf(float x0) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static double nearbyint(double x0) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static float rintf(float x0) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static double rint(double x0) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static long lrintf(float x0) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static long lrint(double x0) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static float roundf(float x0) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static double round(double x0) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static long lroundf(float x0) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static long lround(double x0) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static long llrintf(float x0) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static long llrint(double x0) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static long llroundf(float x0) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static long llround(double x0) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static float truncf(float x0) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static double trunc(double x0) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static float fmodf(float x0, float x1) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static double fmod(double x0, double x1) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static float remainderf(float x0, float x1) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static double remainder(double x0, double x1) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static float remquof(float x0, float x1, MemorySegment x2) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static double remquo(double x0, double x1, MemorySegment x2) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static float copysignf(float x0, float x1) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static double copysign(double x0, double x1) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static float nanf(MemorySegment x0) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static double nan(MemorySegment x0) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static float nextafterf(float x0, float x1) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static double nextafter(double x0, double x1) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static float fdimf(float x0, float x1) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static double fdim(double x0, double x1) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static float fmaxf(float x0, float x1) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static double fmax(double x0, double x1) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static float fminf(float x0, float x1) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static double fmin(double x0, double x1) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static float fmaf(float x0, float x1, float x2) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static double fma(double x0, double x1, double x2) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__exp10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static FunctionDescriptor __exp10f$descriptor() {
        return __exp10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MethodHandle __exp10f$handle() {
        return __exp10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MemorySegment __exp10f$address() {
        return __exp10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static float __exp10f(float x0) {
        var mh$ = __exp10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__exp10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static FunctionDescriptor __exp10$descriptor() {
        return __exp10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MethodHandle __exp10$handle() {
        return __exp10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MemorySegment __exp10$address() {
        return __exp10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static double __exp10(double x0) {
        var mh$ = __exp10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__cospif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static FunctionDescriptor __cospif$descriptor() {
        return __cospif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MethodHandle __cospif$handle() {
        return __cospif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MemorySegment __cospif$address() {
        return __cospif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static float __cospif(float x0) {
        var mh$ = __cospif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__cospi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static FunctionDescriptor __cospi$descriptor() {
        return __cospi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MethodHandle __cospi$handle() {
        return __cospi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MemorySegment __cospi$address() {
        return __cospi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static double __cospi(double x0) {
        var mh$ = __cospi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__sinpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static FunctionDescriptor __sinpif$descriptor() {
        return __sinpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MethodHandle __sinpif$handle() {
        return __sinpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MemorySegment __sinpif$address() {
        return __sinpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static float __sinpif(float x0) {
        var mh$ = __sinpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__sinpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static FunctionDescriptor __sinpi$descriptor() {
        return __sinpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MethodHandle __sinpi$handle() {
        return __sinpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MemorySegment __sinpi$address() {
        return __sinpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static double __sinpi(double x0) {
        var mh$ = __sinpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_FLOAT,
            flecs.C_FLOAT
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__tanpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static FunctionDescriptor __tanpif$descriptor() {
        return __tanpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MethodHandle __tanpif$handle() {
        return __tanpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MemorySegment __tanpif$address() {
        return __tanpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static float __tanpif(float x0) {
        var mh$ = __tanpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__tanpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static FunctionDescriptor __tanpi$descriptor() {
        return __tanpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MethodHandle __tanpi$handle() {
        return __tanpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MemorySegment __tanpi$address() {
        return __tanpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static double __tanpi(double x0) {
        var mh$ = __tanpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_INT,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_INT,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_DOUBLE,
            flecs.C_DOUBLE,
            flecs.C_DOUBLE
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static double scalb(double x0, double x1) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = flecs.C_INT;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }

    private static class vybe_pair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_pair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair(ecs_entity_t e1, ecs_entity_t e2)
     * }
     */
    public static FunctionDescriptor vybe_pair$descriptor() {
        return vybe_pair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair(ecs_entity_t e1, ecs_entity_t e2)
     * }
     */
    public static MethodHandle vybe_pair$handle() {
        return vybe_pair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair(ecs_entity_t e1, ecs_entity_t e2)
     * }
     */
    public static MemorySegment vybe_pair$address() {
        return vybe_pair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair(ecs_entity_t e1, ecs_entity_t e2)
     * }
     */
    public static long vybe_pair(long e1, long e2) {
        var mh$ = vybe_pair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_pair", e1, e2);
            }
            return (long)mh$.invokeExact(e1, e2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_pair_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_pair_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_first(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static FunctionDescriptor vybe_pair_first$descriptor() {
        return vybe_pair_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_first(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static MethodHandle vybe_pair_first$handle() {
        return vybe_pair_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_first(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static MemorySegment vybe_pair_first$address() {
        return vybe_pair_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_first(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static long vybe_pair_first(MemorySegment world, long pair) {
        var mh$ = vybe_pair_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_pair_first", world, pair);
            }
            return (long)mh$.invokeExact(world, pair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_pair_second {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_LONG_LONG,
            flecs.C_POINTER,
            flecs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_pair_second");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_second(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static FunctionDescriptor vybe_pair_second$descriptor() {
        return vybe_pair_second.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_second(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static MethodHandle vybe_pair_second$handle() {
        return vybe_pair_second.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_second(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static MemorySegment vybe_pair_second$address() {
        return vybe_pair_second.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ecs_entity_t vybe_pair_second(const ecs_world_t *world, ecs_entity_t pair)
     * }
     */
    public static long vybe_pair_second(MemorySegment world, long pair) {
        var mh$ = vybe_pair_second.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_pair_second", world, pair);
            }
            return (long)mh$.invokeExact(world, pair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_rest_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_rest_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vybe_rest_enable(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor vybe_rest_enable$descriptor() {
        return vybe_rest_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vybe_rest_enable(ecs_world_t *world)
     * }
     */
    public static MethodHandle vybe_rest_enable$handle() {
        return vybe_rest_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vybe_rest_enable(ecs_world_t *world)
     * }
     */
    public static MemorySegment vybe_rest_enable$address() {
        return vybe_rest_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vybe_rest_enable(ecs_world_t *world)
     * }
     */
    public static void vybe_rest_enable(MemorySegment world) {
        var mh$ = vybe_rest_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_rest_enable", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_default_systems_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_default_systems_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vybe_default_systems_c(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor vybe_default_systems_c$descriptor() {
        return vybe_default_systems_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vybe_default_systems_c(ecs_world_t *world)
     * }
     */
    public static MethodHandle vybe_default_systems_c$handle() {
        return vybe_default_systems_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vybe_default_systems_c(ecs_world_t *world)
     * }
     */
    public static MemorySegment vybe_default_systems_c$address() {
        return vybe_default_systems_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vybe_default_systems_c(ecs_world_t *world)
     * }
     */
    public static void vybe_default_systems_c(MemorySegment world) {
        var mh$ = vybe_default_systems_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_default_systems_c", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_default_systems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_default_systems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vybe_default_systems(ecs_world_t *world)
     * }
     */
    public static FunctionDescriptor vybe_default_systems$descriptor() {
        return vybe_default_systems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vybe_default_systems(ecs_world_t *world)
     * }
     */
    public static MethodHandle vybe_default_systems$handle() {
        return vybe_default_systems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vybe_default_systems(ecs_world_t *world)
     * }
     */
    public static MemorySegment vybe_default_systems$address() {
        return vybe_default_systems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vybe_default_systems(ecs_world_t *world)
     * }
     */
    public static void vybe_default_systems(MemorySegment world) {
        var mh$ = vybe_default_systems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_default_systems", world);
            }
            mh$.invokeExact(world);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_setup_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_setup_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vybe_setup_allocator()
     * }
     */
    public static FunctionDescriptor vybe_setup_allocator$descriptor() {
        return vybe_setup_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vybe_setup_allocator()
     * }
     */
    public static MethodHandle vybe_setup_allocator$handle() {
        return vybe_setup_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vybe_setup_allocator()
     * }
     */
    public static MemorySegment vybe_setup_allocator$address() {
        return vybe_setup_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vybe_setup_allocator()
     * }
     */
    public static void vybe_setup_allocator() {
        var mh$ = vybe_setup_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_setup_allocator");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe__test__rest_issue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            flecs.C_INT,
            flecs.C_BOOL
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe__test__rest_issue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vybe__test__rest_issue(bool is_rest_enabled)
     * }
     */
    public static FunctionDescriptor vybe__test__rest_issue$descriptor() {
        return vybe__test__rest_issue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vybe__test__rest_issue(bool is_rest_enabled)
     * }
     */
    public static MethodHandle vybe__test__rest_issue$handle() {
        return vybe__test__rest_issue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vybe__test__rest_issue(bool is_rest_enabled)
     * }
     */
    public static MemorySegment vybe__test__rest_issue$address() {
        return vybe__test__rest_issue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vybe__test__rest_issue(bool is_rest_enabled)
     * }
     */
    public static int vybe__test__rest_issue(boolean is_rest_enabled) {
        var mh$ = vybe__test__rest_issue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe__test__rest_issue", is_rest_enabled);
            }
            return (int)mh$.invokeExact(is_rest_enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __VYBE_TEST_ACC$constants {
        public static final OfInt LAYOUT = flecs.C_INT;
        public static final MemorySegment SEGMENT = flecs.findOrThrow("__VYBE_TEST_ACC").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * int __VYBE_TEST_ACC = 0
     * }
     */
    public static OfInt __VYBE_TEST_ACC$layout() {
        return __VYBE_TEST_ACC$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * int __VYBE_TEST_ACC = 0
     * }
     */
    public static MemorySegment __VYBE_TEST_ACC$segment() {
        return __VYBE_TEST_ACC$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * int __VYBE_TEST_ACC = 0
     * }
     */
    public static int __VYBE_TEST_ACC() {
        return __VYBE_TEST_ACC$constants.SEGMENT.get(__VYBE_TEST_ACC$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * int __VYBE_TEST_ACC = 0
     * }
     */
    public static void __VYBE_TEST_ACC(int varValue) {
        __VYBE_TEST_ACC$constants.SEGMENT.set(__VYBE_TEST_ACC$constants.LAYOUT, 0L, varValue);
    }

    private static class __UpdateCamera {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("__UpdateCamera");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __UpdateCamera(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor __UpdateCamera$descriptor() {
        return __UpdateCamera.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __UpdateCamera(ecs_iter_t *it)
     * }
     */
    public static MethodHandle __UpdateCamera$handle() {
        return __UpdateCamera.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __UpdateCamera(ecs_iter_t *it)
     * }
     */
    public static MemorySegment __UpdateCamera$address() {
        return __UpdateCamera.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __UpdateCamera(ecs_iter_t *it)
     * }
     */
    public static void __UpdateCamera(MemorySegment it) {
        var mh$ = __UpdateCamera.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__UpdateCamera", it);
            }
            mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_matrix_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Matrix.layout(),
            __Vy_Translation.layout(),
            Vector4.layout(),
            __Vy_Scale.layout()
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_matrix_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __Vy_Transform vybe_matrix_transform(__Vy_Translation translation, __Vy_Rotation rotation, __Vy_Scale scale)
     * }
     */
    public static FunctionDescriptor vybe_matrix_transform$descriptor() {
        return vybe_matrix_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __Vy_Transform vybe_matrix_transform(__Vy_Translation translation, __Vy_Rotation rotation, __Vy_Scale scale)
     * }
     */
    public static MethodHandle vybe_matrix_transform$handle() {
        return vybe_matrix_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __Vy_Transform vybe_matrix_transform(__Vy_Translation translation, __Vy_Rotation rotation, __Vy_Scale scale)
     * }
     */
    public static MemorySegment vybe_matrix_transform$address() {
        return vybe_matrix_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __Vy_Transform vybe_matrix_transform(__Vy_Translation translation, __Vy_Rotation rotation, __Vy_Scale scale)
     * }
     */
    public static MemorySegment vybe_matrix_transform(SegmentAllocator allocator, MemorySegment translation, MemorySegment rotation, MemorySegment scale) {
        var mh$ = vybe_matrix_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_matrix_transform", allocator, translation, rotation, scale);
            }
            return (MemorySegment)mh$.invokeExact(allocator, translation, rotation, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vybe_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            flecs.C_POINTER
        );

        public static final MemorySegment ADDR = flecs.findOrThrow("vybe_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vybe_transform(ecs_iter_t *it)
     * }
     */
    public static FunctionDescriptor vybe_transform$descriptor() {
        return vybe_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vybe_transform(ecs_iter_t *it)
     * }
     */
    public static MethodHandle vybe_transform$handle() {
        return vybe_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vybe_transform(ecs_iter_t *it)
     * }
     */
    public static MemorySegment vybe_transform$address() {
        return vybe_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vybe_transform(ecs_iter_t *it)
     * }
     */
    public static void vybe_transform(MemorySegment it) {
        var mh$ = vybe_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vybe_transform", it);
            }
            mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define FLECS_VERSION "4.0.1"
     * }
     */
    public static MemorySegment FLECS_VERSION() {
        class Holder {
            static final MemorySegment FLECS_VERSION
                = flecs.LIBRARY_ARENA.allocateFrom("4.0.1");
        }
        return Holder.FLECS_VERSION;
    }
    private static final int FLECS_HI_COMPONENT_ID = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FLECS_HI_COMPONENT_ID 256
     * }
     */
    public static int FLECS_HI_COMPONENT_ID() {
        return FLECS_HI_COMPONENT_ID;
    }
    private static final int FLECS_HI_ID_RECORD_ID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FLECS_HI_ID_RECORD_ID 1024
     * }
     */
    public static int FLECS_HI_ID_RECORD_ID() {
        return FLECS_HI_ID_RECORD_ID;
    }
    private static final int FLECS_SPARSE_PAGE_BITS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define FLECS_SPARSE_PAGE_BITS 12
     * }
     */
    public static int FLECS_SPARSE_PAGE_BITS() {
        return FLECS_SPARSE_PAGE_BITS;
    }
    private static final int FLECS_ENTITY_PAGE_BITS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define FLECS_ENTITY_PAGE_BITS 12
     * }
     */
    public static int FLECS_ENTITY_PAGE_BITS() {
        return FLECS_ENTITY_PAGE_BITS;
    }
    private static final int FLECS_ID_DESC_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FLECS_ID_DESC_MAX 32
     * }
     */
    public static int FLECS_ID_DESC_MAX() {
        return FLECS_ID_DESC_MAX;
    }
    private static final int FLECS_EVENT_DESC_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FLECS_EVENT_DESC_MAX 8
     * }
     */
    public static int FLECS_EVENT_DESC_MAX() {
        return FLECS_EVENT_DESC_MAX;
    }
    private static final int FLECS_VARIABLE_COUNT_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FLECS_VARIABLE_COUNT_MAX 64
     * }
     */
    public static int FLECS_VARIABLE_COUNT_MAX() {
        return FLECS_VARIABLE_COUNT_MAX;
    }
    private static final int FLECS_TERM_ARG_COUNT_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FLECS_TERM_ARG_COUNT_MAX 16
     * }
     */
    public static int FLECS_TERM_ARG_COUNT_MAX() {
        return FLECS_TERM_ARG_COUNT_MAX;
    }
    private static final int FLECS_QUERY_VARIABLE_COUNT_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FLECS_QUERY_VARIABLE_COUNT_MAX 64
     * }
     */
    public static int FLECS_QUERY_VARIABLE_COUNT_MAX() {
        return FLECS_QUERY_VARIABLE_COUNT_MAX;
    }
    private static final int FLECS_QUERY_SCOPE_NESTING_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FLECS_QUERY_SCOPE_NESTING_MAX 8
     * }
     */
    public static int FLECS_QUERY_SCOPE_NESTING_MAX() {
        return FLECS_QUERY_SCOPE_NESTING_MAX;
    }
    private static final int EcsWorldQuitWorkers = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldQuitWorkers 1
     * }
     */
    public static int EcsWorldQuitWorkers() {
        return EcsWorldQuitWorkers;
    }
    private static final int EcsWorldReadonly = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldReadonly 2
     * }
     */
    public static int EcsWorldReadonly() {
        return EcsWorldReadonly;
    }
    private static final int EcsWorldInit = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldInit 4
     * }
     */
    public static int EcsWorldInit() {
        return EcsWorldInit;
    }
    private static final int EcsWorldQuit = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldQuit 8
     * }
     */
    public static int EcsWorldQuit() {
        return EcsWorldQuit;
    }
    private static final int EcsWorldFini = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldFini 16
     * }
     */
    public static int EcsWorldFini() {
        return EcsWorldFini;
    }
    private static final int EcsWorldMeasureFrameTime = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldMeasureFrameTime 32
     * }
     */
    public static int EcsWorldMeasureFrameTime() {
        return EcsWorldMeasureFrameTime;
    }
    private static final int EcsWorldMeasureSystemTime = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldMeasureSystemTime 64
     * }
     */
    public static int EcsWorldMeasureSystemTime() {
        return EcsWorldMeasureSystemTime;
    }
    private static final int EcsWorldMultiThreaded = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldMultiThreaded 128
     * }
     */
    public static int EcsWorldMultiThreaded() {
        return EcsWorldMultiThreaded;
    }
    private static final int EcsWorldFrameInProgress = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EcsWorldFrameInProgress 256
     * }
     */
    public static int EcsWorldFrameInProgress() {
        return EcsWorldFrameInProgress;
    }
    private static final int EcsOsApiHighResolutionTimer = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EcsOsApiHighResolutionTimer 1
     * }
     */
    public static int EcsOsApiHighResolutionTimer() {
        return EcsOsApiHighResolutionTimer;
    }
    private static final int EcsOsApiLogWithColors = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsOsApiLogWithColors 2
     * }
     */
    public static int EcsOsApiLogWithColors() {
        return EcsOsApiLogWithColors;
    }
    private static final int EcsOsApiLogWithTimeStamp = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EcsOsApiLogWithTimeStamp 4
     * }
     */
    public static int EcsOsApiLogWithTimeStamp() {
        return EcsOsApiLogWithTimeStamp;
    }
    private static final int EcsOsApiLogWithTimeDelta = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsOsApiLogWithTimeDelta 8
     * }
     */
    public static int EcsOsApiLogWithTimeDelta() {
        return EcsOsApiLogWithTimeDelta;
    }
    private static final int EcsEntityIsId = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define EcsEntityIsId 2147483648
     * }
     */
    public static int EcsEntityIsId() {
        return EcsEntityIsId;
    }
    private static final int EcsEntityIsTarget = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define EcsEntityIsTarget 1073741824
     * }
     */
    public static int EcsEntityIsTarget() {
        return EcsEntityIsTarget;
    }
    private static final int EcsEntityIsTraversable = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define EcsEntityIsTraversable 536870912
     * }
     */
    public static int EcsEntityIsTraversable() {
        return EcsEntityIsTraversable;
    }
    private static final int EcsIdOnDeleteRemove = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteRemove 1
     * }
     */
    public static int EcsIdOnDeleteRemove() {
        return EcsIdOnDeleteRemove;
    }
    private static final int EcsIdOnDeleteDelete = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteDelete 2
     * }
     */
    public static int EcsIdOnDeleteDelete() {
        return EcsIdOnDeleteDelete;
    }
    private static final int EcsIdOnDeletePanic = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeletePanic 4
     * }
     */
    public static int EcsIdOnDeletePanic() {
        return EcsIdOnDeletePanic;
    }
    private static final int EcsIdOnDeleteMask = (int)7L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteMask 7
     * }
     */
    public static int EcsIdOnDeleteMask() {
        return EcsIdOnDeleteMask;
    }
    private static final int EcsIdOnDeleteObjectRemove = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteObjectRemove 8
     * }
     */
    public static int EcsIdOnDeleteObjectRemove() {
        return EcsIdOnDeleteObjectRemove;
    }
    private static final int EcsIdOnDeleteObjectDelete = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteObjectDelete 16
     * }
     */
    public static int EcsIdOnDeleteObjectDelete() {
        return EcsIdOnDeleteObjectDelete;
    }
    private static final int EcsIdOnDeleteObjectPanic = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteObjectPanic 32
     * }
     */
    public static int EcsIdOnDeleteObjectPanic() {
        return EcsIdOnDeleteObjectPanic;
    }
    private static final int EcsIdOnDeleteObjectMask = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnDeleteObjectMask 56
     * }
     */
    public static int EcsIdOnDeleteObjectMask() {
        return EcsIdOnDeleteObjectMask;
    }
    private static final int EcsIdOnInstantiateOverride = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnInstantiateOverride 64
     * }
     */
    public static int EcsIdOnInstantiateOverride() {
        return EcsIdOnInstantiateOverride;
    }
    private static final int EcsIdOnInstantiateInherit = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnInstantiateInherit 128
     * }
     */
    public static int EcsIdOnInstantiateInherit() {
        return EcsIdOnInstantiateInherit;
    }
    private static final int EcsIdOnInstantiateDontInherit = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnInstantiateDontInherit 256
     * }
     */
    public static int EcsIdOnInstantiateDontInherit() {
        return EcsIdOnInstantiateDontInherit;
    }
    private static final int EcsIdOnInstantiateMask = (int)448L;
    /**
     * {@snippet lang=c :
     * #define EcsIdOnInstantiateMask 448
     * }
     */
    public static int EcsIdOnInstantiateMask() {
        return EcsIdOnInstantiateMask;
    }
    private static final int EcsIdExclusive = (int)512L;
    /**
     * {@snippet lang=c :
     * #define EcsIdExclusive 512
     * }
     */
    public static int EcsIdExclusive() {
        return EcsIdExclusive;
    }
    private static final int EcsIdTraversable = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define EcsIdTraversable 1024
     * }
     */
    public static int EcsIdTraversable() {
        return EcsIdTraversable;
    }
    private static final int EcsIdTag = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define EcsIdTag 2048
     * }
     */
    public static int EcsIdTag() {
        return EcsIdTag;
    }
    private static final int EcsIdWith = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define EcsIdWith 4096
     * }
     */
    public static int EcsIdWith() {
        return EcsIdWith;
    }
    private static final int EcsIdCanToggle = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define EcsIdCanToggle 8192
     * }
     */
    public static int EcsIdCanToggle() {
        return EcsIdCanToggle;
    }
    private static final int EcsIdIsTransitive = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define EcsIdIsTransitive 16384
     * }
     */
    public static int EcsIdIsTransitive() {
        return EcsIdIsTransitive;
    }
    private static final int EcsIdHasOnAdd = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnAdd 65536
     * }
     */
    public static int EcsIdHasOnAdd() {
        return EcsIdHasOnAdd;
    }
    private static final int EcsIdHasOnRemove = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnRemove 131072
     * }
     */
    public static int EcsIdHasOnRemove() {
        return EcsIdHasOnRemove;
    }
    private static final int EcsIdHasOnSet = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnSet 262144
     * }
     */
    public static int EcsIdHasOnSet() {
        return EcsIdHasOnSet;
    }
    private static final int EcsIdHasOnTableFill = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnTableFill 524288
     * }
     */
    public static int EcsIdHasOnTableFill() {
        return EcsIdHasOnTableFill;
    }
    private static final int EcsIdHasOnTableEmpty = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnTableEmpty 1048576
     * }
     */
    public static int EcsIdHasOnTableEmpty() {
        return EcsIdHasOnTableEmpty;
    }
    private static final int EcsIdHasOnTableCreate = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnTableCreate 2097152
     * }
     */
    public static int EcsIdHasOnTableCreate() {
        return EcsIdHasOnTableCreate;
    }
    private static final int EcsIdHasOnTableDelete = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define EcsIdHasOnTableDelete 4194304
     * }
     */
    public static int EcsIdHasOnTableDelete() {
        return EcsIdHasOnTableDelete;
    }
    private static final int EcsIdIsSparse = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define EcsIdIsSparse 8388608
     * }
     */
    public static int EcsIdIsSparse() {
        return EcsIdIsSparse;
    }
    private static final int EcsIdIsUnion = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define EcsIdIsUnion 16777216
     * }
     */
    public static int EcsIdIsUnion() {
        return EcsIdIsUnion;
    }
    private static final int EcsIdEventMask = (int)33488896L;
    /**
     * {@snippet lang=c :
     * #define EcsIdEventMask 33488896
     * }
     */
    public static int EcsIdEventMask() {
        return EcsIdEventMask;
    }
    private static final int EcsIdMarkedForDelete = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define EcsIdMarkedForDelete 1073741824
     * }
     */
    public static int EcsIdMarkedForDelete() {
        return EcsIdMarkedForDelete;
    }
    private static final int EcsIterIsValid = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EcsIterIsValid 1
     * }
     */
    public static int EcsIterIsValid() {
        return EcsIterIsValid;
    }
    private static final int EcsIterNoData = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsIterNoData 2
     * }
     */
    public static int EcsIterNoData() {
        return EcsIterNoData;
    }
    private static final int EcsIterNoResults = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsIterNoResults 8
     * }
     */
    public static int EcsIterNoResults() {
        return EcsIterNoResults;
    }
    private static final int EcsIterIgnoreThis = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EcsIterIgnoreThis 16
     * }
     */
    public static int EcsIterIgnoreThis() {
        return EcsIterIgnoreThis;
    }
    private static final int EcsIterHasCondSet = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EcsIterHasCondSet 64
     * }
     */
    public static int EcsIterHasCondSet() {
        return EcsIterHasCondSet;
    }
    private static final int EcsIterProfile = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EcsIterProfile 128
     * }
     */
    public static int EcsIterProfile() {
        return EcsIterProfile;
    }
    private static final int EcsIterTrivialSearch = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EcsIterTrivialSearch 256
     * }
     */
    public static int EcsIterTrivialSearch() {
        return EcsIterTrivialSearch;
    }
    private static final int EcsIterTrivialTest = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define EcsIterTrivialTest 2048
     * }
     */
    public static int EcsIterTrivialTest() {
        return EcsIterTrivialTest;
    }
    private static final int EcsIterTrivialCached = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define EcsIterTrivialCached 16384
     * }
     */
    public static int EcsIterTrivialCached() {
        return EcsIterTrivialCached;
    }
    private static final int EcsIterCacheSearch = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define EcsIterCacheSearch 32768
     * }
     */
    public static int EcsIterCacheSearch() {
        return EcsIterCacheSearch;
    }
    private static final int EcsIterFixedInChangeComputed = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define EcsIterFixedInChangeComputed 65536
     * }
     */
    public static int EcsIterFixedInChangeComputed() {
        return EcsIterFixedInChangeComputed;
    }
    private static final int EcsIterFixedInChanged = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define EcsIterFixedInChanged 131072
     * }
     */
    public static int EcsIterFixedInChanged() {
        return EcsIterFixedInChanged;
    }
    private static final int EcsIterSkip = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define EcsIterSkip 262144
     * }
     */
    public static int EcsIterSkip() {
        return EcsIterSkip;
    }
    private static final int EcsIterCppEach = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define EcsIterCppEach 524288
     * }
     */
    public static int EcsIterCppEach() {
        return EcsIterCppEach;
    }
    private static final int EcsIterTableOnly = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define EcsIterTableOnly 1048576
     * }
     */
    public static int EcsIterTableOnly() {
        return EcsIterTableOnly;
    }
    private static final int EcsEventTableOnly = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define EcsEventTableOnly 1048576
     * }
     */
    public static int EcsEventTableOnly() {
        return EcsEventTableOnly;
    }
    private static final int EcsEventNoOnSet = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define EcsEventNoOnSet 65536
     * }
     */
    public static int EcsEventNoOnSet() {
        return EcsEventNoOnSet;
    }
    private static final int EcsQueryMatchThis = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryMatchThis 2048
     * }
     */
    public static int EcsQueryMatchThis() {
        return EcsQueryMatchThis;
    }
    private static final int EcsQueryMatchOnlyThis = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryMatchOnlyThis 4096
     * }
     */
    public static int EcsQueryMatchOnlyThis() {
        return EcsQueryMatchOnlyThis;
    }
    private static final int EcsQueryMatchOnlySelf = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryMatchOnlySelf 8192
     * }
     */
    public static int EcsQueryMatchOnlySelf() {
        return EcsQueryMatchOnlySelf;
    }
    private static final int EcsQueryMatchWildcards = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryMatchWildcards 16384
     * }
     */
    public static int EcsQueryMatchWildcards() {
        return EcsQueryMatchWildcards;
    }
    private static final int EcsQueryMatchNothing = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryMatchNothing 32768
     * }
     */
    public static int EcsQueryMatchNothing() {
        return EcsQueryMatchNothing;
    }
    private static final int EcsQueryHasCondSet = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasCondSet 65536
     * }
     */
    public static int EcsQueryHasCondSet() {
        return EcsQueryHasCondSet;
    }
    private static final int EcsQueryHasPred = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasPred 131072
     * }
     */
    public static int EcsQueryHasPred() {
        return EcsQueryHasPred;
    }
    private static final int EcsQueryHasScopes = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasScopes 262144
     * }
     */
    public static int EcsQueryHasScopes() {
        return EcsQueryHasScopes;
    }
    private static final int EcsQueryHasRefs = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasRefs 524288
     * }
     */
    public static int EcsQueryHasRefs() {
        return EcsQueryHasRefs;
    }
    private static final int EcsQueryHasOutTerms = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasOutTerms 1048576
     * }
     */
    public static int EcsQueryHasOutTerms() {
        return EcsQueryHasOutTerms;
    }
    private static final int EcsQueryHasNonThisOutTerms = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasNonThisOutTerms 2097152
     * }
     */
    public static int EcsQueryHasNonThisOutTerms() {
        return EcsQueryHasNonThisOutTerms;
    }
    private static final int EcsQueryHasMonitor = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasMonitor 4194304
     * }
     */
    public static int EcsQueryHasMonitor() {
        return EcsQueryHasMonitor;
    }
    private static final int EcsQueryIsTrivial = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryIsTrivial 8388608
     * }
     */
    public static int EcsQueryIsTrivial() {
        return EcsQueryIsTrivial;
    }
    private static final int EcsQueryHasCacheable = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasCacheable 16777216
     * }
     */
    public static int EcsQueryHasCacheable() {
        return EcsQueryHasCacheable;
    }
    private static final int EcsQueryIsCacheable = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryIsCacheable 33554432
     * }
     */
    public static int EcsQueryIsCacheable() {
        return EcsQueryIsCacheable;
    }
    private static final int EcsQueryHasTableThisVar = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryHasTableThisVar 67108864
     * }
     */
    public static int EcsQueryHasTableThisVar() {
        return EcsQueryHasTableThisVar;
    }
    private static final int EcsQueryCacheYieldEmptyTables = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define EcsQueryCacheYieldEmptyTables 134217728
     * }
     */
    public static int EcsQueryCacheYieldEmptyTables() {
        return EcsQueryCacheYieldEmptyTables;
    }
    private static final int EcsTermMatchAny = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EcsTermMatchAny 1
     * }
     */
    public static int EcsTermMatchAny() {
        return EcsTermMatchAny;
    }
    private static final int EcsTermMatchAnySrc = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsTermMatchAnySrc 2
     * }
     */
    public static int EcsTermMatchAnySrc() {
        return EcsTermMatchAnySrc;
    }
    private static final int EcsTermTransitive = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EcsTermTransitive 4
     * }
     */
    public static int EcsTermTransitive() {
        return EcsTermTransitive;
    }
    private static final int EcsTermReflexive = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsTermReflexive 8
     * }
     */
    public static int EcsTermReflexive() {
        return EcsTermReflexive;
    }
    private static final int EcsTermIdInherited = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIdInherited 16
     * }
     */
    public static int EcsTermIdInherited() {
        return EcsTermIdInherited;
    }
    private static final int EcsTermIsTrivial = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsTrivial 32
     * }
     */
    public static int EcsTermIsTrivial() {
        return EcsTermIsTrivial;
    }
    private static final int EcsTermIsCacheable = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsCacheable 128
     * }
     */
    public static int EcsTermIsCacheable() {
        return EcsTermIsCacheable;
    }
    private static final int EcsTermIsScope = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsScope 256
     * }
     */
    public static int EcsTermIsScope() {
        return EcsTermIsScope;
    }
    private static final int EcsTermIsMember = (int)512L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsMember 512
     * }
     */
    public static int EcsTermIsMember() {
        return EcsTermIsMember;
    }
    private static final int EcsTermIsToggle = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsToggle 1024
     * }
     */
    public static int EcsTermIsToggle() {
        return EcsTermIsToggle;
    }
    private static final int EcsTermKeepAlive = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define EcsTermKeepAlive 2048
     * }
     */
    public static int EcsTermKeepAlive() {
        return EcsTermKeepAlive;
    }
    private static final int EcsTermIsSparse = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsSparse 4096
     * }
     */
    public static int EcsTermIsSparse() {
        return EcsTermIsSparse;
    }
    private static final int EcsTermIsUnion = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsUnion 8192
     * }
     */
    public static int EcsTermIsUnion() {
        return EcsTermIsUnion;
    }
    private static final int EcsTermIsOr = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define EcsTermIsOr 16384
     * }
     */
    public static int EcsTermIsOr() {
        return EcsTermIsOr;
    }
    private static final int EcsObserverIsMulti = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverIsMulti 2
     * }
     */
    public static int EcsObserverIsMulti() {
        return EcsObserverIsMulti;
    }
    private static final int EcsObserverIsMonitor = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverIsMonitor 4
     * }
     */
    public static int EcsObserverIsMonitor() {
        return EcsObserverIsMonitor;
    }
    private static final int EcsObserverIsDisabled = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverIsDisabled 8
     * }
     */
    public static int EcsObserverIsDisabled() {
        return EcsObserverIsDisabled;
    }
    private static final int EcsObserverIsParentDisabled = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverIsParentDisabled 16
     * }
     */
    public static int EcsObserverIsParentDisabled() {
        return EcsObserverIsParentDisabled;
    }
    private static final int EcsObserverBypassQuery = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverBypassQuery 32
     * }
     */
    public static int EcsObserverBypassQuery() {
        return EcsObserverBypassQuery;
    }
    private static final int EcsObserverYieldOnCreate = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverYieldOnCreate 64
     * }
     */
    public static int EcsObserverYieldOnCreate() {
        return EcsObserverYieldOnCreate;
    }
    private static final int EcsObserverYieldOnDelete = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EcsObserverYieldOnDelete 128
     * }
     */
    public static int EcsObserverYieldOnDelete() {
        return EcsObserverYieldOnDelete;
    }
}

