(ns vybe.basilisp.bake
  "Creates a torus pattern with randomly colored materials."
  (:import bpy
           math
           inspect)
  (:require
   [basilisp.repl :as repl]
   [clojure.string :as str]))

(def obj bpy.ops/object)
(def objs bpy.ops/objects)

(defmacro with-temp
  "Fields will be temporarily set and then reverted."
  [bindings & body]
  `(let ~ (->> bindings
               (partition-all 2 2)
               (map-indexed (fn [idx [attribute-form v]]
                              `[~(symbol (str "vybe--internal-" idx))
                                ~attribute-form

                                ~'_ (do (println (quote (set! ~attribute-form ~v)))
                                        (set! ~attribute-form ~v))]))
               (apply concat)
               vec)
     (try
       ~@body
       (finally
         ~ (->> bindings
                (partition-all 2 2)
                (map-indexed (fn [idx [attribute-form v]]
                               `(set! ~attribute-form ~(symbol (str "vybe--internal-" idx)))))
                vec)))))

(defmacro active-name
  []
  `(.-name bpy.context.view_layer.objects/active))

(defn select
  [obj]
  (.select_set obj true)
  (set! bpy.context.view_layer.objects/active obj))

(defn deselect-all
  []
  (bpy.ops.object/select_all ** :action "DESELECT"))

(defn select-only
  [obj]
  (deselect-all)
  (select obj))

(defn deselect
  [obj]
  (.select_set obj false))

(defn hide
  [obj]
  (.hide_set obj true)
  (set! (.-hide_render obj) true))

(defn unhide
  [obj]
  (.hide_set obj false)
  (set! (.-hide_render obj) false))

(defn obj-find
  [n]
  (.get bpy.context.scene/objects n))

(defn children-move
  "Move all children from a object into another."
  [source-obj target-obj]
  (mapv #(do
           (set! (.-parent %) target-obj)
           (set! (.-matrix-parent-inverse %) (.inverted (.-matrix-world target-obj))))
        (.-children source-obj)))
#_ (children-move (obj-find "Scene") (obj-find "Scene.__original"))

(defn bake-active
  "Bake active object."
  []
  (let [baked-n (active-name)
        orig-n (str baked-n ".__original")
        _ (do
            ;; If original exists, delete the baked one, rename the original and
            ;; select it (moving children into original).
            (when-let [obj (obj-find orig-n)]
              (children-move (obj-find baked-n) (obj-find orig-n))
              (obj/delete)
              (unhide obj)
              (select-only obj)
              (set! (active-name) baked-n))

            ;; Name and clone.
            (set! (active-name) orig-n)
            (obj/duplicate)
            (set! (active-name) baked-n))

        baked-obj (obj-find baked-n)
        orig-obj (obj-find orig-n)

        ;; New material + image texture.
        baked-path (str (bpy.path/abspath "//")
                        (->> [(bpy.path/display_name_from_filepath bpy.data/filepath)
                              (.-name bpy.context/scene)
                              baked-n
                              (hash bpy.data/filepath)]
                             (str/join "_"))
                        #_".png" ".jpeg")

        width 512 #_ 1024 #_ 2048 #_ 4096
        #_ (bake-selected)
        height width
        baked-image (bpy.data.images/new "bake_image2" ** :width width :height height)
        _ (do (set! (.-file-format baked-image) #_"PNG" "JPEG")
              (set! (.-filepath_raw baked-image) baked-path))
        baked-mat (bpy.data.materials/new ** :name "bake_mat")
        _ (do (set! (.-use-nodes baked-mat) true)
              (.clear bpy.context.object.data/materials)
              (.append bpy.context.object.data/materials baked-mat))
        node-tree (.-node-tree baked-mat)
        node (.. node-tree -nodes (new "ShaderNodeTexImage"))
        _ (do (set! (.-select node) true)
              (set! (.. node-tree -nodes -active) node)
              (set! (.. node -image) baked-image))

        ;; Connect nodes.
        base-color-in (->> (.. baked-mat -node-tree -nodes)
                           (filter #(= (.-name %) "Principled BSDF"))
                           first
                           .-inputs
                           first)
        tex-color-out (first (.-outputs node))
        _ (.. baked-mat -node-tree -links (new base-color-in tex-color-out))]

    ;; Unwrap + Smart UV.
    (select baked-obj)
    (bpy.ops.object/mode_set ** :mode "EDIT")
    (bpy.ops.mesh/select_all ** :action "SELECT")
    (bpy.ops.uv/unwrap **)
    (bpy.ops.uv/smart_project ** :island-margin 0.001)
    (bpy.ops.object/mode_set ** :mode "OBJECT")

    ;; Select both objects for the baking process.
    (select orig-obj)
    (select baked-obj)

    ;; For debugging.
    #_ (do
         (def baked-mat baked-mat)
         (def baked-image baked-image)
         (def node node))

    ;; Bake, unhiding all original objects so we can have proper lightning
    ;; (e.g. for emissive objects).
    (let [original-objs (->> bpy.data/objects
                             (filter #(str/includes? (.-name %) ".__original")))]
      (with-temp [(-> (.get bpy.data/scenes bpy.context.scene/name) .-render .-engine) "CYCLES"
                  bpy.context.scene.cycles/samples 10
                  bpy.context.scene.cycles/device "GPU"
                  bpy.context.scene.cycles/use-denoising true]
        (mapv unhide original-objs)
        (obj/bake **
                  :type "COMBINED"
                  :pass_filter (lisp->py
                                #{"EMIT" "DIRECT" "INDIRECT"
                                  "COLOR" "DIFFUSE" "GLOSSY"
                                  "TRANSMISSION"})
                  :width width
                  :height height
                  :use_selected_to_active true
                  :margin_type "ADJACENT_FACES"
                  :cage_extrusion 0.02
                  :use_clear true)
        (mapv hide original-objs)))

    ;; Save baked image.
    (.save baked-image)
    (deselect orig-obj)
    (hide orig-obj)
    (bpy.ops.wm/save_mainfile)

    ;; Move all children from orig to the baked one.
    (children-move orig-obj baked-obj)

    baked-obj))
#_ (bake-selected)
#_ (bake-active)
#_ (bpy.ops.ed/undo)

(defn bake-selected
  []
  (let [baked-objs (->> bpy.context/selected_objects
                        (mapv (fn [obj]
                                (deselect-all)
                                (select obj)
                                (bake-active))))]
    ;; Select the baked objs so we have an equivalent user selection.
    (deselect-all)
    (run! select baked-objs)

    baked-objs))
#_ (bake-selected)
