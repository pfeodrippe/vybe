(ns vybe.basilisp.blender
  "Creates a torus pattern with randomly colored materials."
  (:require
   [basilisp.repl :as repl]
   [clojure.string :as str]
   [basilisp.edn :as edn])
  (:import bpy
           time
           math
           sys
           inspect
           importlib
           os
           ctypes))

(comment

  (let [cube (obj-find "Cube")]
    (time
     (doseq [_ (range 10000)]
       (set! (.. cube -location -x) 7.4)
       (set! (.. cube -location -y) 4.6)
       (set! (.. cube -location -z) 1.32)
       (set! (.. cube -location -x) 7.4)
       (set! (.. cube -location -y) 4.6)
       (set! (.. cube -location -z) 1.32))))

  ())

(defn jvm-init!
  []
  (sys.path/insert 0 "/Users/pfeodrippe/dev/vybe/basilisp/src")
  (sys.path/insert 0 "/Users/pfeodrippe/.local/lib/python3.11/site-packages")
  (load-file "/Users/pfeodrippe/dev/vybe/basilisp/src/vybe/basilisp/jvm.lpy")
  ((requiring-resolve 'vybe.basilisp.jvm/jvm-init!)))
#_ (jvm-init!)

#_ (vybe.blender/*nrepl-init* vybe.blender/blender-session)
#_ :blender/quit

(defmacro with-temp
  "Fields will be temporarily set and then reverted."
  [bindings & body]
  `(let ~ (->> bindings
               (partition-all 2 2)
               (map-indexed (fn [idx [attribute-form v]]
                              `[~(symbol (str "vybe--internal-" idx))
                                ~attribute-form

                                ~'_ (do (println (quote (set! ~attribute-form ~v)))
                                        (set! ~attribute-form ~v))]))
               (apply concat)
               vec)
     (try
       ~@body
       (finally
         ~ (->> bindings
                (partition-all 2 2)
                (map-indexed (fn [idx [attribute-form v]]
                               `(set! ~attribute-form ~(symbol (str "vybe--internal-" idx)))))
                vec)))))

(defmacro active-name
  []
  `(.-name bpy.context.view_layer.objects/active))

(defn obj-find
  [obj]
  (if (string? obj)
    (.get bpy.context.scene/objects obj)
    obj))

(defn obj+children
  "Return list of visible object + its (nested) children."
  [obj]
  (let [obj (if (string? obj)
              (.get bpy.context.scene/objects obj)
              obj)
        children (.. obj -children)]
    (->> (mapcat obj+children children)
         (concat [obj])
        (filter #(not (.hide-get %))))))
#_ (obj+children "Scene")

(defn deselect-all
  []
  (bpy.ops.object/select_all ** :action "DESELECT"))

(defn select
  "When `children` is true, all the visible children will be selected.
  For `only`, it will deselect everything before starting the selection."
  ([obj]
   (select obj {}))
  ([obj {:keys [children only] :as params}]
   (when only
     (deselect-all))

   (let [obj (obj-find obj)]
     (.select_set obj true)
     (set! bpy.context.view_layer.objects/active obj)
     (->> (if children
            (concat [obj] (mapcat #(select % (dissoc params :only))
                                  (.. obj -children)))
            [obj])
          ;; Hidden objects won't be selected.
          (filter #(.select-get %))))))
#_ (-> (obj-find "Scene")
       (select {:children true :only true}))

(defn deselect
  [obj]
  (.select_set (obj-find obj) false))

(defn hide
  [obj]
  (let [obj (obj-find obj)]
    (.hide_set obj true)
    (set! (.-hide_render obj) true)))

(defn unhide
  [obj]
  (let [obj (obj-find obj)]
    (.hide_set obj false)
    (set! (.-hide_render obj) false)))

(defn children-move
  "Move all children from a object into another."
  [source-obj target-obj]
  (let [source-obj (obj-find source-obj)
        target-obj (obj-find target-obj)]
    (mapv #(do
             (set! (.-parent %) target-obj)
             (set! (.-matrix-parent-inverse %) (.inverted (.-matrix-world target-obj))))
          (.-children source-obj))))
#_ (children-move (obj-find "Scene") (obj-find "Scene.__original"))

(defn- bake--copy
  [{:keys [baked-obj] :as args}]
  ;; If original exists, delete the baked one, rename the original and
  ;; select it (moving children into original).
  (let [baked-obj (obj-find baked-obj)
        baked-n (.-name baked-obj)
        _ (println :BAKING_OBJ baked-n)
        orig-n (str baked-n ".__original")]

    (when-let [orig-obj (obj-find orig-n)]
      ;; Copy world matrix so the transform from the baked one can be the
      ;; main one as this is the visible one in viewport.
      #_(set! (.. orig-obj -matrix-world)
            (.copy (.. baked-obj -matrix-world)))
      ;; Maintain mesh data from baked + materials from orig.
      #_(let [materials #_(.. orig-obj -data -materials)
            (mapv #(.copy %) (.. orig-obj -data -materials))
            active-mat-index (.-active-material-index orig-obj)]
        (set! (.-data orig-obj) (.copy (.-data baked-obj)))

        (.. orig-obj -data -materials clear)
        (doseq [mat materials]
          #_(set! (.-use-nodes mat) true)
          (.. orig-obj -data -materials (append mat)))
        (set! (.-active-material-index orig-obj) active-mat-index))

      #_ (bake-objs)

      (children-move baked-obj orig-obj)
      (bpy.data.objects/remove baked-obj)
      (unhide orig-obj)
      (set! (.-name orig-obj) baked-n))

    (let [baked-obj (obj-find baked-n)
          orig-obj (.copy baked-obj)
          _ (set! (.-data orig-obj) (.copy (.-data baked-obj)))
          _ (do ;; Name and clone.
              (set! (.-name baked-obj) baked-n)
              (set! (.-name orig-obj) orig-n)
              (bpy.context.scene.collection.objects/link orig-obj))]
      (merge args
             {:baked-obj baked-obj
              :orig-obj orig-obj
              :baked-n baked-n
              :orig-n orig-n}))))
#_ (bake--copy "Cube.001")
#_ (bake--copy "Scene")

(defn- bake--add-material-and-texture
  [{:keys [baked-n baked-obj texture-width texture-height]
    :as args}]
  ;; New material + image texture.
  (let [baked-path (str (bpy.path/abspath "//")
                        (->> [(bpy.path/display_name_from_filepath bpy.data/filepath)
                              (.-name bpy.context/scene)
                              baked-n
                              (hash bpy.data/filepath)]
                             (str/join "_"))
                        #_".png" ".jpeg")

        texture-width (or texture-width 512 #_1024 #_ 2048 #_ 4096)
        #_ (bake-objs)
        #_ (toggle-original-objs)
        texture-height (or texture-height texture-width)
        baked-image (bpy.data.images/new "bake_image2" ** :width texture-width :height texture-height)
        _ (do (set! (.-file-format baked-image) #_"PNG" "JPEG")
              (set! (.-filepath_raw baked-image) baked-path))
        baked-mat (bpy.data.materials/new ** :name "bake_mat")
        _ (do (set! (.-use-nodes baked-mat) true)
              (.. baked-obj -data -materials clear)
              (.. baked-obj -data -materials (append baked-mat)))
        #_ (bake-obj "Scene")
        node-tree (.-node-tree baked-mat)
        node (.. node-tree -nodes (new "ShaderNodeTexImage"))
        _ (do (set! (.-select node) true)
              (set! (.. node-tree -nodes -active) node)
              (set! (.. node -image) baked-image))]
    (merge args {:baked-mat baked-mat
                 :baked-image baked-image
                 :node node
                 :texture-width texture-width
                 :texture-height texture-height})))

(defn bake--connect-nodes
  [{:keys [baked-mat node] :as args}]
  (let [base-color-in (->> (.. baked-mat -node-tree -nodes)
                           (filter #(= (.-name %) "Principled BSDF"))
                           first
                           .-inputs
                           first)
        tex-color-out (first (.-outputs node))
        _ (.. baked-mat -node-tree -links (new base-color-in tex-color-out))]
    args))

(defn bake--unwrap+smart-uv
  [{:keys [baked-obj] :as args}]
  ;; Unwrap + Smart UV.
  (select baked-obj)
  (bpy.ops.object/mode_set ** :mode "EDIT")
  (bpy.ops.mesh/select_all ** :action "SELECT")
  (bpy.ops.uv/unwrap **)
  (bpy.ops.uv/smart_project ** :island-margin 0.001)
  (bpy.ops.object/mode_set ** :mode "OBJECT")
  args)

(defn original->baked
  [obj]
  (let [n (->> (str/split (.-name (obj-find obj))  #".__original")
               drop-last
               (str/join ".__original"))]
    (obj-find n)))
#_ (-> (obj-find "Scene.__original")
       original->baked
       .hide_get)

(defn get-original-objs
  "Get original objs that don't have baked hidden in the viewport."
  []
  (->> bpy.data/objects
       (filter #(str/ends-with? (.-name %) ".__original"))
       (remove #(and (.hide_get %)
                     (.hide_get (original->baked %))))))
#_ (get-original-objs)

(defn get-baked-objs
  "Get baked objs that aren't hidden in the viewport."
  []
  (let [original-objs (get-original-objs)]
    (->> original-objs
         (mapv original->baked))))
#_ (get-baked-objs)

(defn show-original-objs
  []
  (run! unhide (get-original-objs))
  (run! hide (get-baked-objs)))
#_ (show-original-objs)

(defn show-baked-objs
  []
  (run! unhide (get-baked-objs))
  (run! hide (get-original-objs)))
#_ (show-baked-objs)

(defn viewport-shading!
  "Set viewport (VIEW_3D) shading type.

  Possible values are
    - :material
    - :rendered
    - :wireframe
    - :solid"
  [shading-type]
  (set! (->> bpy.context.screen/areas
             (filter #(= (.-type %) "VIEW_3D"))
             first
             .-spaces
             (filter #(= (.-type %) "VIEW_3D"))
             first
             .-shading
             .-type)
        (str/upper-case (name shading-type))))
#_ (viewport-shading! :material)
#_ (viewport-shading! :rendered)

(defn original-visible?
  []
  (some #(not (.hide_get %)) (get-original-objs)))

(defn toggle-original-objs
  "Will toggle between original and baked objs.

  Will also switch to Material Preview when baked are selected and to
  Rendered when the original are selected."
  []
  (if (original-visible?)
    (do (show-baked-objs)
        (viewport-shading! :material))
    (do (show-original-objs)
        (viewport-shading! :rendered))))
#_ (toggle-original-objs)

(defn bake--apply-bake
  [{:keys [texture-width texture-height baked-obj orig-obj samples]
    :as args}]
  ;; Bake, unhiding all original objects so we can have proper lightning
  ;; (e.g. for emissive objects).
  (with-temp [(-> (.get bpy.data/scenes bpy.context.scene/name) .-render .-engine) "CYCLES"
              bpy.context.scene.cycles/samples (or samples 10)
              bpy.context.scene.cycles/device "GPU"
              bpy.context.scene.cycles/use-denoising true]

    (show-original-objs)
    ;; Select both objects for the baking process.
    (select orig-obj)
    (unhide baked-obj)
    (select baked-obj)

    (bpy.ops.object/bake **
                         :type "COMBINED"
                         :pass_filter (lisp->py
                                       #{"EMIT" "DIRECT" "INDIRECT"
                                         "COLOR" "DIFFUSE" "GLOSSY"
                                         "TRANSMISSION"})
                         :width texture-width
                         :height texture-height
                         :use_selected_to_active true
                         :margin_type "ADJACENT_FACES"
                         :cage_extrusion 0.02
                         :use_clear true)
    (show-baked-objs))

  args)

(defn bake--save
  [{:keys [orig-obj baked-obj baked-image]}]
  (.save baked-image)
  (bpy.ops.wm/save_mainfile)

  ;; Move all children from orig to the baked one.
  (children-move orig-obj baked-obj)

  baked-obj)

(defn save-backup!
  []
  (let [filepath (str (bpy.path/abspath "//")
                      (bpy.path/display-name-from-filepath bpy.data/filepath)
                      "_" (round (* (time/time) 1000))
                      ".blend")]
    (println :BACKUP_PATH filepath)
    (bpy.ops.wm/save_as_mainfile ** :filepath filepath :copy true)
    filepath))

(defn bake-obj
  "Bake active object."
  ([]
   (bake-obj (active-name)))
  ([obj]
   (bake-obj obj {}))
  ([obj {:keys [is-saving-backup]
         :or {is-saving-backup true}
         :as params}]
   (when is-saving-backup
     (save-backup!))

   (-> (merge {:baked-obj obj} params)
       bake--copy
       bake--add-material-and-texture
       bake--connect-nodes
       bake--unwrap+smart-uv
       bake--apply-bake
       bake--save)))
#_ (bake-obj "Scene")
#_ (bake-obj)
#_ (bake-objs)
#_ (bpy.ops.ed/undo)

(defn bake-objs
  ([]
   (bake-objs (->> bpy.context.scene/objects
                   (filter (fn [v] (.select-get v))))))
  ([objs]
   (bake-objs objs {}))
  ([objs params]
   (when (seq objs)
     (save-backup!)
     (let [baked-objs (->> objs
                           (mapv #(.-name %))
                           (mapv (fn [obj]
                                   (deselect-all)
                                   (select obj)
                                   (bake-obj obj (merge {:is-saving-backup false}
                                                        params)))))]
       ;; Select the baked objs so we have an equivalent user selection.
       (deselect-all)
       (run! select baked-objs)

       baked-objs))))
#_ (bake-objs)
#_ (let [is-visible (original-visible?)]
     (when is-visible (toggle-original-objs))
     (-> (obj+children "SceneOutdoors") bake-objs)
     (-> (obj+children "Scene") bake-objs)
     (when is-visible (toggle-original-objs)))
