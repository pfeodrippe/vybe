## Refs

- VAO, https://paroj.github.io/gltut/Basics/Tut01%20Following%20the%20Data.html
- Baked light map, https://gazebosim.org/api/rendering/5.0/lightmap.html
- GLTF spec, https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html
- GLTF SO question, https://stackoverflow.com/questions/55989429/understanding-the-skinning-part-of-a-gltf2-0-file-for-opengl-engine
- GLTF anim article, https://lisyarus.github.io/blog/posts/gltf-animation.html
- GLTF anim example, https://github.com/KhronosGroup/glTF-Tutorials/blob/main/gltfTutorial/gltfTutorial_019_SimpleSkin.md
- GLTF reference guide, https://www.khronos.org/files/gltf20-reference-guide.pdf
- GLTF code, https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/d32ca25dc273c0b0982e29efcea01b45d0c85105/src/skin.js#L32-L36
- Animation blending/skin article, https://animationprogramming.com
- Use rust lib with Panama, https://foojay.io/today/java-panama-polyglot-rust-part-4/
- JOLT
  - https://github.com/jrouwe/JoltPhysics/blob/master/HelloWorld/HelloWorld.cpp
  - https://github.com/zig-gamedev/zig-gamedev/blob/main/samples/physics_test_wgpu/src/physics_test_wgpu.zig#L321
  - https://github.com/aecsocket/jolt-java/blob/main/src/test/java/jolt/HelloJolt.java
- SuperCollider
  - Live coding, https://theseanco.github.io/howto_co34pt_liveCode/
  - Supercollider PDF, https://cs.wellesley.edu/~cs203/lecture_materials/synthdefs/synthdefs.pdf
  - Patterns tutorial, https://doc.sccode.org/Tutorials/A-Practical-Guide/PG_01_Introduction.html
  - Creating plugin, https://github.com/notam02/supercollider-plugin-tutorial/blob/main/tutorial/how-to-make-a-supercollider-plugin-cpp.md
  - Extra synths, https://github.com/SCLOrkHub/SCLOrkSynths
  - Eurorack plugin, https://github.com/v7b1/mi-UGens
  - Janet for Mortals, https://janet.guide/
  - How to make plugins using dlopen, https://jameshfisher.com/2017/08/24/dlopen/
  - SC server plugins PDF, file:///Users/pfeodrippe/Downloads/how-to-make-a-supercollider-plugin-cpp.pdf
  - SC plugins forum, https://scsynth.org/c/development/server-plugins/29
  - JNI cookbook, https://github.com/mkowsiak/jnicookbook
  - Flucoma, https://www.flucoma.org/download/
  - SC server plugin api, https://doc.sccode.org/Reference/ServerPluginAPI.html
  - https://docs.oracle.com/en/java/javase/22/core/foreign-function-and-memory-api.html
  - AsmJit, https://asmjit.com/
  - JVMTI (JVM Tool Interface), https://docs.oracle.com/en/java/javase/22/docs/specs/jvmti.html
  - Memory mapped file (mmap) lib, https://github.com/OpenHFT/OpenHFT
  - Scoring Sound: Creative Music Coding with SuperCollider book, https://thormagnusson.gitbooks.io/scoring/content/index.html
  - Opinionate advice for beginners, https://scsynth.org/t/opinionated-advice-for-supercollider-beginners/7333
  - DSPs, https://www.musicdsp.org/en/latest/index.html
  - SC example plugin, https://github.com/supercollider/example-plugins/blob/main/03-AnalogEcho/AnalogEcho.cpp
  - C guide, https://beej.us/guide/bgc/html/split/
  - Beej's guides, https://beej.us/guide/
  - clang manual (guide), https://clang.llvm.org/docs/UsersManual.html
  - Arena allocation (by Null Program), https://nullprogram.com/blog/2023/12/17/
  - Delay effect tutorial, https://wiki.analog.com/resources/tools-software/sharc-audio-module/baremetal/delay-effect-tutorial

## TODO

- [x] fix memory leak
- [x] solve lexical scope for with-each
- [x] fix already closed issue
- [x] solve lexical scope for with-system
- [x] call sclang
  - so we can use pseudo ugens easily and create synthdefs from it
  - it's meant to be used only in dev time
  - [x] compile synthdef
    - [x] transpile from clj into SC
    - [x] save
  - [x] plot
  - [x] read byte stream
  - [x] help (.help)
- [x] caching for sclang synthdefs so we can use it transparently
- [x] make `sclang-path` more flexible
- [x] general cpp plugin that allow us to dynamically change a ugen
  - [-] maybe using jank?
    - no as it's changing its internals
  - [x] can we start a REPL from a JVM started from C++?
    - https://stackoverflow.com/questions/992836/how-to-access-the-java-method-in-a-c-application
    - https://stackoverflow.com/questions/819536/how-to-call-java-functions-from-c
    - https://stackoverflow.com/questions/7715804/how-to-use-find-jni-on-cmake/7716814#7716814
    - [x] call a static java method
    - [x] call clj
      - [x] set classpath
      - [x] call function
      - [x] start REPL
    - [x] use memory segment for jvm/native communication
      - [x] `next` modifies one byte and we see it in the jvm
        - [x] create memory segment in the jvm
        - [x] refer it from cpp
        - [x] modify data
        - [x] modify in `next`
      - [x] write to large array
      - [x] structured data
    - [x] c code on demand
      - [x] viz data
      - [x] update data viz in real time
      - [x] fft viz
      - [-] create project in vybesc
      - [x] shared memory
        - https://www.infoq.com/presentations/java-shared-memory-files/
        - [x] jvm
        - [x] c++
        - [x] share raw data
          - [x] fix /cmd
          - [x] create unitcmd or cmd
      - [x] compile c code on demand
        - [x] shared memory
          - [x] read constructor value for make "different" plugins
          - [x] create arena for shared
          - [x] set shared memory
          - [x] fix plugin crash
        - [x] initial transpiler
        - [x] compile c code
        - [x] dopen from the plugin multiple times
        - [x] continue transpiler dev
          - [x] loops
          - [x] receive unit struct
          - [x] source mapping
          - [x] improve error handling
          - [x] state
            - https://github.com/supercollider/example-plugins/blob/main/03-AnalogEcho/AnalogEcho.cpp
            - [x] ctor
              - [x] create struct inheriting from Unit
                - [x] create struct from clj
                - [x] create another component merging with new fields
                - [x] prepend them into the C code
              - [x] set unit parameters
              - [x] store state globally
              - [x] store state for one instance
              - [x] move things to another ns
                - [x] one ns for the c helpers
                - [x] another ns for the client code
              - [x] ctor code
                - [x] attrs
                  - [x] NEXTPOWEROFTWO
                  - [x] RTAlloc
                    - [x] ctor function
                    - [x] shared struct to pass RTAlloc and RTFree
                  - [x] use namespace in function names
                  - [x] setcalc
                  - [ ] use RTAlloc
                    - [x] try with malloc
                    - [x] use RTAlloc for the returned `echo` data
                      - [x] function descriptor
                      - [x] allocate
                      - [x] parse to C
                  - [x] complete ctor
                  - [x] per instance unit
            - [x] plugin loading
            - [x] dtor
            - [x] next
            - [x] put everything together
    - [x] call C function from clojure
      - [x] dyn lib
      - [x] simple test
      - [x] CI
        - [x] osx
        - [x] linux
        - [x] windows
      - [x] docstring
      - [x] dsp test
        - [x] plugin
        - [x] component as an argument
        - [x] ctor
          - [x] unit pointer
          - [x] upcall function for allocator
            - [x] fn-desc to upcall
            - [x] interface name and cache
            - [x] VybeCFn in panama
            - [x] can pass a raw clj function into VybeAllocator
            - [x] use in test
        - [x] dsp
    - [-] safe mode where pointer derefs are checked
      - not for now, we are having issues with sanitizers
      - https://clang.llvm.org/docs/index.html
      - [-] enable address sanitizer, https://clang.llvm.org/docs/AddressSanitizer.html
      - [-] https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#ubsan-checks
    - [-] parse normal clojure functions
      - [-] simple `+`
      - [-] native functions
  - [x] load generated lib dynamically so we can call it in clojure
    - [x] call `defn*` as normal function
  - [-] janet
    - https://github.com/janet-lang/janet
    - [x] call janet from plugin
    - [x] eval janet code
    - [x] compile c code
    - [-] hot reload only at constructor
      - https://jameshfisher.com/2017/08/24/dlopen/
      - [x] check that it works
      - [-] use for setting freq
    - [-] hot reload for every shared lib modification
  - [x] call flecs from a native VybeCFn
    - [x] make world
      - [x] set pointer to jextract function globally
        - [x] don't expand jextract macros
        - [x] create global struct that stores function pointers
          - [x] globals
          - [x] init fn
            - [x] set global struct call
        - [x] call ctor function when loading `vc/defn*`
          - [x] fix bug
      - [-] refer to the dyn lib
      - [-] call it from a standalone (or SC plugin)
      - [x] indirect macro usage
      - [x] support fnc
        - [x] create clj function upcall
        - [x] use it in C
      - [x] println
  - [x] test raylib
  - [x] debug tools
    - [x] tap>
      - [x] tap value back to the jvm
      - [x] add line as metadata?
      - [x] tap compiler/analyzer errors
      - [x] debug sizeof padding
    - [x] portal
- [x] use const by default
  - [x] const
  - [x] `:mut`
  - [x] fn args
  - [x] run tests
- [x] fix dangling keywords
- [ ] VybeC
  - [ ] use dynamic fns by default, even for generated C code (so compilation is
        faster and we can have a tool for hot reloading)
    - [x] fix var name
    - [x] fix types
    - [x] fix npe
    - [ ] hot reload
      - [x] watch vars
      - [ ] test
  - [x] standalone mode (for shared libs) whree you don't use dynamic C fns
  - [ ] exe mode
    - [ ] check that we don't have unitialized resources in the init function if
          in this mode
- [ ] docs
  - let's use mkdocs for simplicity
  - [-] bookdown (?)
  - [x] local test render
  - [x] publish test
  - [ ] short video tutorial
  - [ ] framework
    - [ ] panama
      - [ ] component
        - [ ] `vp/defcomp`
        - [ ] `vp/make-component`
        - [ ] primitives
        - [ ] pointers
        - [ ] structs
        - [ ] padding
        - [ ] datafy
        - [ ] aliases
      - [ ] pmap
        - [ ] memory segments
        - [ ] datafy
        - [ ] `vp/as`
      - [ ] pseq
        - [ ] `vp/arr`
        - [ ] set
        - [ ] get
      - [ ] fcn
        - [ ] usage in components
      - [ ] arena
      - [ ] jextract
        - [ ] wrapping libs
    - [ ] flecs
      - [ ] world
      - [ ] entities
        - [ ] naming
        - [ ] `vp/ent`
        - [ ] `vp/eid`
      - [ ] components
      - [ ] tags
      - [ ] pairs
      - [ ] merge
      - [ ] mutability
      - [ ] hierarchy
        - [ ] parent
        - [ ] children
      - [ ] queries
        - [ ] DSL
      - [ ] systems
      - [ ] observers
        - [ ] sending events
        - [ ] listening events
      - [ ] enabling components/entities
    - [ ] sample
    - [ ] blender
      - [ ] hierarchy
      - [ ] scenes
      - [ ] physics
      - [ ] animation
    - [ ] raylib
    - [ ] jolt
    - [ ] network
    - [ ] audio
      - [ ] overtone
    - [ ] game ns
  - [ ] VybeC
    - [ ] introduction
    - [ ] flags
    - [ ] C semantics
    - [ ] const by default
      - [ ] `:mut`
- [ ] abstraction for dsps?
  - https://faust.grame.fr/
- [ ] don't store test resources in the jar
- [ ] incremental compilation
  - [ ] each `vc/defn*` is compiled independently (already done today) and
        one refers to the other using dyn libs (when in :debug or some other mode)
  - [ ] in the background, we can compile the full version so it's used next time!
- [ ] write docs like https://beej.us/guide/bgc/html/split/ ?
- [ ] clerk viewer for overtone synths
  - [ ] how to get info about existing synthdefs?
    - [ ] parse schelp for additional operators
      - https://depts.washington.edu/dxscdoc/Help/Guides/WritingHelp.html
      - [ ] parse metadata
      - [ ] parse function
        - [ ] arguments
        - [ ] description
  - [ ] show in clerk
  - [ ] create synthdef out of it
  - [ ] show nodes
    - we have `synthdef-decompile` in overtone, can use it as the base
    - [ ] binary op, how to show the used op?
    - [ ] loaded synthdefs
  - [ ] show args
  - [ ] play example
  - [ ] show the ugens in multiple steps so the user can play the step they need
  - [ ] you can hear, viz plots and call other ops on them (e.g. FFT)
  - [x] choose input (sawtooth, sine, any)
- [ ] 3d sound application
  - [ ] charts in TVs
  - [ ] press button
    - [ ] GUI sound
- [ ] VybeC
  - [ ] allocator setting
  - [ ] comptime
- [ ] use portal
  - [ ] memory segment
  - [ ] component
  - [ ] pmap
  - [ ] synth
  - [ ] flecs world
  - [ ] flecs entity
  - [ ] flecs system
- [ ] tap from C into portal
- [ ] make it easy to DSP in the frequency domain
- [ ] create filters in realtime from clerk
- [ ] wasm

- [x] deploy to clojars
  - [x] vybe
- [x] compile libs to targets
  - [x] windows
  - [x] linux
  - [x] osx
    - [x] universal?
- [ ] Use https://github.com/zeux/meshoptimizer?
- [ ] debug arena by tracing calls (for memory leak)
- [ ] ability to apply locks when creating an VybeFlecsSetEntity
- [ ] supercollider/native/C
  - [ ] reimplement delay filters (e.g. ShiftPitch ugen)
  - [ ] put the plugin at the end of the bus
  - [ ] map one index to one lib and receive an id to switch between the
        function pointers
  - [ ] `defdsp` could watch the used vars so it can compile itself automatically (only `:the-var`)
  - [ ] a `defn*` coukd test itself and check that it has the same results as
        the clojure one?
  - [ ] ability to load vars dynamically (using dlopen) so it speeds up compilation
        (and enables hot reloading (using some trickery))?
- [ ] blogpost about vybesc
  - [ ] what's a SC ugen?
  - [ ] graph
  - [ ] real time processing with dyn lib
  - [ ] control ugen parameters from clerk
